/*!
 * Copyright 2011-2012 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 */
(function () {
/**
 * almond 0.0.3 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
/*jslint strict: false, plusplus: false */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {

    var defined = {},
        waiting = {},
        aps = [].slice,
        main, req;

    if (typeof define === "function") {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseName = baseName.split("/");
                baseName = baseName.slice(0, baseName.length - 1);

                name = baseName.concat(name.split("/"));

                //start trimDots
                var i, part;
                for (i = 0; (part = name[i]); i++) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }
        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            main.apply(undef, args);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, i, ret, map;

        //Use name if no relName
        if (!relName) {
            relName = name;
        }

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Default to require, exports, module if no deps if
            //the factory arg has any arguments specified.
            if (!deps.length && callback.length) {
                deps = ['require', 'exports', 'module'];
            }

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            for (i = 0; i < deps.length; i++) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name]
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw name + ' missing ' + depName;
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef) {
                    defined[name] = cjsModule.exports;
                } else if (!usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {

            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            //Drop the config stuff on the ground.
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = arguments[2];
            } else {
                deps = [];
            }
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function () {
        return req;
    };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (define.unordered) {
            waiting[name] = [name, deps, callback];
        } else {
            main(name, deps, callback);
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../ThirdParty/almond-0.0.3/almond.js", function(){});

/*global define*/
define('Core/DefaultProxy',[],function() {
    

    /**
     * A simple proxy that appends the desired resource as the sole query parameter
     * to the given proxy URL.
     *
     * @alias DefaultProxy
     * @constructor
     *
     * @param {String} proxy The proxy URL that will be used to requests all resources.
     */
    var DefaultProxy = function(proxy) {
        this.proxy = proxy;
    };

    /**
     * Get the final URL to use to request a given resource.
     *
     * @memberof DefaultProxy
     *
     * @param {String} resource The resource to request.
     */
    DefaultProxy.prototype.getURL = function(resource) {
        return this.proxy + '?' + encodeURIComponent(resource);
    };

    return DefaultProxy;
});
/*global define*/
define('Core/DeveloperError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
     * argument out of range, etc.  This exception should only be thrown during development;
     * it usually indicates a bug in the calling code.  This exception should never be
     * caught; instead the calling code should strive not to generate it.
     * <br /><br />
     * On the other hand, a {@link RuntimeError} indicates an exception that may
     * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
     * to catch.
     *
     * @alias DeveloperError
     *
     * @param {String} [message=undefined] The error message for this exception.
     *
     * @see RuntimeError
     * @constructor
     */
    var DeveloperError = function(message) {
        /**
         * 'DeveloperError' indicating that this exception was thrown due to a developer error.
         * @type String
         * @constant
         */
        this.name = 'DeveloperError';

        /**
         * The explanation for why this exception was thrown.
         * @type String
         * @constant
         */
        this.message = message;

        /**
         * The Error object containing the stack trace.
         * @type Error
         * @constant
         *
         * @see <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error'>Error object on Mozilla Developer Network</a>.
         */
        this.error = new Error();
    };

    DeveloperError.prototype.toString = function () {
        var str = this.name + ': ' + this.message;
        if (typeof this.error !== 'undefined') {
            if (typeof this.error.stack !== 'undefined') {
                str += '\n' + this.error.stack.toString();
            } else {
                str += '\n' + this.error.toString();
            }
        }
        return str;
    };

    return DeveloperError;
});

/*global define*/
define('Core/Enumeration',[],function() {
    

    /**
     * Constructs an enumeration that contains both a numeric value and a name.
     * This is used so the name of the enumeration is available in the debugger.
     *
     * @param {Number} [value=undefined] The numeric value of the enumeration.
     * @param {String} [name=undefined] The name of the enumeration for debugging purposes.
     * @param {Object} [properties=undefined] An object containing extra properties to be added to the enumeration.
     *
     * @alias Enumeration
     * @constructor
     * @example
     * // Create an object with two enumerations.
     * var filter = {
     *     NEAREST : new Enumeration(0x2600, 'NEAREST'),
     *     LINEAR : new Enumeration(0x2601, 'LINEAR')
     * };
     */
    var Enumeration = function(value, name, properties) {
        /**
         * The numeric value of the enumeration.
         * @type Number
         */
        this.value = value;

        /**
         * The name of the enumeration for debugging purposes.
         * @type String
         */
        this.name = name;

        if (typeof properties !== 'undefined') {
            for ( var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                }
            }
        }
    };

    /**
     * Returns the numeric value of the enumeration.
     *
     * @memberof Enumeration
     *
     * @return {Number} The numeric value of the enumeration.
     */
    Enumeration.prototype.valueOf = function() {
        return this.value;
    };

    /**
     * Returns the name of the enumeration for debugging purposes.
     *
     * @memberof Enumeration
     *
     * @return {String} The name of the enumeration for debugging purposes.
     */
    Enumeration.prototype.toString = function() {
        return this.name;
    };

    return Enumeration;
});
/*global define*/
define('Core/ClockRange',[
        './Enumeration'
       ], function(
         Enumeration) {
    

    /**
     * Constants used by {@link Clock#tick} to determine behavior
     * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
     *
     * @exports ClockRange
     *
     * @see Clock
     * @see ClockStep
     */
    var ClockRange = {
        /**
         * {@link Clock#tick} will always advances the clock in its current direction.
         */
        UNBOUNDED : new Enumeration(0, 'UNBOUNDED'),

        /**
         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
         * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
         */
        CLAMPED : new Enumeration(1, 'CLAMPED'),

        /**
         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
         * {@link Clock#tick} will advance {@link Clock#currentTime} to the opposite end of the interval.
         */
        LOOP : new Enumeration(1, 'LOOP')
    };

    return ClockRange;
});

/*global define*/
define('Core/ClockStep',[
        './Enumeration'
       ], function(
         Enumeration) {
    

    /**
     * Constants to determine how much time advances with each call
     * to {@link Clock#tick}.
     *
     * @exports ClockStep
     *
     * @see Clock
     * @see ClockRange
     */
    var ClockStep = {
        /**
         * {@link Clock#tick} advances the current time by a fixed step,
         * which is the number of seconds specified by {@link Clock#multiplier}.
         */
        TICK_DEPENDENT : new Enumeration(0, 'TICK_DEPENDENT'),

        /**
         * {@link Clock#tick} advances the current time by the amount of system
         * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
         */
        SYSTEM_CLOCK_DEPENDENT : new Enumeration(1, 'SYSTEM_CLOCK_DEPENDENT')
    };

    return ClockStep;
});

/*global define*/
define('Core/ComponentDatatype',['./Enumeration'], function(Enumeration) {
    

    // Earlier versions of IE do not support typed arrays, and as a result,
    // using them below will cause the setup function itself to fail, causing
    // the page to abort load, and preventing us from prompting to install
    // Chrome Frame.  To avoid this, bail out early and return a dummy object,
    // since we won't be able to create a WebGL context anyway.
    if (typeof Int8Array === 'undefined') {
        return {};
    }

    /**
     * DOC_TBA
     *
     * @alias ComponentDatatype
     * @enumeration
     */
    var ComponentDatatype = {};

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.BYTE = new Enumeration(0x1400, 'BYTE');
    ComponentDatatype.BYTE.sizeInBytes = Int8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.BYTE.toTypedArray = function(values) {
        return new Int8Array(values);
    };

    ComponentDatatype.BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Int8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_BYTE = new Enumeration(0x1401, 'UNSIGNED_BYTE');
    ComponentDatatype.UNSIGNED_BYTE.sizeInBytes = Uint8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_BYTE.toTypedArray = function(values) {
        return new Uint8Array(values);
    };

    ComponentDatatype.UNSIGNED_BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.SHORT = new Enumeration(0x1402, 'SHORT');
    ComponentDatatype.SHORT.sizeInBytes = Int16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.SHORT.toTypedArray = function(values) {
        return new Int16Array(values);
    };

    ComponentDatatype.SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Int16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_SHORT = new Enumeration(0x1403, 'UNSIGNED_SHORT');
    ComponentDatatype.UNSIGNED_SHORT.sizeInBytes = Uint16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_SHORT.toTypedArray = function(values) {
        return new Uint16Array(values);
    };

    ComponentDatatype.UNSIGNED_SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.FLOAT = new Enumeration(0x1406, 'FLOAT');
    ComponentDatatype.FLOAT.sizeInBytes = Float32Array.BYTES_PER_ELEMENT;
    ComponentDatatype.FLOAT.toTypedArray = function(values) {
        return new Float32Array(values);
    };

    ComponentDatatype.FLOAT.createArrayBufferView = function(buffer, byteOffset) {
        return new Float32Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     */
    ComponentDatatype.validate = function(componentDatatype) {
        return ((componentDatatype === ComponentDatatype.BYTE) ||
                (componentDatatype === ComponentDatatype.UNSIGNED_BYTE) ||
                (componentDatatype === ComponentDatatype.SHORT) ||
                (componentDatatype === ComponentDatatype.UNSIGNED_SHORT) ||
                (componentDatatype === ComponentDatatype.FLOAT));
    };

    return ComponentDatatype;
});

/*global define*/
define('Core/Event',[
        './DeveloperError'
       ], function(
         DeveloperError) {
    

    /**
     * A generic utility class for managing subscribers for a particular event.
     * This class is usually instantiated inside of a container class and
     * exposed as a property for others to subscribe to.
     *
     * @alias Event
     * @constructor
     *
     * @example
     * MyObject.prototype.myListener = function(arg1, arg2) {
     *     this.myArg1Copy = arg1;
     *     this.myArg2Copy = arg2;
     * }
     *
     * var myObjectInstance = new MyObject();
     * var evt = new Event();
     * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
     * evt.raiseEvent('1', '2');
     * evt.removeEventListener(MyObject.prototype.myListener);
     */
    var Event = function() {
        this._listeners = [];
        this._scopes = [];
    };

    /**
     * Gets the number of listeners currently subscribed to the event.
     *
     * @memberof Event
     *
     * @returns {Number} The number of subscribed listeners.
     */
    Event.prototype.getNumberOfListeners = function() {
        return this._listeners.length;
    };

    /**
     * Registers a callback function to be executed whenever the event is raised.
     * An optional scope can be provided to serve as the <code>this</code> pointer
     * in which the function will execute.
     * @memberof Event
     *
     * @param {Function} listener The function to be executed when the event is raised.
     * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
     * pointer in which the listener function will execute.
     *
     * @see Event#raiseEvent
     * @see Event#removeEventListener
     *
     * @exception {DeveloperError} listener is required and must be a function.
     * @exception {DeveloperError} listener is already subscribed.
     */
    Event.prototype.addEventListener = function(listener, scope) {
        if (typeof listener !== 'function') {
            throw new DeveloperError('listener is required and must be a function.');
        }

        var thisListeners = this._listeners;
        var index = thisListeners.indexOf(listener);

        if (index !== -1) {
            throw new DeveloperError('listener is already subscribed.');
        }

        thisListeners.push(listener);
        this._scopes.push(scope);
    };

    /**
     * Unregisters a previously registered callback.
     * @memberof Event
     *
     * @param {Function} listener The function to be unregistered.
     *
     * @see Event#addEventListener
     * @see Event#raiseEvent
     *
     * @exception {DeveloperError} listener is required and must be a function.
     * @exception {DeveloperError} listener is not subscribed.
     */
    Event.prototype.removeEventListener = function(listener) {
        if (typeof listener !== 'function') {
            throw new DeveloperError('listener is required and must be a function.');
        }

        var thisListeners = this._listeners;
        var index = thisListeners.indexOf(listener);

        if (index === -1) {
            throw new DeveloperError('listener is not subscribed.');
        }

        thisListeners.splice(index, 1);
        this._scopes.splice(index, 1);
    };

    /**
     * Raises the event by calling each registered listener with all supplied arguments.
     * @memberof Event
     *
     * @param {*} arguments This method takes any number of parameters and passes them through to the listener functions.
     *
     * @see Event#addEventListener
     * @see Event#removeEventListener
     */
    Event.prototype.raiseEvent = function() {
        var listeners = this._listeners;
        var scopes = this._scopes;
        for ( var i = listeners.length - 1; i > -1; i--) {
            listeners[i].apply(scopes[i], arguments);
        }
    };

    return Event;
});
/*global define*/
define('Core/EventModifier',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for representing keyboard modifiers. These are keys
     * that are held down in addition to other event types.
     *
     * @exports EventModifier
     */
    var EventModifier = {
        /**
         * Represents the shift key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        SHIFT : new Enumeration(0, 'SHIFT'),

        /**
         * Represents the control key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        CTRL : new Enumeration(1, 'CTRL'),

        /**
         * Represents the alt key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        ALT : new Enumeration(2, 'ALT')
    };

    return EventModifier;
});
/*global define*/
define('Core/FAR',[],function() {
    

    /**
     * Distance from the Sun to Pluto in meters.
     *
     * @exports FAR
     */
    var FAR = 5906376272000.0;

    return FAR;
});
/*global define*/
define('Core/Fullscreen',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    var _supportsFullscreen;
    var _names = {
        requestFullscreen : undefined,
        exitFullscreen : undefined,
        fullscreenEnabled : undefined,
        fullscreenElement : undefined,
        fullscreenchange : undefined,
        fullscreenerror : undefined
    };

    /**
     * Browser-independent functions for working with the standard fullscreen API.
     *
     * @exports Fullscreen
     *
     * @see <a href='http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html'>W3C Fullscreen Living Specification</a>
     */
    var Fullscreen = {};

    /**
     * Detects whether the browser supports the standard fullscreen API.
     *
     * @returns <code>true</code> if the browser supports the standard fullscreen API,
     * <code>false</code> otherwise.
     */
    Fullscreen.supportsFullscreen = function() {
        if (typeof _supportsFullscreen !== 'undefined') {
            return _supportsFullscreen;
        }

        _supportsFullscreen = false;

        var body = document.body;
        if (typeof body.requestFullscreen === 'function') {
            // go with the unprefixed, standard set of names
            _names.requestFullscreen = 'requestFullscreen';
            _names.exitFullscreen = 'exitFullscreen';
            _names.fullscreenEnabled = 'fullscreenEnabled';
            _names.fullscreenElement = 'fullscreenElement';
            _names.fullscreenchange = 'fullscreenchange';
            _names.fullscreenerror = 'fullscreenerror';
            _supportsFullscreen = true;
            return _supportsFullscreen;
        }

        //check for the correct combination of prefix plus the various names that browsers use
        var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
        var name;
        for ( var i = 0, len = prefixes.length; i < len; ++i) {
            var prefix = prefixes[i];

            // casing of Fullscreen differs across browsers
            name = prefix + 'RequestFullscreen';
            if (typeof body[name] === 'function') {
                _names.requestFullscreen = name;
                _supportsFullscreen = true;
            } else {
                name = prefix + 'RequestFullScreen';
                if (typeof body[name] === 'function') {
                    _names.requestFullscreen = name;
                    _supportsFullscreen = true;
                }
            }

            // disagreement about whether it's "exit" as per spec, or "cancel"
            name = prefix + 'ExitFullscreen';
            if (typeof document[name] === 'function') {
                _names.exitFullscreen = name;
            } else {
                name = prefix + 'CancelFullScreen';
                if (typeof document[name] === 'function') {
                    _names.exitFullscreen = name;
                }
            }

            // casing of Fullscreen differs across browsers
            name = prefix + 'FullscreenEnabled';
            if (typeof document[name] !== 'undefined') {
                _names.fullscreenEnabled = name;
            } else {
                name = prefix + 'FullScreenEnabled';
                if (typeof document[name] !== 'undefined') {
                    _names.fullscreenEnabled = name;
                }
            }

            // casing of Fullscreen differs across browsers
            name = prefix + 'FullscreenElement';
            if (typeof document[name] !== 'undefined') {
                _names.fullscreenElement = name;
            } else {
                name = prefix + 'FullScreenElement';
                if (typeof document[name] !== 'undefined') {
                    _names.fullscreenElement = name;
                }
            }

            // thankfully, event names are all lowercase per spec
            name = prefix + 'fullscreenchange';
            // event names do not have 'on' in the front, but the property on the document does
            if (typeof document['on' + name] !== 'undefined') {
                _names.fullscreenchange = name;
            }

            name = prefix + 'fullscreenerror';
            if (typeof document['on' + name] !== 'undefined') {
                _names.fullscreenerror = name;
            }
        }

        return _supportsFullscreen;
    };

    /**
     * Asynchronously requests the browser to enter fullscreen mode on the given element.
     * If fullscreen mode is not supported by the browser, does nothing.
     *
     * @param {Object} element The HTML element which will be placed into fullscreen mode.
     *
     * @example
     * // Put the entire page into fullscreen.
     * Fullscreen.requestFullscreen(document.body)
     *
     * // Place only the Cesium canvas into fullscreen.
     * Fullscreen.requestFullscreen(scene.getCanvas())
     */
    Fullscreen.requestFullscreen = function(element) {
        if (!Fullscreen.supportsFullscreen()) {
            return;
        }

        element[_names.requestFullscreen]();
    };

    /**
     * Asynchronously exits fullscreen mode.  If the browser is not currently
     * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
     */
    Fullscreen.exitFullscreen = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return;
        }

        document[_names.exitFullscreen]();
    };

    /**
     * Determine whether the browser will allow an element to be made fullscreen, or not.
     * For example, by default, iframes cannot go fullscreen unless the containing page
     * adds an "allowfullscreen" attribute (or prefixed equivalent).
     *
     * @returns {Boolean} <code>true</code> if the browser is able to enter fullscreen mode,
     * <code>false</code> if not, and <code>undefined</code> if the browser does not
     * support fullscreen mode.
     */
    Fullscreen.isFullscreenEnabled = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return undefined;
        }

        return document[_names.fullscreenEnabled];
    };

    /**
     * Gets the element that is currently fullscreen, if any.  To simply check if the
     * browser is in fullscreen mode or not, use {@link Fullscreen#isFullscreen}.
     *
     * @returns {Object} the element that is currently fullscreen, or <code>null</code> if the browser is
     * not in fullscreen mode, or <code>undefined</code> if the browser does not support fullscreen
     * mode.
     */
    Fullscreen.getFullscreenElement = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return undefined;
        }

        return document[_names.fullscreenElement];
    };

    /**
     * Determines if the browser is currently in fullscreen mode.
     *
     * @returns {Boolean} <code>true</code> if the browser is currently in fullscreen mode, <code>false</code>
     * if it is not, or <code>undefined</code> if the browser does not support fullscreen mode.
     */
    Fullscreen.isFullscreen = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return undefined;
        }

        return Fullscreen.getFullscreenElement() !== null;
    };

    /**
     * Gets the name of the event on the document that is fired when fullscreen is
     * entered or exited.  This event name is intended for use with addEventListener.
     *
     * In your event handler, to determine if the browser is in fullscreen mode or not,
     * use {@link Fullscreen#isFullscreen}.
     *
     * @returns {String} the name of the event that is fired when fullscreen is entered or
     * exited, or <code>undefined</code> if fullscreen is not supported.
     */
    Fullscreen.getFullscreenChangeEventName = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return undefined;
        }

        return _names.fullscreenchange;
    };

    /**
     * Gets the name of the event that is fired when a fullscreen error
     * occurs.  This event name is intended for use with addEventListener.
     *
     * @returns {String} the name of the event that is fired when a fullscreen error occurs,
     * or <code>undefined</code> if fullscreen is not supported.
     */
    Fullscreen.getFullscreenErrorEventName = function() {
        if (!Fullscreen.supportsFullscreen()) {
            return undefined;
        }

        return _names.fullscreenerror;
    };

    return Fullscreen;
});
/*global define*/
define('Core/FeatureDetection',[
        './Fullscreen'
    ], function(
        Fullscreen) {
    

    /**
     * A set of functions to detect whether the current browser supports
     * various features.
     *
     * @exports FeatureDetection
     */
    var FeatureDetection = {};

    function extractVersion(versionString) {
        return versionString.split('.').map(function(v) {
            return parseInt(v, 10);
        });
    }

    var _isChrome;
    var _chromeVersion;
    function isChrome() {
        if (typeof _isChrome === 'undefined') {
            var fields = (/ Chrome\/([\.0-9]+)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isChrome = false);
            }

            _isChrome = true;
            _chromeVersion = extractVersion(fields[1]);
        }

        return _isChrome;
    }

    function chromeVersion() {
        return isChrome() && _chromeVersion;
    }

    var _isSafari;
    var _safariVersion;
    function isSafari() {
        if (typeof _isSafari === 'undefined') {
            // Chrome contains Safari in the user agent too
            if (isChrome() || !(/ Safari\/[\.0-9]+/).test(navigator.userAgent)) {
                return (_isSafari = false);
            }

            var fields = (/ Version\/([\.0-9]+)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isSafari = false);
            }

            _isSafari = true;
            _safariVersion = extractVersion(fields[1]);
        }

        return _isSafari;
    }

    function safariVersion() {
        return isSafari() && _safariVersion;
    }

    var _isWebkit;
    var _webkitVersion;
    function isWebkit() {
        if (typeof _isWebkit === 'undefined') {
            var fields = (/ AppleWebKit\/([\.0-9]+)(\+?)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isWebkit = false);
            }

            _isWebkit = true;
            _webkitVersion = extractVersion(fields[1]);
            _webkitVersion.isNightly = !!fields[2];
        }

        return _isWebkit;
    }

    function webkitVersion() {
        return isWebkit() && _webkitVersion;
    }

    var _supportsCrossOriginImagery;

    /**
     * Detects whether the current browser supports the use of cross-origin
     * requests to load streaming imagery.
     *
     * @returns true if the browser can load cross-origin streaming imagery, false if not.
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     */
    FeatureDetection.supportsCrossOriginImagery = function() {
        if (typeof _supportsCrossOriginImagery === 'undefined') {
            if (isSafari() && webkitVersion()[0] < 536) {
                // versions of Safari below this incorrectly throw a DOM error when calling
                // readPixels on a canvas containing a cross-origin image.
                _supportsCrossOriginImagery = false;
            } else {
                // any other versions of browsers that incorrectly block
                // readPixels on canvas containing crossOrigin images?
                _supportsCrossOriginImagery = 'withCredentials' in new XMLHttpRequest();
            }
        }
        return _supportsCrossOriginImagery;
    };

    /**
     * Detects whether the current browser supports the full screen standard.
     *
     * @returns true if the supports the full screen standard, false if not.
     *
     * @see Fullscreen
     * @see <a href='http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html'>W3C Fullscreen Living Specification</a>
     */
    FeatureDetection.supportsFullscreen = function() {
        return Fullscreen.supportsFullscreen();
    };

    return FeatureDetection;
});
/*global define*/
define('Core/IndexDatatype',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports IndexDatatype
     */
    var IndexDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, 'UNSIGNED_BYTE'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT : new Enumeration(0x1403, 'UNSIGNED_SHORT')
    };

    return IndexDatatype;
});

/*global define*/
define('Core/Intersect',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining where, relative to the frustum, an
     * object is located. The object can either be fully contained within the frustum (INSIDE),
     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely
     * outside of the frustum's 6 planes (OUTSIDE).
     *
     * @exports Intersect
     */
    var Intersect = {
        /**
         * Represents that an object is not contained within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        OUTSIDE : new Enumeration(-1, 'OUTSIDE'),

        /**
         * Represents that an object intersects one of the frustum's planes.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERSECTING : new Enumeration(0, 'INTERSECTING'),

        /**
         * Represents that an object is fully within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        INSIDE : new Enumeration(1, 'INSIDE')
    };

    return Intersect;
});

/*global define*/
define('Core/LagrangePolynomialApproximation',[],function() {
    

    /**
     * Functions for performing Lagrange interpolation.
     * @exports LagrangePolynomialApproximation
     *
     * @see LinearApproximation
     * @see HermitePolynomialApproximation
     */
    var LagrangePolynomialApproximation = {
        type : 'Lagrange'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof LagrangePolynomialApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    LagrangePolynomialApproximation.getRequiredDataPoints = function(degree) {
        return Math.max(degree + 1.0, 2);
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LinearApproximation
     * @see HermitePolynomialApproximation
     *
     * @memberof LagrangePolynomialApproximation
     *
     */
    LagrangePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        var i;
        var j;
        var length = xTable.length;
        var result = new Array(yStride);

        for (i = 0; i < yStride; i++) {
            result[i] = 0;
        }

        for (i = 0; i < length; i++) {
            var coefficient = 1;

            for (j = 0; j < length; j++) {
                if (j !== i) {
                    var diffX = xTable[i] - xTable[j];
                    coefficient *= (x - xTable[j]) / diffX;
                }
            }

            for (j = 0; j < yStride; j++) {
                result[j] += coefficient * yTable[i * yStride + j];
            }
        }

        return result;
    };

    return LagrangePolynomialApproximation;
});
/*global define*/
define('Core/LeapSecond',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
     * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
     *
     * @alias LeapSecond
     * @constructor
     *
     * @param {JulianDate} date A Julian date representing the time of the leap second.
     * @param {Number} offset The cumulative number of seconds, that TAI is ahead of UTC at provided date.
     *
     * @exception {DeveloperError} <code>date</code> is required.
     * @exception {DeveloperError} <code>offset</code> is required.
     *
     * @see JulianDate
     * @see TimeStandard
     *
     * @example
     * // Example 1. Construct a LeapSecond using a JulianDate
     * var date = new Date('January 1, 1990 00:00:00 UTC');
     * var leapSecond = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * var offset = leapSecond.offset;    // 25.0
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Construct a LeapSecond using a date string
     * var date = 'January 1, 1990 00:00:00 UTC';
     * var leapSecond = new LeapSecond(date, 25.0);
     */
    var LeapSecond = function(date, offset) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date is required.');
        }

        if (offset === null || isNaN(offset)) {
            throw new DeveloperError('offset is required and must be a number.');
        }

        /**
         * The Julian date at which this leap second occurs.
         *
         * @type {JulianDate}
         */
        this.julianDate = date;

        /**
         * The cumulative number of seconds between the UTC and TAI time standards at the time
         * of this leap second.
         *
         * @type {Number}
         */
        this.offset = offset;
    };

    /**
     * Sets the list of leap seconds used throughout Cesium.
     *
     * @memberof LeapSecond
     *
     * @param {Array} leapSeconds An array of {@link LeapSecond} objects.
     * @exception {DeveloperErrpr} leapSeconds is required and must be an array.
     *
     * @see LeapSecond.setLeapSeconds
     *
     * @example
     * LeapSecond.setLeapSeconds([
     *                            new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
     *                            new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
     *                            new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35)  // July 1, 2012 00:00:00 UTC
     *                           ]);
     */
    LeapSecond.setLeapSeconds = function(leapSeconds) {
        if (!Array.isArray(leapSeconds)) {
            throw new DeveloperError("leapSeconds is required and must be an array.");
        }
        LeapSecond._leapSeconds = leapSeconds;
        LeapSecond._leapSeconds.sort(LeapSecond.compareLeapSecondDate);
    };

    /**
     * Returns a copy of the array of leap seconds used throughout Cesium. By default, this is the
     * official list of leap seconds that was available when Cesium was released.
     *
     * @memberof LeapSecond
     *
     * @return {Array} A list of {@link LeapSecond} objects.
     *
     * @see LeapSecond.setLeapSeconds
     */
    LeapSecond.getLeapSeconds = function(leapSeconds) {
        return LeapSecond._leapSeconds;
    };

    /**
     * Checks whether two leap seconds are equivalent to each other.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} other The leap second to compare against.
     *
     * @return {Boolean} <code>true</code> if the leap seconds are equal; otherwise, <code>false</code>.
     *
     * @example
     * var date = new Date('January 1, 1990 00:00:00 UTC');
     * var leapSecond1 = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * var leapSecond2 = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * leapSecond1.equals(leapSecond2);     // true
     */
    LeapSecond.prototype.equals = function(other) {
        return this.julianDate.equals(other.julianDate) && (this.offset === other.offset);
    };

    /**
     * Given two leap seconds, determines which comes before the other by comparing
     * their respective Julian dates.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} leapSecond1 The first leap second to be compared.
     * @param {LeapSecond} leapSecond2 The second leap second to be compared.
     *
     * @return {Number} A negative value if the first leap second is earlier than the second,
     *                  a positive value if the first leap second is later than the second, or
     *                  zero if the two leap seconds are equal (ignoring their offsets).
     *
     * @see JulianDate#lessThan
     * @see JulianDate#isAfter
     *
     * @example
     * var date = new Date('January 1, 2006 00:00:00 UTC');
     * var leapSecond1 = new LeapSecond(JulianDate.fromDate(date), 33.0);
     * var leapSecond2 = new LeapSecond(JulianDate.fromDate(date), 34.0);
     * LeapSecond.compareLeapSecondDate(leapSecond1, leapSecond2);    // returns 0
     */
    LeapSecond.compareLeapSecondDate = function(leapSecond1, leapSecond2) {
        var julianDayNum1 = leapSecond1.julianDate.getJulianDayNumber();
        var julianDayNum2 = leapSecond2.julianDate.getJulianDayNumber();
        if (julianDayNum1 !== julianDayNum2) {
            return julianDayNum1 < julianDayNum2 ? -1 : 1;
        }
        var secondsOfDay1 = leapSecond1.julianDate.getSecondsOfDay();
        var secondsOfDay2 = leapSecond2.julianDate.getSecondsOfDay();
        if (secondsOfDay1 !== secondsOfDay2) {
            return secondsOfDay1 < secondsOfDay2 ? -1 : 1;
        }
        return 0;
    };

    LeapSecond._leapSeconds = [];

    return LeapSecond;
});
/*global define*/
define('Core/LinearApproximation',[
        './DeveloperError'
       ],function(
         DeveloperError) {
    


    /**
     * Functions for performing linear interpolation.
     * @exports LinearApproximation
     *
     * @see LagrangePolynomialApproximation
     * @see HermitePolynomialApproximation
     */
    var LinearApproximation = {
        type : 'Linear'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof LinearApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @exception {DeveloperError} Linear interpolation can only generate a first degree polynomial.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    LinearApproximation.getRequiredDataPoints = function(degree) {
        if (degree !== 1) {
            throw new DeveloperError('Linear interpolation can only generate a first degree polynomial.');
        }
        return 2;
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LagrangePolynomialApproximation
     * @see HermitePolynomialApproximation
     *
     *
     * @memberof LinearApproximation
     */
    LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        if (xTable.length !== 2) {
            throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
        } else if (yStride <= 0) {
            throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
        }

        var result = new Array(yStride), x0 = xTable[0], x1 = xTable[1], i, y0, y1;

        for (i = 0; i < yStride; i++) {
            //calculates the interpolated values

            y0 = yTable[i];
            y1 = yTable[i + yStride];

            result[i] = (((y1 - y0) * x) + (x1 * y0) - (x0 * y1)) / (x1 - x0);
        }

        return result;
    };

    return LinearApproximation;
});
/*global define*/
define('Core/MouseEventType',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
     *
     * @exports MouseEventType
     */
    var MouseEventType = {
        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOWN : new Enumeration(0, 'LEFT_DOWN'),

        /**
         * Represents a mouse left button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_UP : new Enumeration(1, 'LEFT_UP'),

        /**
         * Represents a mouse left click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_CLICK : new Enumeration(2, 'LEFT_CLICK'),

        /**
         * Represents a mouse left double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOUBLE_CLICK : new Enumeration(3, 'LEFT_DOUBLE_CLICK'),

        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOWN : new Enumeration(5, 'RIGHT_DOWN'),

        /**
         * Represents a mouse right button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_UP : new Enumeration(6, 'RIGHT_UP'),

        /**
         * Represents a mouse right click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_CLICK : new Enumeration(7, 'RIGHT_CLICK'),

        /**
         * Represents a mouse right double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOUBLE_CLICK : new Enumeration(8, 'RIGHT_DOUBLE_CLICK'),

        /**
         * Represents a mouse middle button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOWN : new Enumeration(10, 'MIDDLE_DOWN'),

        /**
         * Represents a mouse middle button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_UP : new Enumeration(11, 'MIDDLE_UP'),

        /**
         * Represents a mouse middle click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_CLICK : new Enumeration(12, 'MIDDLE_CLICK'),

        /**
         * Represents a mouse middle double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOUBLE_CLICK : new Enumeration(13, 'MIDDLE_DOUBLE_CLICK'),

        /**
         * Represents a mouse move event.
         *
         * @constant
         * @type {Enumeration}
         */
        MOVE : new Enumeration(15, 'MOVE'),

        /**
         * Represents a mouse wheel event.
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(16, 'WHEEL')
    };

    return MouseEventType;
});
/*global define*/
define('Core/PrimitiveType',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PrimitiveType
     */
    var PrimitiveType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        POINTS : new Enumeration(0x0000, 'POINTS'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINES : new Enumeration(0x0001, 'LINES'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_LOOP : new Enumeration(0x0002, 'LINE_LOOP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_STRIP : new Enumeration(0x0003, 'LINE_STRIP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLES : new Enumeration(0x0004, 'TRIANGLES'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_STRIP : new Enumeration(0x0005, 'TRIANGLE_STRIP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_FAN : new Enumeration(0x0006, 'TRIANGLE_FAN'),

        /**
         * DOC_TBA
         *
         * @param primitiveType
         *
         * @returns {Boolean}
         */
        validate : function(primitiveType) {
            return ((primitiveType === PrimitiveType.POINTS) ||
                    (primitiveType === PrimitiveType.LINES) ||
                    (primitiveType === PrimitiveType.LINE_LOOP) ||
                    (primitiveType === PrimitiveType.LINE_STRIP) ||
                    (primitiveType === PrimitiveType.TRIANGLES) ||
                    (primitiveType === PrimitiveType.TRIANGLE_STRIP) ||
                    (primitiveType === PrimitiveType.TRIANGLE_FAN));
        }
    };

    return PrimitiveType;
});

/*global define*/
define('Core/Queue',[],function() {
    

    /**
     * A queue that can enqueue items at the end, and dequeue items from the front.
     *
     * @alias Queue
     * @constructor
     */
    var Queue = function() {
        this._array = [];
        this._offset = 0;

        /**
         * The length of the queue.
         */
        this.length = 0;
    };

    /**
     * Enqueues the specified item.
     *
     * @param {Object} item The item to enqueue.
     * @memberof Queue
     */
    Queue.prototype.enqueue = function(item) {
        this._array.push(item);
        this.length++;
    };

    /**
     * Dequeues an item.  Returns undefined if the queue is empty.
     *
     * @memberof Queue
     */
    Queue.prototype.dequeue = function() {
        if (this.length === 0) {
            return undefined;
        }

        var array = this._array;
        var offset = this._offset;
        var item = array[offset];
        array[offset] = undefined;

        offset++;
        if (offset > 10 && offset * 2 > array.length) {
            //compact array
            this._array = array.slice(offset);
            offset = 0;
        }

        this._offset = offset;
        this.length--;

        return item;
    };

    /**
     * Check whether this queue contains the specified item.
     *
     * @param {Object} the item to search for.
     * @memberof Queue
     */
    Queue.prototype.contains = function(item) {
        return this._array.indexOf(item) !== -1;
    };

    /**
     * Remove all items from the queue.
     * @memberof Queue
     */
    Queue.prototype.clear = function() {
        this._array.length = this._offset = this.length = 0;
    };

    /**
     * Sort the items in the queue in-place.
     *
     * @param {Function} compareFunction a function that defines the sort order.
     * @memberof Queue
     */
    Queue.prototype.sort = function(compareFunction) {
        if (this._offset > 0) {
            //compact array
            this._array = this._array.slice(this._offset);
            this._offset = 0;
        }

        this._array.sort(compareFunction);
    };

    return Queue;
});
/*global define*/
define('Core/RuntimeError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
     * out of memory, could not compile shader, etc.  If a function may throw this
     * exception, the calling code should be prepared to catch it.
     * <br /><br />
     * On the other hand, a {@link DeveloperError} indicates an exception due
     * to a developer error, e.g., invalid argument, that usually indicates a bug in the
     * calling code.
     *
     * @alias RuntimeError
     *
     * @param {String} [message=undefined] The error message for this exception.
     *
     * @see DeveloperError
     * @constructor
     */
    var RuntimeError = function(message) {
        /**
         * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
         * @type String
         * @constant
         */
        this.name = 'RuntimeError';

        /**
         * The explanation for why this exception was thrown.
         * @type String
         * @constant
         */
        this.message = message;

        /**
         * The Error object containing the stack trace.
         * @type Error
         * @constant
         *
         * @see <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error'>Error object on Mozilla Developer Network</a>.
         */
        this.error = new Error();
    };

    RuntimeError.prototype.toString = function () {
        var str = this.name + ': ' + this.message;
        if (typeof this.error !== 'undefined') {
            if (typeof this.error.stack !== 'undefined') {
                str += '\n' + this.error.stack.toString();
            } else {
                str += '\n' + this.error.toString();
            }
        }
        return str;
    };

    return RuntimeError;
});

/*global define*/
define('Core/Spherical',[],function() {
    

    /**
     * A set of curvilinear 3-dimensional coordinates.
     *
     * @alias Spherical
     * @constructor
     *
     * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
     * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.
     * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.
     */
    var Spherical = function(clock, cone, magnitude) {
        this.clock = typeof clock === 'undefined' ? 0.0 : clock;
        this.cone = typeof cone === 'undefined' ? 0.0 : cone;
        this.magnitude = typeof magnitude === 'undefined' ? 1.0 : magnitude;
    };

    /**
     * Converts the provided Cartesian3 into Spherical coordinates.
     * @memberof Spherical
     *
     * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.
     * @param {Spherical} [spherical] The object in which the result will be stored, if undefined a new instance will be created.
     *
     * @returns The modified result parameter, or a new instance if one was not provided.
     */
    Spherical.fromCartesian3 = function(cartesian3, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        var x = cartesian3.x;
        var y = cartesian3.y;
        var z = cartesian3.z;
        var radialSquared = x * x + y * y;
        result.clock = Math.atan2(y, x);
        result.cone = Math.atan2(Math.sqrt(radialSquared), z);
        result.magnitude = Math.sqrt(radialSquared + z * z);
        return result;
    };

    /**
     * Creates a duplicate of a Spherical.
     * @memberof Spherical
     *
     * @param {Spherical} spherical The spherical to clone.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.clone = function(spherical, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = spherical.magnitude;
        return result;
    };

    /**
     * Computes the normalized version of the provided spherical.
     * @memberof Spherical
     *
     * @param {Spherical} spherical The spherical to be normalized.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.normalize = function(spherical, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = 1.0;
        return result;
    };

    /**
     * Returns true if the first spherical is equal to the second spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     *
     * @return true if the first spherical is equal to the second spherical, false otherwise.
     */
    Spherical.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.clock === right.clock) &&
                (left.cone === right.cone) &&
                (left.magnitude === right.magnitude));
    };

    /**
     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     * @param {Number} [epsilon=0.0] The epsilon to compare against.
     *
     * @return true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     */
    Spherical.equalsEpsilon = function(left, right, epsilon) {
        epsilon = typeof epsilon === 'undefined' ? 0.0 : epsilon;
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.clock - right.clock) <= epsilon) &&
                (Math.abs(left.cone - right.cone) <= epsilon) &&
                (Math.abs(left.magnitude - right.magnitude) <= epsilon));
    };

    /**
     * Returns a string representing the provided instance in the format (clock, cone, magnitude).
     * @memberof Spherical
     *
     * @param {Spherical} spherical The object to be converted.
     *
     * @return A string representing the provided instance.
     */
    Spherical.toString = function(spherical) {
        return '(' + spherical.clock + ', ' + spherical.cone + ', ' + spherical.magnitude + ')';
    };

    /**
     * Creates a duplicate of this Spherical.
     * @memberof Spherical
     *
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.prototype.clone = function(result) {
        return Spherical.clone(this, result);
    };

    /**
     * Computes the normalized version of this spherical.
     * @memberof Spherical
     *
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.prototype.normalize = function(result) {
        return Spherical.normalize(this, result);
    };

    /**
     * Returns true if this spherical is equal to the provided spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} other The Spherical to be compared.
     *
     * @return true if this spherical is equal to the provided spherical, false otherwise.
     */
    Spherical.prototype.equals = function(other) {
        return Spherical.equals(this, other);
    };

    /**
     * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} other The Spherical to be compared.
     * @param {Number} epsilon The epsilon to compare against.
     *
     * @return true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     */
    Spherical.prototype.equalsEpsilon = function(other, epsilon) {
        return Spherical.equalsEpsilon(this, other, epsilon);
    };

    /**
     * Returns a string representing this instance in the format (clock, cone, magnitude).
     * @memberof Spherical
     *
     * @return A string representing this instance.
     */
    Spherical.prototype.toString = function() {
        return Spherical.toString(this);
    };

    return Spherical;
});

/*global define*/
define('Core/TimeConstants',[],function() {
    

    /**
     * Constants for time conversions like those done by {@link JulianDate}.
     *
     * @exports TimeConstants
     *
     * @see JulianDate
     */
    var TimeConstants = {
        /**
         * The number of seconds in one millisecond: <code>0.001</code>
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MILLISECOND : 0.001,

        /**
         * The number of seconds in one minute: <code>60</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MINUTE : 60.0,

        /**
         * The number of minutes in one hour: <code>60</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_HOUR : 60.0,

        /**
         * The number of hours in one day: <code>24</code>.
         * @constant
         * @type {Number}
         */
        HOURS_PER_DAY : 24.0,

        /**
         * The number of seconds in one hour: <code>3600</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_HOUR : 3600.0,

        /**
         * The number of minutes in one day: <code>1440</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_DAY : 1440.0,

        /**
         * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_DAY : 86400.0,

        /**
         * The number of days in one Julian century: <code>36525</code>.
         * @constant
         * @type {Number}
         */
        DAYS_PER_JULIAN_CENTURY : 36525.0,

        /**
         * One trillionth of a second.
         * @constant
         * @type {Number}
         */
        PICOSECOND : 0.000000001,

        /**
         * DOC_TBA
         * @constant
         * @type {Number}
         */
        MODIFIED_JULIAN_DATE_DIFFERENCE : 2400000.5
    };

    return TimeConstants;
});
/*global define*/
define('Core/TimeStandard',[],function() {
    

    /**
     * Provides the type of time standards which JulianDate can take as input.
     *
     * @exports TimeStandard
     *
     * @see JulianDate
     */
    var TimeStandard = {
        /**
         * Represents the coordinated Universal Time (UTC) time standard.
         *
         * UTC is related to TAI according to the relationship
         * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
         * seconds which have been introduced as of the time in TAI.
         *
         */
        UTC : 0,

        /**
         * Represents the International Atomic Time (TAI) time standard.
         * TAI is the principal time standard to which the other time standards are related.
         */
        TAI : 1
    };

    return TimeStandard;
});
/*global define*/
define('Core/Tipsify',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Encapsulates an algorithm to optimize triangles for the post
     * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper
     * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'
     * The runtime is linear but several passes are made.
     *
     * @exports Tipsify
     *
     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     */
    var Tipsify = {};

    /**
     * Calculates the average cache miss ratio (ACMR) for a given set of indices.
     *
     * @param {Array} description.indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} [description.maximumIndex] The maximum value of the elements in <code>args.indices</code>.
     *                                     If not supplied, this value will be computed.
     * @param {Number} [description.cacheSize=24] The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Number} The average cache miss ratio (ACMR).
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var acmr = Tipsify.calculateACMR(indices, maxIndex, cacheSize);
     */
    Tipsify.calculateACMR = function(description) {
        description = description || {};
        var indices = description.indices;
        var maximumIndex = description.maximumIndex;
        var cacheSize = description.cacheSize || 24;

        if (!indices) {
            throw new DeveloperError('indices is required.');
        }

        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError('indices length must be a multiple of three.');
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError('maximumIndex must be greater than zero.');
        }
        if (cacheSize < 3) {
            throw new DeveloperError('cacheSize must be greater than two.');
        }

        // Compute the maximumIndex if not given
        if(!maximumIndex) {
            maximumIndex = 0;
            var currentIndex = 0;
            var intoIndices = indices[currentIndex];
            while (currentIndex < numIndices) {
                if (intoIndices > maximumIndex) {
                    maximumIndex = intoIndices;
                }
                ++currentIndex;
                intoIndices = indices[currentIndex];
            }
        }

        // Vertex time stamps
        var vertexTimeStamps = [];
        for ( var i = 0; i < maximumIndex + 1; i++) {
            vertexTimeStamps[i] = 0;
        }

        // Cache processing
        var s = cacheSize + 1;
        for ( var j = 0; j < numIndices; ++j) {
            if ((s - vertexTimeStamps[indices[j]]) > cacheSize) {
                vertexTimeStamps[indices[j]] = s;
                ++s;
            }
        }

        return (s - cacheSize + 1) / (numIndices / 3);
    };

    /**
     * Optimizes triangles for the post-vertex shader cache.
     *
     * @param {Array} description.indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} [description.maximumIndex] The maximum value of the elements in <code>args.indices</code>.
     *                                     If not supplied, this value will be computed.
     * @param {Number} [description.cacheSize=24] The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Array} A list of the input indices in an optimized order.
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var reorderedIndices = Tipsify.tipsify(indices, maxIndex, cacheSize);
     */
    Tipsify.tipsify = function(description) {
        description = description || {};
        var indices = description.indices;
        var maximumIndex = description.maximumIndex;
        var cacheSize = description.cacheSize || 24;

        var cursor;

        function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {
            while (deadEnd.length >= 1) {
                // while the stack is not empty
                var d = deadEnd[deadEnd.length - 1]; // top of the stack
                deadEnd.splice(deadEnd.length - 1, 1); // pop the stack

                if (vertices[d].numLiveTriangles > 0) {
                    return d;
                }
            }

            while (cursor < maximumIndexPlusOne) {
                if (vertices[cursor].numLiveTriangles > 0) {
                    ++cursor;
                    return cursor - 1;
                }
                ++cursor;
            }
            return -1;
        }

        function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {
            var n = -1;
            var p;
            var m = -1;
            var itOneRing = 0;
            while (itOneRing < oneRing.length) {
                var index = oneRing[itOneRing];
                if (vertices[index].numLiveTriangles) {
                    p = 0;
                    if ((s - vertices[index].timeStamp + (2 * vertices[index].numLiveTriangles)) <= cacheSize) {
                        p = s - vertices[index].timeStamp;
                    }
                    if ((p > m) || (m === -1)) {
                        m = p;
                        n = index;
                    }
                }
                ++itOneRing;
            }
            if (n === -1) {
                return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);
            }
            return n;
        }

        if (!indices) {
            throw new DeveloperError('indices is required.');
        }
        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError('indices length must be a multiple of three.');
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError('maximumIndex must be greater than zero.');
        }
        if (cacheSize < 3) {
            throw new DeveloperError('cacheSize must be greater than two.');
        }

        // Determine maximum index
        var maximumIndexPlusOne = 0;
        var currentIndex = 0;
        var intoIndices = indices[currentIndex];
        var endIndex = numIndices;
        if (maximumIndex) {
            maximumIndexPlusOne = maximumIndex + 1;
        } else {
            while (currentIndex < endIndex) {
                if (intoIndices > maximumIndexPlusOne) {
                    maximumIndexPlusOne = intoIndices;
                }
                ++currentIndex;
                intoIndices = indices[currentIndex];
            }
            if (maximumIndexPlusOne === -1) {
                return 0;
            }
            ++maximumIndexPlusOne;
        }

        // Vertices
        var vertices = [];
        for ( var i = 0; i < maximumIndexPlusOne; i++) {
            vertices[i] = {
                numLiveTriangles : 0,
                timeStamp : 0,
                vertexTriangles : []
            };
        }
        currentIndex = 0;
        var triangle = 0;
        while (currentIndex < endIndex) {
            (vertices[indices[currentIndex]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex]]).numLiveTriangles;
            (vertices[indices[currentIndex + 1]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 1]]).numLiveTriangles;
            (vertices[indices[currentIndex + 2]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 2]]).numLiveTriangles;
            ++triangle;
            currentIndex += 3;
        }

        // Starting index
        var f = 0;

        // Time Stamp
        var s = cacheSize + 1;
        cursor = 1;

        // Process
        var oneRing = [];
        var deadEnd = []; //Stack
        var vertex;
        var intoVertices;
        var currentOutputIndex = 0;
        var outputIndices = [];
        var numTriangles = numIndices / 3;
        var triangleEmitted = [];
        for (i = 0; i < numTriangles; i++) {
            triangleEmitted[i] = false;
        }
        var index;
        var limit;
        while (f !== -1) {
            oneRing = [];
            intoVertices = vertices[f];
            limit = intoVertices.vertexTriangles.length;
            for ( var k = 0; k < limit; ++k) {
                triangle = intoVertices.vertexTriangles[k];
                if (!triangleEmitted[triangle]) {
                    triangleEmitted[triangle] = true;
                    currentIndex = triangle + triangle + triangle;
                    for ( var j = 0; j < 3; ++j) {
                        // Set this index as a possible next index
                        index = indices[currentIndex];
                        oneRing.push(index);
                        deadEnd.push(index);

                        // Output index
                        outputIndices[currentOutputIndex] = index;
                        ++currentOutputIndex;

                        // Cache processing
                        vertex = vertices[index];
                        --vertex.numLiveTriangles;
                        if ((s - vertex.timeStamp) > cacheSize) {
                            vertex.timeStamp = s;
                            ++s;
                        }
                        ++currentIndex;
                    }
                }
            }
            f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);
        }

        return outputIndices;
    };

    return Tipsify;
});

/*global define*/
define('Core/TridiagonalSystemSolver',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
     * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
     *
     * @exports TridiagonalSystemSolver
     */
    var TridiagonalSystemSolver = {};

    /**
     * Solves a tridiagonal system of linear equations.
     *
     * @param {Array} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
     * @param {Array} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
     * @param {Array} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
     * @param {Array} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
     *
     * @exception {DeveloperError} The array lower is required.
     * @exception {DeveloperError} The array diagonal is required.
     * @exception {DeveloperError} The array upper is required.
     * @exception {DeveloperError} The array right is required.
     * @exception {DeveloperError} diagonal and right must have the same lengths.
     * @exception {DeveloperError} lower and upper must have the same lengths.
     * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.
     *
     * @returns {Array} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
     *
     * @performance Linear time.
     *
     * @example
     * var lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
     * var upperDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var rightHandSide = [
     *     new Cartesian3(410757.0, -1595711.0, 1375302.0),
     *     new Cartesian3(-5986705.0, -2190640.0, 1099600.0),
     *     new Cartesian3(-12593180.0, 288588.0, -1755549.0),
     *     new Cartesian3(-5349898.0, 2457005.0, -2685438.0),
     *     new Cartesian3(845820.0, 1573488.0, -1205591.0)
     * ];
     *
     * var solution = TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
     */
    TridiagonalSystemSolver.solve = function(lower, diagonal, upper, right) {
        if (!lower || !(lower instanceof Array)) {
            throw new DeveloperError('The array lower is required.');
        }

        if (!diagonal || !(diagonal instanceof Array)) {
            throw new DeveloperError('The array diagonal is required.');
        }

        if (!upper || !(upper instanceof Array)) {
            throw new DeveloperError('The array upper is required.');
        }

        if (!right || !(right instanceof Array)) {
            throw new DeveloperError('The array right is required.');
        }

        if (diagonal.length !== right.length) {
            throw new DeveloperError('diagonal and right must have the same lengths.');
        }

        if (lower.length !== upper.length) {
            throw new DeveloperError('lower and upper must have the same lengths.');
        } else if (lower.length !== diagonal.length - 1) {
            throw new DeveloperError('lower and upper must be one less than the length of diagonal.');
        }

        var c = [], d = [], x = [];
        c.length = upper.length;
        d.length = x.length = right.length;

        c[0] = upper[0] / diagonal[0];
        d[0] = right[0].multiplyByScalar(1.0 / diagonal[0]);

        var scalar, i = 1;
        for (; i < c.length; ++i) {
            scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
            c[i] = upper[i] * scalar;
            d[i] = right[i].subtract(d[i - 1].multiplyByScalar(lower[i - 1]));
            d[i] = d[i].multiplyByScalar(scalar);
        }

        scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
        d[i] = right[i].subtract(d[i - 1].multiplyByScalar(lower[i - 1]));
        d[i] = d[i].multiplyByScalar(scalar);

        x[x.length - 1] = d[d.length - 1];
        for (i = x.length - 2; i >= 0; --i) {
            x[i] = d[i].subtract(x[i + 1].multiplyByScalar(c[i]));
        }

        return x;
    };

    return TridiagonalSystemSolver;
});

/*global define*/
define('Core/Visibility',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining to what extent an object, the occludee,
     * is visible during horizon culling. An occluder may fully block an occludee, in which case
     * it has no visibility, may partially block an occludee from view, or may not block it at all,
     * leading to full visibility.
     *
     * @exports Visibility
     */
    var Visibility = {
        /**
         * Represents that no part of an object is visible.
         *
         * @constant
         * @type {Enumeration}
         */
        NONE : new Enumeration(-1, 'NONE'),
        /**
        * Represents that part, but not all, of an object is visible
        *
        * @constant
        * @type {Enumeration}
        */
        PARTIAL : new Enumeration(0, 'PARTIAL'),
        /**
        * Represents that an object is visible in its entirety.
        *
        * @constant
        * @type {Enumeration}
        */
        FULL : new Enumeration(1, 'FULL')
    };

    return Visibility;
});
/*global define*/
define('Core/WindingOrder',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports WindingOrder
     */
    var WindingOrder = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLOCKWISE : new Enumeration(0x0900, 'CLOCKWISE'), // WebGL: CW
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COUNTER_CLOCKWISE : new Enumeration(0x0901, 'COUNTER_CLOCKWISE'), // WebGL CCW

        /**
         * DOC_TBA
         *
         * @param windingOrder
         *
         * @returns {Boolean}
         */
        validate : function(windingOrder) {
            return ((windingOrder === WindingOrder.CLOCKWISE) ||
                    (windingOrder === WindingOrder.COUNTER_CLOCKWISE));
        }
    };

    return WindingOrder;
});
/*global define*/
define('Core/binarySearch',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Finds an item in a sorted array.
     *
     * @exports binarySearch
     *
     * @param {Array} array The sorted array to search.
     * @param {Object} itemToFind The item to find in the array.
     *
     * @param {Function} comparator The function to use to compare the item to elements in the array.
     *        The first parameter passed to the comparator function is an item in the array, the
     *        second is <code>itemToFind</code>.  If the array item is less than <code>itemToFind</code>,
     *        the function should return a negative value.  If it is greater, the function should return
     *        a positive value.  If the items are equal, it should return 0.
     *
     * @return {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
     *        does not exist, the return value is a negative number which is the bitwise complement (~)
     *        of the index before which the itemToFind should be inserted in order to maintain the
     *        sorted order of the array.
     *
     * @exception {DeveloperError} <code>array</code> is required.
     * @exception {DeveloperError} <code>toFind</code> is required.
     * @exception {DeveloperError} <code>comparator</code> is required.
     *
     * @example
     * // Create a comparator function to search through an array of numbers.
     * var comparator = function (a, b){
     *     return a - b;
     * };
     * var numbers = [0, 2, 4, 6, 8];
     * var index = binarySearch(numbers, 6, comparator); // 3
     */
    var binarySearch = function(array, itemToFind, comparator) {
        if (!array) {
            throw new DeveloperError('array is required.');
        }
        if (!itemToFind) {
            throw new DeveloperError('itemToFind is required.');
        }
        if (!comparator) {
            throw new DeveloperError('comparator is required.');
        }

        var low = 0;
        var high = array.length - 1;
        var i;
        var comparison;

        while (low <= high) {
            i = ~~((low + high) / 2);
            comparison = comparator(array[i], itemToFind);
            if (comparison < 0) {
                low = i + 1;
                continue;
            }
            if (comparison > 0) {
                high = i - 1;
                continue;
            }
            return i;
        }
        return ~(high + 1);
    };

    return binarySearch;
});
/*global define*/
define('Core/AnimationController',[
    './binarySearch',
    './DeveloperError'
], function(
    binarySearch,
    DeveloperError
) {
    

    /**
     * This controls animation by manipulating a Clock object.
     * @alias AnimationController
     * @constructor
     *
     * @param {Clock} clock The clock that will be controlled.
     *
     * @see Clock
     */
    var AnimationController = function(clock) {
        this.clock = clock;
        this._animating = true;
        if (typeof clock !== 'object') {
            throw new DeveloperError('Clock parameter required to construct AnimationController.');
        }
    };

    var typicalMultipliers = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.0, 7200.0, 14400.0, 21600.0,
                              43200.0, 86400.0];

    /**
     * Test if the AnimationController is playing or paused.
     * @memberof AnimationController
     *
     * @returns Boolean <code>true</code> if the AnimationController is animating in either direction.
     */
    AnimationController.prototype.isAnimating = function() {
        return this._animating;
    };

    /**
     * Stop animating, and reset the clock back to the start time.
     * @memberof AnimationController
     */
    AnimationController.prototype.reset = function() {
        this.clock.currentTime = this.clock.startTime;
        this._animating = false;
    };

    /**
     * Update the clock to the appropriate animation time.  This function
     * should be called exactly once per animation frame, prior to updating
     * any other objects that depend on the animation time.
     * @memberof AnimationController
     *
     * @returns {JulianDate} The updated time if animating, or <code>currentTime</code> if paused.
     */
    AnimationController.prototype.update = function() {
        return this._animating ? this.clock.tick() : this.clock.currentTime;
    };

    /**
     * Stop animating, and hold on the current time.
     * @memberof AnimationController
     */
    AnimationController.prototype.pause = function() {
        this._animating = false;
    };

    /**
     * Begin or resume animating in a forward direction.
     * @memberof AnimationController
     */
    AnimationController.prototype.play = function() {
        this._animating = true;
        var clock = this.clock;
        if (clock.multiplier < 0) {
            clock.multiplier = -clock.multiplier;
        }
        this.clock.tick(0);
    };

    /**
     * Begin or resume animating in a reverse direction.
     * @memberof AnimationController
     */
    AnimationController.prototype.playReverse = function() {
        this._animating = true;
        var clock = this.clock;
        if (clock.multiplier > 0) {
            clock.multiplier = -clock.multiplier;
        }
        this.clock.tick(0);
    };

    /**
     * Slow down the speed of animation, so time appears to pass more slowly.
     * @memberof AnimationController
     */
    AnimationController.prototype.slower = function() {
        var clock = this.clock;
        var multiplier = clock.multiplier > 0 ? clock.multiplier : -clock.multiplier;
        var index = binarySearch(typicalMultipliers, multiplier, function(left, right) {
            return left - right;
        });

        if (index < 0) {
            index = ~index;
        }
        index--;

        if (index === -1) {
            clock.multiplier *= 0.5;
        } else if (clock.multiplier >= 0) {
            clock.multiplier = typicalMultipliers[index];
        } else {
            clock.multiplier = -typicalMultipliers[index];
        }
    };

    /**
     * Speed up the animation, so time appears to pass more quickly.
     * @memberof AnimationController
     */
    AnimationController.prototype.faster = function() {
        var clock = this.clock;
        var multiplier = clock.multiplier > 0 ? clock.multiplier : -clock.multiplier;
        var index = binarySearch(typicalMultipliers, multiplier, function(left, right) {
            return left - right;
        });

        if (index < 0) {
            index = ~index;
        } else {
            index++;
        }

        if (index === typicalMultipliers.length) {
            clock.multiplier *= 2.0;
        } else if (clock.multiplier >= 0) {
            clock.multiplier = typicalMultipliers[index];
        } else {
            clock.multiplier = -typicalMultipliers[index];
        }
    };

    return AnimationController;
});
/*global define*/
define('Core/clone',[],function() {
    

    function clone(object) {
        if (object === null || typeof object !== 'object') {
            return object;
        }

        var temp = new object.constructor();
        for ( var key in object) {
            if (object.hasOwnProperty(key)) {
                temp[key] = clone(object[key]);
            }
        }

        return temp;
    }

    return clone;
});

/*global define*/
define('Core/createGuid',[],function() {
    

    /**
     * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
     *
     * @exports createGuid
     *
     * @see <a href='http://www.ietf.org/rfc/rfc4122.txt'>RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace</a>
     *
     * @example
     * this.guid = createGuid();
     */
    var createGuid = function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    return createGuid;
});
/*global define*/
define('Core/defaultValue',[],function() {
    

    /**
     * Returns the first parameter if not undefined, otherwise the second parameter.
     * Useful for setting a default value for a parameter.
     *
     * @exports defaultValue
     *
     * @example
     * param = defaultValue(param, 'default');
     */
    var defaultValue = function(a, b) {
        if (typeof a !== 'undefined') {
            return a;
        }
        return b;
    };

    return defaultValue;
});
/*global define*/
define('Core/Interval',['./defaultValue'], function(defaultValue) {
    

    /**
     * Represents the closed interval [start, stop].
     * @alias Interval
     * @constructor
     *
     * @param {Number} [start=0.0] The beginning of the interval.
     * @param {Number} [stop=0.0] The end of the interval.
     */
    var Interval = function(start, stop) {
        /**
         * The beginning of the interval.
         * @type {Number}
         */
        this.start = defaultValue(start, 0.0);
        /**
         * The end of the interval.
         * @type {Number}
         */
        this.stop = defaultValue(stop, 0.0);
    };

    return Interval;
});
/*global define*/
define('Core/Math',[
        './defaultValue',
        './DeveloperError'
       ], function(
         defaultValue,
         DeveloperError) {
    

    /**
     * Math functions.
     * @exports CesiumMath
     */
    var CesiumMath = {};

    /**
     * 0.1
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON1 = 0.1;

    /**
     * 0.01
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON2 = 0.01;

    /**
     * 0.001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON3 = 0.001;

    /**
     * 0.0001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON4 = 0.0001;

    /**
     * 0.00001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON5 = 0.00001;

    /**
     * 0.000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON6 = 0.000001;

    /**
     * 0.0000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON7 = 0.0000001;

    /**
     * 0.00000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON8 = 0.00000001;

    /**
     * 0.000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON9 = 0.000000001;

    /**
     * 0.0000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON10 = 0.0000000001;

    /**
     * 0.00000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON11 = 0.00000000001;

    /**
     * 0.000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON12 = 0.000000000001;

    /**
     * 0.0000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON13 = 0.0000000000001;

    /**
     * 0.00000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON14 = 0.00000000000001;

    /**
     * 0.000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON15 = 0.000000000000001;

    /**
     * 0.0000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON16 = 0.0000000000000001;

    /**
     * 0.00000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON17 = 0.00000000000000001;

    /**
     * 0.000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON18 = 0.000000000000000001;

    /**
     * 0.0000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON19 = 0.0000000000000000001;

    /**
     * 0.00000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON20 = 0.00000000000000000001;

    /**
     * 3.986004418e14
     * @constant
     * @type Number
     */
    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

    /**
     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
     * negative, or 0 if the value is 0.
     *
     * @param {Number} value The value to return the sign of.
     *
     * @return {Number} The sign of value.
     */
    CesiumMath.sign = function(value) {
        if (value > 0) {
            return 1;
        } else if (value < 0) {
            return -1;
        }

        return 0;
    };

    /**
     * Returns the hyperbolic sine of a {@code Number}.
     * The hyperbolic sine of <em>value</em> is defined to be
     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is an infinity
     *     with the same sign as the argument.</li>
     *
     *     <li>If the argument is zero, then the result is a zero with the
     *     same sign as the argument.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic sine is to be returned.
     *
     * @return The hyperbolic sine of {@code value}.
     *
     */
    CesiumMath.sinh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 - part2) * 0.5;
    };

    /**
     * Returns the hyperbolic cosine of a {@code Number}.
     * The hyperbolic cosine of <strong>value</strong> is defined to be
     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is positive infinity.</li>
     *
     *     <li>If the argument is zero, then the result is {@code 1.0}.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic cosine is to be returned.
     *
     * @return The hyperbolic cosine of {@code value}.
     */
    CesiumMath.cosh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 + part2) * 0.5;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.lerp = function(p, q, time) {
        return ((1.0 - time) * p) + (time * q);
    };

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see czm_pi
     */
    CesiumMath.PI = Math.PI;

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see czm_oneOverPi
     */
    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

    /**
     * pi/2
     *
     * @constant
     * @type {Number}
     * @see czm_piOverTwo
     */
    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;

    /**
     * pi/3
     * <br /><br />
     *
     * @constant
     * @type {Number}
     * @see czm_piOverThree
     */
    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

    /**
     * pi/4
     *
     * @constant
     * @type {Number}
     * @see czm_piOverFour
     */
    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

    /**
     * pi/6
     *
     * @constant
     * @type {Number}
     * @see czm_piOverSix
     */
    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

    /**
     * 3pi/2
     *
     * @constant
     * @type {Number}
     * @see czm_threePiOver2
     */
    CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;

    /**
     * 2pi
     *
     * @constant
     * @type {Number}
     * @see czm_twoPi
     */
    CesiumMath.TWO_PI = 2.0 * Math.PI;

    /**
     * 1/2pi
     *
     * @constant
     * @type {Number}
     * @see czm_oneOverTwoPi
     */
    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

    /**
     * The number of radians in a degree.
     *
     * @constant
     * @type {Number}
     * @see czm_radiansPerDegree
     */
    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

    /**
     * The number of degrees in a radian.
     *
     * @constant
     * @type {Number}
     * @see czm_degreesPerRadian
     */
    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

    /**
     * Converts degrees to radians.
     * @param {Number} degrees The angle to convert in degrees.
     * @return {Number} The corresponding angle in radians.
     */
    CesiumMath.toRadians = function(degrees) {
        return degrees * CesiumMath.RADIANS_PER_DEGREE;
    };

    /**
     * Converts radians to degrees.
     * @param {Number} radians The angle to convert in radians.
     * @return {Number} The corresponding angle in degrees.
     */
    CesiumMath.toDegrees = function(radians) {
        return radians * CesiumMath.DEGREES_PER_RADIAN;
    };

    /**
     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @return {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @example
     * // Convert 270 degrees to -90 degrees longitude
     * var longitude = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(270.0));
     */
    CesiumMath.convertLongitudeRange = function(angle) {
        var twoPi = CesiumMath.TWO_PI;

        var simplified = angle - Math.floor(angle / twoPi) * twoPi;
        if (simplified < -Math.PI) {
            simplified += twoPi;
        } else if (simplified >= Math.PI) {
            simplified -= twoPi;
        }
        return simplified;
    };

    /**
     * Alters the value of input x such that <code>-CesiumMath.PI</code> <= x <= <code>CesiumMath.PI</code>
     * @param {Number} angle in radians
     * @return {Number} The angle in the range ()<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>).
    */
    CesiumMath.negativePiToPi = function(x){
        var epsilon10 = CesiumMath.EPSILON10;
        var pi = CesiumMath.PI;
        var two_pi = CesiumMath.TWO_PI;
        while(x < -(pi+ epsilon10)){
            x += two_pi;
        }
        if(x < -pi){
            x = -pi;
        }
        while(x > pi + epsilon10){
            x-=two_pi;
        }
        if(x > pi){
            x = pi;
        }
        return x;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.equalsEpsilon = function(left, right, epsilon) {
        epsilon = epsilon || 0.0;
        return Math.abs(left - right) <= epsilon;
    };

    var factorials = [1];

    /**
     * Computes the factorial of the provided number.
     *
     * @memberof CesiumMath
     *
     * @param {Number} n The number whose factorial is to be computed.
     *
     * @return {Number} The factorial of the provided number or undefined if the number is less than 0.
     *
     * @see <a href='http://en.wikipedia.org/wiki/Factorial'>Factorial on Wikipedia</a>.
     *
     * @example
     * //Compute 7!, which is equal to 5040
     * var computedFactorial = CesiumMath.factorial(7);
     *
     * @exception {DeveloperError} A number greater than or equal to 0 is required.
     */
    CesiumMath.factorial = function(n) {
        if (typeof n !== 'number' || n < 0) {
            throw new DeveloperError('A number greater than or equal to 0 is required.');
        }

        var length = factorials.length;
        if (n >= length) {
            var sum = factorials[length - 1];
            for ( var i = length; i <= n; i++) {
                factorials.push(sum * i);
            }
        }
        return factorials[n];
    };

    /**
     * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
     *
     * @memberof CesiumMath
     *
     * @param {Number} [n] The number to be incremented.
     * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.
     * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.
     *
     * @return {Number} The incremented number.
     *
     * @example
     * var n = CesiumMath.incrementWrap(5, 10, 0); // returns 6
     * var n = CesiumMath.incrementWrap(10, 10, 0); // returns 0
     *
     * @exception {DeveloperError} Maximum value must be greater than minimum value.
     */
    CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {
        minimumValue = defaultValue(minimumValue, 0.0);

        if (maximumValue <= minimumValue) {
            throw new DeveloperError('Maximum value must be greater than minimum value.');
        }

        ++n;
        if(n > maximumValue) {
            n = minimumValue;
        }
        return n;
    };

    /**
     * Determines if a positive integer is a power of two.
     *
     * @memberof CesiumMath
     *
     * @param {Number} n The positive integer to test.
     *
     * @return {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
     *
     * @example
     * var t = CesiumMath.isPowerOfTwo(16); // true
     * var f = CesiumMath.isPowerOfTwo(20); // false
     *
     * @exception {DeveloperError} A number greater than or equal to 0 is required.
     */
    CesiumMath.isPowerOfTwo = function(n) {
        if (typeof n !== 'number' || n < 0) {
            throw new DeveloperError('A number greater than or equal to 0 is required.');
        }

        var m = n | 0;
        return (m !== 0) && ((m & (m - 1)) === 0);
    };

    /**
     * Constraint a value to lie between two values.
     *
     * @memberof CesiumMath
     *
     * @param {Number} value The value to constrain.
     * @param {Number} min The minimum value.
     * @param {Number} max The maximum value.
     * @returns The value clamped so that min <= value <= max.
     */
    CesiumMath.clamp = function(value, min, max) {
        return value < min ? min : value > max ? max : value;
    };

    return CesiumMath;
});

/*global define*/
define('Core/HermitePolynomialApproximation',['./Math'
       ], function(
        CesiumMath) {
    

    var factorial = CesiumMath.factorial;

    function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
        var result = 0;
        var reserved;
        var i;
        var j;

        if (derivOrder > 0) {
            for (i = 0; i < termOrder; i++) {
                reserved = false;
                for (j = 0; j < reservedIndices.length && !reserved; j++) {
                    if (i === reservedIndices[j]) {
                        reserved = true;
                    }
                }

                if (!reserved) {
                    reservedIndices.push(i);
                    result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
                    reservedIndices.splice(reservedIndices.length - 1, 1);
                }
            }

            return result;
        }

        result = 1;
        for (i = 0; i < termOrder; i++) {
            reserved = false;
            for (j = 0; j < reservedIndices.length && !reserved; j++) {
                if (i === reservedIndices[j]) {
                    reserved = true;
                }
            }

            if (!reserved) {
                result *= x - xTable[zIndices[i]];
            }
        }

        return result;
    }

    /**
     * Functions for performing Hermite interpolation.
     * @exports HermitePolynomialApproximation
     *
     * @see LinearApproximation
     * @see LagrangePolynomialApproximation
     */
    var HermitePolynomialApproximation = {
        type : 'Hermite'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof HermitePolynomialApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    HermitePolynomialApproximation.getRequiredDataPoints = function(degree) {
        return Math.max(degree + 1, 2);
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LinearApproximation
     * @see LagrangePolynomialApproximation
     *
     * @memberof HermitePolynomialApproximation
     */
    HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        var length = xTable.length, i, j, d, s, len, index, result = new Array(yStride), coefficients = new Array(yStride);

        for (i = 0; i < yStride; i++) {
            result[i] = 0;

            var l = new Array(length);
            coefficients[i] = l;
            for (j = 0; j < length; j++) {
                l[j] = [];
            }
        }

        var zIndicesLength = length, zIndices = new Array(zIndicesLength);

        for (i = 0; i < zIndicesLength; i++) {
            zIndices[i] = i;
        }

        var highestNonZeroCoef = length - 1;
        for (s = 0; s < yStride; s++) {
            for (j = 0; j < zIndicesLength; j++) {
                index = zIndices[j] * yStride + s;
                coefficients[s][0].push(yTable[index]);
            }

            for (i = 1; i < zIndicesLength; i++) {
                var nonZeroCoefficients = false;
                for (j = 0; j < zIndicesLength - i; j++) {
                    var zj = xTable[zIndices[j]];
                    var zn = xTable[zIndices[j + i]];

                    var numerator;
                    if (zn - zj <= 0) {
                        index = zIndices[j] * yStride + yStride * i + s;
                        numerator = yTable[index];
                        coefficients[s][i].push(numerator / factorial(i));
                    } else {
                        numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
                        coefficients[s][i].push(numerator / (zn - zj));
                    }
                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
                }

                if (!nonZeroCoefficients) {
                    highestNonZeroCoef = i - 1;
                }
            }
        }

        for (d = 0, len = 0; d <= len; d++) {
            for (i = d; i <= highestNonZeroCoef; i++) {
                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
                for (s = 0; s < yStride; s++) {
                    var coeff = coefficients[s][i][0];
                    result[s + d * yStride] += coeff * tempTerm;
                }
            }
        }

        return result;
    };

    return HermitePolynomialApproximation;
});
/*global define*/
define('Core/QuadraticRealPolynomial',[
        './DeveloperError',
        './Math'
    ],
    function(
        DeveloperError,
        CesiumMath) {
    

    /**
     * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
     *
     * @exports QuadraticRealPolynomial
     */
    var QuadraticRealPolynomial = {};

    /**
     * Provides the discriminant of the quadratic equation from the supplied coefficients.
     * @memberof QuadraticRealPolynomial
     *
     * @param {Number} a The coefficient of the 2nd order monomial.
     * @param {Number} b The coefficient of the 1st order monomial.
     * @param {Number} c The coefficient of the 0th order monomial.
     * @returns {Number} The value of the discriminant.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     */
    QuadraticRealPolynomial.discriminant = function(a, b, c){
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }

        var discriminant = b * b - 4.0 * a * c;
        return discriminant;
    };

    function addWithCancellationCheck(left, right, tolerance) {
        var difference = left + right;
        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&
                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
            return 0.0;
        }

        return difference;
    }

    /**
     * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
     * @memberof QuadraticRealPolynomial
     *
     * @param {Number} a The coefficient of the 2nd order monomial.
     * @param {Number} b The coefficient of the 1st order monomial.
     * @param {Number} c The coefficient of the 0th order monomial.
     * @returns {Array} The real valued roots.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     */
    QuadraticRealPolynomial.realRoots = function(a, b, c) {
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }

        var ratio;
        if (a === 0.0) {
            if (b === 0.0) {
                // Constant function: c = 0.
                return [];
            }

            // Linear function: b * x + c = 0.
            return [ -c / b ];
        } else if (b === 0.0) {
            if (c === 0.0) {
                // 2nd order monomial: a * x^2 = 0.
                return [ 0.0, 0.0 ];
            }

            var cMagnitude = Math.abs(c);
            var aMagnitude = Math.abs(a);

            if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < CesiumMath.EPSILON14)) { // c ~= 0.0.
                // 2nd order monomial: a * x^2 = 0.
                return [ 0.0, 0.0 ];
            } else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < CesiumMath.EPSILON14)) { // a ~= 0.0.
                // Constant function: c = 0.
                return [];
            }

            // a * x^2 + c = 0
            ratio = -c / a;

            if (ratio < 0.0) {
                // Both roots are complex.
                return [];
            }

            // Both roots are real.
            var root = Math.sqrt(ratio);
            return [ -root, root ];
        } else if (c === 0.0) {
            // a * x^2 + b * x = 0
            ratio = -b / a;
            if (ratio < 0.0) {
                return [ ratio, 0.0 ];
            }

            return [ 0.0, ratio ];
        }

        // a * x^2 + b * x + c = 0
        var b2 = b * b;
        var four_ac = 4.0 * a * c;
        var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);

        if (radicand < 0.0) {
            // Both roots are complex.
            return [];
        }

        var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);
        if (b > 0.0) {
            return [ q / a, c / q ];
        }

        return [ c / q, q / a ];
    };

    return QuadraticRealPolynomial;
});
/*global define*/
define('Core/CubicRealPolynomial',[
        './DeveloperError',
        './Math',
        './QuadraticRealPolynomial'
    ],
    function(
        DeveloperError,
        CesiumMath,
        QuadraticRealPolynomial) {
    

    /**
     * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
     *
     * @exports CubicRealPolynomial
     */
    var CubicRealPolynomial = {};

    /**
     * Provides the discriminant of the cubic equation from the supplied coefficients.
     * @memberof CubicRealPolynomial
     *
     * @param {Number} a The coefficient of the 3rd order monomial.
     * @param {Number} b The coefficient of the 2nd order monomial.
     * @param {Number} c The coefficient of the 1st order monomial.
     * @param {Number} d The coefficient of the 0th order monomial.
     * @returns {Number} The value of the discriminant.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     * @exception {DeveloperError} d is a required number.
     */
    CubicRealPolynomial.discriminant = function(a, b, c, d){
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }
        if (typeof d !== 'number') {
            throw new DeveloperError('d is a required number.');
        }

        var a2 = a * a;
        var b2 = b * b;
        var c2 = c * c;
        var d2 = d * d;

        var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);
        return discriminant;
    };

    function computeRealRoots(a, b, c, d)
    {
        var A = a;
        var B = b / 3.0;
        var C = c / 3.0;
        var D = d;

        var AC = A * C;
        var BD = B * D;
        var B2 = B * B;
        var C2 = C * C;
        var delta1 = A * C - B2;
        var delta2 = A * D - B * C;
        var delta3 = B * D - C2;

        var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;
        var temp;
        var temp1;

        if (discriminant < 0.0){
            var ABar;
            var CBar;
            var DBar;

            if (B2 * BD >= AC * C2)
            {
                ABar = A;
                CBar = delta1;
                DBar = -2.0 * B * delta1 + A * delta2;
            } else {
                ABar = D;
                CBar = delta3;
                DBar = -D * delta2 + 2.0 * C * delta3;
            }

            var s = (DBar < 0.0) ? -1.0 : 1.0; // This is not Math.Sign()!
            var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
            temp1 = -DBar + temp0;

            var x = temp1 / 2.0;
            var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);
            var q = (temp1 === temp0) ? -p : -CBar / p;

            temp = (CBar <= 0.0) ? p + q : -DBar / (p * p + q * q + CBar);

            if (B2 * BD >= AC * C2) {
                return [ (temp - B) / A ];
            }

            return [ -D / (temp + C) ];
        }

        var CBarA = delta1;
        var DBarA = -2.0 * B * delta1 + A * delta2;

        var CBarD = delta3;
        var DBarD = -D * delta2 + 2.0 * C * delta3;

        var squareRootOfDiscriminant = Math.sqrt(discriminant);
        var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;

        var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);
        temp = 2.0 * Math.sqrt(-CBarA);
        var cosine = Math.cos(theta);
        temp1 = temp * cosine;
        var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

        var numeratorLarge = (temp1 + temp3 > 2.0 * B) ? temp1 - B : temp3 - B;
        var denominatorLarge = A;

        var root1 = numeratorLarge / denominatorLarge;

        theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);
        temp = 2.0 * Math.sqrt(-CBarD);
        cosine = Math.cos(theta);
        temp1 = temp * cosine;
        temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

        var numeratorSmall = -D;
        var denominatorSmall = (temp1 + temp3 < 2.0 * C) ? temp1 + C : temp3 + C;

        var root3 = numeratorSmall / denominatorSmall;

        var E = denominatorLarge * denominatorSmall;
        var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
        var G = numeratorLarge * numeratorSmall;

        var root2 = (C * F - B * G) / (-B * F + C * E);

        if (root1 <= root2) {
            if (root1 <= root3) {
                if (root2 <= root3) {
                    return [ root1, root2, root3 ];
                }
                return [ root1, root3, root2 ];
            }
            return [ root3, root1, root2 ];
        }
        if (root1 <= root3) {
            return [ root2, root1, root3 ];
        }
        if (root2 <= root3) {
            return [ root2, root3, root1 ];
        }
        return [ root3, root2, root1 ];
    }

    /**
     * Provides the real valued roots of the cubic polynomial with the provided coefficients.
     * @memberof CubicRealPolynomial
     *
     * @param {Number} a The coefficient of the 3rd order monomial.
     * @param {Number} b The coefficient of the 2nd order monomial.
     * @param {Number} c The coefficient of the 1st order monomial.
     * @param {Number} d The coefficient of the 0th order monomial.
     * @returns {Array} The real valued roots.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     * @exception {DeveloperError} d is a required number.
     */
    CubicRealPolynomial.realRoots = function(a, b, c, d) {
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }
        if (typeof d !== 'number') {
            throw new DeveloperError('d is a required number.');
        }

        var roots;
        var ratio;
        if (a === 0.0) {
            // Quadratic function: b * x^2 + c * x + d = 0.
            return QuadraticRealPolynomial.realRoots(b, c, d);
        } else if (b === 0.0) {
            if (c === 0.0) {
                if (d === 0.0) {
                    // 3rd order monomial: a * x^3 = 0.
                    return [ 0.0, 0.0, 0.0 ];
                }

                // a * x^3 + d = 0
                ratio = -d / a;
                var root = (ratio < 0.0) ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);
                return [ root, root, root ];
            } else if (d === 0.0) {
                // x * (a * x^2 + c) = 0.
                roots = QuadraticRealPolynomial.realRoots(a, 0, c);

                // Return the roots in ascending order.
                if (roots.Length === 0){
                    return [ 0.0 ];
                }
                return [ roots[0], 0.0, roots[1] ];
            }

            // Deflated cubic polynomial: a * x^3 + c * x + d= 0.
            return computeRealRoots(a, 0, c, d);
        } else if (c === 0.0) {
            if (d === 0.0) {
                // x^2 * (a * x + b) = 0.
                ratio = -b / a;
                if (ratio < 0.0) {
                    return [ ratio, 0.0, 0.0 ];
                }
                return [ 0.0, 0.0, ratio ];
            }
            // a * x^3 + b * x^2 + d = 0.
            return computeRealRoots(a, b, 0, d);
        } else if (d === 0.0) {
            // x * (a * x^2 + b * x + c) = 0
            roots = QuadraticRealPolynomial.realRoots(a, b, c);

            // Return the roots in ascending order.
            if (roots.length === 0) {
                return [ 0.0 ];
            } else if (roots[1] <= 0.0) {
                return [ roots[0], roots[1], 0.0 ];
            } else if (roots[0] >= 0.0) {
                return [ 0.0, roots[0], roots[1] ];
            }
            return [ roots[0], 0.0, roots[1] ];
        }

        return computeRealRoots(a, b, c, d);
    };

    return CubicRealPolynomial;
});
/*global define*/
define('Core/QuarticRealPolynomial',[
        './DeveloperError',
        './Math',
        './CubicRealPolynomial',
        './QuadraticRealPolynomial'
    ],
    function(
        DeveloperError,
        CesiumMath,
        CubicRealPolynomial,
        QuadraticRealPolynomial) {
    

    /**
     * Defines functions for 4th order polynomial functions of one variable with only real coefficients.
     *
     * @exports QuarticRealPolynomial
     */
    var QuarticRealPolynomial = {};

    /**
     * Provides the discriminant of the quartic equation from the supplied coefficients.
     * @memberof QuarticRealPolynomial
     *
     * @param {Number} a The coefficient of the 4th order monomial.
     * @param {Number} b The coefficient of the 3rd order monomial.
     * @param {Number} c The coefficient of the 2nd order monomial.
     * @param {Number} d The coefficient of the 1st order monomial.
     * @param {Number} e The coefficient of the 0th order monomial.
     * @returns {Number} The value of the discriminant.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     * @exception {DeveloperError} d is a required number.
     * @exception {DeveloperError} e is a required number.
     */
    QuarticRealPolynomial.discriminant = function(a, b, c, d, e){
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }
        if (typeof d !== 'number') {
            throw new DeveloperError('d is a required number.');
        }
        if (typeof e !== 'number') {
            throw new DeveloperError('e is a required number.');
        }

        var a2 = a * a;
        var a3 = a2 * a;
        var b2 = b * b;
        var b3 = b2 * b;
        var c2 = c * c;
        var c3 = c2 * c;
        var d2 = d * d;
        var d3 = d2 * d;
        var e2 = e * e;
        var e3 = e2 * e;

        var discriminant = (b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3) +
            e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) +
            e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);
        return discriminant;
    };

    function original(a3, a2, a1, a0) {
        var a3Squared = a3 * a3;

        var p = a2 - 3.0 * a3Squared / 8.0;
        var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;
        var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;

        // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.
        var cubicRoots = CubicRealPolynomial.realRoots(1.0, 2.0 * p, p * p - 4.0 * r, - q * q);

        if (cubicRoots.length > 0) {
            var temp = -a3 / 4.0;

            // Use the largest positive root.
            var hSquared = cubicRoots[cubicRoots.length - 1];

            if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
                // y^4 + p y^2 + r = 0.
                var roots = QuadraticRealPolynomial.realRoots(1.0, p, r);

                if (roots.length === 2){
                    var root0 = roots[0];
                    var root1 = roots[1];

                    var y;
                    if (root0 >= 0.0 && root1 >= 0.0)
                    {
                        var y0 = Math.sqrt(root0);
                        var y1 = Math.sqrt(root1);

                        return [ temp - y1, temp - y0, temp + y0, temp + y1 ];
                    } else if (root0 >= 0.0 && root1 < 0.0) {
                        y = Math.sqrt(root0);
                        return [ temp - y, temp + y ];
                    } else if (root0 < 0.0 && root1 >= 0.0) {
                        y = Math.sqrt(root1);
                        return [ temp - y, temp + y ];
                    }
                }
                return [];
            } else if (hSquared > 0.0) {
                var h = Math.sqrt(hSquared);

                var m = (p + hSquared - q / h) / 2.0;
                var n = (p + hSquared + q / h) / 2.0;

                // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);
                var roots1 = QuadraticRealPolynomial.realRoots(1.0, h, m);
                var roots2 = QuadraticRealPolynomial.realRoots(1.0, -h, n);

                if (roots1.length !== 0) {
                    roots1[0] += temp;
                    roots1[1] += temp;

                    if (roots2.length !== 0) {
                        roots2[0] += temp;
                        roots2[1] += temp;

                        if (roots1[1] <= roots2[0]) {
                            return [ roots1[0], roots1[1], roots2[0], roots2[1] ];
                        } else if (roots2[1] <= roots1[0]) {
                            return [ roots2[0], roots2[1], roots1[0], roots1[1] ];
                        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                            return [ roots2[0], roots1[0], roots1[1], roots2[1] ];
                        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                            return [ roots1[0], roots2[0], roots2[1], roots1[1] ];
                        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                            return [ roots2[0], roots1[0], roots2[1], roots1[1] ];
                        }
                        return [ roots1[0], roots2[0], roots1[1], roots2[1] ];
                    }
                    return roots1;
                }

                if (roots2.length !== 0) {
                    roots2[0] += temp;
                    roots2[1] += temp;

                    return roots2;
                }
                return [];
            }
        }
        return [];
    }

    function neumark(a3, a2, a1, a0) {
        var a1Squared = a1 * a1;
        var a2Squared = a2 * a2;
        var a3Squared = a3 * a3;

        var p = -2.0 * a2;
        var q = a1 * a3 + a2Squared - 4.0 * a0;
        var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;

        var cubicRoots = CubicRealPolynomial.realRoots(1.0, p, q, r);

        if (cubicRoots.length > 0) {
            // Use the most positive root
            var y = cubicRoots[0];

            var temp = (a2 - y);
            var tempSquared = temp * temp;

            var g1 = a3 / 2.0;
            var h1 = temp / 2.0;

            var m = tempSquared - 4.0 * a0;
            var mError = tempSquared + 4.0 * Math.abs(a0);

            var n = a3Squared - 4.0 * y;
            var nError = a3Squared + 4.0 * Math.abs(y);

            var g2;
            var h2;

            if (y < 0.0 || (m * nError < n * mError)) {
                var squareRootOfN = Math.sqrt(n);
                g2 = squareRootOfN / 2.0;
                h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;
            } else {
                var squareRootOfM = Math.sqrt(m);
                g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;
                h2 = squareRootOfM / 2.0;
            }

            var G;
            var g;
            if (g1 === 0.0 && g2 === 0.0)
            {
                G = 0.0;
                g = 0.0;
            } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
                G = g1 + g2;
                g = y / G;
            } else {
                g = g1 - g2;
                G = y / g;
            }

            var H;
            var h;
            if (h1 === 0.0 && h2 === 0.0) {
                H = 0.0;
                h = 0.0;
            }
            else if (CesiumMath.sign(h1) === CesiumMath.sign(h2))
            {
                H = h1 + h2;
                h = a0 / H;
            } else {
                h = h1 - h2;
                H = a0 / h;
            }

            // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);
            var roots1 = QuadraticRealPolynomial.realRoots(1.0, G, H);
            var roots2 = QuadraticRealPolynomial.realRoots(1.0, g, h);

            if (roots1.length !== 0) {
                if (roots2.length !== 0) {
                    if (roots1[1] <= roots2[0]) {
                        return [ roots1[0], roots1[1], roots2[0], roots2[1] ];
                    } else if (roots2[1] <= roots1[0]) {
                        return [ roots2[0], roots2[1], roots1[0], roots1[1] ];
                    } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                        return [ roots2[0], roots1[0], roots1[1], roots2[1] ];
                    } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                        return [ roots1[0], roots2[0], roots2[1], roots1[1] ];
                    } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                        return [ roots2[0], roots1[0], roots2[1], roots1[1] ];
                    } else {
                        return [ roots1[0], roots2[0], roots1[1], roots2[1] ];
                    }
                }
                return roots1;
            }
            if (roots2.length !== 0) {
                return roots2;
            }
        }
        return [];
    }

    /**
     * Provides the real valued roots of the quartic polynomial with the provided coefficients.
     * @memberof QuarticRealPolynomial
     *
     * @param {Number} a The coefficient of the 4th order monomial.
     * @param {Number} b The coefficient of the 3rd order monomial.
     * @param {Number} c The coefficient of the 2nd order monomial.
     * @param {Number} d The coefficient of the 1st order monomial.
     * @param {Number} e The coefficient of the 0th order monomial.
     * @returns {Array} The real valued roots.
     *
     * @exception {DeveloperError} a is a required number.
     * @exception {DeveloperError} b is a required number.
     * @exception {DeveloperError} c is a required number.
     * @exception {DeveloperError} d is a required number.
     * @exception {DeveloperError} e is a required number.
     */
    QuarticRealPolynomial.realRoots = function(a, b, c, d, e) {
        if (typeof a !== 'number') {
            throw new DeveloperError('a is a required number.');
        }
        if (typeof b !== 'number') {
            throw new DeveloperError('b is a required number.');
        }
        if (typeof c !== 'number') {
            throw new DeveloperError('c is a required number.');
        }
        if (typeof d !== 'number') {
            throw new DeveloperError('d is a required number.');
        }
        if (typeof e !== 'number') {
            throw new DeveloperError('e is a required number.');
        }

        if (Math.abs(a) < CesiumMath.EPSILON15)
        {
            return CubicRealPolynomial.realRoots(b, c, d, e);
        }
        var a3 = b / a;
        var a2 = c / a;
        var a1 = d / a;
        var a0 = e / a;

        var k = (a3 < 0.0) ? 1 : 0;
        k += (a2 < 0.0) ? k + 1 : k;
        k += (a1 < 0.0) ? k + 1 : k;
        k += (a0 < 0.0) ? k + 1 : k;

        switch (k) {
            case 0: return original(a3, a2, a1, a0);
            case 1: return neumark(a3, a2, a1, a0);
            case 2: return neumark(a3, a2, a1, a0);
            case 3: return original(a3, a2, a1, a0);
            case 4: return original(a3, a2, a1, a0);
            case 5: return neumark(a3, a2, a1, a0);
            case 6: return original(a3, a2, a1, a0);
            case 7: return original(a3, a2, a1, a0);
            case 8: return neumark(a3, a2, a1, a0);
            case 9: return original(a3, a2, a1, a0);
            case 10: return original(a3, a2, a1, a0);
            case 11: return neumark(a3, a2, a1, a0);
            case 12: return original(a3, a2, a1, a0);
            case 13: return original(a3, a2, a1, a0);
            case 14: return original(a3, a2, a1, a0);
            case 15: return original(a3, a2, a1, a0);
            default: return undefined;
        }
    };

    return QuarticRealPolynomial;
});
/*global define*/
define('Core/combine',[
        './DeveloperError',
        './defaultValue'
    ], function(
        DeveloperError,
        defaultValue) {
    

    /**
     * Merges object properties into a new combined object. When two objects have the same
     * property, the value of the object that comes earlier in the array is used.
     *
     * @example
     * var object1 = {
     *     one : 1,
     *     deep : {
     *         value1 : 10
     *     }
     * }
     * var object2 = {
     *     two : 2
     * }
     * var object3 = {
     *     deep : {
     *         value1 : 5,
     *         value2 : 11
     *     }
     * }
     * var final = combine([object1,object2, object3], true, true);
     *
     * // final === {
     * //     one : 1,
     * //     two : 2,
     * //     deep : {
     * //         value1 : 10,
     * //         value2 : 11
     * //     }
     * // }
     *
     * @param {Array} objects Array of objects that get merged together.
     * @param {Boolean} [deep = true] Perform a recursive merge.
     * @param {Boolean} [allowDuplicates = true] An error gets thrown if allowDuplicates is false and two objects contain the same property.
     *
     * @returns {Object} combined object
     *
     * @exports combine
     *
     * @exception {DeveloperError} Duplicate member.
     */

    var combine = function(objects, deep, allowDuplicates) {
        deep = defaultValue(deep, true);
        allowDuplicates = defaultValue(allowDuplicates, true);

        var combined = {};
        for (var i = 0; i < objects.length; i++) {
            combineTwoObjects(combined, objects[i], deep, allowDuplicates);
        }
        return combined;
    };
    var combineTwoObjects = function(object1, object2, deep, allowDuplicates) {
        for (var property in object2) {
            if (object2.hasOwnProperty(property)) {
                if (object1.hasOwnProperty(property) && (typeof object1[property] !== 'undefined')) {
                    if (!allowDuplicates) {
                        throw new DeveloperError('Duplicate member: ' + property);
                    }
                    if (deep && typeof object1[property] === 'object' && typeof object2[property] === 'object') {
                        combineTwoObjects(object1[property], object2[property], deep, allowDuplicates);
                    }
                }
                else {
                    object1[property] = object2[property];
                }
            }
        }
    };

    return combine;
});
/*global define*/
define('Core/destroyObject',[
        './defaultValue',
        './DeveloperError'
    ], function(
        defaultValue,
        DeveloperError) {
    

    function returnTrue() {
        return true;
    }

    /**
     * Destroys an object.  Each of the object's functions, including functions in its prototype,
     * is replaced with a function that throws a {@link DeveloperError}, except for the object's
     * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
     * The object's properties are removed with <code>delete</code>.
     * <br /><br />
     * This function is used by objects that hold native resources, e.g., WebGL resources, which
     * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
     * which then releases the native resource and calls <code>destroyObject</code> to put itself
     * in a destroyed state.
     *
     * @exports destroyObject
     *
     * @param {Object} object The object to destroy.
     * @param {String} [message] The message to include in the exception that is thrown if
     *                           a destroyed object's function is called.
     *
     * @see DeveloperError
     *
     * @example
     * // How a texture would destroy itself.
     * this.destroy = function () {
     *     _gl.deleteTexture(_texture);
     *     return destroyObject(this);
     * };
     */
    var destroyObject = function(object, message) {
        message = defaultValue(message, 'This object was destroyed, i.e., destroy() was called.');

        function throwOnDestroyed() {
            throw new DeveloperError(message);
        }

        for ( var key in object) {
            if (typeof object[key] === 'function') {
                object[key] = throwOnDestroyed;
            } else {
                delete object[key];
            }
        }

        object.isDestroyed = returnTrue;

        return undefined;
    };

    return destroyObject;
});
/*global define*/
define('Core/freezeObject',[],function() {
    

    /**
     * Freezes an object, using Object.freeze if available, otherwise returns
     * the object unchanged.  This function should be used in setup code to prevent
     * errors from completely halting JavaScript execution in legacy browsers.
     *
     * @exports freezeObject
     */
    var freezeObject = Object.freeze;
    if (typeof freezeObject === 'undefined') {
        freezeObject = function(o) {
            return o;
        };
    }

    return freezeObject;
});
/*global define*/
define('Core/Cartesian2',[
        './defaultValue',
        './DeveloperError',
        './freezeObject'
    ], function(
        defaultValue,
        DeveloperError,
        freezeObject) {
    

    /**
     * A 2D Cartesian point.
     * @alias Cartesian2
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     *
     * @see Cartesian3
     * @see Cartesian4
     */
    var Cartesian2 = function(x, y) {
        /**
         * The Y component.
         * @type Number
         */
        this.x = defaultValue(x, 0.0);

        /**
         * The X component.
         * @type Number
         */
        this.y = defaultValue(y, 0.0);
    };

    /**
     * Duplicates a Cartesian2 instance.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to duplicate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x, cartesian.y);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        return result;
    };

    /**
     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
     * x and y properties of the Cartesian3 and drops z.
     * @memberof Cartesian2
     * @function
     *
     * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.fromCartesian3 = Cartesian2.clone;

    /**
     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
     * x and y properties of the Cartesian4 and drops z and w.
     * @function
     *
     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.fromCartesian4 = Cartesian2.clone;

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be normalized.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian2.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x / magnitude, cartesian.y / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x * right.x, left.y * right.y);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x + right.x, left.y + right.y);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x - right.x, left.y - right.y);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x * scalar, cartesian.y * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x / scalar, cartesian.y / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be negated.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(-cartesian.x, -cartesian.y);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(Math.abs(cartesian.x), Math.abs(cartesian.y));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        return result;
    };

    var lerpScratch = new Cartesian2();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian2
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian2.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian2.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian2.add(lerpScratch, result, result);
    };

    var angleBetweenScratch = new Cartesian2();
    var angleBetweenScratch2 = new Cartesian2();
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.angleBetween = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        Cartesian2.normalize(left, angleBetweenScratch);
        Cartesian2.normalize(right, angleBetweenScratch2);
        return Math.acos(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
    };

    var mostOrthogonalAxisScratch = new Cartesian2();
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The most orthogonal axis.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.mostOrthogonalAxis = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
        Cartesian2.abs(f, f);

        if (f.x <= f.y) {
            result = Cartesian2.clone(Cartesian2.UNIT_X, result);
        } else {
            result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
        }

        return result;
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [left] The first Cartesian.
     * @param {Cartesian2} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian2.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [left] The first Cartesian.
     * @param {Cartesian2} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian2.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon));
    };

    /**
     * An immutable Cartesian2 instance initialized to (0.0, 0.0).
     * @memberof Cartesian2
     */
    Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));

    /**
     * An immutable Cartesian2 instance initialized to (1.0, 0.0).
     * @memberof Cartesian2
     */
    Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));

    /**
     * An immutable Cartesian2 instance initialized to (0.0, 1.0).
     * @memberof Cartesian2
     */
    Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian2
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian2.prototype.getMaximumComponent = function() {
        return Cartesian2.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian2
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian2.prototype.getMinimumComponent = function() {
        return Cartesian2.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian2 instance.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    Cartesian2.prototype.clone = function(result) {
        return Cartesian2.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian2
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian2.prototype.magnitudeSquared = function() {
        return Cartesian2.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian2
     *
     * @return {Number} The magnitude.
     */
    Cartesian2.prototype.magnitude = function() {
        return Cartesian2.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    Cartesian2.prototype.normalize = function(result) {
        return Cartesian2.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.dot = function(right) {
        return Cartesian2.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.multiplyComponents = function(right, result) {
        return Cartesian2.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.add = function(right, result) {
        return Cartesian2.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.subtract = function(right, result) {
        return Cartesian2.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian2.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.prototype.divideByScalar = function(scalar, result) {
        return Cartesian2.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    Cartesian2.prototype.negate = function(result) {
        return Cartesian2.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    Cartesian2.prototype.abs = function(result) {
        return Cartesian2.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian2
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian2.prototype.lerp = function(end, t, result) {
        return Cartesian2.lerp(this, end, t, result);
    };

    /**
     * Returns the angle, in radians, between this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.angleBetween = function(right) {
        return Cartesian2.angleBetween(this, right);
    };

    /**
     * Returns the axis that is most orthogonal to the this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The most orthogonal axis.
     */
    Cartesian2.prototype.mostOrthogonalAxis = function(result) {
        return Cartesian2.mostOrthogonalAxis(this, result);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian2.prototype.equals = function(right) {
        return Cartesian2.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian2.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian2.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @memberof Cartesian2
     *
     * @return {String} A string representing the provided Cartesian in the format '(x, y)'.
     */
    Cartesian2.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ')';
    };

    return Cartesian2;
});

/*global define*/
define('Core/PlaneTessellator',[
        './DeveloperError',
        './Cartesian2',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian2,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports PlaneTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     */
    var PlaneTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} Resolution must be greater than one in both the x and y directions.
         */
        compute : function(template) {
            template = template || {};
            var resolution = template.resolution || new Cartesian2(2, 2);
            var onInterpolation = template.onInterpolation; // Can be undefined

            if (resolution.x <= 1 || resolution.y <= 1) {
                throw new DeveloperError('Resolution must be greater than one in both the x and y directions.');
            }

            var i;
            var j;

            // To allow computing custom attributes, e.g., texture coordinates, etc.
            if (onInterpolation) {
                for (j = 0; j < resolution.y; ++j) {
                    var yTime = j / (resolution.y - 1);

                    for (i = 0; i < resolution.x; ++i) {
                        var xTime = i / (resolution.x - 1);
                        onInterpolation(new Cartesian2(xTime, yTime));
                    }
                }
            }

            var indices = [];

            // Counterclockwise winding order
            for (j = 0; j < resolution.y - 1; ++j) {
                var row = j * resolution.x;
                var aboveRow = (j + 1) * resolution.x;

                for (i = 0; i < resolution.x - 1; ++i) {
                    indices.push(row + i, row + i + 1, aboveRow + i + 1);
                    indices.push(row + i, aboveRow + i + 1, aboveRow + i);
                }
            }

            return {
                attributes : {},
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : indices
                }]
            };
        }
    };

    return PlaneTessellator;
});
/*global define*/
define('Core/Cartesian3',[
        './defaultValue',
        './DeveloperError',
        './freezeObject'
    ], function(
        defaultValue,
        DeveloperError,
        freezeObject) {
    

    /**
     * A 3D Cartesian point.
     * @alias Cartesian3
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     *
     * @see Cartesian2
     * @see Cartesian4
     */
    var Cartesian3 = function(x, y, z) {
        /**
         * The X component.
         * @type Number
         */
        this.x = defaultValue(x, 0.0);

        /**
         * The Y component.
         * @type Number
         */
        this.y = defaultValue(y, 0.0);

        /**
         * The Z component.
         * @type Number
         */
        this.z = defaultValue(z, 0.0);
    };

    /**
     * Converts the provided Spherical into Cartesian3 coordinates.
     * @memberof Cartesian3
     *
     * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} spherical is required.
     */
    Cartesian3.fromSpherical = function(spherical, result) {
        if (typeof spherical === 'undefined') {
            throw new DeveloperError('spherical is required');
        }
        if (typeof result === 'undefined') {
            result = new Cartesian3();
        }
        var clock = spherical.clock;
        var cone = spherical.cone;
        var magnitude = defaultValue(spherical.magnitude, 1.0);
        var radial = magnitude * Math.sin(cone);
        result.x = radial * Math.cos(clock);
        result.y = radial * Math.sin(clock);
        result.z = magnitude * Math.cos(cone);
        return result;
    };

    /**
     * Duplicates a Cartesian3 instance.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to duplicate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        result.z = cartesian.z;
        return result;
    };

    /**
     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
     * x, y, and z properties of the Cartesian4 and drops w.
     * @function
     *
     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.fromCartesian4 = Cartesian3.clone;

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be normalized.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian3.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x / magnitude, cartesian.y / magnitude, cartesian.z / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        result.z = cartesian.z / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y + left.z * right.z;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x * right.x, left.y * right.y, left.z * right.z);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        result.z = left.z * right.z;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x + right.x, left.y + right.y, left.z + right.z);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x - right.x, left.y - right.y, left.z - right.z);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        result.z = left.z - right.z;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x * scalar,  cartesian.y * scalar,  cartesian.z * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        result.z = cartesian.z * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x / scalar, cartesian.y / scalar, cartesian.z / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        result.z = cartesian.z / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be negated.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(-cartesian.x, -cartesian.y, -cartesian.z);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        result.z = -cartesian.z;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(Math.abs(cartesian.x), Math.abs(cartesian.y), Math.abs(cartesian.z));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        result.z = Math.abs(cartesian.z);
        return result;
    };

    var lerpScratch = new Cartesian3();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian3
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian3.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian3.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian3.add(lerpScratch, result, result);
    };

    var angleBetweenScratch = new Cartesian3();
    var angleBetweenScratch2 = new Cartesian3();
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.angleBetween = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        Cartesian3.normalize(left, angleBetweenScratch);
        Cartesian3.normalize(right, angleBetweenScratch2);
        var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
        var sine = Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch).magnitude();
        return Math.atan2(sine, cosine);
    };

    var mostOrthogonalAxisScratch = new Cartesian3();
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The most orthogonal axis.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.mostOrthogonalAxis = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
        Cartesian3.abs(f, f);

        if (f.x <= f.y) {
            if (f.x <= f.z) {
                result = Cartesian3.clone(Cartesian3.UNIT_X, result);
            } else {
                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
            }
        } else {
            if (f.y <= f.z) {
                result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
            } else {
                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
            }
        }

        return result;
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [left] The first Cartesian.
     * @param {Cartesian3} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian3.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.z === right.z));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [left] The first Cartesian.
     * @param {Cartesian3} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian3.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon) &&
                (Math.abs(left.z - right.z) <= epsilon));
    };

    /**
     * Computes the cross (outer) product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The cross product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.cross = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var leftX = left.x;
        var leftY = left.y;
        var leftZ = left.z;
        var rightX = right.x;
        var rightY = right.y;
        var rightZ = right.z;

        var x = leftY * rightZ - leftZ * rightY;
        var y = leftZ * rightX - leftX * rightZ;
        var z = leftX * rightY - leftY * rightX;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian3
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian3.prototype.getMaximumComponent = function() {
        return Cartesian3.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian3
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian3.prototype.getMinimumComponent = function() {
        return Cartesian3.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian3 instance.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Cartesian3.prototype.clone = function(result) {
        return Cartesian3.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian3
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian3.prototype.magnitudeSquared = function() {
        return Cartesian3.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian3
     *
     * @return {Number} The magnitude.
     */
    Cartesian3.prototype.magnitude = function() {
        return Cartesian3.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Cartesian3.prototype.normalize = function(result) {
        return Cartesian3.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.dot = function(right) {
        return Cartesian3.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.multiplyComponents = function(right, result) {
        return Cartesian3.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.add = function(right, result) {
        return Cartesian3.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.subtract = function(right, result) {
        return Cartesian3.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian3.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.prototype.divideByScalar = function(scalar, result) {
        return Cartesian3.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Cartesian3.prototype.negate = function(result) {
        return Cartesian3.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Cartesian3.prototype.abs = function(result) {
        return Cartesian3.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian3
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian3.prototype.lerp = function(end, t, result) {
        return Cartesian3.lerp(this, end, t, result);
    };

    /**
     * Returns the angle, in radians, between this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.angleBetween = function(right) {
        return Cartesian3.angleBetween(this, right);
    };

    /**
     * Returns the axis that is most orthogonal to the this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The most orthogonal axis.
     */
    Cartesian3.prototype.mostOrthogonalAxis = function(result) {
        return Cartesian3.mostOrthogonalAxis(this, result);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian3.prototype.equals = function(right) {
        return Cartesian3.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian3.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian3.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y, z)'.
     * @memberof Cartesian3
     *
     * @return {String} A string representing this Cartesian in the format '(x, y, z)'.
     */
    Cartesian3.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    };

    /**
     * Computes the cross (outer) product of this and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The cross product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.cross = function(right, result) {
        return Cartesian3.cross(this, right, result);
    };

    return Cartesian3;
});

/*global define*/
define('Core/AxisAlignedBoundingBox',[
        './defaultValue',
        './DeveloperError',
        './Cartesian3',
        './Intersect'
    ], function(
        defaultValue,
        DeveloperError,
        Cartesian3,
        Intersect) {
    

    /**
     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
     * @alias AxisAlignedBoundingBox
     * @constructor
     *
     * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.
     * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.
     * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.
     *
     * @see BoundingSphere
     */
    var AxisAlignedBoundingBox = function(minimum, maximum, center) {
        /**
         * The minimum point defining the bounding box.
         * @type {Cartesian3}
         */
        this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));

        /**
         * The maximum point defining the bounding box.
         * @type {Cartesian3}
         */
        this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));

        //If center was not defined, compute it.
        if (typeof center === 'undefined') {
            center = Cartesian3.add(this.minimum, this.maximum);
            Cartesian3.multiplyByScalar(center, 0.5, center);
        } else {
            center = Cartesian3.clone(center);
        }

        /**
         * The center point of the bounding box.
         * @type {Cartesian3}
         */
        this.center = center;
    };

    /**
     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by
     * finding the points spaced the farthest apart on the x, y, and z axes.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {Array} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
     * @return {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
     *
     * @example
     * // Compute an axis aligned bounding box enclosing two points.
     * var box = AxisAlignedBoundingBox.fromPoints([new Cartesian3(2, 0, 0), new Cartesian3(-2, 0, 0)]);
     */
    AxisAlignedBoundingBox.fromPoints = function(positions, result) {
        if (typeof result === 'undefined') {
            result = new AxisAlignedBoundingBox();
        }

        if (typeof positions === 'undefined' || positions.length === 0) {
            result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);
            result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);
            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
            return result;
        }

        var minimumX = positions[0].x;
        var minimumY = positions[0].y;
        var minimumZ = positions[0].z;

        var maximumX = positions[0].x;
        var maximumY = positions[0].y;
        var maximumZ = positions[0].z;

        var length = positions.length;
        for ( var i = 1; i < length; i++) {
            var p = positions[i];
            var x = p.x;
            var y = p.y;
            var z = p.z;

            minimumX = Math.min(x, minimumX);
            maximumX = Math.max(x, maximumX);
            minimumY = Math.min(y, minimumY);
            maximumY = Math.max(y, maximumY);
            minimumZ = Math.min(z, minimumZ);
            maximumZ = Math.max(z, maximumZ);
        }

        var minimum = result.minimum;
        minimum.x = minimumX;
        minimum.y = minimumY;
        minimum.z = minimumZ;

        var maximum = result.maximum;
        maximum.x = maximumX;
        maximum.y = maximumY;
        maximum.z = maximumZ;

        var center = Cartesian3.add(minimum, maximum, result.center);
        Cartesian3.multiplyByScalar(center, 0.5, center);

        return result;
    };

    /**
     * Duplicates a AxisAlignedBoundingBox instance.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.
     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
     * @return {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided.
     *
     * @exception {DeveloperError} box is required.
     */
    AxisAlignedBoundingBox.clone = function(box, result) {
        if (typeof box === 'undefined') {
            throw new DeveloperError('box is required');
        }

        if (typeof result === 'undefined') {
            return new AxisAlignedBoundingBox(box.minimum, box.maximum);
        }

        result.minimum = Cartesian3.clone(box.minimum, result.minimum);
        result.maximum = Cartesian3.clone(box.maximum, result.maximum);
        result.center = Cartesian3.clone(box.center, result.center);
        return result;
    };

    /**
     * Compares the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.
     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    AxisAlignedBoundingBox.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                Cartesian3.equals(left.center, right.center) &&
                Cartesian3.equals(left.minimum, right.minimum) &&
                Cartesian3.equals(left.maximum, right.maximum));
    };

    var intersectScratch = new Cartesian3();
    /**
     * Determines which side of a plane a box is located.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {AxisAlignedBoundingBox} box The bounding box to test.
     * @param {Cartesian4} plane The coefficients of the plane in the form <code>ax + by + cz + d = 0</code>
     *                           where the coefficients a, b, c, and d are the components x, y, z, and w
     *                           of the {Cartesian4}, respectively.
     * @return {Intersect} {Intersect.INSIDE} if the entire box is on the side of the plane the normal is pointing,
     *                     {Intersect.OUTSIDE} if the entire box is on the opposite side, and {Intersect.INTERSETING}
     *                     if the box intersects the plane.
     *
     * @exception {DeveloperError} box is required.
     * @exception {DeveloperError} plane is required.
     */
    AxisAlignedBoundingBox.intersect = function(box, plane) {
        if (typeof box === 'undefined') {
            throw new DeveloperError('box is required.');
        }

        if (typeof plane === 'undefined') {
            throw new DeveloperError('plane is required.');
        }

        intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);
        var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal
        var e = h.x * Math.abs(plane.x) + h.y * Math.abs(plane.y) + h.z * Math.abs(plane.z);
        var s = Cartesian3.dot(box.center, plane) + plane.w; //signed distance from center

        if (s - e > 0) {
            return Intersect.INSIDE;
        }

        if (s + e < 0) {
            //Not in front because normals point inward
            return Intersect.OUTSIDE;
        }

        return Intersect.INTERSECTING;
    };

    /**
     * Duplicates this AxisAlignedBoundingBox instance.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
     * @return {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
     */
    AxisAlignedBoundingBox.prototype.clone = function(result) {
        return AxisAlignedBoundingBox.clone(this, result);
    };

    /**
     * Determines which side of a plane this box is located.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {Cartesian4} plane The coefficients of the plane in the form <code>ax + by + cz + d = 0</code>
     *                           where the coefficients a, b, c, and d are the components x, y, z, and w
     *                           of the {Cartesian4}, respectively.
     * @return {Intersect} {Intersect.INSIDE} if the entire box is on the side of the plane the normal is pointing,
     *                     {Intersect.OUTSIDE} if the entire box is on the opposite side, and {Intersect.INTERSETING}
     *                     if the box intersects the plane.
     *
     * @exception {DeveloperError} plane is required.
     */
    AxisAlignedBoundingBox.prototype.intersect = function(plane) {
        return AxisAlignedBoundingBox.intersect(this, plane);
    };

    /**
     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof AxisAlignedBoundingBox
     *
     * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    AxisAlignedBoundingBox.prototype.equals = function(right) {
        return AxisAlignedBoundingBox.equals(this, right);
    };

    return AxisAlignedBoundingBox;
});

/*global define*/
define('Core/BoxTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @alias BoxTessellator
     * @exports BoxTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see PlaneTessellator
     */
    var BoxTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} All dimensions' components must be greater than or equal to zero.
         */
        compute : function(template) {
            template = template || {};
            var minimumCorner;
            var maximumCorner;

            if (template.minimumCorner && template.maximumCorner) {
                minimumCorner = template.minimumCorner;
                maximumCorner = template.maximumCorner;
            } else {
                var dimensions = template.dimensions || new Cartesian3(1.0, 1.0, 1.0);

                if (dimensions.x < 0 || dimensions.y < 0 || dimensions.z < 0) {
                    throw new DeveloperError('All dimensions components must be greater than or equal to zero.');
                }

                var corner = dimensions.multiplyByScalar(0.5);
                minimumCorner = corner.negate();
                maximumCorner = corner;
            }

            var mesh = {};
            mesh.attributes = {};
            mesh.indexLists = [];

            // 8 corner points.
            mesh.attributes.position = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : [
                          minimumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, maximumCorner.y, maximumCorner.z,
                          minimumCorner.x, maximumCorner.y, maximumCorner.z
                      ]
            };

            // 12 triangles:  6 faces, 2 triangles each.
            mesh.indexLists.push({
                primitiveType : PrimitiveType.TRIANGLES,
                values : [
                          4, 5, 6, // Top: plane z = corner.Z
                          4, 6, 7,
                          1, 0, 3, // Bottom: plane z = -corner.Z
                          1, 3, 2,
                          1, 6, 5, // Side: plane x = corner.X
                          1, 2, 6,
                          2, 3, 7, // Side: plane y = corner.Y
                          2, 7, 6,
                          3, 0, 4, // Side: plane x = -corner.X
                          3, 4, 7,
                          0, 1, 5, // Side: plane y = -corner.Y
                          0, 5, 4
                      ]
            });

            return mesh;
        }
    };

    return BoxTessellator;
});
/*global define*/
define('Core/CubeMapEllipsoidTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports CubeMapEllipsoidTessellator
     *
     * @see BoxTessellator
     */
    var CubeMapEllipsoidTessellator = {};

    /**
     * DOC_TBA
     *
     * @param {Ellipsoid} ellipsoid DOC_TBA.
     * @param {Number} numberOfPartitions DOC_TBA.
     * @param {String} attributeName DOC_TBA.
     *
     * @exception {DeveloperError} numberOfPartitions must be greater than zero.
     */
    CubeMapEllipsoidTessellator.compute = function(ellipsoid, numberOfPartitions, attributeName) {
        if (numberOfPartitions <= 0) {
            throw new DeveloperError('numberOfPartitions must be greater than zero.');
        }

        attributeName = attributeName || 'position';

        var positions = [];
        var indices = [];

        function addEdgePositions(i0, i1) {
            var indices = [];
            indices[0] = i0;
            indices[2 + (numberOfPartitions - 1) - 1] = i1;

            var origin = positions[i0];
            var direction = positions[i1].subtract(positions[i0]);

            for ( var i = 1; i < numberOfPartitions; ++i) {
                var delta = i / numberOfPartitions;

                indices[i] = positions.length;
                positions.push(origin.add(direction.multiplyByScalar(delta)));
            }

            return indices;
        }

        function addFaceTriangles(leftBottomToTop, bottomLeftToRight, rightBottomToTop, topLeftToRight) {
            var origin = positions[bottomLeftToRight[0]];
            var x = positions[bottomLeftToRight[bottomLeftToRight.length - 1]].subtract(origin);
            var y = positions[topLeftToRight[0]].subtract(origin);

            var bottomIndicesBuffer = [];
            var topIndicesBuffer = [];

            var bottomIndices = bottomLeftToRight;
            var topIndices = topIndicesBuffer;

            for ( var j = 1; j <= numberOfPartitions; ++j) {
                if (j !== numberOfPartitions) {
                    if (j !== 1) {
                        //
                        // This copy could be avoided by ping ponging buffers.
                        //
                        bottomIndicesBuffer = topIndicesBuffer.slice(0);
                        bottomIndices = bottomIndicesBuffer;
                    }

                    topIndicesBuffer[0] = leftBottomToTop[j];
                    topIndicesBuffer[numberOfPartitions] = rightBottomToTop[j];

                    var deltaY = j / numberOfPartitions;
                    var offsetY = y.multiplyByScalar(deltaY);

                    for ( var i = 1; i < numberOfPartitions; ++i) {
                        var deltaX = i / numberOfPartitions;
                        var offsetX = x.multiplyByScalar(deltaX);

                        topIndicesBuffer[i] = positions.length;
                        positions.push(origin.add(offsetX).add(offsetY));
                    }
                } else {
                    if (j !== 1) {
                        bottomIndices = topIndicesBuffer;
                    }
                    topIndices = topLeftToRight;
                }

                for ( var k = 0; k < numberOfPartitions; ++k) {
                    indices.push(bottomIndices[k]);
                    indices.push(bottomIndices[k + 1]);
                    indices.push(topIndices[k + 1]);

                    indices.push(bottomIndices[k]);
                    indices.push(topIndices[k + 1]);
                    indices.push(topIndices[k]);
                }
            }
        }

        //
        // Initial cube.  In the plane, z = -1:
        //
        //                   +y
        //                    |
        //             Q2     * p3     Q1
        //                  / | \
        //              p0 *--+--* p2   +x
        //                  \ | /
        //             Q3     * p1     Q4
        //                    |
        //
        // Similarly, p4 to p7 are in the plane z = 1.
        //
        positions.push(new Cartesian3(-1, 0, -1));
        positions.push(new Cartesian3(0, -1, -1));
        positions.push(new Cartesian3(1, 0, -1));
        positions.push(new Cartesian3(0, 1, -1));
        positions.push(new Cartesian3(-1, 0, 1));
        positions.push(new Cartesian3(0, -1, 1));
        positions.push(new Cartesian3(1, 0, 1));
        positions.push(new Cartesian3(0, 1, 1));

        //
        // Edges
        //
        // 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 0.  Plane z = -1
        // 4 -> 5, 5 -> 6, 6 -> 7, 7 -> 4.  Plane z = 1
        // 0 -> 4, 1 -> 5, 2 -> 6, 3 -> 7.  From plane z = -1 to plane z - 1
        //
        var edge0to1 = addEdgePositions(0, 1);
        var edge1to2 = addEdgePositions(1, 2);
        var edge2to3 = addEdgePositions(2, 3);
        var edge3to0 = addEdgePositions(3, 0);

        var edge4to5 = addEdgePositions(4, 5);
        var edge5to6 = addEdgePositions(5, 6);
        var edge6to7 = addEdgePositions(6, 7);
        var edge7to4 = addEdgePositions(7, 4);

        var edge0to4 = addEdgePositions(0, 4);
        var edge1to5 = addEdgePositions(1, 5);
        var edge2to6 = addEdgePositions(2, 6);
        var edge3to7 = addEdgePositions(3, 7);

        addFaceTriangles(edge0to4, edge0to1, edge1to5, edge4to5); // Q3 Face
        addFaceTriangles(edge1to5, edge1to2, edge2to6, edge5to6); // Q4 Face
        addFaceTriangles(edge2to6, edge2to3, edge3to7, edge6to7); // Q1 Face
        addFaceTriangles(edge3to7, edge3to0, edge0to4, edge7to4); // Q2 Face
        addFaceTriangles(edge7to4.slice(0).reverse(), edge4to5, edge5to6, edge6to7.slice(0).reverse()); // Plane z = 1
        addFaceTriangles(edge1to2, edge0to1.slice(0).reverse(), edge3to0.slice(0).reverse(), edge2to3); // Plane z = -1

        // Expand cube into ellipsoid and flatten values
        var radii = ellipsoid.getRadii();
        var length = positions.length;
        var q = 0;
        var flattenedPositions = new Array(length * 3);
        for ( var i = 0; i < length; ++i) {
            var item = positions[i];
            Cartesian3.normalize(item, item);
            Cartesian3.multiplyComponents(item, radii, item);
            flattenedPositions[q++] = item.x;
            flattenedPositions[q++] = item.y;
            flattenedPositions[q++] = item.z;
        }

        var mesh = {};
        mesh.attributes = {};
        mesh.indexLists = [];

        mesh.attributes[attributeName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : flattenedPositions
        };

        mesh.indexLists.push({
            primitiveType : PrimitiveType.TRIANGLES,
            values : indices
        });

        return mesh;
    };

    return CubeMapEllipsoidTessellator;
});
/*global define*/
define('Core/EncodedCartesian3',[
        './Cartesian3',
        './DeveloperError'
    ], function(
        Cartesian3,
        DeveloperError) {
    

    /**
     * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}
     * values that, when converted to 32-bit floating-point and added, approximate the original input.
     * <p>
     * This is used to encode positions in vertex buffers for rendering without jittering artifacts
     * as described in <a href="http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/">Precisions, Precisions</a>.
     * </p>
     *
     * @alias EncodedCartesian3
     * @constructor
     *
     * @see czm_modelViewRelativeToEye
     * @see czm_modelViewProjectionRelativeToEye
     */
    var EncodedCartesian3 = function() {
        /**
         * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.
         * <p>
         * The default is {@link Cartesian3.ZERO}.
         * </p>
         *
         * @type Number
         */
        this.high = Cartesian3.ZERO.clone();

        /**
         * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.
         * <p>
         * The default is {@link Cartesian3.ZERO}.
         * </p>
         *
         * @type Number
         */
        this.low = Cartesian3.ZERO.clone();
    };

    function spilt(value, result) {
        var doubleHigh;
        if (value >= 0.0) {
            doubleHigh = Math.floor(value / 65536.0) * 65536.0;
            result.high = doubleHigh;
            result.low = value - doubleHigh;
        } else {
            doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
            result.high = -doubleHigh;
            result.low = value + doubleHigh;
        }
    }

    var scratchSpilt = function() {
        this.high = 0.0;
        this.low = 0.0;
    };

    /**
     * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}
     * values that, when converted to 32-bit floating-point and added, approximate the original input.
     * <p>
     * The fixed-point encoding follows <a href="http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/">Precisions, Precisions</a>.
     * </p>
     * @memberof EncodedCartesian3
     *
     * @param {Cartesian3} cartesian The cartesian to encode.
     * @param {EncodedCartesian3} [result] The object onto which to store the result.
     * @return {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     *
     * @example
     * var c = new Cartesian3(-10000000.0, 0.0, 10000000.0);
     * var encoded = EncodedCartesian3.fromCartesian(c);
     */
    EncodedCartesian3.fromCartesian = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            result = new EncodedCartesian3();
        }

        var high = result.high;
        var low = result.low;

        spilt(cartesian.x, scratchSpilt);
        high.x = scratchSpilt.high;
        low.x = scratchSpilt.low;

        spilt(cartesian.y, scratchSpilt);
        high.y = scratchSpilt.high;
        low.y = scratchSpilt.low;

        spilt(cartesian.z, scratchSpilt);
        high.z = scratchSpilt.high;
        low.z = scratchSpilt.low;

        return result;
    };

    var encodedP = new EncodedCartesian3();

    /**
     * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>
     * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.
     * <p>
     * This is used to create interleaved high-precision position vertex attributes.
     * </p>
     *
     * @param {Cartesian3} cartesian The cartesian to encode.
     * @param {Array} cartesianArray The array to write to.
     * @param {Number} index The index into the array to start writing.  Six elements will be written.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} cartesianArray is required.
     * @exception {DeveloperError} index must be a number greater than or equal to 0.
     *
     * @example
     * var positions = [
     *    new Cartesian3(),
     *    // ...
     * ];
     * var encodedPositions = new Float32Array(2 * 3 * positions.length);
     * var j = 0;
     * for (var i = 0; i < positions.length; ++i) {
     *   EncodedCartesian3.writeElement(positions[i], encodedPositions, j);
     *   j += 6;
     * }
     */
    EncodedCartesian3.writeElements = function(cartesian, cartesianArray, index) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof cartesianArray === 'undefined') {
            throw new DeveloperError('cartesianArray is required');
        }

        if (typeof index !== 'number' || index < 0) {
            throw new DeveloperError('index must be a number greater than or equal to 0.');
        }

        EncodedCartesian3.fromCartesian(cartesian, encodedP);
        var high = encodedP.high;
        var low = encodedP.low;

        cartesianArray[index] = high.x;
        cartesianArray[index + 1] = high.y;
        cartesianArray[index + 2] = high.z;
        cartesianArray[index + 3] = low.x;
        cartesianArray[index + 4] = low.y;
        cartesianArray[index + 5] = low.z;
    };

    return EncodedCartesian3;
});

/*global define*/
define('Core/Ray',[
        './DeveloperError',
        './defaultValue',
        './Cartesian3'
       ], function(
         DeveloperError,
         defaultValue,
         Cartesian3) {
    

    /**
     * Represents a ray that extends infinitely from the provided origin in the provided direction.
     * @alias Ray
     * @constructor
     *
     * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.
     * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.
     */
    var Ray = function(origin, direction) {
        direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
        if (!direction.equals(Cartesian3.ZERO)) {
            Cartesian3.normalize(direction, direction);
        }

        /**
         * The origin of the ray.
         * @type {Cartesian3}
         */
        this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));

        /**
         * The direction of the ray.
         * @type {Cartesian3}
         */
        this.direction = direction;
    };

    /**
     * Computes the point along the ray given by r(t) = o + t*d,
     * where o is the origin of the ray and d is the direction.
     * @memberof Ray
     *
     * @param {Number} t A scalar value.
     * @param {Cartesian3} [result] The object in which the result will be stored.
     * @returns The modified result parameter, or a new instance if none was provided.
     *
     * @exception {DeveloperError} t is a required number
     *
     * @example
     * //Get the first intersection point of a ray and an ellipsoid.
     * var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
     * var point = ray.getPoint(intersection.start);
     */
    Ray.prototype.getPoint = function(t, result) {
        if (typeof t !== 'number') {
            throw new DeveloperError('t is a required number');
        }
        result = Cartesian3.multiplyByScalar(this.direction, t, result);
        return Cartesian3.add(this.origin, result, result);
    };

    return Ray;
});
/*global define*/
define('Core/Cartesian4',[
        './defaultValue',
        './DeveloperError',
        './freezeObject'
    ], function(
        defaultValue,
        DeveloperError,
        freezeObject) {
    

    /**
     * A 4D Cartesian point.
     * @alias Cartesian4
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     *
     * @see Cartesian2
     * @see Cartesian3
     */
    var Cartesian4 = function(x, y, z, w) {
        /**
         * The X component.
         * @type Number
         */
        this.x = defaultValue(x, 0.0);

        /**
         * The Y component.
         * @type Number
         */
        this.y = defaultValue(y, 0.0);

        /**
         * The Z component.
         * @type Number
         */
        this.z = defaultValue(z, 0.0);

        /**
         * The W component.
         * @type Number
         */
        this.w = defaultValue(w, 0.0);
    };

    /**
     * Duplicates a Cartesian4 instance.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to duplicate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        result.z = cartesian.z;
        result.w = cartesian.w;
        return result;
    };

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be normalized.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian4.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x / magnitude, cartesian.y / magnitude, cartesian.z / magnitude, cartesian.w / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        result.z = cartesian.z / magnitude;
        result.w = cartesian.w / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x * right.x, left.y * right.y, left.z * right.z, left.w * right.w);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        result.z = left.z * right.z;
        result.w = left.w * right.w;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
        result.w = left.w + right.w;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        result.z = left.z - right.z;
        result.w = left.w - right.w;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x * scalar, cartesian.y * scalar, cartesian.z * scalar, cartesian.w * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        result.z = cartesian.z * scalar;
        result.w = cartesian.w * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x / scalar, cartesian.y / scalar, cartesian.z / scalar, cartesian.w / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        result.z = cartesian.z / scalar;
        result.w = cartesian.w / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be negated.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(-cartesian.x, -cartesian.y, -cartesian.z, -cartesian.w);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        result.z = -cartesian.z;
        result.w = -cartesian.w;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(Math.abs(cartesian.x), Math.abs(cartesian.y), Math.abs(cartesian.z), Math.abs(cartesian.w));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        result.z = Math.abs(cartesian.z);
        result.w = Math.abs(cartesian.w);
        return result;
    };

    var lerpScratch = new Cartesian4();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian4
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian4.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian4.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian4.add(lerpScratch, result, result);
    };

    var mostOrthogonalAxisScratch = new Cartesian4();
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The most orthogonal axis.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.mostOrthogonalAxis = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
        Cartesian4.abs(f, f);

        if (f.x <= f.y) {
            if (f.x <= f.z) {
                if (f.x <= f.w) {
                    result = Cartesian4.clone(Cartesian4.UNIT_X, result);
                } else {
                    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
                }
            } else if (f.z <= f.w) {
                result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
            } else {
                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
            }
        } else if (f.y <= f.z) {
            if (f.y <= f.w) {
                result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
            } else {
                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
            }
        } else if (f.z <= f.w) {
            result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
        } else {
            result = Cartesian4.clone(Cartesian4.UNIT_W, result);
        }

        return result;
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [left] The first Cartesian.
     * @param {Cartesian4} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian4.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.z === right.z) &&
                (left.w === right.w));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [left] The first Cartesian.
     * @param {Cartesian4} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian4.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon) &&
                (Math.abs(left.z - right.z) <= epsilon) &&
                (Math.abs(left.w - right.w) <= epsilon));
    };

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian4
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian4.prototype.getMaximumComponent = function() {
        return Cartesian4.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian4
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian4.prototype.getMinimumComponent = function() {
        return Cartesian4.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian4 instance.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    Cartesian4.prototype.clone = function(result) {
        return Cartesian4.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian4
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian4.prototype.magnitudeSquared = function() {
        return Cartesian4.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian4
     *
     * @return {Number} The magnitude.
     */
    Cartesian4.prototype.magnitude = function() {
        return Cartesian4.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    Cartesian4.prototype.normalize = function(result) {
        return Cartesian4.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.dot = function(right) {
        return Cartesian4.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.multiplyComponents = function(right, result) {
        return Cartesian4.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.add = function(right, result) {
        return Cartesian4.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.subtract = function(right, result) {
        return Cartesian4.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian4.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.prototype.divideByScalar = function(scalar, result) {
        return Cartesian4.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    Cartesian4.prototype.negate = function(result) {
        return Cartesian4.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    Cartesian4.prototype.abs = function(result) {
        return Cartesian4.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian4
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian4.prototype.lerp = function(end, t, result) {
        return Cartesian4.lerp(this, end, t, result);
    };

    /**
     * Returns the axis that is most orthogonal to the this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The most orthogonal axis.
     */
    Cartesian4.prototype.mostOrthogonalAxis = function(result) {
        return Cartesian4.mostOrthogonalAxis(this, result);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian4.prototype.equals = function(right) {
        return Cartesian4.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian4.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian4.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @memberof Cartesian4
     *
     * @return {String} A string representing the provided Cartesian in the format '(x, y)'.
     */
    Cartesian4.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    };

    return Cartesian4;
});

/*global define*/
define('Core/Cartographic',[
        './defaultValue',
        './DeveloperError',
        './freezeObject',
        './Math'
    ], function(
        defaultValue,
        DeveloperError,
        freezeObject,
        CesiumMath) {
    

    /**
     * A position defined by longitude, latitude, and height.
     * @alias Cartographic
     * @constructor
     *
     * @param {Number} [longitude=0.0] The longitude, in radians.
     * @param {Number} [latitude=0.0] The latitude, in radians.
     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
     *
     * @see Ellipsoid
     */
    var Cartographic = function(longitude, latitude, height) {
        /**
         * The longitude, in radians.
         * @type Number
         */
        this.longitude = defaultValue(longitude, 0.0);

        /**
         * The latitude, in radians.
         * @type Number
         */
        this.latitude = defaultValue(latitude, 0.0);

        /**
         * The height, in meters, above the ellipsoid.
         * @type Number
         */
        this.height = defaultValue(height, 0.0);
    };

    /**
     * Creates a new Cartographic instance from longitude and latitude
     * specified in degrees.  The values in the resulting object will
     * be in radians.
     * @memberof Cartographic
     *
     * @param {Number} [longitude=0.0] The longitude, in degrees.
     * @param {Number} [latitude=0.0] The latitude, in degrees.
     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
     */
    Cartographic.fromDegrees = function(longitude, latitude, height, result) {
        longitude = CesiumMath.toRadians(defaultValue(longitude, 0.0));
        latitude = CesiumMath.toRadians(defaultValue(latitude, 0.0));
        height = defaultValue(height, 0.0);

        if (typeof result === 'undefined') {
            return new Cartographic(longitude, latitude, height);
        }

        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    };

    /**
     * Duplicates a Cartographic instance.
     * @memberof Cartographic
     *
     * @param {Cartographic} cartographic The cartographic to duplicate.
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Cartographic.clone = function(cartographic, result) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required');
        }
        if (typeof result === 'undefined') {
            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
        }
        result.longitude = cartographic.longitude;
        result.latitude = cartographic.latitude;
        result.height = cartographic.height;
        return result;
    };

    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [left] The first cartographic.
     * @param {Cartographic} [right] The second cartographic.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartographic.equals = function(left, right) {
        return (left === right) ||
                ((typeof left !== 'undefined') &&
                 (typeof right !== 'undefined') &&
                 (left.longitude === right.longitude) &&
                 (left.latitude === right.latitude) &&
                 (left.height === right.height));
    };

    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [left] The first cartographic.
     * @param {Cartographic} [right] The second cartographic.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartographic.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.longitude - right.longitude) <= epsilon) &&
                (Math.abs(left.latitude - right.latitude) <= epsilon) &&
                (Math.abs(left.height - right.height) <= epsilon));
    };

    /**
     * Creates a string representing the provided cartographic in the format '(longitude, latitude, height)'.
     * @memberof Cartographic
     *
     * @param {Cartographic} cartographic The cartographic to stringify.
     * @return {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Cartographic.toString = function(cartographic) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required');
        }
        return '(' + cartographic.longitude + ', ' + cartographic.latitude + ', ' + cartographic.height + ')';
    };

    /**
     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
     *
     * @memberof Cartographic
     */
    Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));

    /**
     * Duplicates this instance.
     * @memberof Cartographic
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
     */
    Cartographic.prototype.clone = function(result) {
        return Cartographic.clone(this, result);
    };

    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [right] The second cartographic.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartographic.prototype.equals = function(right) {
        return Cartographic.equals(this, right);
    };

    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [right] The second cartographic.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartographic.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
     * @memberof Cartographic
     *
     * @return {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
     */
    Cartographic.prototype.toString = function() {
        return Cartographic.toString(this);
    };

    return Cartographic;
});

/*global define*/
define('Core/PolylinePipeline',['./Cartographic',
        './Cartesian3'
    ], function(
        Cartographic,
        Cartesian3) {
    

    /**
     * DOC_TBA
     *
     * @exports PolylinePipeline
     */
    var PolylinePipeline = {
        /**
         * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid to wrap around.
         * @param {Array} positions The polyline's Cartesian positions.
         *
         * @returns An array of polyline segment objects containing the Cartesian and {@link Cartographic} positions and indices.
         *
         * @see Polyline
         * @see PolylineCollection
         *
         * @example
         * var polylines = new PolylineCollection();
         * polylines.add(...);
         * var positions = polylines.get(0).getPositions();
         * var segments = PolylinePipeline.wrapLongitude(ellipsoid, positions);
         */
        wrapLongitude : function(ellipsoid, positions) {
            var segments = [];

            if (positions && (positions.length > 0)) {
                var length = positions.length;

                var currentSegment = [{
                    cartesian : Cartesian3.clone(positions[0]),
                    cartographic : ellipsoid.cartesianToCartographic(positions[0]),
                    index : 0
                }];

                var prev = currentSegment[0].cartographic;

                for ( var i = 1; i < length; ++i) {
                    var cur = ellipsoid.cartesianToCartographic(positions[i]);

                    if (Math.abs(prev.longitude - cur.longitude) > Math.PI) {
                        var interpolatedLongitude = prev.longitude < 0.0 ? -Math.PI : Math.PI;
                        var longitude = cur.longitude + (2.0 * interpolatedLongitude);
                        var ratio = (interpolatedLongitude - prev.longitude) / (longitude - prev.longitude);
                        var interpolatedLatitude = prev.latitude + (cur.latitude - prev.latitude) * ratio;
                        var interpolatedHeight = prev.height + (cur.height - prev.height) * ratio;

                        currentSegment.push({
                            cartesian : ellipsoid.cartographicToCartesian(new Cartographic(interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic(interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                        segments.push(currentSegment);

                        currentSegment = [];
                        currentSegment.push({
                            cartesian : ellipsoid.cartographicToCartesian(new Cartographic(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                    }

                    currentSegment.push({
                        cartesian : Cartesian3.clone(positions[i]),
                        cartographic : ellipsoid.cartesianToCartographic(positions[i]),
                        index : i
                    });

                    prev = cur.clone();
                }

                if (currentSegment.length > 1) {
                    segments.push(currentSegment);
                }
            }

            return segments;
        }
    };

    return PolylinePipeline;
});
/*global define*/
define('Core/Color',[
        './defaultValue',
        './freezeObject'
    ], function(
        defaultValue,
        freezeObject) {
    

    /**
     * A color, specified using red, green, blue, and alpha values,
     * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     * @param {Number} [red=1.0] The red component.
     * @param {Number} [green=1.0] The green component.
     * @param {Number} [blue=1.0] The blue component.
     * @param {Number} [alpha=1.0] The alpha component.
     *
     * @constructor
     * @alias Color
     */
    var Color = function(red, green, blue, alpha) {
        /**
         * The red component.
         */
        this.red = defaultValue(red, 1.0);
        /**
         * The green component.
         */
        this.green = defaultValue(green, 1.0);
        /**
         * The blue component.
         */
        this.blue = defaultValue(blue, 1.0);
        /**
         * The alpha component.
         */
        this.alpha = defaultValue(alpha, 1.0);
    };

    /**
     * Creates a new Color specified using red, green, blue, and alpha values
     * that are in the range of 0 to 255, converting them internally to a
     * range of 0.0 to 1.0.
     * @memberof Color
     *
     * @param {Number} [red=255] The red component.
     * @param {Number} [green=255] The green component.
     * @param {Number} [blue=255] The blue component.
     * @param {Number} [alpha=255] The alpha component.
     * @returns {Color} A new color instance.
     */
    Color.fromBytes = function(red, green, blue, alpha) {
        red = defaultValue(red, 255.0);
        green = defaultValue(green, 255.0);
        blue = defaultValue(blue, 255.0);
        alpha = defaultValue(alpha, 255.0);
        return new Color(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);
    };

    /**
     * Converts a 'byte' color component in the range of 0 to 255 into
     * a 'float' color component range of 0 to 1.0.
     * @memberof Color
     *
     * @param {Number} number The number to be converted.
     * @returns {number} The converted number.
     */
    Color.byteToFloat = function(number) {
        return number / 255.0;
    };

    /**
     * Converts a 'float' color component in the range of 0 to 1.0 into
     * a 'byte' color component range of 0 to 255.
     * @memberof Color
     *
     * @param {Number} number The number to be converted.
     * @returns {number} The converted number.
     */
    Color.floatToByte = function(number) {
        return number === 1.0 ? 255.0 : (number * 256.0) | 0;
    };

    /**
     * Duplicates a Color.
     * @memberof Color
     *
     * @param {Color} color The Color to duplicate.
     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
     * @return {Color} The modified result parameter or a new instance if result was undefined.
     */
    Color.clone = function(color, result) {
        if (typeof result === 'undefined') {
            return new Color(color.red, color.green, color.blue, color.alpha);
        }
        result.red = color.red;
        result.green = color.green;
        result.blue = color.blue;
        result.alpha = color.alpha;
        return result;
    };

    /**
     * Returns true if the first Color equals the second color.
     * @memberof Color
     *
     * @param {Color} left The first Color to compare for equality.
     * @param {Color} right The second Color to compare for equality.
     * @return {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    Color.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left.red === right.red &&
                left.green === right.green &&
                left.blue === right.blue &&
                left.alpha === right.alpha);
    };

    /**
     * Returns a duplicate of a Color instance.
     * @memberof Color
     *
     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
     * @return {Color} The modified result parameter or a new instance if result was undefined.
     */
    Color.prototype.clone = function(result) {
        return Color.clone(this, result);
    };

    /**
     * Returns true if this Color equals other.
     * @memberof Color
     *
     * @param {Color} other The Color to compare for equality.
     * @return {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    Color.prototype.equals = function(other) {
        return Color.equals(this, other);
    };

    /**
     * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
     * @memberof Color
     *
     * @param {Color} other The Color to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Color.prototype.equalsEpsilon = function(other, epsilon) {
        return (this === other) ||
               ((typeof other !== 'undefined') &&
                (Math.abs(this.red - other.red) <= epsilon) &&
                (Math.abs(this.green - other.green) <= epsilon) &&
                (Math.abs(this.blue - other.blue) <= epsilon) &&
                (Math.abs(this.alpha - other.alpha) <= epsilon));
    };

    /**
     * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
     * @memberof Color
     *
     * @return {String} A string representing this Color in the format '(red, green, blue, alpha)'.
     */
    Color.prototype.toString = function() {
        return '(' + this.red + ', ' + this.green + ', ' + this.blue + ', ' + this.alpha + ')';
    };

    /**
     * Creates a string containing the CSS color value for this color.
     * @memberof Color
     *
     * @return {String} The CSS equivalent of this color.
     * @see <a href="http://www.w3.org/TR/css3-color/#rgba-color">CSS RGBA color values</a>
     */
    Color.prototype.toCSSColor = function() {
        var r = Color.floatToByte(this.red);
        var g = Color.floatToByte(this.green);
        var b = Color.floatToByte(this.blue);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + this.alpha + ')';
    };

    /**
     * An immutable Color instance initialized to white, RGBA (1.0, 1.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.WHITE = freezeObject(new Color(1.0, 1.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to black, RGBA (0.0, 0.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.BLACK = freezeObject(new Color(0.0, 0.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to red, RGBA (1.0, 0.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.RED = freezeObject(new Color(1.0, 0.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to green, RGBA (0.0, 1.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.GREEN = freezeObject(new Color(0.0, 1.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to blue, RGBA (0.0, 0.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.BLUE = freezeObject(new Color(0.0, 0.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to yellow, RGBA (1.0, 1.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.YELLOW = freezeObject(new Color(1.0, 1.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to magenta, RGBA (1.0, 0.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.MAGENTA = freezeObject(new Color(1.0, 0.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to cyan, RGBA (0.0, 1.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.CYAN = freezeObject(new Color(0.0, 1.0, 1.0, 1.0));

    return Color;
});
/*global define*/
define('Core/Ellipsoid',[
        './freezeObject',
        './defaultValue',
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Cartographic'
       ], function(
         freezeObject,
         defaultValue,
         DeveloperError,
         CesiumMath,
         Cartesian3,
         Cartographic) {
    

    /**
     * A quadratic surface defined in Cartesian coordinates by the equation
     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
     * by Cesium to represent the shape of planetary bodies.
     *
     * Rather than constructing this object directly, one of the provided
     * constants is normally used.
     * @alias Ellipsoid
     * @constructor
     * @immutable
     *
     * @param {Number} [x=0] The radius in the x direction.
     * @param {Number} [y=0] The radius in the y direction.
     * @param {Number} [z=0] The radius in the z direction.
     *
     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
     *
     * @see Ellipsoid.fromCartesian3
     * @see Ellipsoid.WGS84
     * @see Ellipsoid.UNIT_SPHERE
     */
    var Ellipsoid = function(x, y, z) {
        x = defaultValue(x, 0.0);
        y = defaultValue(y, 0.0);
        z = defaultValue(z, 0.0);

        if (x < 0.0 || y < 0.0 || z < 0.0) {
            throw new DeveloperError('All radii components must be greater than or equal to zero.');
        }

        this._radii = new Cartesian3(x, y, z);

        this._radiiSquared = new Cartesian3(x * x,
                                            y * y,
                                            z * z);

        this._radiiToTheFourth = new Cartesian3(x * x * x * x,
                                                y * y * y * y,
                                                z * z * z * z);

        this._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,
                                            y === 0.0 ? 0.0 : 1.0 / y,
                                            z === 0.0 ? 0.0 : 1.0 / z);

        this._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),
                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),
                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));

        this._minimumRadius = Math.min(x, y, z);

        this._maximumRadius = Math.max(x, y, z);
    };

    /**
     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
     *
     * @param {Cartesian3} [radii=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.
     * @return {Ellipsoid} A new Ellipsoid instance.
     *
     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
     *
     * @see Ellipsoid.WGS84
     * @see Ellipsoid.UNIT_SPHERE
     */
    Ellipsoid.fromCartesian3 = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            return new Ellipsoid();
        }
        return new Ellipsoid(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * An Ellipsoid instance initialized to the WGS84 standard.
     * @memberof Ellipsoid
     *
     * @see czm_getWgs84EllipsoidEC
     */
    Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));

    /**
     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
     * @memberof Ellipsoid
     */
    Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} The radii of the ellipsoid.
     */
    Ellipsoid.prototype.getRadii = function() {
        return this._radii;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} The squared radii of the ellipsoid.
     */
    Ellipsoid.prototype.getRadiiSquared = function() {
        return this._radiiSquared;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} The radii of the ellipsoid raised to the fourth power.
     */
    Ellipsoid.prototype.getRadiiToTheFourth = function() {
        return this._radiiToTheFourth;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} One over the radii of the ellipsoid.
     */
    Ellipsoid.prototype.getOneOverRadii = function() {
        return this._oneOverRadii;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} One over the squared radii of the ellipsoid.
     */
    Ellipsoid.prototype.getOneOverRadiiSquared = function() {
        return this._oneOverRadiiSquared;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} The minimum radius of the ellipsoid.
     */
    Ellipsoid.prototype.getMinimumRadius = function() {
        return this._minimumRadius;
    };

    /**
     * @memberof Ellipsoid
     * @return {Cartesian3} The maximum radius of the ellipsoid.
     */
    Ellipsoid.prototype.getMaximumRadius = function() {
        return this._maximumRadius;
    };

    /**
     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;

    /**
     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
     * @memberof Ellipsoid
     *
     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required.');
        }

        var longitude = cartographic.longitude;
        var latitude = cartographic.latitude;
        var cosLatitude = Math.cos(latitude);

        var x = cosLatitude * Math.cos(longitude);
        var y = cosLatitude * Math.sin(longitude);
        var z = Math.sin(latitude);

        if (typeof result === 'undefined') {
            result = new Cartesian3();
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return Cartesian3.normalize(result, result);
    };

    /**
     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {
        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
        return Cartesian3.normalize(result, result);
    };

    var cartographicToCartesianNormal = new Cartesian3();
    var cartographicToCartesianK = new Cartesian3();

    /**
     * Converts the provided cartographic to Cartesian representation.
     * @memberof Ellipsoid
     *
     * @param {Cartographic} cartographic The cartographic position.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartographic is required.
     *
     * @example
     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
     * var position = new Cartographic(Math.toRadians(21), Math.toRadians(78), 5000);
     * var cartesianPosition = Ellipsoid.WGS84.cartographicToCartesian(position);
     */
    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {
        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.
        var n = cartographicToCartesianNormal;
        var k = cartographicToCartesianK;
        this.geodeticSurfaceNormalCartographic(cartographic, n);
        Cartesian3.multiplyComponents(this._radiiSquared, n, k);
        var gamma = Math.sqrt(Cartesian3.dot(n, k));
        Cartesian3.divideByScalar(k, gamma, k);
        Cartesian3.multiplyByScalar(n, cartographic.height, n);
        return Cartesian3.add(k, n, result);
    };

    /**
     * Converts the provided array of cartographics to an array of Cartesians.
     * @memberof Ellipsoid
     *
     * @param {Array} cartographics An array of cartographic positions.
     * @param {Array} [result] The object onto which to store the result.
     * @return {Array} The modified result parameter or a new Array instance if none was provided.
     *
     * @exception {DeveloperError} cartographics is required.
     *
     * @example
     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
     * var positions = [new Cartographic(Math.toRadians(21), Math.toRadians(78), 0),
     *                  new Cartographic(Math.toRadians(21.321), Math.toRadians(78.123), 100),
     *                  new Cartographic(Math.toRadians(21.645), Math.toRadians(78.456), 250)
     * var cartesianPositions = Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
     */
    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {
        if (typeof cartographics === 'undefined') {
            throw new DeveloperError('cartographics is required.');
        }

        var length = cartographics.length;
        if (typeof result === 'undefined') {
            result = new Array(length);
        } else {
            result.length = length;
        }
        for ( var i = 0; i < length; i++) {
            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
        }
        return result;
    };

    var cartesianToCartographicN = new Cartesian3();
    var cartesianToCartographicP = new Cartesian3();
    var cartesianToCartographicH = new Cartesian3();

    /**
     * Converts the provided cartesian to cartographic representation.
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     *
     * @example
     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
     * var position = new Cartesian(17832.12, 83234.52, 952313.73);
     * var cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(position);
     */
    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {
        //`cartesian is required.` is thrown from scaleToGeodeticSurface
        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);
        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

        var longitude = Math.atan2(n.y, n.x);
        var latitude = Math.asin(n.z);
        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

        if (typeof result === 'undefined') {
            return new Cartographic(longitude, latitude, height);
        }
        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    };

    /**
     * Converts the provided array of cartesians to an array of cartographics.
     * @memberof Ellipsoid
     *
     * @param {Array} cartesians An array of Cartesian positions.
     * @param {Array} [result] The object onto which to store the result.
     * @return {Array} The modified result parameter or a new Array instance if none was provided.
     *
     * @exception {DeveloperError} cartesians is required.
     *
     * @example
     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
     * var positions = [new Cartesian(17832.12, 83234.52, 952313.73),
     *                  new Cartesian(17832.13, 83234.53, 952313.73),
     *                  new Cartesian(17832.14, 83234.54, 952313.73)]
     * var cartographicPositions = Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
     */
    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {
        if (typeof cartesians === 'undefined') {
            throw new DeveloperError('cartesians is required.');
        }

        var length = cartesians.length;
        if (typeof result === 'undefined') {
            result = new Array(length);
        } else {
            result.length = length;
        }
        for ( var i = 0; i < length; ++i) {
            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
        }
        return result;
    };

    /**
     * Scales the provided Cartesian position along the geodetic surface normal
     * so that it is on the surface of this ellipsoid.
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} cartesian The Cartesian position to scale.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var positionX = cartesian.x;
        var positionY = cartesian.y;
        var positionZ = cartesian.z;

        var oneOverRadiiSquared = this._oneOverRadiiSquared;
        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

        var radiiSquared = this._radiiSquared;
        var radiiSquaredX = radiiSquared.x;
        var radiiSquaredY = radiiSquared.y;
        var radiiSquaredZ = radiiSquared.z;

        var radiiToTheFourth = this._radiiToTheFourth;
        var radiiToTheFourthX = radiiToTheFourth.x;
        var radiiToTheFourthY = radiiToTheFourth.y;
        var radiiToTheFourthZ = radiiToTheFourth.z;

        var beta = 1.0 / Math.sqrt(
                (positionX * positionX) * oneOverRadiiSquaredX +
                (positionY * positionY) * oneOverRadiiSquaredY +
                (positionZ * positionZ) * oneOverRadiiSquaredZ);

        var x = beta * positionX * oneOverRadiiSquaredX;
        var y = beta * positionY * oneOverRadiiSquaredY;
        var z = beta * positionZ * oneOverRadiiSquaredZ;

        var n = Math.sqrt(x * x + y * y + z * z);
        var alpha = (1.0 - beta) * (Cartesian3.magnitude(cartesian) / n);

        var x2 = positionX * positionX;
        var y2 = positionY * positionY;
        var z2 = positionZ * positionZ;

        var da = 0.0;
        var db = 0.0;
        var dc = 0.0;

        var s = 0.0;
        var dSdA = 1.0;

        do {
            alpha -= (s / dSdA);

            da = 1.0 + (alpha * oneOverRadiiSquaredX);
            db = 1.0 + (alpha * oneOverRadiiSquaredY);
            dc = 1.0 + (alpha * oneOverRadiiSquaredZ);

            var da2 = da * da;
            var db2 = db * db;
            var dc2 = dc * dc;

            var da3 = da * da2;
            var db3 = db * db2;
            var dc3 = dc * dc2;

            s = x2 / (radiiSquaredX * da2) + y2 / (radiiSquaredY * db2) + z2 / (radiiSquaredZ * dc2) - 1.0;

            dSdA = -2.0 * (x2 / (radiiToTheFourthX * da3) + y2 / (radiiToTheFourthY * db3) + z2 / (radiiToTheFourthZ * dc3));
        } while (Math.abs(s) > CesiumMath.EPSILON10);

        x = positionX / da;
        y = positionY / db;
        z = positionZ / dc;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Scales the provided Cartesian position along the geocentric surface normal
     * so that it is on the surface of this ellipsoid.
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} cartesian The Cartesian position to scale.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var positionX = cartesian.x;
        var positionY = cartesian.y;
        var positionZ = cartesian.z;
        var oneOverRadiiSquared = this._oneOverRadiiSquared;

        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +
                                   (positionY * positionY) * oneOverRadiiSquared.y +
                                   (positionZ * positionZ) * oneOverRadiiSquared.z);

        return Cartesian3.multiplyByScalar(cartesian, beta, result);
    };

    /**
     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
     * its components by the result of {@link Ellipsoid#getOneOverRadii}.
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position The position to transform.
     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
     *        return a new instance.
     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the
     *          one passed as the result parameter if it is not undefined, or a new instance of it is.
     */
    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {
        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
    };

    /**
     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Ellipsoid
     *
     * @param {Ellipsoid} [right] The other Ellipsoid.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Ellipsoid.prototype.equals = function(right) {
        return (this === right) ||
               (typeof right !== 'undefined' &&
                Cartesian3.equals(this._radii, right._radii));
    };

    /**
     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
     * @memberof Ellipsoid
     *
     * @return {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
     */
    Ellipsoid.prototype.toString = function() {
        return this._radii.toString();
    };

    return Ellipsoid;
});

/*global define*/
define('Core/GeographicProjection',[
        './defaultValue',
        './Cartesian3',
        './Cartographic',
        './Ellipsoid'
    ], function(
        defaultValue,
        Cartesian3,
        Cartographic,
        Ellipsoid) {
    

    /**
     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
     * them by the {@link Ellipsoid#getMaximumRadius}.  This projection
     * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
     * is also known as EPSG:4326.
     *
     * @alias GeographicProjection
     * @constructor
     * @immutable
     *
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
     *
     * @see WebMercatorProjection
     */
    var GeographicProjection = function(ellipsoid) {
        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        this._semimajorAxis = this._ellipsoid.getMaximumRadius();
        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
    };

    /**
     * Gets the {@link Ellipsoid}.
     *
     * @memberof GeographicProjection
     *
     * @returns {Ellipsoid} The ellipsoid.
     */
    GeographicProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
     * ellipsoid.  Z is the unmodified height.
     *
     * @memberof GeographicProjection
     *
     * @param {Cartographic} cartographic The coordinates to project.
     * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    GeographicProjection.prototype.project = function(cartographic, result) {
        // Actually this is the special case of equidistant cylindrical called the plate carree
        var semimajorAxis = this._semimajorAxis;
        var x = cartographic.longitude * semimajorAxis;
        var y = cartographic.latitude * semimajorAxis;
        var z = cartographic.height;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }

        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
     *
     * @memberof GeographicProjection
     *
     * @param {Cartesian3} cartesian The coordinate to unproject.
     * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    GeographicProjection.prototype.unproject = function(cartesian, result) {
        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
        var longitude = cartesian.x * oneOverEarthSemimajorAxis;
        var latitude = cartesian.y * oneOverEarthSemimajorAxis;
        var height = cartesian.z;

        if (typeof result === 'undefined') {
            return new Cartographic(longitude, latitude, height);
        }

        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    };

    return GeographicProjection;
});

/*global define*/
define('Core/BoundingRectangle',[
        './defaultValue',
        './DeveloperError',
        './Cartographic',
        './GeographicProjection',
        './Intersect'
    ], function(
        defaultValue,
        DeveloperError,
        Cartographic,
        GeographicProjection,
        Intersect) {
    

    /**
     * A bounding rectangle given by a corner, width and height.
     * @alias BoundingRectangle
     * @constructor
     *
     * @param {Number} [x=0.0] The x coordinate of the rectangle.
     * @param {Number} [y=0.0] The y coordinate of the rectangle.
     * @param {Number} [width=0.0] The width of the rectangle.
     * @param {Number} [height=0.0] The height of the rectangle.
     *
     * @see BoundingSphere
     */
    var BoundingRectangle = function(x, y, width, height) {
        /**
         * The x coordinate of the rectangle.
         * @type Number
         */
        this.x = defaultValue(x, 0.0);

        /**
         * The y coordinate of the rectangle.
         * @type Number
         */
        this.y = defaultValue(y, 0.0);

        /**
         * The width of the rectangle.
         * @type Number
         */
        this.width = defaultValue(width, 0.0);

        /**
         * The height of the rectangle.
         * @type Number
         */
        this.height = defaultValue(height, 0.0);
    };

    /**
     * Computes a bounding rectangle enclosing the list of 2D points.
     * The rectangle is oriented with the corner at the bottom left.
     * @memberof BoundingRectangle
     *
     * @param {Array} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    BoundingRectangle.fromPoints = function(positions, result) {
        if (typeof result === 'undefined') {
            result = new BoundingRectangle();
        }

        if (typeof positions === 'undefined' || positions.length === 0) {
            result.x = 0;
            result.y = 0;
            result.width = 0;
            result.height = 0;
            return result;
        }

        var length = positions.length;

        var minimumX = positions[0].x;
        var minimumY = positions[0].y;

        var maximumX = positions[0].x;
        var maximumY = positions[0].y;

        for ( var i = 1; i < length; i++) {
            var p = positions[i];
            var x = p.x;
            var y = p.y;

            minimumX = Math.min(x, minimumX);
            maximumX = Math.max(x, maximumX);
            minimumY = Math.min(y, minimumY);
            maximumY = Math.max(y, maximumY);
        }

        result.x = minimumX;
        result.y = minimumY;
        result.width = maximumX - minimumX;
        result.height = maximumY - minimumY;
        return result;
    };

    var defaultProjection = new GeographicProjection();
    var fromExtentLowerLeft = new Cartographic();
    var fromExtentUpperRight = new Cartographic();
    /**
     * Computes a bounding rectangle from an extent.
     * @memberof BoundingRectangle
     *
     * @param {Extent} extent The valid extent used to create a bounding rectangle.
     * @param {Object} [projection=GeographicProjection] The projection used to project the extent into 2D.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    BoundingRectangle.fromExtent = function(extent, projection, result) {
        if (typeof result === 'undefined') {
            result = new BoundingRectangle();
        }

        if (typeof extent === 'undefined') {
            result.x = 0;
            result.y = 0;
            result.width = 0;
            result.height = 0;
            return result;
        }

        projection = (typeof projection !== 'undefined') ? projection : defaultProjection;

        var lowerLeft = projection.project(extent.getSouthwest(fromExtentLowerLeft));
        var upperRight = projection.project(extent.getNortheast(fromExtentUpperRight));

        upperRight.subtract(lowerLeft, upperRight);

        result.x = lowerLeft.x;
        result.y = lowerLeft.y;
        result.width = upperRight.x;
        result.height = upperRight.y;
        return result;
    };

    /**
     * Duplicates a BoundingRectangle instance.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     *
     * @exception {DeveloperError} rectangle is required.
     */
    BoundingRectangle.clone = function(rectangle, result) {
        if (typeof rectangle === 'undefined') {
            throw new DeveloperError('rectangle is required');
        }

        if (typeof result === 'undefined') {
            return new BoundingRectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
        }

        result.x = rectangle.x;
        result.y = rectangle.y;
        result.width = rectangle.width;
        result.height = rectangle.height;
        return result;
    };

    /**
     * Computes a bounding rectangle that is the union of the left and right bounding rectangles.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.
     * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    BoundingRectangle.union = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }

        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }

        if (typeof result === 'undefined') {
            result = new BoundingRectangle();
        }

        var lowerLeftX = Math.min(left.x, right.x);
        var lowerLeftY = Math.min(left.y, right.y);
        var upperRightX = Math.max(left.x + left.width, right.x + right.width);
        var upperRightY = Math.max(left.y + left.height, right.y + right.height);

        result.x = lowerLeftX;
        result.y = lowerLeftY;
        result.width = upperRightX - lowerLeftX;
        result.height = upperRightY - lowerLeftY;
        return result;
    };

    /**
     * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} rectangle A rectangle to expand.
     * @param {Cartesian2} point A point to enclose in a bounding rectangle.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     *
     * @exception {DeveloperError} rectangle is required.
     * @exception {DeveloperError} point is required.
     */
    BoundingRectangle.expand = function(rectangle, point, result) {
        if (typeof rectangle === 'undefined') {
            throw new DeveloperError('rectangle is required.');
        }

        if (typeof point === 'undefined') {
            throw new DeveloperError('point is required.');
        }

        result = BoundingRectangle.clone(rectangle, result);

        var width = point.x - result.x;
        var height = point.y - result.y;

        if (width > result.width) {
            result.width = width;
        } else if (width < 0) {
            result.width -= width;
            result.x = point.x;
        }

        if (height > result.height) {
            result.height = height;
        } else if (height < 0) {
            result.height -= height;
            result.y = point.y;
        }

        return result;
    };

    /**
     * Determines if two rectangles intersect.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} left A rectangle to check for intersection.
     * @param {BoundingRectangle} right The other rectangle to check for intersection.
     * @return {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    BoundingRectangle.intersect = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }

        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }

        var leftX = left.x;
        var leftY = left.y;
        var rightX = right.x;
        var rightY = right.y;
        if (!(leftX > rightX + right.width ||
              leftX + left.width < rightX ||
              leftY + left.height < rightY ||
              leftY > rightY + right.height)) {
            return Intersect.INTERSECTING;
        }

        return Intersect.OUTSIDE;
    };

    /**
     * Compares the provided BoundingRectangles componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} [left] The first BoundingRectangle.
     * @param {BoundingRectangle} [right] The second BoundingRectangle.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    BoundingRectangle.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.width === right.width) &&
                (left.height === right.height));
    };

    /**
     * Duplicates this BoundingRectangle instance.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    BoundingRectangle.prototype.clone = function(result) {
        return BoundingRectangle.clone(this, result);
    };

    /**
     * Computes a bounding rectangle that contains both this bounding rectangle and the argument rectangle.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} right The rectangle to enclose in this bounding rectangle.
     * @param {BoundingRectangle} [result] The object onto which to store the result.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    BoundingRectangle.prototype.union = function(right, result) {
        return BoundingRectangle.union(this, right, result);
    };

    /**
     * Computes a bounding rectangle that is rectangle expanded to contain point.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} point A point to enclose in a bounding rectangle.
     * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
     *
     * @exception {DeveloperError} point is required.
     */
    BoundingRectangle.prototype.expand = function(point, result) {
        return BoundingRectangle.expand(this, point, result);
    };

    /**
     * Determines if this rectangle intersects with another.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} right A rectangle to check for intersection.
     * @return {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
     *
     * @exception {DeveloperError} right is required.
     */
    BoundingRectangle.prototype.intersect = function(right) {
        return BoundingRectangle.intersect(this, right);
    };

    /**
     * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof BoundingRectangle
     *
     * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    BoundingRectangle.prototype.equals = function(right) {
        return BoundingRectangle.equals(this, right);
    };

    return BoundingRectangle;
});
/*global define*/
define('Core/MeshFilters',[
        './DeveloperError',
        './Cartesian3',
        './GeographicProjection',
        './ComponentDatatype',
        './PrimitiveType',
        './Tipsify'
    ], function(
        DeveloperError,
        Cartesian3,
        GeographicProjection,
        ComponentDatatype,
        PrimitiveType,
        Tipsify) {
    

    /**
     * DOC_TBA
     *
     * @exports MeshFilters
     *
     * @see Context#createVertexArrayFromMesh
     */
    var MeshFilters = {};

    /**
     * Converts a mesh's triangle indices to line indices.  Each list of indices in the mesh's <code>indexList</code> with
     * a primitive type of <code>triangles</code>, <code>triangleStrip</code>, or <code>trangleFan</code> is converted to a
     * list of indices with a primitive type of <code>lines</code>.  Lists of indices with other primitive types remain unchanged.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * This filter is commonly used to create a wireframe mesh for visual debugging.
     *
     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @returns The modified <code>mesh</code> argument, with its triangle indices converted to lines.
     *
     * @see BoxTessellator
     *
     * @example
     * var mesh = BoxTessellator.compute();
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     */
    MeshFilters.toWireframeInPlace = function(mesh) {
        function addTriangle(lines, i0, i1, i2) {
            lines.push(i0);
            lines.push(i1);

            lines.push(i1);
            lines.push(i2);

            lines.push(i2);
            lines.push(i0);
        }

        function trianglesToLines(triangles) {
            var lines = [];
            var count = triangles.length;
            for ( var i = 0; i < count; i += 3) {
                addTriangle(lines, triangles[i], triangles[i + 1], triangles[i + 2]);
            }

            return lines;
        }

        function triangleStripToLines(triangles) {
            var lines = [];
            var count = triangles.length;

            if (count >= 3) {
                addTriangle(lines, triangles[0], triangles[1], triangles[2]);

                for ( var i = 3; i < count; ++i) {
                    addTriangle(lines, triangles[i - 1], triangles[i], triangles[i - 2]);
                }
            }

            return lines;
        }

        function triangleFanToLines(triangles) {
            var lines = [];

            if (triangles.length > 0) {
                var base = triangles[0];
                var count = triangles.length - 1;
                for ( var i = 1; i < count; ++i) {
                    addTriangle(lines, base, triangles[i], triangles[i + 1]);
                }
            }

            return lines;
        }

        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; ++i) {
                    var indices = indexLists[i];

                    switch (indices.primitiveType) {
                        case PrimitiveType.TRIANGLES:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = trianglesToLines(indices.values);
                            break;
                        case PrimitiveType.TRIANGLE_STRIP:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = triangleStripToLines(indices.values);
                            break;
                        case PrimitiveType.TRIANGLE_FAN:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = triangleFanToLines(indices.values);
                            break;
                    }
                }
            }
        }

        return mesh;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.createAttributeIndices = function(mesh) {
        var indices = {};

        if (mesh) {
            var attributes = mesh.attributes;
            var j = 0;

            for ( var name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    indices[name] = j++;
                }
            }
        }

        return indices;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.mapAttributeIndices = function(indices, map) {
        var mappedIndices = {};

        if (indices && map) {
            for ( var name in map) {
                if (map.hasOwnProperty(name)) {
                    mappedIndices[map[name]] = indices[name];
                }
            }
        }

        return mappedIndices;
    };

    MeshFilters._computeNumberOfAttributes = function(mesh) {
        var numberOfVertices = -1;
        for ( var property in mesh.attributes) {
            if (mesh.attributes.hasOwnProperty(property) && mesh.attributes[property].values) {
                var attribute = mesh.attributes[property];
                var num = attribute.values.length / attribute.componentsPerAttribute;
                if ((numberOfVertices !== num) && (numberOfVertices !== -1)) {
                    throw new DeveloperError('All mesh attribute lists must have the same number of attributes.');
                }
                numberOfVertices = num;
            }
        }

        return numberOfVertices;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's pre-vertex-shader cache.
     * Each list of indices in the mesh's <code>indexList</code> is reordered to keep the same index-vertex correspondence.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     *
     * @returns The modified <code>mesh</code> argument, with its vertices and indices reordered for the GPU's pre-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPostVertexCache
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPreVertexCache(mesh);
     */
    MeshFilters.reorderForPreVertexCache = function(mesh) {
        if (mesh) {
            var numVertices = MeshFilters._computeNumberOfAttributes(mesh);

            var indexCrossReferenceOldToNew = [];
            for ( var i = 0; i < numVertices; i++) {
                indexCrossReferenceOldToNew[i] = -1;
            }

            //Construct cross reference and reorder indices
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var j = 0; j < count; ++j) {
                    var indicesIn = indexLists[j].values;
                    var numIndices = indicesIn.length;
                    var indicesOut = [];
                    var intoIndicesIn = 0;
                    var intoIndicesOut = 0;
                    var nextIndex = 0;
                    var tempIndex;
                    while (intoIndicesIn < numIndices) {
                        tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];
                        if (tempIndex !== -1) {
                            indicesOut[intoIndicesOut] = tempIndex;
                        } else {
                            tempIndex = indicesIn[intoIndicesIn];
                            if (tempIndex >= numVertices) {
                                throw new DeveloperError('Input indices contains a value greater than or equal to the number of vertices');
                            }
                            indexCrossReferenceOldToNew[tempIndex] = nextIndex;

                            indicesOut[intoIndicesOut] = nextIndex;
                            ++nextIndex;
                        }
                        ++intoIndicesIn;
                        ++intoIndicesOut;
                    }
                    indexLists[j].values = indicesOut;
                }
            }

            //Reorder Vertices
            var attributes = mesh.attributes;
            if (attributes) {
                for ( var property in attributes) {
                    if (attributes.hasOwnProperty(property) && attributes[property].values) {
                        var elementsIn = attributes[property].values;
                        var intoElementsIn = 0;
                        var numComponents = attributes[property].componentsPerAttribute;
                        var elementsOut = [];
                        while (intoElementsIn < numVertices) {
                            var temp = indexCrossReferenceOldToNew[intoElementsIn];
                            for (i = 0; i < numComponents; i++) {
                                elementsOut[numComponents * temp + i] = elementsIn[numComponents * intoElementsIn + i];
                            }
                            ++intoElementsIn;
                        }
                        attributes[property].values = elementsOut;
                    }
                }
            }
        }
        return mesh;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's post vertex-shader cache by using the Tipsify algorithm.
     * Each list of indices in the mesh's <code>indexList</code> is optimally reordered.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.
     *
     * @exception {DeveloperError} Mesh's index list must be defined.
     * @exception {DeveloperError} Mesh's index lists' lengths must each be a multiple of three.
     * @exception {DeveloperError} Mesh's index list's maximum index value must be greater than zero.
     * @exception {DeveloperError} cacheCapacity must be greater than two.
     *
     * @returns The modified <code>mesh</code> argument, with its indices optimally reordered for the post-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPreVertexCache
     * @see Tipsify
     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPostVertexCache(mesh);
     */
    MeshFilters.reorderForPostVertexCache = function(mesh, cacheCapacity) {
        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; i++) {
                    var indices = indexLists[i].values;
                    var numIndices = indices.length;
                    var maximumIndex = 0;
                    for ( var j = 0; j < numIndices; j++) {
                        if (indices[j] > maximumIndex) {
                            maximumIndex = indices[j];
                        }
                    }
                    indexLists[i].values = Tipsify.tipsify({indices : indices,
                                                            maximumIndex : maximumIndex,
                                                            cacheSize : cacheCapacity});
                }
            }
        }
        return mesh;
    };

    MeshFilters._verifyTrianglesPrimitiveType = function(indexLists) {
        var length = indexLists.length;
        for ( var i = 0; i < length; ++i) {
            if (indexLists[i].primitiveType !== PrimitiveType.TRIANGLES) {
                throw new DeveloperError('indexLists must have PrimitiveType equal to PrimitiveType.TRIANGLES.');
            }
        }
    };

    MeshFilters._copyAttributesDescriptions = function(attributes) {
        var newAttributes = {};

        for ( var attribute in attributes) {
            if (attributes.hasOwnProperty(attribute) && attributes[attribute].values) {
                var attr = attributes[attribute];
                newAttributes[attribute] = {
                    componentDatatype : attr.componentDatatype,
                    componentsPerAttribute : attr.componentsPerAttribute,
                    values : []
                };
            }
        }

        return newAttributes;
    };

    MeshFilters._copyVertex = function(destinationAttributes, sourceAttributes, index) {
        for ( var attribute in sourceAttributes) {
            if (sourceAttributes.hasOwnProperty(attribute) && sourceAttributes[attribute].values) {
                var attr = sourceAttributes[attribute];

                for ( var k = 0; k < attr.componentsPerAttribute; ++k) {
                    destinationAttributes[attribute].values.push(attr.values[(index * attr.componentsPerAttribute) + k]);
                }
            }
        }
    };

    /**
     * DOC_TBA.  Old mesh is not guaranteed to be copied.
     *
     * @exception {DeveloperError} The mesh's index-lists must have PrimitiveType equal to PrimitiveType.TRIANGLES.
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     */
    MeshFilters.fitToUnsignedShortIndices = function(mesh) {
        function createMesh(attributes, primitiveType, indices) {
            return {
                attributes : attributes,
                indexLists : [{
                    primitiveType : primitiveType,
                    values : indices
                }]
            };
        }

        var meshes = [];

        if (mesh) {
            MeshFilters._verifyTrianglesPrimitiveType(mesh.indexLists);

            var numberOfVertices = MeshFilters._computeNumberOfAttributes(mesh);

            // If there's an index list and more than 64K attributes, it is possible that
            // some indices are outside the range of unsigned short [0, 64K - 1]
            var sixtyFourK = 64 * 1024;
            var indexLists = mesh.indexLists;
            if (indexLists && (numberOfVertices > sixtyFourK)) {
                // PERFORMANCE_IDEA:  If an input mesh has more than one index-list.  This creates
                // at least one vertex-array per index-list.  A more sophisticated implementation
                // may create less vertex-arrays.
                var length = indexLists.length;
                for ( var i = 0; i < length; ++i) {
                    var oldToNewIndex = [];
                    var newIndices = [];
                    var currentIndex = 0;
                    var newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);

                    var originalIndices = indexLists[i].values;
                    var numberOfIndices = originalIndices.length;

                    for ( var j = 0; j < numberOfIndices; j += 3) {
                        // It would be easy to extend this inter-loop to support all primitive-types.

                        var x0 = originalIndices[j];
                        var x1 = originalIndices[j + 1];
                        var x2 = originalIndices[j + 2];

                        var i0 = oldToNewIndex[x0];
                        if (typeof i0 === 'undefined') {
                            i0 = currentIndex++;
                            oldToNewIndex[x0] = i0;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x0);
                        }

                        var i1 = oldToNewIndex[x1];
                        if (typeof i1 === 'undefined') {
                            i1 = currentIndex++;
                            oldToNewIndex[x1] = i1;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x1);
                        }

                        var i2 = oldToNewIndex[x2];
                        if (typeof i2 === 'undefined') {
                            i2 = currentIndex++;
                            oldToNewIndex[x2] = i2;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x2);
                        }

                        newIndices.push(i0);
                        newIndices.push(i1);
                        newIndices.push(i2);

                        if (currentIndex + 3 > sixtyFourK) {
                            meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));

                            // Reset for next vertex-array
                            oldToNewIndex = [];
                            newIndices = [];
                            currentIndex = 0;
                            newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);
                        }
                    }

                    if (newIndices.length !== 0) {
                        meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));
                    }
                }
            } else {
                // No need to split into multiple meshes
                meshes.push(mesh);
            }
        }

        return meshes;
    };

    ///////////////////////////////////////////////////////////////////////////

    /**
     * DOC_TBA
     */
    MeshFilters.projectTo2D = function(mesh, projection) {
        if (mesh && mesh.attributes && mesh.attributes.position) {
            projection = projection || new GeographicProjection();
            var ellipsoid = projection.getEllipsoid();

            // Project original positions to 2D.
            var wgs84Positions = mesh.attributes.position.values;
            var projectedPositions = [];

            for ( var i = 0; i < wgs84Positions.length; i += 3) {
                var lonLat = ellipsoid.cartesianToCartographic(new Cartesian3(wgs84Positions[i], wgs84Positions[i + 1], wgs84Positions[i + 2]));
                var projectedLonLat = projection.project(lonLat);
                projectedPositions.push(projectedLonLat.x, projectedLonLat.y);
            }

            // Rename original positions to WGS84 Positions.
            mesh.attributes.position3D = mesh.attributes.position;

            // Replace original positions with 2D projected positions
            mesh.attributes.position2D = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : projectedPositions
            };
            delete mesh.attributes.position;
        }

        return mesh;
    };

    return MeshFilters;
});

/*global define*/
define('Core/WebMercatorProjection',[
        './defaultValue',
        './Cartesian3',
        './Cartographic',
        './Math',
        './Ellipsoid'
    ], function(
        defaultValue,
        Cartesian3,
        Cartographic,
        CesiumMath,
        Ellipsoid) {
    

    /**
     * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
     * projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
     * the spherical (rather than ellipsoidal) equations.
     *
     * @alias WebMercatorProjection
     * @constructor
     * @immutable
     *
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
     *
     * @see GeographicProjection
     */
    var WebMercatorProjection = function(ellipsoid) {
        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        this._semimajorAxis = this._ellipsoid.getMaximumRadius();
        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
    };

    /**
     * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude
     * in the range -PI/2 to PI/2.
     *
     * @memberof WebMercatorProjection
     *
     * @param {Number} mercatorAngle The angle to convert.
     * @returns {Number} The geodetic latitude in radians.
     */
    WebMercatorProjection.mercatorAngleToGeodeticLatitude = function(mercatorAngle) {
        return CesiumMath.PI_OVER_TWO - (2.0 * Math.atan(Math.exp(-mercatorAngle)));
    };

    /**
     * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator
     * angle in the range -PI to PI.
     *
     * @memberof WebMercatorProjection
     *
     * @param {Number} latitude The geodetic latitude in radians.
     * @returns {Number} The Mercator angle.
     */
    WebMercatorProjection.geodeticLatitudeToMercatorAngle = function(latitude) {
        // Clamp the latitude coordinate to the valid Mercator bounds.
        if (latitude > WebMercatorProjection.MaximumLatitude) {
            latitude = WebMercatorProjection.MaximumLatitude;
        } else if (latitude < -WebMercatorProjection.MaximumLatitude) {
            latitude = -WebMercatorProjection.MaximumLatitude;
        }
        var sinLatitude = Math.sin(latitude);
        return 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));
    };

    /**
     * The maximum latitude (both North and South) supported by a Web Mercator
     * (EPSG:3857) projection.  Technically, the Mercator projection is defined
     * for any latitude up to (but not including) 90 degrees, but it makes sense
     * to cut it off sooner because it grows exponentially with increasing latitude.
     * The logic behind this particular cutoff value, which is the one used by
     * Google Maps, Bing Maps, and Esri, is that it makes the projection
     * square.  That is, the extent is equal in the X and Y directions.
     *
     * The constant value is computed by calling:
     *    WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)
     *
     * @memberof WebMercatorProjection
     *
     * @type {Number}
     */
    WebMercatorProjection.MaximumLatitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI);

    /**
     * Gets the {@link Ellipsoid}.
     *
     * @memberof WebMercatorProjection
     *
     * @returns {Ellipsoid} The ellipsoid.
     */
    WebMercatorProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator
     * X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height
     * is copied unmodified to the Z coordinate.
     *
     * @memberof WebMercatorProjection
     *
     * @param {Cartographic} cartographic The cartographic coordinates in radians.
     * @param {Cartesian3} [result] The instance to which to copy the result, or undefined if a
     *        new instance should be created.
     * @returns {Cartesian3} The equivalent web mercator X, Y, Z coordinates, in meters.
     */
    WebMercatorProjection.prototype.project = function(cartographic, result) {
        var semimajorAxis = this._semimajorAxis;
        var x = cartographic.longitude * semimajorAxis;
        var y = WebMercatorProjection.geodeticLatitudeToMercatorAngle(cartographic.latitude) * semimajorAxis;
        var z = cartographic.height;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }

        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}
     * containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the
     * height.
     *
     * @memberof WebMercatorProjection
     *
     * @param {Cartesian2} cartesian The web mercator coordinates in meters.
     * @param {Cartographic} [result] The instance to which to copy the result, or undefined if a
     *        new instance should be created.
     * @returns {Cartographic} The equivalent cartographic coordinates.
     */
    WebMercatorProjection.prototype.unproject = function(cartesian, result) {
        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
        var longitude = cartesian.x * oneOverEarthSemimajorAxis;
        var latitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(cartesian.y * oneOverEarthSemimajorAxis);
        var height = cartesian.z;

        if (typeof result === 'undefined') {
            return new Cartographic(longitude, latitude, height);
        }

        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    };

    return WebMercatorProjection;
});
/*global define*/
define('Core/Extent',[
        './freezeObject',
        './defaultValue',
        './Ellipsoid',
        './Cartographic',
        './DeveloperError',
        './Math'
    ], function(
        freezeObject,
        defaultValue,
        Ellipsoid,
        Cartographic,
        DeveloperError,
        CesiumMath) {
    

    /**
     * A two dimensional region specified as longitude and latitude coordinates.
     * @alias Extent
     * @constructor
     *
     * @param {Number} [west=0.0] The westernmost longitude in the range [-Pi, Pi].
     * @param {Number} [south=0.0] The southernmost latitude in the range [-Pi/2, Pi/2].
     * @param {Number} [east=0.0] The easternmost longitude in the range [-Pi, Pi].
     * @param {Number} [north=0.0] The northernmost latitude in the range [-Pi/2, Pi/2].
     */
    var Extent = function(west, south, east, north) {
        /**
         * The westernmost longitude in the range [-Pi, Pi].
         * @type Number
         */
        this.west = defaultValue(west, 0.0);

        /**
         * The southernmost latitude in the range [-Pi/2, Pi/2].
         * @type Number
         */
        this.south = defaultValue(south, 0.0);

        /**
         * The easternmost longitude in the range [-Pi, Pi].
         * @type Number
         */
        this.east = defaultValue(east, 0.0);

        /**
         * The northernmost latitude in the range [-Pi/2, Pi/2].
         * @type Number
         */
        this.north = defaultValue(north, 0.0);
    };

    /**
     * Duplicates this Extent.
     *
     * @param {Extent} [result] The object onto which to store the result.
     * @return {Extent} The modified result parameter or a new Extent instance if none was provided.
     */
    Extent.prototype.clone = function(result) {
        if (typeof result === 'undefined') {
            return new Extent(this.west, this.south, this.east, this.north);
        }
        result.west = this.west;
        result.south = this.south;
        result.east = this.east;
        result.north = this.north;
        return result;
    };

    /**
     * Compares the provided Extent with this Extent componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Extent} [other] The Extent to compare.
     * @return {Boolean} <code>true</code> if the Extents are equal, <code>false</code> otherwise.
     */
    Extent.prototype.equals = function(other) {
        return typeof other !== 'undefined' &&
               this.west === other.west &&
               this.south === other.south &&
               this.east === other.east &&
               this.north === other.north;
    };

    /**
     * Compares the provided Extent with this Extent componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Extent
     *
     * @param {Extent} [other] The Extent to compare.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if the Extents are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Extent.prototype.equalsEpsilon = function(other, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }

        return typeof other !== 'undefined' &&
               (Math.abs(this.west - other.west) <= epsilon) &&
               (Math.abs(this.south - other.south) <= epsilon) &&
               (Math.abs(this.east - other.east) <= epsilon) &&
               (Math.abs(this.north - other.north) <= epsilon);
    };

    /**
     * Checks this Extent's properties and throws if they are not in valid ranges.
     *
     * @exception {DeveloperError} <code>north</code> is required to be a number.
     * @exception {DeveloperError} <code>south</code> is required to be a number.
     * @exception {DeveloperError} <code>east</code> is required to be a number.
     * @exception {DeveloperError} <code>west</code> is required to be a number.
     * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     */
    Extent.prototype.validate = function() {
        var north = this.north;
        if (typeof north !== 'number') {
            throw new DeveloperError('north is required to be a number.');
        }

        if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError('north must be in the interval [-Pi/2, Pi/2].');
        }

        var south = this.south;
        if (typeof south !== 'number') {
            throw new DeveloperError('south is required to be a number.');
        }

        if (south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError('south must be in the interval [-Pi/2, Pi/2].');
        }

        var west = this.west;
        if (typeof west !== 'number') {
            throw new DeveloperError('west is required to be a number.');
        }

        if (west < -Math.PI || west > Math.PI) {
            throw new DeveloperError('west must be in the interval [-Pi, Pi].');
        }

        var east = this.east;
        if (typeof east !== 'number') {
            throw new DeveloperError('east is required to be a number.');
        }

        if (east < -Math.PI || east > Math.PI) {
            throw new DeveloperError('east must be in the interval [-Pi, Pi].');
        }
    };

    /**
     * Computes the southwest corner of this extent.
     * @memberof Extent
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Extent.prototype.getSouthwest = function(result) {
        if (typeof result === 'undefined') {
            return new Cartographic(this.west, this.south);
        }
        result.longitude = this.west;
        result.latitude = this.south;
        result.height = 0.0;
        return result;
    };

    /**
     * Computes the northwest corner of this extent.
     * @memberof Extent
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Extent.prototype.getNorthwest = function(result) {
        if (typeof result === 'undefined') {
            return new Cartographic(this.west, this.north);
        }
        result.longitude = this.west;
        result.latitude = this.north;
        result.height = 0.0;
        return result;
    };

    /**
     * Computes the northeast corner of this extent.
     * @memberof Extent
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Extent.prototype.getNortheast = function(result) {
        if (typeof result === 'undefined') {
            return new Cartographic(this.east, this.north);
        }
        result.longitude = this.east;
        result.latitude = this.north;
        result.height = 0.0;
        return result;
    };

    /**
     * Computes the southeast corner of this extent.
     * @memberof Extent
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Extent.prototype.getSoutheast = function(result) {
        if (typeof result === 'undefined') {
            return new Cartographic(this.east, this.south);
        }
        result.longitude = this.east;
        result.latitude = this.south;
        result.height = 0.0;
        return result;
    };

    /**
     * Computes the center of this extent.
     * @memberof Extent
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Extent.prototype.getCenter = function(result) {
        if (typeof result === 'undefined') {
            return new Cartographic((this.west + this.east) * 0.5, (this.south + this.north) * 0.5);
        }
        result.longitude = (this.west + this.east) * 0.5;
        result.latitude = (this.south + this.north) * 0.5;
        result.height = 0.0;
        return result;
    };

    /**
     * Computes the intersection of this extent with the provided extent.
     * @memberof Extent
     *
     * @param otherExtent The extent to intersect with this extent.
     * @param {Extent} [result] The object onto which to store the result.
     * @return {Extent} The modified result parameter or a new Extent instance if none was provided.
     *
     * @exception {DeveloperError} otherExtent is required.
     */
    Extent.prototype.intersectWith = function(otherExtent, result) {
        if (typeof otherExtent === 'undefined') {
            throw new DeveloperError('otherExtent is required.');
        }
        var west = Math.max(this.west, otherExtent.west);
        var south = Math.max(this.south, otherExtent.south);
        var east = Math.min(this.east, otherExtent.east);
        var north = Math.min(this.north, otherExtent.north);
        if (typeof result === 'undefined') {
            return new Extent(west, south, east, north);
        }
        result.west = west;
        result.south = south;
        result.east = east;
        result.north = north;
        return result;
    };

    /**
     * Returns true if the provided cartographic is on or inside the extent, false otherwise.
     * @memberof Extent
     *
     * @param {Cartographic} cartographic The cartographic to test.
     * @returns {Boolean} true if the provided cartographic is inside the extent, false otherwise.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Extent.prototype.contains = function(cartographic) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required.');
        }
        return cartographic.longitude >= this.west &&
               cartographic.longitude <= this.east &&
               cartographic.latitude >= this.south &&
               cartographic.latitude <= this.north;
    };

    /**
     * Determines if the extent is empty, i.e., if <code>west === east</code>
     * and <code>south === north</code>.
     *
     * @memberof Extent
     *
     * @return {Boolean} True if the extent is empty; otherwise, false.
     */
    Extent.prototype.isEmpty = function() {
        return (this.west === this.east) && (this.south === this.north);
    };

    var subsampleLlaScratch = new Cartographic();
    /**
     * Samples this Extent so that it includes a list of Cartesian points suitable for passing to
     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
     * for extents that cover the poles or cross the equator.
     *
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
     * @param {Array} [result] The array of Cartesians onto which to store the result.
     * @return {Array} The modified result parameter or a new Array of Cartesians instances if none was provided.
     */
    Extent.prototype.subsample = function(ellipsoid, result) {
        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

        if (typeof result === 'undefined') {
            result = [];
        }
        var length = 0;

        var north = this.north;
        var south = this.south;
        var east = this.east;
        var west = this.west;

        var lla = subsampleLlaScratch;
        lla.longitude = west;
        lla.latitude = north;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;

        lla.longitude = east;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;

        lla.latitude = south;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;

        lla.longitude = west;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;

        if (north < 0.0) {
            lla.latitude = north;
        } else if (south > 0.0) {
            lla.latitude = south;
        } else {
            lla.latitude = 0.0;
        }

        for ( var i = 1; i < 8; ++i) {
            var temp = -Math.PI + i * CesiumMath.PI_OVER_TWO;
            if (west < temp && temp < east) {
                lla.longitude = temp;
                result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
                length++;
            }
        }

        if (lla.latitude === 0.0) {
            lla.longitude = west;
            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
            length++;
            lla.longitude = east;
            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
            length++;
        }
        result.length = length;
        return result;
    };

    /**
     * The largest possible extent.
     * @memberof Extent
     * @type Extent
    */
    Extent.MAX_VALUE = freezeObject(new Extent(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));

    return Extent;
});

/*global define*/
define('Core/ExtentTessellator',[
        './defaultValue',
        './DeveloperError',
        './Math',
        './Ellipsoid',
        './Extent',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Ellipsoid,
        Extent,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * Contains class functions to create a mesh or vertex array from a cartographic extent.
     *
     * @exports ExtentTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     * @see PlaneTessellator
     */
    var ExtentTessellator = {};

    /**
     * Compute vertices from a cartographic extent.  This function is different from
     * {@link ExtentTessellator#compute} and {@link ExtentTessellator#computeBuffers}
     * in that it assumes that you have already allocated output arrays of the correct size.
     *
     * @param {Extent} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Number} description.width The number of vertices in the longitude direction.
     * @param {Number} description.height The number of vertices in the latitude direction.
     * @param {Number} description.granularityX The distance, in radians, between each longitude.
     * @param {Number} description.granularityY The distance, in radians, between each latitude.
     * @param {Number} description.surfaceHeight The height from the surface of the ellipsoid.
     * @param {Boolean} description.generateTextureCoordinates Whether to generate texture coordinates.
     * @param {Boolean} description.interleaveTextureCoordinates Whether to interleave the texture coordinates into the vertex array.
     * @param {Cartesian3} description.relativetoCenter The positions will be computed as <code>worldPosition.subtract(relativeToCenter)</code>.
     * @param {Cartesian3} description.radiiSquared The radii squared of the ellipsoid to use.
     * @param {Array|Float32Array} description.vertices The array to use to store computed vertices.
     * @param {Array|Float32Array} description.textureCoordinates The array to use to store computed texture coordinates, unless interleaved.
     * @param {Array|Float32Array} [description.indices] The array to use to store computed indices.  If undefined, indices will be not computed.
     */
    ExtentTessellator.computeVertices = function(description) {
        description = defaultValue(description, {});

        var extent = description.extent;
        var surfaceHeight = description.surfaceHeight;
        var width = description.width;
        var height = description.height;

        var granularityX = (extent.east - extent.west) / (width - 1);
        var granularityY = (extent.north - extent.south) / (height - 1);
        var generateTextureCoordinates = description.generateTextureCoordinates;
        var interleaveTextureCoordinates = description.interleaveTextureCoordinates;
        var relativeToCenter = description.relativeToCenter;

        var vertices = description.vertices;
        var textureCoordinates = description.textureCoordinates;
        var indices = description.indices;

        var radiiSquared = description.radiiSquared;
        var radiiSquaredX = radiiSquared.x;
        var radiiSquaredY = radiiSquared.y;
        var radiiSquaredZ = radiiSquared.z;

        var cos = Math.cos;
        var sin = Math.sin;
        var sqrt = Math.sqrt;

        // for computing texture coordinates
        var lonScalar = 1.0 / (extent.east - extent.west);
        var latScalar = 1.0 / (extent.north - extent.south);

        var vertexArrayIndex = 0;
        var textureCoordinatesIndex = 0;

        for ( var row = 0; row < height; ++row) {
            var latitude = extent.north - granularityY * row;
            var cosLatitude = cos(latitude);
            var nZ = sin(latitude);
            var kZ = radiiSquaredZ * nZ;

            var geographicV = (latitude - extent.south) * latScalar;

            var v = geographicV;

            for ( var col = 0; col < width; ++col) {
                var longitude = extent.west + granularityX * col;

                var nX = cosLatitude * cos(longitude);
                var nY = cosLatitude * sin(longitude);

                var kX = radiiSquaredX * nX;
                var kY = radiiSquaredY * nY;

                var gamma = sqrt((kX * nX) + (kY * nY) + (kZ * nZ));

                var rSurfaceX = kX / gamma;
                var rSurfaceY = kY / gamma;
                var rSurfaceZ = kZ / gamma;

                vertices[vertexArrayIndex++] = rSurfaceX + nX * surfaceHeight - relativeToCenter.x;
                vertices[vertexArrayIndex++] = rSurfaceY + nY * surfaceHeight - relativeToCenter.y;
                vertices[vertexArrayIndex++] = rSurfaceZ + nZ * surfaceHeight - relativeToCenter.z;

                if (generateTextureCoordinates) {
                    var geographicU = (longitude - extent.west) * lonScalar;

                    var u = geographicU;

                    if (interleaveTextureCoordinates) {
                        vertices[vertexArrayIndex++] = u;
                        vertices[vertexArrayIndex++] = v;
                    } else {
                        textureCoordinates[textureCoordinatesIndex++] = u;
                        textureCoordinates[textureCoordinatesIndex++] = v;
                    }
                }
            }
        }

        if (typeof indices !== 'undefined') {
            var index = 0;
            var indicesIndex = 0;
            for ( var i = 0; i < height - 1; ++i) {
                for ( var j = 0; j < width - 1; ++j) {
                    var upperLeft = index;
                    var lowerLeft = upperLeft + width;
                    var lowerRight = lowerLeft + 1;
                    var upperRight = upperLeft + 1;

                    indices[indicesIndex++] = upperLeft;
                    indices[indicesIndex++] = lowerLeft;
                    indices[indicesIndex++] = upperRight;
                    indices[indicesIndex++] = upperRight;
                    indices[indicesIndex++] = lowerLeft;
                    indices[indicesIndex++] = lowerRight;

                    ++index;
                }
                ++index;
            }
        }
    };

    /**
     * Creates a mesh from a cartographic extent.
     *
     * @param {Extent} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Ellipsoid} [description.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the extent lies.
     * @param {Number} [description.granularity=0.1] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number} [description.surfaceHeight=0.0] The height from the surface of the ellipsoid.
     * @param {Cartesian3} [description.relativetoCenter=Cartesian3.ZERO] The positions will be computed as <code>worldPosition.subtract(relativeToCenter)</code>.
     * @param {Boolean} [description.generateTextureCoordinates=false] Whether to generate texture coordinates.
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     * @exception {DeveloperError} <code>description.context</code> is required.
     *
     * @return {Object} A mesh containing attributes for positions, possibly texture coordinates and indices
     * from the extent for creating a vertex array.
     *
     * @see Context#createVertexArrayFromMesh
     * @see MeshFilters.createAttributeIndices
     * @see MeshFilters.toWireframeInPlace
     * @see Extent
     *
     * @example
     * // Create a vertex array for rendering a wireframe extent.
     * var mesh = ExtentTessellator.compute({
     *     ellipsoid : Ellipsoid.WGS84,
     *     extent : new Extent(
     *         CesiumMath.toRadians(-80.0),
     *         CesiumMath.toRadians(39.0),
     *         CesiumMath.toRadians(-74.0),
     *         CesiumMath.toRadians(42.0)
     *     ),
     *     granularity : 0.01,
     *     surfaceHeight : 10000.0
     * });
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh)
     * });
     */
    ExtentTessellator.compute = function(description) {
        description = defaultValue(description, {});

        var extent = description.extent;
        extent.validate();

        var ellipsoid = defaultValue(description.ellipsoid, Ellipsoid.WGS84);
        description.radiiSquared = ellipsoid.getRadiiSquared();
        description.relativeToCenter = defaultValue(description.relativeToCenter, Cartesian3.ZERO);

        var granularity = defaultValue(description.granularity, 0.1);
        description.surfaceHeight = defaultValue(description.surfaceHeight, 0.0);

        description.width = Math.ceil((extent.east - extent.west) / granularity) + 1;
        description.height = Math.ceil((extent.north - extent.south) / granularity) + 1;

        var vertices = [];
        var indices = [];
        var textureCoordinates = [];

        description.generateTextureCoordinates = defaultValue(description.generateTextureCoordinates, false);
        description.interleaveTextureCoordinates = false;
        description.vertices = vertices;
        description.textureCoordinates = textureCoordinates;
        description.indices = indices;

        ExtentTessellator.computeVertices(description);

        var mesh = {
            attributes : {},
            indexLists : [{
                primitiveType : PrimitiveType.TRIANGLES,
                values : indices
            }]
        };

        var positionName = defaultValue(description.positionName, 'position');
        mesh.attributes[positionName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : vertices
        };

        if (description.generateTextureCoordinates) {
            var textureCoordinatesName = defaultValue(description.textureCoordinatesName, 'textureCoordinates');
            mesh.attributes[textureCoordinatesName] = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : textureCoordinates
            };
        }

        return mesh;
    };

    /**
     * Creates arrays of vertex attributes and indices from a cartographic extent.
     *
     * @param {Extent} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Ellipsoid} [description.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the extent lies.
     * @param {Number} [description.granularity=0.1] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number} [description.surfaceHeight=0.0] The height from the surface of the ellipsoid.
     * @param {Cartesian3} [description.relativetoCenter=Cartesian3.ZERO] The positions will be computed as <code>worldPosition.subtract(relativeToCenter)</code>.
     * @param {Boolean} [description.generateTextureCoordinates=false] Whether to generate texture coordinates.
     * @param {Boolean} [description.interleaveTextureCoordinates=false] If texture coordinates are generated, whether to interleave the positions and texture coordinates in a single buffer.
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.     *
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     *
     * @return {Object} An object with flattened arrays for vertex attributes and indices.
     *
     * @example
     * // Example 1:
     * // Create a vertex array for a solid extent, with separate positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoordinates : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var positionBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.positions), usage);
     * var textureCoordinateBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.textureCoordinates), usage);
     * attributes = [{
     *         index : attributeIndices.position,
     *         vertexBuffer : positionBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : textureCoordinateBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var va = context.createVertexArray(attributes, indexBuffer);
     *
     * @example
     * // Example 2:
     * // Create a vertex array for a solid extent, with interleaved positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoordinates : true,
     *     interleaveTextureCoordinates : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var typedArray = datatype.toTypedArray(buffers.vertices);
     * var buffer = context.createVertexBuffer(typedArray, usage);
     * var stride = 5 * datatype.sizeInBytes;
     * var attributes = [{
     *         index : attributeIndices.position3D,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3,
     *         normalize : false,
     *         offsetInBytes : 0,
     *         strideInBytes : stride
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2,
     *         normalize : false,
     *         offsetInBytes : 3 * datatype.sizeInBytes,
     *         strideInBytes : stride
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var vacontext.createVertexArray(attributes, indexBuffer);
     */
    ExtentTessellator.computeBuffers = function(description) {
        description = defaultValue(description, {});

        var extent = description.extent;
        extent.validate();

        var ellipsoid = defaultValue(description.ellipsoid, Ellipsoid.WGS84);
        description.radiiSquared = ellipsoid.getRadiiSquared();
        description.relativeToCenter = defaultValue(description.relativeToCenter, Cartesian3.ZERO);

        var granularity = defaultValue(description.granularity, 0.1);
        description.surfaceHeight = defaultValue(description.surfaceHeight, 0.0);

        description.width = Math.ceil((extent.east - extent.west) / granularity) + 1;
        description.height = Math.ceil((extent.north - extent.south) / granularity) + 1;

        var vertices = [];
        var indices = [];
        var textureCoordinates = [];

        description.generateTextureCoordinates = defaultValue(description.generateTextureCoordinates, false);
        description.interleaveTextureCoordinates = defaultValue(description.interleaveTextureCoordinates, false);
        description.vertices = vertices;
        description.textureCoordinates = textureCoordinates;
        description.indices = indices;

        ExtentTessellator.computeVertices(description);

        var result = {
            indices : indices
        };

        if (description.interleaveTextureCoordinates) {
            result.vertices = vertices;
        } else {
            result.positions = vertices;
            if (description.generateTextureCoordinates) {
                result.textureCoordinates = textureCoordinates;
            }
        }

        return result;
    };

    return ExtentTessellator;
});

/*global define*/
define('Core/Matrix2',[
        './Cartesian2',
        './defaultValue',
        './DeveloperError',
        './freezeObject'
    ], function(
        Cartesian2,
        defaultValue,
        DeveloperError,
        freezeObject) {
    

    /**
     * A 2x2 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix2
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     *
     * @see Matrix2.fromColumnMajor
     * @see Matrix2.fromRowMajorArray
     * @see Matrix3
     * @see Matrix4
     */
    var Matrix2 = function(column0Row0, column1Row0, column0Row1, column1Row1) {
        this[0] = defaultValue(column0Row0, 0.0);
        this[1] = defaultValue(column0Row1, 0.0);
        this[2] = defaultValue(column1Row0, 0.0);
        this[3] = defaultValue(column1Row1, 0.0);
    };

    /**
     * Duplicates a Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to duplicate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix2(values[0], values[2],
                               values[1], values[3]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        return result;
    };

    /**
     * Creates a Matrix2 instance from a column-major order array.
     * @memberof Matrix2
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix2.fromColumnMajorArray = Matrix2.clone;

    /**
     * Creates a Matrix2 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix2
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix2.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix2(values[0], values[1],
                               values[2], values[3]);
        }
        result[0] = values[0];
        result[1] = values[2];
        result[2] = values[1];
        result[3] = values[3];
        return result;
    };

    /**
     * Creates an Array from the provided Matrix2 instance.
     * The array will be in column-major order.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        return result;
    };

    /**
     * Computes the array index of the element at the provided row and column.
     * @memberof Matrix2
     *
     * @param {Number} row The zero-based index of the row.
     * @param {Number} column The zero-based index of the column.
     * @return {Number} The index of the element at the provided row and column.
     *
     * @exception {DeveloperError} row is required and must be 0 or 1.
     * @exception {DeveloperError} column is required and must be 0 or 1.
     *
     * @example
     * var myMatrix = new Matrix2();
     * var column1Row0Index = Matrix2.getElementIndex(1, 0);
     * var column1Row0 = myMatrix[column1Row0Index]
     * myMatrix[column1Row0Index] = 10.0;
     */
    Matrix2.getElementIndex = function(column, row) {
        if (typeof row !== 'number' || row < 0 || row > 1) {
            throw new DeveloperError('row is required and must be 0 or 1.');
        }
        if (typeof column !== 'number' || column < 0 || column > 1) {
            throw new DeveloperError('column is required and must be 0 or 1.');
        }
        return column * 2 + row;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        var startIndex = index * 2;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }
        result = Matrix2.clone(matrix, result);
        var startIndex = index * 2;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        var x = matrix[index];
        var y = matrix[index + 2];

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        result = Matrix2.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 2] = cartesian.y;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix2
     *
     * @param {Matrix2} left The first matrix.
     * @param {Matrix2} right The second matrix.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix2.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var column0Row0 = left[0] * right[0] + left[2] * right[1];
        var column1Row0 = left[0] * right[2] + left[2] * right[3];
        var column0Row1 = left[1] * right[0] + left[3] * right[1];
        var column1Row1 = left[1] * right[2] + left[3] * right[3];

        if (typeof result === 'undefined') {
            return new Matrix2(column0Row0, column1Row0,
                               column0Row1, column1Row1);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column1Row0;
        result[3] = column1Row1;
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix.
     * @param {Cartesian2} cartesian The column.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix2.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;
        var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix2.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix2(matrix[0] * scalar, matrix[2] * scalar,
                               matrix[1] * scalar, matrix[3] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        return result;
    };

    /**
     * Creates a negated copy of the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to negate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix2(-matrix[0], -matrix[2],
                               -matrix[1], -matrix[3]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to transpose.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        var column0Row0 = matrix[0];
        var column0Row1 = matrix[2];
        var column1Row0 = matrix[1];
        var column1Row1 = matrix[3];

        if (typeof result === 'undefined') {
            return new Matrix2(column0Row0, column1Row0,
                               column0Row1, column1Row1);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column1Row0;
        result[3] = column1Row1;
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [left] The first matrix.
     * @param {Matrix2} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix2.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [left] The first matrix.
     * @param {Matrix2} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix2.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon);
    };

    /**
     * An immutable Matrix2 instance initialized to the identity matrix.
     * @memberof Matrix2
     */
    Matrix2.IDENTITY = freezeObject(new Matrix2(1.0, 0.0,
                                                0.0, 1.0));

    /**
     * The index into Matrix2 for column 0, row 0.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN0ROW0] = 5.0; //set column 0, row 0 to 5.0
     */
    Matrix2.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix2 for column 0, row 1.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN0ROW1] = 5.0; //set column 0, row 1 to 5.0
     */
    Matrix2.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix2 for column 1, row 0.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN1ROW0] = 5.0; //set column 1, row 0 to 5.0
     */
    Matrix2.COLUMN1ROW0 = 2;

    /**
     * The index into Matrix2 for column 1, row 1.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN1ROW1] = 5.0; //set column 1, row 1 to 5.0
     */
    Matrix2.COLUMN1ROW1 = 3;

    /**
     * Duplicates the provided Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     */
    Matrix2.prototype.clone = function(result) {
        return Matrix2.clone(this, result);
    };

    /**
     * Creates an Array from this Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     */
    Matrix2.prototype.toArray = function(result) {
        return Matrix2.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.getColumn = function(index, result) {
        return Matrix2.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.setColumn = function(index, cartesian, result) {
        return Matrix2.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.getRow = function(index, result) {
        return Matrix2.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.setRow = function(index, cartesian, result) {
        return Matrix2.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} right The right hand side matrix.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix2.prototype.multiply = function(right, result) {
        return Matrix2.multiply(this, right, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix2
     *
     * @param {Cartesian2} cartesian The column.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix2.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix2.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix2
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix2.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix2.multiplyByScalar(this, scalar, result);
    };
    /**
     * Creates a negated copy of this matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to negate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.prototype.negate = function(result) {
        return Matrix2.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
     */
    Matrix2.prototype.transpose = function(result) {
        return Matrix2.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix2.prototype.equals = function(right) {
        return Matrix2.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix2.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix2.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1)'.
     * @memberof Matrix2
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
     */
    Matrix2.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[2] + ')\n' +
               '(' + this[1] + ', ' + this[3] + ')';
    };

    return Matrix2;
});

/*global define*/
define('Core/Matrix3',[
        './Cartesian3',
        './defaultValue',
        './DeveloperError',
        './freezeObject'
    ], function(
        Cartesian3,
        defaultValue,
        DeveloperError,
        freezeObject) {
    

    /**
     * A 3x3 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix3
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
     *
     * @see Matrix3.fromColumnMajor
     * @see Matrix3.fromRowMajorArray
     * @see Matrix3.fromQuaternion
     * @see Matrix3.fromScale
     * @see Matrix2
     * @see Matrix4
     */
    var Matrix3 = function(column0Row0, column1Row0, column2Row0,
                           column0Row1, column1Row1, column2Row1,
                           column0Row2, column1Row2, column2Row2) {
        this[0] = defaultValue(column0Row0, 0.0);
        this[1] = defaultValue(column0Row1, 0.0);
        this[2] = defaultValue(column0Row2, 0.0);
        this[3] = defaultValue(column1Row0, 0.0);
        this[4] = defaultValue(column1Row1, 0.0);
        this[5] = defaultValue(column1Row2, 0.0);
        this[6] = defaultValue(column2Row0, 0.0);
        this[7] = defaultValue(column2Row1, 0.0);
        this[8] = defaultValue(column2Row2, 0.0);
    };

    /**
     * Duplicates a Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to duplicate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix3(values[0], values[3], values[6],
                               values[1], values[4], values[7],
                               values[2], values[5], values[8]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        result[4] = values[4];
        result[5] = values[5];
        result[6] = values[6];
        result[7] = values[7];
        result[8] = values[8];
        return result;
    };

    /**
     * Creates a Matrix3 instance from a column-major order array.
     * @memberof Matrix3
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix3.fromColumnMajorArray = Matrix3.clone;

    /**
     * Creates a Matrix3 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix3
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix3.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix3(values[0], values[1], values[2],
                               values[3], values[4], values[5],
                               values[6], values[7], values[8]);
        }
        result[0] = values[0];
        result[1] = values[3];
        result[2] = values[6];
        result[3] = values[1];
        result[4] = values[4];
        result[5] = values[7];
        result[6] = values[2];
        result[7] = values[5];
        result[8] = values[8];
        return result;
    };

    /**
     * Computes a 3x3 rotation matrix from the provided quaternion.
     * @memberof Matrix3
     *
     * @param {Quaternion} quaternion the quaternion to use.
     *
     * @return {Matrix3} The 3x3 rotation matrix from this quaternion.
     */
    Matrix3.fromQuaternion = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        var x2 = quaternion.x * quaternion.x;
        var xy = quaternion.x * quaternion.y;
        var xz = quaternion.x * quaternion.z;
        var xw = quaternion.x * quaternion.w;
        var y2 = quaternion.y * quaternion.y;
        var yz = quaternion.y * quaternion.z;
        var yw = quaternion.y * quaternion.w;
        var z2 = quaternion.z * quaternion.z;
        var zw = quaternion.z * quaternion.w;
        var w2 = quaternion.w * quaternion.w;

        var m00 = x2 - y2 - z2 + w2;
        var m01 = 2.0 * (xy + zw);
        var m02 = 2.0 * (xz - yw);

        var m10 = 2.0 * (xy - zw);
        var m11 = -x2 + y2 - z2 + w2;
        var m12 = 2.0 * (yz + xw);

        var m20 = 2.0 * (xz + yw);
        var m21 = 2.0 * (yz - xw);
        var m22 = -x2 - y2 + z2 + w2;

        if (typeof result === 'undefined') {
            return new Matrix3(m00, m01, m02,
                               m10, m11, m12,
                               m20, m21, m22);
        }
        result[0] = m00;
        result[1] = m10;
        result[2] = m20;
        result[3] = m01;
        result[4] = m11;
        result[5] = m21;
        result[6] = m02;
        result[7] = m12;
        result[8] = m22;
        return result;
    };

    /**
     * Computes a Matrix3 instance representing a non-uniform scale.
     * @memberof Matrix3
     *
     * @param {Cartesian3} scale The x, y, and z scale factors.
     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} scale is required.
     *
     * @example
     * // Creates
     * //   [7.0, 0.0, 0.0]
     * //   [0.0, 8.0, 0.0]
     * //   [0.0, 0.0, 9.0]
     * var m = Matrix3.fromScale(new Cartesian3(7.0, 8.0, 9.0));
     */
    Matrix3.fromScale = function(scale, result) {
        if (typeof scale === 'undefined') {
            throw new DeveloperError('scale is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix3(scale.x, 0.0,     0.0,
                               0.0,     scale.y, 0.0,
                               0.0,     0.0,     scale.z);
        }

        result[0] = scale.x;
        result[1] = 0.0;
        result[2] = 0.0;

        result[3] = 0.0;
        result[4] = scale.y;
        result[5] = 0.0;

        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = scale.z;

        return result;
    };

    /**
     * Creates an Array from the provided Matrix3 instance.
     * The array will be in column-major order.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        result[4] = matrix[4];
        result[5] = matrix[5];
        result[6] = matrix[6];
        result[7] = matrix[7];
        result[8] = matrix[8];
        return result;
    };

    /**
     * Computes the array index of the element at the provided row and column.
     * @memberof Matrix3
     *
     * @param {Number} row The zero-based index of the row.
     * @param {Number} column The zero-based index of the column.
     * @return {Number} The index of the element at the provided row and column.
     *
     * @exception {DeveloperError} row is required and must be 0, 1, or 2.
     * @exception {DeveloperError} column is required and must be 0, 1, or 2.
     *
     * @example
     * var myMatrix = new Matrix3();
     * var column1Row0Index = Matrix3.getElementIndex(1, 0);
     * var column1Row0 = myMatrix[column1Row0Index]
     * myMatrix[column1Row0Index] = 10.0;
     */
    Matrix3.getElementIndex = function(column, row) {
        if (typeof row !== 'number' || row < 0 || row > 2) {
            throw new DeveloperError('row is required and must be 0, 1, or 2.');
        }
        if (typeof column !== 'number' || column < 0 || column > 2) {
            throw new DeveloperError('column is required and must be 0, 1, or 2.');
        }
        return column * 3 + row;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        var startIndex = index * 3;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];
        var z = matrix[startIndex + 2];

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }
        result = Matrix3.clone(matrix, result);
        var startIndex = index * 3;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        result[startIndex + 2] = cartesian.z;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        var x = matrix[index];
        var y = matrix[index + 3];
        var z = matrix[index + 6];

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        result = Matrix3.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 3] = cartesian.y;
        result[index + 6] = cartesian.z;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix3
     *
     * @param {Matrix3} left The first matrix.
     * @param {Matrix3} right The second matrix.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix3.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
        var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
        var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];

        var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
        var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
        var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];

        var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
        var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
        var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];

        if (typeof result === 'undefined') {
            return new Matrix3(column0Row0, column1Row0, column2Row0,
                               column0Row1, column1Row1, column2Row1,
                               column0Row2, column1Row2, column2Row2);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column1Row0;
        result[4] = column1Row1;
        result[5] = column1Row2;
        result[6] = column2Row0;
        result[7] = column2Row1;
        result[8] = column2Row2;
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix.
     * @param {Cartesian3} cartesian The column.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix3.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var vX = cartesian.x;
        var vY = cartesian.y;
        var vZ = cartesian.z;

        var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
        var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
        var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix3.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix3(matrix[0] * scalar, matrix[3] * scalar, matrix[6] * scalar,
                               matrix[1] * scalar, matrix[4] * scalar, matrix[7] * scalar,
                               matrix[2] * scalar, matrix[5] * scalar, matrix[8] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        result[4] = matrix[4] * scalar;
        result[5] = matrix[5] * scalar;
        result[6] = matrix[6] * scalar;
        result[7] = matrix[7] * scalar;
        result[8] = matrix[8] * scalar;
        return result;
    };

    /**
     * Creates a negated copy of the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to negate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix3(-matrix[0], -matrix[3], -matrix[6],
                               -matrix[1], -matrix[4], -matrix[7],
                               -matrix[2], -matrix[5], -matrix[8]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        result[4] = -matrix[4];
        result[5] = -matrix[5];
        result[6] = -matrix[6];
        result[7] = -matrix[7];
        result[8] = -matrix[8];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to transpose.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        var column0Row0 = matrix[0];
        var column0Row1 = matrix[3];
        var column0Row2 = matrix[6];
        var column1Row0 = matrix[1];
        var column1Row1 = matrix[4];
        var column1Row2 = matrix[7];
        var column2Row0 = matrix[2];
        var column2Row1 = matrix[5];
        var column2Row2 = matrix[8];

        if (typeof result === 'undefined') {
            return new Matrix3(column0Row0, column1Row0, column2Row0,
                               column0Row1, column1Row1, column2Row1,
                               column0Row2, column1Row2, column2Row2);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column1Row0;
        result[4] = column1Row1;
        result[5] = column1Row2;
        result[6] = column2Row0;
        result[7] = column2Row1;
        result[8] = column2Row2;
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [left] The first matrix.
     * @param {Matrix3} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix3.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3] &&
                left[4] === right[4] &&
                left[5] === right[5] &&
                left[6] === right[6] &&
                left[7] === right[7] &&
                left[8] === right[8]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [left] The first matrix.
     * @param {Matrix3} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix3.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon &&
                Math.abs(left[4] - right[4]) <= epsilon &&
                Math.abs(left[5] - right[5]) <= epsilon &&
                Math.abs(left[6] - right[6]) <= epsilon &&
                Math.abs(left[7] - right[7]) <= epsilon &&
                Math.abs(left[8] - right[8]) <= epsilon);
    };

    /**
     * An immutable Matrix3 instance initialized to the identity matrix.
     * @memberof Matrix3
     */
    Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0,
                                                0.0, 1.0, 0.0,
                                                0.0, 0.0, 1.0));

    /**
     * The index into Matrix3 for column 0, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix3 for column 0, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix3 for column 0, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW2 = 2;

    /**
     * The index into Matrix3 for column 1, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW0 = 3;

    /**
     * The index into Matrix3 for column 1, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW1 = 4;

    /**
     * The index into Matrix3 for column 1, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW2 = 5;

    /**
     * The index into Matrix3 for column 2, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW0 = 6;

    /**
     * The index into Matrix3 for column 2, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW1 = 7;

    /**
     * The index into Matrix3 for column 2, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW2 = 8;

    /**
     * Duplicates the provided Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     */
    Matrix3.prototype.clone = function(result) {
        return Matrix3.clone(this, result);
    };

    /**
     * Creates an Array from this Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     */
    Matrix3.prototype.toArray = function(result) {
        return Matrix3.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.getColumn = function(index, result) {
        return Matrix3.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.setColumn = function(index, cartesian, result) {
        return Matrix3.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.getRow = function(index, result) {
        return Matrix3.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.setRow = function(index, cartesian, result) {
        return Matrix3.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} right The right hand side matrix.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix3.prototype.multiply = function(right, result) {
        return Matrix3.multiply(this, right, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix3
     *
     * @param {Cartesian3} cartesian The column.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix3.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix3.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix3
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix3.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix3.multiplyByScalar(this, scalar, result);
    };
    /**
     * Creates a negated copy of this matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to negate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.prototype.negate = function(result) {
        return Matrix3.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
     */
    Matrix3.prototype.transpose = function(result) {
        return Matrix3.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix3.prototype.equals = function(right) {
        return Matrix3.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix3.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2)'.
     * @memberof Matrix3
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
     */
    Matrix3.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' +
               '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' +
               '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
    };

    return Matrix3;
});
/*global define*/
define('Core/IntersectionTests',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Cartographic',
        './Matrix3',
        './QuadraticRealPolynomial',
        './QuarticRealPolynomial'
    ],
    function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Cartographic,
        Matrix3,
        QuadraticRealPolynomial,
        QuarticRealPolynomial) {
    

    /**
     * DOC_TBA
     *
     * @exports IntersectionTests
     */
    var IntersectionTests = {};

    /**
     * Computes the intersection of a ray and a plane.
     * @memberof IntersectionTests
     *
     * @param {Ray} ray The ray.
     * @param {Cartesian3} planeNormal The plane normal.
     * @param {Number} planeD The distance from the plane to the origin.
     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
     *
     * @exception {DeveloperError} ray is required.
     * @exception {DeveloperError} planeNormal is required.
     * @exception {DeveloperError} planeD is required.
     */
    IntersectionTests.rayPlane = function(ray, planeNormal, planeD, result) {
        if (typeof ray === 'undefined') {
            throw new DeveloperError('ray is required.');
        }

        if (typeof planeNormal === 'undefined') {
            throw new DeveloperError('planeNormal is required.');
        }

        if (typeof planeD === 'undefined') {
            throw new DeveloperError('planeD is required.');
        }

        var origin = ray.origin;
        var direction = ray.direction;
        var denominator = Cartesian3.dot(planeNormal, direction);

        if (Math.abs(denominator) < CesiumMath.EPSILON15) {
            // Ray is parallel to plane.  The ray may be in the polygon's plane.
            return undefined;
        }

        var t = (-planeD - Cartesian3.dot(planeNormal, origin)) / denominator;

        if (t < 0) {
            return undefined;
        }

        result = direction.multiplyByScalar(t, result);
        return Cartesian3.add(origin, result);
    };

    /**
     * Computes the intersection points of a ray with an ellipsoid.
     * @memberof IntersectionTests
     *
     * @param {Ray} ray The ray.
     * @param {Ellipsoid} ellipsoid The ellipsoid.
     * @returns {Array} An array of one or two intersection scalars for points along the ray or undefined if there are no intersections.
     *
     * @exception {DeveloperError} ray is required.
     * @exception {DeveloperError} ellipsoid is required.
     */
    IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {
        if (typeof ray === 'undefined') {
            throw new DeveloperError('ray is required.');
        }

        if (typeof ellipsoid === 'undefined') {
            throw new DeveloperError('ellipsoid is required.');
        }

        var inverseRadii = ellipsoid.getOneOverRadii();
        var q = inverseRadii.multiplyComponents(ray.origin);
        var w = inverseRadii.multiplyComponents(ray.direction);

        var q2 = q.magnitudeSquared();
        var qw = q.dot(w);

        var difference, w2, product, discriminant, temp;

        if (q2 > 1.0) {
            // Outside ellipsoid.
            if (qw >= 0.0) {
                // Looking outward or tangent (0 intersections).
                return undefined;
            }

            // qw < 0.0.
            var qw2 = qw * qw;
            difference = q2 - 1.0; // Positively valued.
            w2 = w.magnitudeSquared();
            product = w2 * difference;

            if (qw2 < product) {
                // Imaginary roots (0 intersections).
                return undefined;
            } else if (qw2 > product) {
                // Distinct roots (2 intersections).
                discriminant = qw * qw - product;
                temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                var root0 = temp / w2;
                var root1 = difference / temp;
                if (root0 < root1) {
                    return {
                        start : root0,
                        stop : root1
                    };
                }

                return {
                    start : root1,
                    stop : root0
                };
            } else {
                // qw2 == product.  Repeated roots (2 intersections).
                var root = Math.sqrt(difference / w2);
                return {
                    start : root,
                    stop : root
                };
            }

        } else if (q2 < 1.0) {
            // Inside ellipsoid (2 intersections).
            difference = q2 - 1.0; // Negatively valued.
            w2 = w.magnitudeSquared();
            product = w2 * difference; // Negatively valued.
            if (qw < 0.0) {
                // Looking inward.
                discriminant = qw * qw - product;
                temp = qw - Math.sqrt(discriminant); // Avoid cancellation.  Negatively valued.
                return {
                    start : 0.0,
                    stop : difference / temp
                };
            } else if (qw > 0.0) {
                // Looking outward.
                discriminant = qw * qw - product;
                temp = qw + Math.sqrt(discriminant); // Avoid cancellation. Positively valued.
                return {
                    start : 0.0,
                    stop : temp / w2
                };
            } else {
                // qw == 0.0 // Looking tangent.
                temp = Math.sqrt(-product);
                return {
                    start : 0.0,
                    stop : temp / w2
                };
            }
        } else {
            // q2 == 1.0. On ellipsoid.
            if (qw < 0.0) {
                // Looking inward.
                w2 = w.magnitudeSquared();
                return {
                    start : 0.0,
                    stop : -qw / w2
                };
            }

            // qw >= 0.0.  Looking outward or tangent.
            return undefined;
        }
    };

    function addWithCancellationCheck(left, right, tolerance) {
        var difference = left + right;
        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&
                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
            return 0.0;
        }

        return difference;
    }

    function quadraticVectorExpression(A, b, c, x, w) {
        var xSquared = x * x;
        var wSquared = w * w;

        var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
        var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);
        var l0 = (A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared) + x * b.x + c;

        var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);
        var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);

        var cosines;
        var solutions = [];
        if (r0 === 0.0 && r1 === 0.0) {
            cosines = QuadraticRealPolynomial.realRoots(l2, l1, l0);
            if (cosines.length === 0) {
                return solutions;
            }

            var cosine0 = cosines[0];
            var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));
            solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
            solutions.push(new Cartesian3(x, w * cosine0, w * sine0));

            if (cosines.length === 2) {
                var cosine1 = cosines[1];
                var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));
                solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
                solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
            }

            return solutions;
        }

        var r0Squared = r0 * r0;
        var r1Squared = r1 * r1;
        var l2Squared = l2 * l2;
        var r0r1 = r0 * r1;

        var c4 = l2Squared + r1Squared;
        var c3 = 2.0 * (l1 * l2 + r0r1);
        var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
        var c1 = 2.0 * (l0 * l1 - r0r1);
        var c0 = l0 * l0 - r0Squared;

        if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {
            return solutions;
        }

        cosines = QuarticRealPolynomial.realRoots(c4, c3, c2, c1, c0);
        var length = cosines.length;
        if (length === 0) {
            return solutions;
        }


        for (var i = 0; i < length; ++i) {
            var cosine = cosines[i];
            var cosineSquared = cosine * cosine;
            var sineSquared = Math.max(1.0 - cosineSquared, 0.0);
            var sine = Math.sqrt(sineSquared);

            //var left = l2 * cosineSquared + l1 * cosine + l0;
            var left;
            if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
                left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);
            } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
                left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);
            } else {
                left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);
            }

            var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);
            var product = left * right;

            if (product < 0.0) {
                solutions.push(new Cartesian3(x, w * cosine, w * sine));
            } else if (product > 0.0) {
                solutions.push(new Cartesian3(x, w * cosine, w * -sine));
            } else if (sine !== 0.0) {
                solutions.push(new Cartesian3(x, w * cosine, w * -sine));
                solutions.push(new Cartesian3(x, w * cosine, w * sine));
                ++i;
            } else {
                solutions.push(new Cartesian3(x, w * cosine, w * sine));
            }
        }

        return solutions;
    }

    /**
     * Provides the point along the ray which is nearest to the ellipsoid.
     * @memberof IntersectionTests
     *
     * @param {Ray} ray The ray.
     * @param {Ellipsoid} ellipsoid The ellipsoid.
     * @returns {Cartesian} The nearest planetodetic point on the ray.
     *
     * @exception {DeveloperError} ray is required.
     * @exception {DeveloperError} ellipsoid is required.
     */
    IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {
        if (typeof ray === 'undefined') {
            throw new DeveloperError('ray is required.');
        }

        if (typeof ellipsoid === 'undefined') {
            throw new DeveloperError('ellipsoid is required.');
        }

        var position = ray.origin;
        var direction = ray.direction;

        var normal = ellipsoid.geodeticSurfaceNormal(position);

        if (Cartesian3.dot(direction, normal) >= 0.0) { // The location provided is the closest point in altitude
            return position;
        }

        var intersects = typeof this.rayEllipsoid(ray, ellipsoid) !== 'undefined';

        // Compute the scaled direction vector.
        var f = ellipsoid.transformPositionToScaledSpace(direction);

        // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.
        var firstAxis = f.normalize();
        var reference = f.mostOrthogonalAxis();
        var secondAxis = reference.cross(firstAxis).normalize();
        var thirdAxis = firstAxis.cross(secondAxis).normalize();
        var B = new Matrix3(firstAxis.x, secondAxis.x, thirdAxis.x,
                            firstAxis.y, secondAxis.y, thirdAxis.y,
                            firstAxis.z, secondAxis.z, thirdAxis.z);
        var B_T = B.transpose();

        // Get the scaling matrix and its inverse.
        var D_I = Matrix3.fromScale(ellipsoid.getRadii());
        var D = Matrix3.fromScale(ellipsoid.getOneOverRadii());

        var C = new Matrix3(0.0, direction.z, -direction.y,
                            -direction.z, 0.0, direction.x,
                            direction.y, -direction.x, 0.0);

        var temp = B_T.multiply(D).multiply(C);
        var A = temp.multiply(D_I).multiply(B);
        var b = temp.multiplyByVector(position);

        // Solve for the solutions to the expression in standard form:
        var solutions = quadraticVectorExpression(A, b.negate(), 0.0, 0.0, 1.0);

        var s;
        var altitude;
        var length = solutions.length;
        if(length > 0) {
            var closest = Cartesian3.ZERO;
            var maximumValue = Number.NEGATIVE_INFINITY;

            for (var i = 0; i < length; ++i) {
                s = D_I.multiplyByVector(B.multiplyByVector(solutions[i]));
                var v = s.subtract(position).normalize();
                var dotProduct = v.dot(direction);

                if (dotProduct > maximumValue) {
                    maximumValue = dotProduct;
                    closest = s;
                }
            }

            var surfacePoint = ellipsoid.cartesianToCartographic(closest);
            maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);
            altitude = closest.subtract(position).magnitude() * Math.sqrt(1.0 - maximumValue * maximumValue);
            altitude = intersects ? -altitude : altitude;
            return ellipsoid.cartographicToCartesian(new Cartographic(surfacePoint.longitude, surfacePoint.latitude, altitude));
        }

        return undefined;
    };

    return IntersectionTests;
});

/*global define*/
define('Core/Matrix4',[
        './Cartesian3',
        './Cartesian4',
        './defaultValue',
        './DeveloperError',
        './freezeObject',
        './Math',
        './Matrix3',
        './RuntimeError'
    ], function(
        Cartesian3,
        Cartesian4,
        defaultValue,
        DeveloperError,
        freezeObject,
        CesiumMath,
        Matrix3,
        RuntimeError) {
    

    /**
     * A 4x4 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix4
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
     * @param {Number} [column3Row0=0.0] The value for column 3, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
     * @param {Number} [column3Row1=0.0] The value for column 3, row 1.
     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
     * @param {Number} [column3Row2=0.0] The value for column 3, row 2.
     * @param {Number} [column0Row3=0.0] The value for column 0, row 3.
     * @param {Number} [column1Row3=0.0] The value for column 1, row 3.
     * @param {Number} [column2Row3=0.0] The value for column 2, row 3.
     * @param {Number} [column3Row3=0.0] The value for column 3, row 3.
     *
     * @see Matrix4.fromColumnMajorArray
     * @see Matrix4.fromRowMajorArray
     * @see Matrix4.fromRotationTranslation
     * @see Matrix4.fromTranslation
     * @see Matrix4.fromScale
     * @see Matrix4.fromCamera
     * @see Matrix4.computePerspectiveFieldOfView
     * @see Matrix4.computeOrthographicOffCenter
     * @see Matrix4.computePerspectiveOffCenter
     * @see Matrix4.computeInfinitePerspectiveOffCenter
     * @see Matrix4.computeViewportTransformation
     * @see Matrix2
     * @see Matrix3
     */
    var Matrix4 = function(column0Row0, column1Row0, column2Row0, column3Row0,
                           column0Row1, column1Row1, column2Row1, column3Row1,
                           column0Row2, column1Row2, column2Row2, column3Row2,
                           column0Row3, column1Row3, column2Row3, column3Row3) {
        this[0] = defaultValue(column0Row0, 0.0);
        this[1] = defaultValue(column0Row1, 0.0);
        this[2] = defaultValue(column0Row2, 0.0);
        this[3] = defaultValue(column0Row3, 0.0);
        this[4] = defaultValue(column1Row0, 0.0);
        this[5] = defaultValue(column1Row1, 0.0);
        this[6] = defaultValue(column1Row2, 0.0);
        this[7] = defaultValue(column1Row3, 0.0);
        this[8] = defaultValue(column2Row0, 0.0);
        this[9] = defaultValue(column2Row1, 0.0);
        this[10] = defaultValue(column2Row2, 0.0);
        this[11] = defaultValue(column2Row3, 0.0);
        this[12] = defaultValue(column3Row0, 0.0);
        this[13] = defaultValue(column3Row1, 0.0);
        this[14] = defaultValue(column3Row2, 0.0);
        this[15] = defaultValue(column3Row3, 0.0);
    };

    /**
     * Duplicates a Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to duplicate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(values[0], values[4], values[8], values[12],
                               values[1], values[5], values[9], values[13],
                               values[2], values[6], values[10], values[14],
                               values[3], values[7], values[11], values[15]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        result[4] = values[4];
        result[5] = values[5];
        result[6] = values[6];
        result[7] = values[7];
        result[8] = values[8];
        result[9] = values[9];
        result[10] = values[10];
        result[11] = values[11];
        result[12] = values[12];
        result[13] = values[13];
        result[14] = values[14];
        result[15] = values[15];
        return result;
    };

    /**
     * Computes a Matrix4 instance from a column-major order array.
     * @memberof Matrix4
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix4.fromColumnMajorArray = Matrix4.clone;

    /**
     * Computes a Matrix4 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix4
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix4.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(values[0], values[1], values[2], values[3],
                               values[4], values[5], values[6], values[7],
                               values[8], values[9], values[10], values[11],
                               values[12], values[13], values[14], values[15]);
        }
        result[0] = values[0];
        result[1] = values[4];
        result[2] = values[8];
        result[3] = values[12];
        result[4] = values[1];
        result[5] = values[5];
        result[6] = values[9];
        result[7] = values[13];
        result[8] = values[2];
        result[9] = values[6];
        result[10] = values[10];
        result[11] = values[14];
        result[12] = values[3];
        result[13] = values[7];
        result[14] = values[11];
        result[15] = values[15];
        return result;
    };

    /**
     * Computes a Matrix4 instance from a Matrix3 representing the rotation
     * and a Cartesian3 representing the translation.
     * @memberof Matrix4
     *
     * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} rotation is required.
     * @exception {DeveloperError} translation is required.
     */
    Matrix4.fromRotationTranslation = function(rotation, translation, result) {
        if (typeof rotation === 'undefined') {
            throw new DeveloperError('rotation is required.');
        }
        if (typeof translation === 'undefined') {
            throw new DeveloperError('translation is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x,
                               rotation[1], rotation[4], rotation[7], translation.y,
                               rotation[2], rotation[5], rotation[8], translation.z,
                                       0.0,         0.0,         0.0,           1.0);
        }

        result[0] = rotation[0];
        result[1] = rotation[1];
        result[2] = rotation[2];
        result[3] = 0.0;
        result[4] = rotation[3];
        result[5] = rotation[4];
        result[6] = rotation[5];
        result[7] = 0.0;
        result[8] = rotation[6];
        result[9] = rotation[7];
        result[10] = rotation[8];
        result[11] = 0.0;
        result[12] = translation.x;
        result[13] = translation.y;
        result[14] = translation.z;
        result[15] = 1.0;
        return result;
    };

    /**
     * Creates a Matrix4 instance from a Cartesian3 representing the translation.
     * @memberof Matrix4
     *
     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @see Matrix4.multiplyByTranslation
     *
     * @exception {DeveloperError} translation is required.
     */
    Matrix4.fromTranslation = function(translation, result) {
        return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
    };

    /**
     * Computes a Matrix4 instance representing a non-uniform scale.
     * @memberof Matrix4
     *
     * @param {Cartesian3} scale The x, y, and z scale factors.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} scale is required.
     *
     * @example
     * // Creates
     * //   [7.0, 0.0, 0.0, 0.0]
     * //   [0.0, 8.0, 0.0, 0.0]
     * //   [0.0, 0.0, 9.0, 0.0]
     * //   [0.0, 0.0, 0.0, 1.0]
     * var m = Matrix4.fromScale(new Cartesian3(7.0, 8.0, 9.0));
     */
    Matrix4.fromScale = function(scale, result) {
        if (typeof scale === 'undefined') {
            throw new DeveloperError('scale is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(scale.x, 0.0,     0.0,     0.0,
                               0.0,     scale.y, 0.0,     0.0,
                               0.0,     0.0,     scale.z, 0.0,
                               0.0,     0.0,     0.0,     1.0);
        }

        result[0] = scale.x;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = scale.y;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = scale.z;
        result[11] = 0.0;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = 0.0;
        result[15] = 1.0;
        return result;
    };

    var fromCameraF = new Cartesian3();
    var fromCameraS = new Cartesian3();
    var fromCameraU = new Cartesian3();

    /**
     * Computes a Matrix4 instance from a Camera.
     * @memberof Matrix4
     *
     * @param {Camera} camera The camera to use.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} camera is required.
     * @exception {DeveloperError} camera.eye is required.
     * @exception {DeveloperError} camera.target is required.
     * @exception {DeveloperError} camera.up is required.
     */
    Matrix4.fromCamera = function(camera, result) {
        if (typeof camera === 'undefined') {
            throw new DeveloperError('camera is required.');
        }

        var eye = camera.eye;
        var target = camera.target;
        var up = camera.up;

        if (typeof eye === 'undefined') {
            throw new DeveloperError('camera.eye is required.');
        }
        if (typeof target === 'undefined') {
            throw new DeveloperError('camera.target is required.');
        }
        if (typeof up === 'undefined') {
            throw new DeveloperError('camera.up is required.');
        }

        Cartesian3.subtract(target, eye, fromCameraF).normalize(fromCameraF);
        Cartesian3.cross(fromCameraF, up, fromCameraS).normalize(fromCameraS);
        Cartesian3.cross(fromCameraS, fromCameraF, fromCameraU).normalize(fromCameraU);

        var sX = fromCameraS.x;
        var sY = fromCameraS.y;
        var sZ = fromCameraS.z;
        var fX = fromCameraF.x;
        var fY = fromCameraF.y;
        var fZ = fromCameraF.z;
        var uX = fromCameraU.x;
        var uY = fromCameraU.y;
        var uZ = fromCameraU.z;
        var eyeX = eye.x;
        var eyeY = eye.y;
        var eyeZ = eye.z;
        var t0 = sX * -eyeX + sY * -eyeY+ sZ * -eyeZ;
        var t1 = uX * -eyeX + uY * -eyeY+ uZ * -eyeZ;
        var t2 = fX * eyeX + fY * eyeY + fZ * eyeZ;

        //The code below this comment is an optimized
        //version of the commented lines.
        //Rather that create two matrices and then multiply,
        //we just bake in the multiplcation as part of creation.
        //var rotation = new Matrix4(
        //                sX,  sY,  sZ, 0.0,
        //                uX,  uY,  uZ, 0.0,
        //               -fX, -fY, -fZ, 0.0,
        //                0.0,  0.0,  0.0, 1.0);
        //var translation = new Matrix4(
        //                1.0, 0.0, 0.0, -eye.x,
        //                0.0, 1.0, 0.0, -eye.y,
        //                0.0, 0.0, 1.0, -eye.z,
        //                0.0, 0.0, 0.0, 1.0);
        //return rotation.multiply(translation);
        if (typeof result === 'undefined') {
            return new Matrix4(
                    sX,   sY,  sZ, t0,
                    uX,   uY,  uZ, t1,
                   -fX,  -fY, -fZ, t2,
                    0.0, 0.0, 0.0, 1.0);
        }
        result[0] = sX;
        result[1] = uX;
        result[2] = -fX;
        result[3] = 0.0;
        result[4] = sY;
        result[5] = uY;
        result[6] = -fY;
        result[7] = 0.0;
        result[8] = sZ;
        result[9] = uZ;
        result[10] = -fZ;
        result[11] = 0.0;
        result[12] = t0;
        result[13] = t1;
        result[14] = t2;
        result[15] = 1.0;
        return result;

    };

     /**
      * Computes a Matrix4 instance representing a perspective transformation matrix.
      * @memberof Matrix4
      *
      * @param {Number} fovY The field of view along the Y axis in radians.
      * @param {Number} aspectRatio The aspect ratio.
      * @param {Number} near The distance to the near plane in meters.
      * @param {Number} far The distance to the far plane in meters.
      * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
      * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
      *
      * @exception {DeveloperError} fovY must be in [0, PI).
      * @exception {DeveloperError} aspectRatio must be greater than zero.
      * @exception {DeveloperError} near must be greater than zero.
      * @exception {DeveloperError} far must be greater than zero.
      */
    Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
        if (fovY <= 0.0 || fovY > Math.PI) {
            throw new DeveloperError('fovY must be in [0, PI).');
        }

        if (aspectRatio <= 0.0) {
            throw new DeveloperError('aspectRatio must be greater than zero.');
        }

        if (near <= 0.0) {
            throw new DeveloperError('near must be greater than zero.');
        }

        if (far <= 0.0) {
            throw new DeveloperError('far must be greater than zero.');
        }

        var bottom = Math.tan(fovY * 0.5);

        var column1Row1 = 1.0 / bottom;
        var column0Row0 = column1Row1 / aspectRatio;
        var column2Row2 = (far + near) / (near - far);
        var column3Row2 = (2.0 * far * near) / (near - far);

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0,         0.0,         0.0,         0.0,
                                       0.0, column1Row1,         0.0,         0.0,
                                       0.0,         0.0, column2Row2, column3Row2,
                                       0.0,         0.0,        -1.0,         0.0);
         }

        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = column2Row2;
        result[11] = -1.0;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = column3Row2;
        result[15] = 0.0;
        return result;
    };

    /**
    * Computes a Matrix4 instance representing an orthographic transformation matrix.
    * @memberof Matrix4
    *
    * @param {Number} left The number of meters to the left of the camera that will be in view.
    * @param {Number} right The number of meters to the right of the camera that will be in view.
    * @param {Number} bottom The number of meters below of the camera that will be in view.
    * @param {Number} top The number of meters above of the camera that will be in view.
    * @param {Number} near The distance to the near plane in meters.
    * @param {Number} far The distance to the far plane in meters.
    * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
    * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
    *
    * @exception {DeveloperError} left is required.
    * @exception {DeveloperError} right is required.
    * @exception {DeveloperError} bottom is required.
    * @exception {DeveloperError} top is required.
    * @exception {DeveloperError} near is required.
    * @exception {DeveloperError} far is required.
    */
    Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }
        if (typeof far === 'undefined') {
            throw new DeveloperError('far is required.');
        }

        var a = 1.0 / (right - left);
        var b = 1.0 / (top - bottom);
        var c = 1.0 / (far - near);

        var tx = -(right + left) * a;
        var ty = -(top + bottom) * b;
        var tz = -(far + near) * c;
        a *= 2.0;
        b *= 2.0;
        c *= -2.0;

        if (typeof result === 'undefined') {
            return new Matrix4(  a, 0.0, 0.0, tx,
                               0.0,   b, 0.0, ty,
                               0.0, 0.0,   c, tz,
                               0.0, 0.0, 0.0, 1.0);
        }

        result[0] = a;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = b;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = c;
        result[11] = 0.0;
        result[12] = tx;
        result[13] = ty;
        result[14] = tz;
        result[15] = 1.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance representing an off center perspective transformation.
     * @memberof Matrix4
     *
     * @param {Number} left The number of meters to the left of the camera that will be in view.
     * @param {Number} right The number of meters to the right of the camera that will be in view.
     * @param {Number} bottom The number of meters below of the camera that will be in view.
     * @param {Number} top The number of meters above of the camera that will be in view.
     * @param {Number} near The distance to the near plane in meters.
     * @param {Number} far The distance to the far plane in meters.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     * @exception {DeveloperError} bottom is required.
     * @exception {DeveloperError} top is required.
     * @exception {DeveloperError} near is required.
     * @exception {DeveloperError} far is required.
     */
    Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }
        if (typeof far === 'undefined') {
            throw new DeveloperError('far is required.');
        }

        var column0Row0 = 2.0 * near / (right - left);
        var column1Row1 = 2.0 * near / (top - bottom);
        var column2Row0 = (right + left) / (right - left);
        var column2Row1 = (top + bottom) / (top - bottom);
        var column2Row2 = -(far + near) / (far - near);
        var column2Row3 = -1.0;
        var column3Row2 = -2.0 * far * near / (far - near);

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         column2Row0, 0.0,
                                       0.0, column1Row1, column2Row1, 0.0,
                                       0.0, 0.0,         column2Row2, column3Row2,
                                       0.0, 0.0,         column2Row3, 0.0);
        }

        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = column3Row2;
        result[15] = 0.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance representing an infinite off center perspective transformation.
     * @memberof Matrix4
     *
     * @param {Number} left The number of meters to the left of the camera that will be in view.
     * @param {Number} right The number of meters to the right of the camera that will be in view.
     * @param {Number} bottom The number of meters below of the camera that will be in view.
     * @param {Number} top The number of meters above of the camera that will be in view.
     * @param {Number} near The distance to the near plane in meters.
     * @param {Number} far The distance to the far plane in meters.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     * @exception {DeveloperError} bottom is required.
     * @exception {DeveloperError} top is required.
     * @exception {DeveloperError} near is required.
     */
    Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }

        var column0Row0 = 2.0 * near / (right - left);
        var column1Row1 = 2.0 * near / (top - bottom);
        var column2Row0 = (right + left) / (right - left);
        var column2Row1 = (top + bottom) / (top - bottom);
        var column2Row2 = -1.0;
        var column2Row3 = -1.0;
        var column3Row2 = -2.0 * near;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         column2Row0, 0.0,
                                       0.0, column1Row1, column2Row1, 0.0,
                                       0.0, 0.0,         column2Row2, column3Row2,
                                       0.0, 0.0,         column2Row3, 0.0);
        }

        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = column3Row2;
        result[15] = 0.0;
        return result;
    };

    var EMPTY_OBJECT = {};
    /**
     * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
     * @memberof Matrix4
     *
     * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
     * @param {Number}[nearDepthRange = 0.0] The near plane distance in window coordinates.
     * @param {Number}[farDepthRange = 1.0] The far plane distance in window coordinates.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     *
     * @see czm_viewportTransformation
     * @see Context#getViewport
     *
     * @example
     * // Example 1.  Create viewport transformation using an explicit viewport and depth range.
     * var m = Matrix4.computeViewportTransformation({
     *     x : 0.0,
     *     y : 0.0,
     *     width : 1024.0,
     *     height : 768.0
     * }, 0.0, 1.0);
     *
     * // Example 2.  Create viewport transformation using the context's viewport.
     * var m = Matrix4.computeViewportTransformation(context.getViewport());
     */
    Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
        viewport = defaultValue(viewport, EMPTY_OBJECT);
        var x = defaultValue(viewport.x, 0.0);
        var y = defaultValue(viewport.y, 0.0);
        var width = defaultValue(viewport.width, 0.0);
        var height = defaultValue(viewport.height, 0.0);
        nearDepthRange = defaultValue(nearDepthRange, 0.0);
        farDepthRange = defaultValue(farDepthRange, 1.0);

        var halfWidth = width * 0.5;
        var halfHeight = height * 0.5;
        var halfDepth = (farDepthRange - nearDepthRange) * 0.5;

        var column0Row0 = halfWidth;
        var column1Row1 = halfHeight;
        var column2Row2 = halfDepth;
        var column3Row0 = x + halfWidth;
        var column3Row1 = y + halfHeight;
        var column3Row2 = nearDepthRange + halfDepth;
        var column3Row3 = 1.0;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         0.0,         column3Row0,
                               0.0,         column1Row1, 0.0,         column3Row1,
                               0.0,         0.0,         column2Row2, column3Row2,
                               0.0,         0.0,         0.0,         column3Row3);
        }
        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = column2Row2;
        result[11] = 0.0;
        result[12] = column3Row0;
        result[13] = column3Row1;
        result[14] = column3Row2;
        result[15] = column3Row3;
        return result;
    };

    /**
     * Computes an Array from the provided Matrix4 instance.
     * The array will be in column-major order.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3],
                    matrix[4], matrix[5], matrix[6], matrix[7],
                    matrix[8], matrix[9], matrix[10], matrix[11],
                    matrix[12], matrix[13], matrix[14], matrix[15]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        result[4] = matrix[4];
        result[5] = matrix[5];
        result[6] = matrix[6];
        result[7] = matrix[7];
        result[8] = matrix[8];
        result[9] = matrix[9];
        result[10] = matrix[10];
        result[11] = matrix[11];
        result[12] = matrix[12];
        result[13] = matrix[13];
        result[14] = matrix[14];
        result[15] = matrix[15];
        return result;
    };

    /**
     * Computes the array index of the element at the provided row and column.
     * @memberof Matrix4
     *
     * @param {Number} row The zero-based index of the row.
     * @param {Number} column The zero-based index of the column.
     * @return {Number} The index of the element at the provided row and column.
     *
     * @exception {DeveloperError} row is required and must be 0, 1, 2, or 3.
     * @exception {DeveloperError} column is required and must be 0, 1, 2, or 3.
     *
     * @example
     * var myMatrix = new Matrix4();
     * var column1Row0Index = Matrix4.getElementIndex(1, 0);
     * var column1Row0 = myMatrix[column1Row0Index]
     * myMatrix[column1Row0Index] = 10.0;
     */
    Matrix4.getElementIndex = function(column, row) {
        if (typeof row !== 'number' || row < 0 || row > 3) {
            throw new DeveloperError('row is required and must be 0, 1, 2, or 3.');
        }
        if (typeof column !== 'number' || column < 0 || column > 3) {
            throw new DeveloperError('column is required and must be 0, 1, 2, or 3.');
        }
        return column * 4 + row;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        var startIndex = index * 4;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];
        var z = matrix[startIndex + 2];
        var w = matrix[startIndex + 3];

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }
        result = Matrix4.clone(matrix, result);
        var startIndex = index * 4;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        result[startIndex + 2] = cartesian.z;
        result[startIndex + 3] = cartesian.w;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        var x = matrix[index];
        var y = matrix[index + 4];
        var z = matrix[index + 8];
        var w = matrix[index + 12];

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        result = Matrix4.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 4] = cartesian.y;
        result[index + 8] = cartesian.z;
        result[index + 12] = cartesian.w;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix4
     *
     * @param {Matrix4} left The first matrix.
     * @param {Matrix4} right The second matrix.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix4.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var left0 = left[0];
        var left1 = left[1];
        var left2 = left[2];
        var left3 = left[3];
        var left4 = left[4];
        var left5 = left[5];
        var left6 = left[6];
        var left7 = left[7];
        var left8 = left[8];
        var left9 = left[9];
        var left10 = left[10];
        var left11 = left[11];
        var left12 = left[12];
        var left13 = left[13];
        var left14 = left[14];
        var left15 = left[15];

        var right0 = right[0];
        var right1 = right[1];
        var right2 = right[2];
        var right3 = right[3];
        var right4 = right[4];
        var right5 = right[5];
        var right6 = right[6];
        var right7 = right[7];
        var right8 = right[8];
        var right9 = right[9];
        var right10 = right[10];
        var right11 = right[11];
        var right12 = right[12];
        var right13 = right[13];
        var right14 = right[14];
        var right15 = right[15];

        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
        var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;

        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
        var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;

        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
        var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;

        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
        var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, column1Row0, column2Row0, column3Row0,
                               column0Row1, column1Row1, column2Row1, column3Row1,
                               column0Row2, column1Row2, column2Row2, column3Row2,
                               column0Row3, column1Row3, column2Row3, column3Row3);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column0Row3;
        result[4] = column1Row0;
        result[5] = column1Row1;
        result[6] = column1Row2;
        result[7] = column1Row3;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = column3Row0;
        result[13] = column3Row1;
        result[14] = column3Row2;
        result[15] = column3Row3;
        return result;
    };

    /**
     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
     * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
     * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
     *
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix on the left-hand side.
     * @param {Cartesian3} translation The translation on the right-hand side.
     * @param {Matrix4} [result] The object onto which to store the result.
     *
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} translation is required.
     *
     * @see Matrix.#fromTranslation
     *
     * @example
     * // Instead of Matrix4.multiply(m, Matrix4.fromTranslation(position), m);
     * Matrix4.multiplyByTranslation(m, position, m);
     */
    Matrix4.multiplyByTranslation = function(matrix, translation, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof translation === 'undefined') {
            throw new DeveloperError('translation is required');
        }

        var x = translation.x;
        var y = translation.y;
        var z = translation.z;

        var tx = (x * matrix[0]) + (y * matrix[4]) + (z * matrix[8]) + matrix[12];
        var ty = (x * matrix[1]) + (y * matrix[5]) + (z * matrix[9]) + matrix[13];
        var tz = (x * matrix[2]) + (y * matrix[6]) + (z * matrix[10]) + matrix[14];

        if (typeof result === 'undefined') {
            return new Matrix4(matrix[0], matrix[4], matrix[8], tx,
                               matrix[1], matrix[5], matrix[9], ty,
                               matrix[2], matrix[6], matrix[10], tz,
                               matrix[3], matrix[7], matrix[11], matrix[15]);
        }

        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        result[4] = matrix[4];
        result[5] = matrix[5];
        result[6] = matrix[6];
        result[7] = matrix[7];
        result[8] = matrix[8];
        result[9] = matrix[9];
        result[10] = matrix[10];
        result[11] = matrix[11];
        result[12] = tx;
        result[13] = ty;
        result[14] = tz;
        result[15] = matrix[15];
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix.
     * @param {Cartesian4} cartesian The vector.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix4.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var vX = cartesian.x;
        var vY = cartesian.y;
        var vZ = cartesian.z;
        var vW = cartesian.w;

        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
        var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    var scratchPoint = new Cartesian4(0.0, 0.0, 0.0, 1.0);

    /**
     * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
     * with a {@link Cartesian4} with a <code>w</code> component of one.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix.
     * @param {Cartesian3} cartesian The point.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} matrix is required.
     *
     * @example
     * Cartesian3 p = new Cartesian3(1.0, 2.0, 3.0);
     * Matrix4.multiplyByPoint(matrix, p, result);
     * // A shortcut for
     * //   Cartesian3 p = ...
     * //   Matrix4.multiplyByVector(matrix, new Cartesian4(p.x, p.y, p.z, 1.0), result);
     */
    Matrix4.multiplyByPoint = function(matrix, cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        scratchPoint.x = cartesian.x;
        scratchPoint.y = cartesian.y;
        scratchPoint.z = cartesian.z;
        // scratchPoint.w is one.  See above.

        return Matrix4.multiplyByVector(matrix, scratchPoint, result);
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix4.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix4(matrix[0] * scalar, matrix[4] * scalar, matrix[8] * scalar, matrix[12] * scalar,
                               matrix[1] * scalar, matrix[5] * scalar, matrix[9] * scalar, matrix[13] * scalar,
                               matrix[2] * scalar, matrix[6] * scalar, matrix[10] * scalar, matrix[14] * scalar,
                               matrix[3] * scalar, matrix[7] * scalar, matrix[11] * scalar, matrix[15] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        result[4] = matrix[4] * scalar;
        result[5] = matrix[5] * scalar;
        result[6] = matrix[6] * scalar;
        result[7] = matrix[7] * scalar;
        result[8] = matrix[8] * scalar;
        result[9] = matrix[9] * scalar;
        result[10] = matrix[10] * scalar;
        result[11] = matrix[11] * scalar;
        result[12] = matrix[12] * scalar;
        result[13] = matrix[13] * scalar;
        result[14] = matrix[14] * scalar;
        result[15] = matrix[15] * scalar;
        return result;
    };

    /**
     * Computes a negated copy of the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to negate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix4(-matrix[0], -matrix[4], -matrix[8], -matrix[12],
                               -matrix[1], -matrix[5], -matrix[9], -matrix[13],
                               -matrix[2], -matrix[6], -matrix[10], -matrix[14],
                               -matrix[3], -matrix[7], -matrix[11], -matrix[15]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        result[4] = -matrix[4];
        result[5] = -matrix[5];
        result[6] = -matrix[6];
        result[7] = -matrix[7];
        result[8] = -matrix[8];
        result[9] = -matrix[9];
        result[10] = -matrix[10];
        result[11] = -matrix[11];
        result[12] = -matrix[12];
        result[13] = -matrix[13];
        result[14] = -matrix[14];
        result[15] = -matrix[15];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to transpose.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(matrix[0], matrix[1], matrix[2], matrix[3],
                               matrix[4], matrix[5], matrix[6], matrix[7],
                               matrix[8], matrix[9], matrix[10], matrix[11],
                               matrix[12], matrix[13], matrix[14], matrix[15]);
        }

        var matrix1 = matrix[1];
        var matrix2 = matrix[2];
        var matrix3 = matrix[3];
        var matrix6 = matrix[6];
        var matrix7 = matrix[7];
        var matrix11 = matrix[11];

        result[0] = matrix[0];
        result[1] = matrix[4];
        result[2] = matrix[8];
        result[3] = matrix[12];
        result[4] = matrix1;
        result[5] = matrix[5];
        result[6] = matrix[9];
        result[7] = matrix[13];
        result[8] = matrix2;
        result[9] = matrix6;
        result[10] = matrix[10];
        result[11] = matrix[14];
        result[12] = matrix3;
        result[13] = matrix7;
        result[14] = matrix11;
        result[15] = matrix[15];
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [left] The first matrix.
     * @param {Matrix4} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix4.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3] &&
                left[4] === right[4] &&
                left[5] === right[5] &&
                left[6] === right[6] &&
                left[7] === right[7] &&
                left[8] === right[8] &&
                left[9] === right[9] &&
                left[10] === right[10] &&
                left[11] === right[11] &&
                left[12] === right[12] &&
                left[13] === right[13] &&
                left[14] === right[14] &&
                left[15] === right[15]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [left] The first matrix.
     * @param {Matrix4} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix4.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon &&
                Math.abs(left[4] - right[4]) <= epsilon &&
                Math.abs(left[5] - right[5]) <= epsilon &&
                Math.abs(left[6] - right[6]) <= epsilon &&
                Math.abs(left[7] - right[7]) <= epsilon &&
                Math.abs(left[8] - right[8]) <= epsilon &&
                Math.abs(left[9] - right[9]) <= epsilon &&
                Math.abs(left[10] - right[10]) <= epsilon &&
                Math.abs(left[11] - right[11]) <= epsilon &&
                Math.abs(left[12] - right[12]) <= epsilon &&
                Math.abs(left[13] - right[13]) <= epsilon &&
                Math.abs(left[14] - right[14]) <= epsilon &&
                Math.abs(left[15] - right[15]) <= epsilon);
    };

    /**
     * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     *
     * @see Cartesian3
     */
    Matrix4.getTranslation = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(matrix[12], matrix[13], matrix[14]);
        }
        result.x = matrix[12];
        result.y = matrix[13];
        result.z = matrix[14];
        return result;
    };

    /**
     * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     *
     * @see Matrix3
     */
     Matrix4.getRotation = function(matrix, result) {
         if (typeof matrix === 'undefined') {
             throw new DeveloperError('matrix is required');
         }
         if (typeof result === 'undefined') {
             return new Matrix3(matrix[0], matrix[4], matrix[8],
                                matrix[1], matrix[5], matrix[9],
                                matrix[2], matrix[6], matrix[10]);
         }
         result[0] = matrix[0];
         result[1] = matrix[1];
         result[2] = matrix[2];
         result[3] = matrix[4];
         result[4] = matrix[5];
         result[5] = matrix[6];
         result[6] = matrix[8];
         result[7] = matrix[9];
         result[8] = matrix[10];
         return result;
     };

     /**
      * Computes the inverse of the provided matrix using Cramers Rule.
      * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
      * If the matrix is an affine transformation matrix, it is more efficient
      * to invert it with {@link #inverseTransformation}.
      * @memberof Matrix4
      *
      * @param {Matrix4} matrix The matrix to invert.
      * @param {Matrix4} [result] The object onto which to store the result.
      * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if one was not provided.
      *
      * @exception {DeveloperError} matrix is required.
      * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
      */
    Matrix4.inverse = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        //
        // Ported from:
        //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
        //
        var src0 = matrix[0];
        var src1 = matrix[4];
        var src2 = matrix[8];
        var src3 = matrix[12];
        var src4 = matrix[1];
        var src5 = matrix[5];
        var src6 = matrix[9];
        var src7 = matrix[13];
        var src8 = matrix[2];
        var src9 = matrix[6];
        var src10 = matrix[10];
        var src11 = matrix[14];
        var src12 = matrix[3];
        var src13 = matrix[7];
        var src14 = matrix[11];
        var src15 = matrix[15];

        // calculate pairs for first 8 elements (cofactors)
        var tmp0 = src10 * src15;
        var tmp1 = src11 * src14;
        var tmp2 = src9 * src15;
        var tmp3 = src11 * src13;
        var tmp4 = src9 * src14;
        var tmp5 = src10 * src13;
        var tmp6 = src8 * src15;
        var tmp7 = src11 * src12;
        var tmp8 = src8 * src14;
        var tmp9 = src10 * src12;
        var tmp10 = src8 * src13;
        var tmp11 = src9 * src12;

        // calculate first 8 elements (cofactors)
        var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
        var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
        var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
        var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
        var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
        var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
        var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
        var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

        // calculate pairs for second 8 elements (cofactors)
        tmp0 = src2 * src7;
        tmp1 = src3 * src6;
        tmp2 = src1 * src7;
        tmp3 = src3 * src5;
        tmp4 = src1 * src6;
        tmp5 = src2 * src5;
        tmp6 = src0 * src7;
        tmp7 = src3 * src4;
        tmp8 = src0 * src6;
        tmp9 = src2 * src4;
        tmp10 = src0 * src5;
        tmp11 = src1 * src4;

        // calculate second 8 elements (cofactors)
        var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
        var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
        var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
        var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
        var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
        var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
        var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
        var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

        // calculate determinant
        var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;

        if (Math.abs(det) < CesiumMath.EPSILON20) {
            throw new RuntimeError('matrix is not invertible because its determinate is zero.');
        }

        // calculate matrix inverse
        det = 1.0 / det;
        if (typeof result === 'undefined') {
            return new Matrix4(dst0 * det, dst4 * det, dst8 * det, dst12 * det,
                               dst1 * det, dst5 * det, dst9 * det, dst13 * det,
                               dst2 * det, dst6 * det, dst10 * det, dst14 * det,
                               dst3 * det, dst7 * det, dst11 * det, dst15 * det);
        }

        result[0] = dst0 * det;
        result[1] = dst1 * det;
        result[2] = dst2 * det;
        result[3] = dst3 * det;
        result[4] = dst4 * det;
        result[5] = dst5 * det;
        result[6] = dst6 * det;
        result[7] = dst7 * det;
        result[8] = dst8 * det;
        result[9] = dst9 * det;
        result[10] = dst10 * det;
        result[11] = dst11 * det;
        result[12] = dst12 * det;
        result[13] = dst13 * det;
        result[14] = dst14 * det;
        result[15] = dst15 * det;
        return result;
    };

    /**
     * Computes the inverse of the provided matrix assuming it is
     * an affine transformation matrix, where the upper left 3x3 elements
     * are a rotation matrix, and the upper three elements in the fourth
     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link #inverse}.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to invert.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.inverseTransformation = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        //This function is an optimized version of the below 4 lines.
        //var rT = Matrix3.transpose(Matrix4.getRotation(matrix));
        //var rTN = Matrix3.negate(rT);
        //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
        //return Matrix4.fromRotationTranslation(rT, rTT, result);

        var matrix0 = matrix[0];
        var matrix1 = matrix[1];
        var matrix2 = matrix[2];
        var matrix4 = matrix[4];
        var matrix5 = matrix[5];
        var matrix6 = matrix[6];
        var matrix8 = matrix[8];
        var matrix9 = matrix[9];
        var matrix10 = matrix[10];

        var vX = matrix[12];
        var vY = matrix[13];
        var vZ = matrix[14];

        var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
        var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
        var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;

        if (typeof result === 'undefined') {
            return new Matrix4(matrix0, matrix1, matrix2,  x,
                               matrix4, matrix5, matrix6,  y,
                               matrix8, matrix9, matrix10, z,
                               0.0,         0.0,      0.0, 1.0);
        }
        result[0] = matrix0;
        result[1] = matrix4;
        result[2] = matrix8;
        result[3] = 0.0;
        result[4] = matrix1;
        result[5] = matrix5;
        result[6] = matrix9;
        result[7] = 0.0;
        result[8] = matrix2;
        result[9] = matrix6;
        result[10] = matrix10;
        result[11] = 0.0;
        result[12] = x;
        result[13] = y;
        result[14] = z;
        result[15] = 1.0;
        return result;
    };

    /**
     * An immutable Matrix4 instance initialized to the identity matrix.
     * @memberof Matrix4
     */
    Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0,
                                                0.0, 1.0, 0.0, 0.0,
                                                0.0, 0.0, 1.0, 0.0,
                                                0.0, 0.0, 0.0, 1.0));

    /**
     * The index into Matrix4 for column 0, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix4 for column 0, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix4 for column 0, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW2 = 2;

    /**
     * The index into Matrix4 for column 0, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW3 = 3;

    /**
     * The index into Matrix4 for column 1, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW0 = 4;

    /**
     * The index into Matrix4 for column 1, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW1 = 5;

    /**
     * The index into Matrix4 for column 1, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW2 = 6;

    /**
     * The index into Matrix4 for column 1, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW3 = 7;

    /**
     * The index into Matrix4 for column 2, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW0 = 8;

    /**
     * The index into Matrix4 for column 2, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW1 = 9;

    /**
     * The index into Matrix4 for column 2, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW2 = 10;

    /**
     * The index into Matrix4 for column 2, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW3 = 11;

    /**
     * The index into Matrix4 for column 3, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW0 = 12;

    /**
     * The index into Matrix4 for column 3, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW1 = 13;

    /**
     * The index into Matrix4 for column 3, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW2 = 14;

    /**
     * The index into Matrix4 for column 3, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW3 = 15;

    /**
     * Duplicates the provided Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     */
    Matrix4.prototype.clone = function(result) {
        return Matrix4.clone(this, result);
    };

    /**
     * Computes an Array from this Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if one was not provided.
     */
    Matrix4.prototype.toArray = function(result) {
        return Matrix4.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.getColumn = function(index, result) {
        return Matrix4.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.setColumn = function(index, cartesian, result) {
        return Matrix4.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.getRow = function(index, result) {
        return Matrix4.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.setRow = function(index, cartesian, result) {
        return Matrix4.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} right The right hand side matrix.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix4.prototype.multiply = function(right, result) {
        return Matrix4.multiply(this, right, result);
    };

    /**
     * Multiplies this matrix, assuming it is a transformation matrix (with a bottom row of
     * <code>[0.0, 0.0, 0.0, 1.0]</code>), by an implicit translation matrix defined by a {@link Cartesian3}.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian3} translation The translation on the right-hand side of the multiplication.
     * @param {Matrix4} [result] The object onto which to store the result.
     *
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} translation is required.
     */
    Matrix4.prototype.multiplyByTranslation = function(translation, result) {
        return Matrix4.multiplyByTranslation(this, translation, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix4
     *
     * @param {Cartesian4} cartesian The vector.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix4.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix4.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4#multiplyByVector}
     * with a {@link Cartesian4} with a <code>w</code> component of one.
     * @memberof Matrix4
     *
     * @param {Cartesian3} cartesian The point.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix4.prototype.multiplyByPoint = function(cartesian, result) {
        return Matrix4.multiplyByPoint(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix4
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix4.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix4.multiplyByScalar(this, scalar, result);
    };
    /**
     * Computes a negated copy of this matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to negate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.prototype.negate = function(result) {
        return Matrix4.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
     */
    Matrix4.prototype.transpose = function(result) {
        return Matrix4.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix4.prototype.equals = function(right) {
        return Matrix4.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix4.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Computes a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2, column3)'.
     * @memberof Matrix4
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
     */
    Matrix4.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] +')\n' +
               '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] +')\n' +
               '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] +')\n' +
               '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] +')';
    };

    /**
     * Gets the translation portion of this matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @see Cartesian3
     */
    Matrix4.prototype.getTranslation = function(result) {
        return Matrix4.getTranslation(this, result);
    };

    /**
     * Gets the upper left 3x3 rotation matrix of this matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @see Matrix3
     */
    Matrix4.prototype.getRotation = function(result) {
        return Matrix4.getRotation(this, result);
    };

    /**
     * Computes the inverse of this matrix using Cramers Rule.
     * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
     * If the matrix is an affine transformation matrix, it is more efficient
     * to invert it with {@link #inverseTransformation}.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
     */
    Matrix4.prototype.inverse = function(result) {
        return Matrix4.inverse(this, result);
    };

    /**
     * Computes the inverse of this matrix assuming it is
     * an affine transformation matrix, where the upper left 3x3 elements
     * are a rotation matrix, and the upper three elements in the fourth
     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link #inverse}.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Matrix4.prototype.inverseTransformation = function(result) {
        return Matrix4.inverseTransformation(this, result);
    };

    return Matrix4;
});

/*global define*/
define('Core/BoundingSphere',[
        './defaultValue',
        './DeveloperError',
        './Cartesian2',
        './Cartesian3',
        './Cartesian4',
        './Cartographic',
        './Ellipsoid',
        './GeographicProjection',
        './Extent',
        './Intersect',
        './Interval',
        './Matrix4'
    ], function(
        defaultValue,
        DeveloperError,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Ellipsoid,
        GeographicProjection,
        Extent,
        Intersect,
        Interval,
        Matrix4) {
    

    /**
     * A bounding sphere with a center and a radius.
     * @alias BoundingSphere
     * @constructor
     *
     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.
     * @param {Number} [radius=0.0] The radius of the bounding sphere.
     *
     * @see AxisAlignedBoundingBox
     * @see BoundingRectangle
     */
    var BoundingSphere = function(center, radius) {
        /**
         * The center point of the sphere.
         * @type {Cartesian3}
         */
        this.center = (typeof center !== 'undefined') ? Cartesian3.clone(center) : Cartesian3.ZERO.clone();
        /**
         * The radius of the sphere.
         * @type {Number}
         */
        this.radius = defaultValue(radius, 0.0);
    };

    var fromPointsXMin = new Cartesian3();
    var fromPointsYMin = new Cartesian3();
    var fromPointsZMin = new Cartesian3();
    var fromPointsXMax = new Cartesian3();
    var fromPointsYMax = new Cartesian3();
    var fromPointsZMax = new Cartesian3();
    var fromPointsCurrentPos = new Cartesian3();
    var fromPointsScratch = new Cartesian3();
    var fromPointsRitterCenter = new Cartesian3();
    var fromPointsMinBoxPt = new Cartesian3();
    var fromPointsMaxBoxPt = new Cartesian3();

    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
     * The bounding sphere is computed by running two algorithms, a naive algorithm and
     * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.
     * @memberof BoundingSphere
     *
     * @param {Array} positions An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
     *
     * @see <a href='http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/'>Bounding Sphere computation article</a>
     */
    BoundingSphere.fromPoints = function(positions, result) {
        if (typeof result === 'undefined') {
            result = new BoundingSphere();
        }

        if (typeof positions === 'undefined' || positions.length === 0) {
            result.center = Cartesian3.ZERO.clone(result.center);
            result.radius = 0.0;
            return result;
        }

        var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);

        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);

        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);

        var numPositions = positions.length;
        for ( var i = 1; i < numPositions; i++) {
            Cartesian3.clone(positions[i], currentPos);

            var x = currentPos.x;
            var y = currentPos.y;
            var z = currentPos.z;

            // Store points containing the the smallest and largest components
            if (x < xMin.x) {
                Cartesian3.clone(currentPos, xMin);
            }

            if (x > xMax.x) {
                Cartesian3.clone(currentPos, xMax);
            }

            if (y < yMin.y) {
                Cartesian3.clone(currentPos, yMin);
            }

            if (y > yMax.y) {
                Cartesian3.clone(currentPos, yMax);
            }

            if (z < zMin.z) {
                Cartesian3.clone(currentPos, zMin);
            }

            if (z > zMax.z) {
                Cartesian3.clone(currentPos, zMax);
            }
        }

        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));

        // Set the diameter endpoints to the largest span.
        var diameter1 = xMin;
        var diameter2 = xMax;
        var maxSpan = xSpan;
        if (ySpan > maxSpan) {
            maxSpan = ySpan;
            diameter1 = yMin;
            diameter2 = yMax;
        }
        if (zSpan > maxSpan) {
            maxSpan = zSpan;
            diameter1 = zMin;
            diameter2 = zMax;
        }

        // Calculate the center of the initial sphere found by Ritter's algorithm
        var ritterCenter = fromPointsRitterCenter;
        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;

        // Calculate the radius of the initial sphere found by Ritter's algorithm
        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
        var ritterRadius = Math.sqrt(radiusSquared);

        // Find the center of the sphere found using the Naive method.
        var minBoxPt = fromPointsMinBoxPt;
        minBoxPt.x = xMin.x;
        minBoxPt.y = yMin.y;
        minBoxPt.z = zMin.z;

        var maxBoxPt = fromPointsMaxBoxPt;
        maxBoxPt.x = xMax.x;
        maxBoxPt.y = yMax.y;
        maxBoxPt.z = zMax.z;

        var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5);

        // Begin 2nd pass to find naive radius and modify the ritter sphere.
        var naiveRadius = 0;
        for (i = 0; i < numPositions; i++) {
            Cartesian3.clone(positions[i], currentPos);

            // Find the furthest point from the naive center to calculate the naive radius.
            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
            if (r > naiveRadius) {
                naiveRadius = r;
            }

            // Make adjustments to the Ritter Sphere to include all points.
            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
            if (oldCenterToPointSquared > radiusSquared) {
                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
                // Calculate new radius to include the point that lies outside
                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
                radiusSquared = ritterRadius * ritterRadius;
                // Calculate center of new Ritter sphere
                var oldToNew = oldCenterToPoint - ritterRadius;
                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
            }
        }

        if (ritterRadius < naiveRadius) {
            Cartesian3.clone(ritterCenter, result.center);
            result.radius = ritterRadius;
        } else {
            Cartesian3.clone(naiveCenter, result.center);
            result.radius = naiveRadius;
        }

        return result;
    };

    var defaultProjection = new GeographicProjection();
    var fromExtent2DLowerLeft = new Cartographic();
    var fromExtent2DUpperRight = new Cartographic();
    /**
     * Computes a bounding sphere from an extent projected in 2D.
     * @memberof BoundingSphere
     *
     * @param {Extent} extent The extent around which to create a bounding sphere.
     * @param {Object} [projection=GeographicProjection] The projection used to project the extent into 2D.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    BoundingSphere.fromExtent2D = function(extent, projection, result) {
        if (typeof result === 'undefined') {
            result = new BoundingSphere();
        }

        if (typeof extent === 'undefined') {
            result.center = Cartesian3.ZERO.clone(result.center);
            result.radius = 0.0;
            return result;
        }

        projection = (typeof projection !== 'undefined') ? projection : defaultProjection;

        var lowerLeft = projection.project(extent.getSouthwest(fromExtent2DLowerLeft));
        var upperRight = projection.project(extent.getNortheast(fromExtent2DUpperRight));

        var width = upperRight.x - lowerLeft.x;
        var height = upperRight.y - lowerLeft.y;

        result.radius = Math.sqrt(width * width + height * height) * 0.5;
        var center = result.center;
        center.x = lowerLeft.x + width * 0.5;
        center.y = lowerLeft.y + height * 0.5;
        center.z = 0;
        return result;
    };

    var fromExtent3DScratch = [];
    /**
     * Computes a bounding sphere from an extent in 3D. The bounding sphere is created using a subsample of points
     * on the ellipsoid and contained in the extent. It may not be accurate for all extents on all types of ellipsoids.
     * @memberof BoundingSphere
     *
     * @param {Extent} extent The valid extent used to create a bounding sphere.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the extent.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    BoundingSphere.fromExtent3D = function(extent, ellipsoid, result) {
        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        var positions = typeof extent !== 'undefined' ? extent.subsample(ellipsoid, fromExtent3DScratch) : undefined;
        return BoundingSphere.fromPoints(positions, result);
    };

    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are
     * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two
     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
     * ensure a tight fit.
     *
     * @memberof BoundingSphere
     *
     * @param {Array} positions An array of points that the bounding sphere will enclose.  Each point
     *        is formed from three elements in the array in the order X, Y, Z.
     * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the
     *        origin of the coordinate system.  This is useful when the positions are to be used for
     *        relative-to-center (RTC) rendering.
     * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may
     *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position
     *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index
     *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If
     *        the stride is 5, however, two array elements are skipped and the next position begins at array
     *        index 5.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
     *
     * @see <a href='http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/'>Bounding Sphere computation article</a>
     *
     * @example
     * // Compute the bounding sphere from 3 positions, each specified relative to a center.
     * // In addition to the X, Y, and Z coordinates, the points array contains two additional
     * // elements per point which are ignored for the purpose of computing the bounding sphere.
     * var center = new Cartesian3(1.0, 2.0, 3.0);
     * var points = [1.0, 2.0, 3.0, 0.1, 0.2,
     *               4.0, 5.0, 6.0, 0.1, 0.2,
     *               7.0, 8.0, 9.0, 0.1, 0.2];
     * var sphere = BoundingSphere.fromVertices(points, center, 5);
     */
    BoundingSphere.fromVertices = function(positions, center, stride, result) {
        if (typeof result === 'undefined') {
            result = new BoundingSphere();
        }

        if (typeof positions === 'undefined' || positions.length === 0) {
            result.center = Cartesian3.ZERO.clone(result.center);
            result.radius = 0.0;
            return result;
        }

        if (typeof center === 'undefined') {
            center = Cartesian3.ZERO;
        }

        if (typeof stride === 'undefined') {
            stride = 3;
        }

        if (stride < 3) {
            throw new DeveloperError('stride must be 3 or greater.');
        }

        var currentPos = fromPointsCurrentPos;
        currentPos.x = positions[0] + center.x;
        currentPos.y = positions[1] + center.y;
        currentPos.z = positions[2] + center.z;

        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);

        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);

        var numElements = positions.length;
        for (var i = 0; i < numElements; i += stride) {
            var x = positions[i] + center.x;
            var y = positions[i + 1] + center.y;
            var z = positions[i + 2] + center.z;

            currentPos.x = x;
            currentPos.y = y;
            currentPos.z = z;

            // Store points containing the the smallest and largest components
            if (x < xMin.x) {
                Cartesian3.clone(currentPos, xMin);
            }

            if (x > xMax.x) {
                Cartesian3.clone(currentPos, xMax);
            }

            if (y < yMin.y) {
                Cartesian3.clone(currentPos, yMin);
            }

            if (y > yMax.y) {
                Cartesian3.clone(currentPos, yMax);
            }

            if (z < zMin.z) {
                Cartesian3.clone(currentPos, zMin);
            }

            if (z > zMax.z) {
                Cartesian3.clone(currentPos, zMax);
            }
        }

        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));

        // Set the diameter endpoints to the largest span.
        var diameter1 = xMin;
        var diameter2 = xMax;
        var maxSpan = xSpan;
        if (ySpan > maxSpan) {
            maxSpan = ySpan;
            diameter1 = yMin;
            diameter2 = yMax;
        }
        if (zSpan > maxSpan) {
            maxSpan = zSpan;
            diameter1 = zMin;
            diameter2 = zMax;
        }

        // Calculate the center of the initial sphere found by Ritter's algorithm
        var ritterCenter = fromPointsRitterCenter;
        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;

        // Calculate the radius of the initial sphere found by Ritter's algorithm
        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
        var ritterRadius = Math.sqrt(radiusSquared);

        // Find the center of the sphere found using the Naive method.
        var minBoxPt = fromPointsMinBoxPt;
        minBoxPt.x = xMin.x;
        minBoxPt.y = yMin.y;
        minBoxPt.z = zMin.z;

        var maxBoxPt = fromPointsMaxBoxPt;
        maxBoxPt.x = xMax.x;
        maxBoxPt.y = yMax.y;
        maxBoxPt.z = zMax.z;

        var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5);

        // Begin 2nd pass to find naive radius and modify the ritter sphere.
        var naiveRadius = 0;
        for (i = 0; i < numElements; i += stride) {
            currentPos.x = positions[i] + center.x;
            currentPos.y = positions[i + 1] + center.y;
            currentPos.z = positions[i + 2] + center.z;

            // Find the furthest point from the naive center to calculate the naive radius.
            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
            if (r > naiveRadius) {
                naiveRadius = r;
            }

            // Make adjustments to the Ritter Sphere to include all points.
            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
            if (oldCenterToPointSquared > radiusSquared) {
                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
                // Calculate new radius to include the point that lies outside
                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
                radiusSquared = ritterRadius * ritterRadius;
                // Calculate center of new Ritter sphere
                var oldToNew = oldCenterToPoint - ritterRadius;
                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
            }
        }

        if (ritterRadius < naiveRadius) {
            Cartesian3.clone(ritterCenter, result.center);
            result.radius = ritterRadius;
        } else {
            Cartesian3.clone(naiveCenter, result.center);
            result.radius = naiveRadius;
        }

        return result;
    };

    /**
     * Duplicates a BoundingSphere instance.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} sphere The bounding sphere to duplicate.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} sphere is required.
     */
    BoundingSphere.clone = function(sphere, result) {
        if (typeof sphere === 'undefined') {
            throw new DeveloperError('sphere is required');
        }

        if (typeof result === 'undefined') {
            return new BoundingSphere(sphere.center, sphere.radius);
        }

        result.center = Cartesian3.clone(sphere.center, result.center);
        result.radius = sphere.radius;
        return result;
    };

    var unionScratch = new Cartesian3();
    var unionScratchCenter = new Cartesian3();
    /**
     * Computes a bounding sphere that contains both the left and right bounding spheres.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.
     * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    BoundingSphere.union = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }

        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }

        if (typeof result === 'undefined') {
            result = new BoundingSphere();
        }

        var leftCenter = left.center;
        var rightCenter = right.center;

        Cartesian3.add(leftCenter, rightCenter, unionScratchCenter);
        var center = Cartesian3.multiplyByScalar(unionScratchCenter, 0.5, unionScratchCenter);

        var radius1 = Cartesian3.subtract(leftCenter, center, unionScratch).magnitude() + left.radius;
        var radius2 = Cartesian3.subtract(rightCenter, center, unionScratch).magnitude() + right.radius;

        result.radius = Math.max(radius1, radius2);
        Cartesian3.clone(center, result.center);

        return result;
    };

    var expandScratch = new Cartesian3();
    /**
     * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} sphere A sphere to expand.
     * @param {Cartesian3} point A point to enclose in a bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} sphere is required.
     * @exception {DeveloperError} point is required.
     */
    BoundingSphere.expand = function(sphere, point, result) {
        if (typeof sphere === 'undefined') {
            throw new DeveloperError('sphere is required.');
        }

        if (typeof point === 'undefined') {
            throw new DeveloperError('point is required.');
        }

        result = BoundingSphere.clone(sphere, result);

        var radius = Cartesian3.subtract(point, result.center, expandScratch).magnitude();
        if (radius > result.radius) {
            result.radius = radius;
        }

        return result;
    };

    /**
     * Determines which side of a plane a sphere is located.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} sphere The bounding sphere to test.
     * @param {Cartesian4} plane The coefficients of the plane in the for ax + by + cz + d = 0
     *                           where the coefficients a, b, c, and d are the components x, y, z,
     *                           and w of the {Cartesian4}, respectively.
     * @return {Intersect} {Intersect.INSIDE} if the entire sphere is on the side of the plane the normal
     *                     is pointing, {Intersect.OUTSIDE} if the entire sphere is on the opposite side,
     *                     and {Intersect.INTERSETING} if the sphere intersects the plane.
     *
     * @exception {DeveloperError} sphere is required.
     * @exception {DeveloperError} plane is required.
     */
    BoundingSphere.intersect = function(sphere, plane) {
        if (typeof sphere === 'undefined') {
            throw new DeveloperError('sphere is required.');
        }

        if (typeof plane === 'undefined') {
            throw new DeveloperError('plane is required.');
        }

        var center = sphere.center;
        var radius = sphere.radius;
        var distanceToPlane = Cartesian3.dot(plane, center) + plane.w;

        if (distanceToPlane < -radius) {
            // The center point is negative side of the plane normal
            return Intersect.OUTSIDE;
        } else if (distanceToPlane < radius) {
            // The center point is positive side of the plane, but radius extends beyond it; partial overlap
            return Intersect.INTERSECTING;
        }
        return Intersect.INSIDE;
    };

    var transformCart4 = Cartesian4.UNIT_W.clone();
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.
     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} sphere is required.
     * @exception {DeveloperError} transform is required.
     */
    BoundingSphere.transform = function(sphere, transform, result) {
        if (typeof sphere === 'undefined') {
            throw new DeveloperError('sphere is required.');
        }

        if (typeof transform === 'undefined') {
            throw new DeveloperError('transform is required.');
        }

        if (typeof result === 'undefined') {
            result = new BoundingSphere();
        }

        Matrix4.multiplyByPoint(transform, sphere.center, transformCart4);

        Cartesian3.clone(transformCart4, result.center);
        result.radius = sphere.radius;
        return result;
    };

    var scratchCartesian3 = new Cartesian3();
    /**
     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
     * plus/minus the radius of the bounding sphere.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding sphere.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.
     * @param {Cartesian3} position The position to calculate the distance from.
     * @param {Cartesian3} direction The direction from position.
     * @param {Cartesian2} [result] A Cartesian2 to store the nearest and farthest distances.
     * @return {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
     *
     * @exception {DeveloperError} sphere is required.
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     */
    BoundingSphere.getPlaneDistances = function(sphere, position, direction, result) {
        if (typeof sphere === 'undefined') {
            throw new DeveloperError('sphere is required.');
        }

        if (typeof position === 'undefined') {
            throw new DeveloperError('position is required.');
        }

        if (typeof direction === 'undefined') {
            throw new DeveloperError('direction is required.');
        }

        if (typeof result === 'undefined') {
            result = new Interval();
        }

        var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);
        var proj = Cartesian3.multiplyByScalar(direction, direction.dot(toCenter), scratchCartesian3);
        var mag = proj.magnitude();

        result.start = mag - sphere.radius;
        result.stop = mag + sphere.radius;
        return result;
    };

    /**
     * Compares the provided BoundingSphere componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} [left] The first BoundingSphere.
     * @param {BoundingSphere} [right] The second BoundingSphere.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    BoundingSphere.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                Cartesian3.equals(left.center, right.center) &&
                left.radius === right.radius);
    };

    /**
     * Duplicates this BoundingSphere instance.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    BoundingSphere.prototype.clone = function(result) {
        return BoundingSphere.clone(this, result);
    };

    /**
     * Computes a bounding sphere that contains both this bounding sphere and the argument sphere.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} right The sphere to enclose in this bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} sphere is required.
     */
    BoundingSphere.prototype.union = function(right, result) {
        return BoundingSphere.union(this, right, result);
    };

    /**
     * Computes a bounding sphere that is sphere expanded to contain point.
     * @memberof BoundingSphere
     *
     * @param {Cartesian3} point A point to enclose in a bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
     *
     * @exception {DeveloperError} point is required.
     */
    BoundingSphere.prototype.expand = function(point, result) {
        return BoundingSphere.expand(this, point, result);
    };

    /**
     * Determines which side of a plane the sphere is located.
     * @memberof BoundingSphere
     *
     * @param {Cartesian4} plane The coefficients of the plane in the for ax + by + cz + d = 0
     *                           where the coefficients a, b, c, and d are the components x, y, z,
     *                           and w of the {Cartesian4}, respectively.
     * @return {Intersect} {Intersect.INSIDE} if the entire sphere is on the side of the plane the normal
     *                     is pointing, {Intersect.OUTSIDE} if the entire sphere is on the opposite side,
     *                     and {Intersect.INTERSETING} if the sphere intersects the plane.
     *
     * @exception {DeveloperError} plane is required.
     */
    BoundingSphere.prototype.intersect = function(plane) {
        return BoundingSphere.intersect(this, plane);
    };

    /**
     * Applies a 4x4 affine transformation matrix to this bounding sphere.
     * @memberof BoundingSphere
     *
     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
     * @param {BoundingSphere} [result] The object onto which to store the result.
     * @return {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
     *
     * @exception {DeveloperError} transform is required.
     */
    BoundingSphere.prototype.transform = function(transform, result) {
        return BoundingSphere.transform(this, transform, result);
    };

    /**
     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
     * plus/minus the radius of the bounding sphere.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding sphere.
     * @memberof BoundingSphere
     *
     * @param {Cartesian3} position The position to calculate the distance from.
     * @param {Cartesian3} direction The direction from position.
     * @param {Cartesian2} [result] A Cartesian2 to store the nearest and farthest distances.
     * @return {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     */
    BoundingSphere.prototype.getPlaneDistances = function(position, direction, result) {
        return BoundingSphere.getPlaneDistances(this, position, direction, result);
    };

    /**
     * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof BoundingSphere
     *
     * @param {BoundingSphere} [right] The right hand side BoundingSphere.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    BoundingSphere.prototype.equals = function(right) {
        return BoundingSphere.equals(this, right);
    };

    return BoundingSphere;
});

/*global define*/
define('Core/EllipsoidalOccluder',[
        './defaultValue',
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Visibility',
        './Ellipsoid',
        './BoundingSphere'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Visibility,
        Ellipsoid,
        BoundingSphere) {
    

    /**
     * Determine whether or not other objects are visible or hidden behind the visible horizon defined by
     * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the
     * origin of the coordinate system.
     *
     * @alias EllipsoidalOccluder
     *
     * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.
     * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not
     *        specified, {@link EllipsoidalOccluder#setCameraPosition} must be called before
     *        testing visibility.
     *
     * @exception {DeveloperError} <code>ellipsoid</code> is required.
     *
     * @constructor
     *
     * @example
     * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.
     * var cameraPosition = new Cartesian3(5.0, 6.0, 7.0);
     * var occluderEllipsoid = new Ellipsoid(1.0, 1.1, 0.9);
     * var occluder = new EllipsoidalOccluder(occluderEllipsoid, cameraPosition);
     */
    var EllipsoidalOccluder = function(ellipsoid, cameraPosition) {
        if (typeof ellipsoid === 'undefined') {
            throw new DeveloperError('ellipsoid is required.');
        }

        this._ellipsoid = ellipsoid;
        this._cameraPosition = new Cartesian3(0.0, 0.0, 0.0);
        this._cameraPositionInScaledSpace = new Cartesian3(0.0, 0.0, 0.0);
        this._distanceToLimbInScaledSpaceSquared = 0.0;

        // setCameraPosition fills in the above values
        if (typeof cameraPosition !== 'undefined') {
            this.setCameraPosition(cameraPosition);
        }
    };

    /**
     * Returns the occluding ellipsoid.
     *
     * @memberof EllipsoidalOccluder
     *
     * @return {Ellipsoid} The ellipsoid.
     */
    EllipsoidalOccluder.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Sets the position of the camera.
     *
     * @memberof EllipsoidalOccluder
     *
     * @param {Cartesian3} cameraPosition The new position of the camera.
     */
    EllipsoidalOccluder.prototype.setCameraPosition = function(cameraPosition) {
        var ellipsoid = this._ellipsoid;
        var cameraPositionInScaledSpace = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);
        var magnitudeCameraPositionInScaledSpace = Cartesian3.magnitude(cameraPositionInScaledSpace);
        var distanceToLimbInScaledSpaceSquared = magnitudeCameraPositionInScaledSpace * magnitudeCameraPositionInScaledSpace - 1.0;

        Cartesian3.clone(cameraPosition, this._cameraPosition);
        this._cameraPositionInScaledSpace = cameraPositionInScaledSpace;
        this._distanceToLimbInScaledSpaceSquared = distanceToLimbInScaledSpaceSquared;
    };

    /**
     * Gets the position of the camera.
     *
     * @memberof EllipsoidalOccluder
     *
     * @returns {Cartesian3} The position of the camera.
     */
    EllipsoidalOccluder.prototype.getCameraPosition = function() {
        return this._cameraPosition;
    };

    var scratchCartesian = new Cartesian3(0.0, 0.0, 0.0);

    /**
     * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
     *
     * @memberof EllipsoidalOccluder
     *
     * @param {Cartesian3} occludee The point to test for visibility.
     *
     * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 2.5);
     * var ellipsoid = new Ellipsoid(1.0, 1.1, 0.9);
     * var occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);
     * var point = new Cartesian3(0, -3, -3);
     * occluder.isPointVisible(point); //returns true
     */
    EllipsoidalOccluder.prototype.isPointVisible = function(occludee) {
        var ellipsoid = this._ellipsoid;
        var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);
        return this.isScaledSpacePointVisible(occludeeScaledSpacePosition);
    };

    /**
     * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the
     * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid
     * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.
     *
     * @memberof EllipsoidalOccluder
     *
     * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.
     *
     * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 2.5);
     * var ellipsoid = new Ellipsoid(1.0, 1.1, 0.9);
     * var occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);
     * var point = new Cartesian3(0, -3, -3);
     * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);
     * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true
     */
    EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function(occludeeScaledSpacePosition) {
        // Based on Cozzi and Stoner's paper, "GPU Ray Casting of Virtual Globes Supplement"
        var q = this._cameraPositionInScaledSpace;
        var wMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;
        var b = Cartesian3.subtract(occludeeScaledSpacePosition, q, scratchCartesian);
        var d = -b.dot(q);
        return d < wMagnitudeSquared || d * d / b.magnitudeSquared() < wMagnitudeSquared;
    };

    return EllipsoidalOccluder;
});
/*global define*/
define('Core/Occluder',[
        './defaultValue',
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Visibility',
        './Ellipsoid',
        './BoundingSphere'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Visibility,
        Ellipsoid,
        BoundingSphere) {
    

    /**
     * Creates an Occluder derived from an object's position and radius, as well as the camera position.
     * The occluder can be used to determine whether or not other objects are visible or hidden behind the
     * visible horizon defined by the occluder and camera position.
     *
     * @alias Occluder
     *
     * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
     * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.
     *
     * @exception {DeveloperError} <code>occluderBoundingSphere</code> is required.
     * @exception {DeveloperError} <code>cameraPosition</code> is required.
     *
     * @constructor
     *
     * @example
     * // Construct an occluder one unit away from the origin with a radius of one.
     * var cameraPosition = new Cartesian3.ZERO;
     * var occluderBoundingSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 1);
     * var occluder = new Occluder(occluderBoundingSphere, cameraPosition);
     */
    var Occluder = function(occluderBoundingSphere, cameraPosition) {
        if (!occluderBoundingSphere) {
            throw new DeveloperError('occluderBoundingSphere is required.');
        }

        if (!cameraPosition) {
            throw new DeveloperError('camera position is required.');
        }

        this._occluderPosition = occluderBoundingSphere.center.clone();
        this._occluderRadius = occluderBoundingSphere.radius;

        this._horizonDistance = 0.0;
        this._horizonPlaneNormal = undefined;
        this._horizonPlanePosition = undefined;
        this._cameraPosition = undefined;

        // setCameraPosition fills in the above values
        this.setCameraPosition(cameraPosition);
    };

    /**
     * Returns the position of the occluder.
     *
     * @memberof Occluder
     *
     * @return {Cartesian3} The position of the occluder.
     */
    Occluder.prototype.getPosition = function() {
        return this._occluderPosition;
    };

    /**
     * Returns the radius of the occluder.
     *
     * @return {Number} The radius of the occluder.
     */
    Occluder.prototype.getRadius = function() {
        return this._occluderRadius;
    };

    /**
     * Sets the position of the camera.
     *
     * @param {Cartesian3} cameraPosition The new position of the camera.
     */
    Occluder.prototype.setCameraPosition = function(cameraPosition) {
        cameraPosition = Cartesian3.clone(cameraPosition);

        var cameraToOccluderVec = this._occluderPosition.subtract(cameraPosition);
        var invCameraToOccluderDistance = cameraToOccluderVec.magnitudeSquared();
        var occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;

        var horizonDistance;
        var horizonPlaneNormal;
        var horizonPlanePosition;
        if (invCameraToOccluderDistance > occluderRadiusSqrd) {
            horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);
            invCameraToOccluderDistance = 1.0 / Math.sqrt(invCameraToOccluderDistance);
            horizonPlaneNormal = cameraToOccluderVec.multiplyByScalar(invCameraToOccluderDistance);
            var nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;
            horizonPlanePosition = cameraPosition.add(horizonPlaneNormal.multiplyByScalar(nearPlaneDistance));
        } else {
            horizonDistance = Number.MAX_VALUE;
        }

        this._horizonDistance = horizonDistance;
        this._horizonPlaneNormal = horizonPlaneNormal;
        this._horizonPlanePosition = horizonPlanePosition;
        this._cameraPosition = cameraPosition;
    };

    var tempVecScratch = new Cartesian3(0.0, 0.0, 0.0);

    /**
     * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
     *
     * @memberof Occluder
     *
     * @param {Cartesian3} occludee The point surrounding the occludee object.
     *
     * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var littleSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 0.25);
     * var occluder = new Occluder(littleSphere, cameraPosition);
     * var point = new Cartesian3(0, 0, -3);
     * occluder.isPointVisible(point); //returns true
     *
     * @see Occluder#getVisibility
     */
     Occluder.prototype.isPointVisible = function(occludee) {
         if (this._horizonDistance !== Number.MAX_VALUE) {
             var tempVec = Cartesian3.subtract(occludee, this._occluderPosition, tempVecScratch);
             var temp = this._occluderRadius;
             temp = tempVec.magnitudeSquared() - (temp * temp);
             if (temp > 0.0) {
                 temp = Math.sqrt(temp) + this._horizonDistance;
                 tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);
                 return temp * temp > tempVec.magnitudeSquared();
             }
         }
         return false;
     };

    /**
    * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.
    *
    * @memberof Occluder
    *
    * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.
    *
    * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
    *
    * @example
    * var cameraPosition = new Cartesian3(0, 0, 0);
    * var littleSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 0.25);
    * var occluder = new Occluder(littleSphere, cameraPosition);
    * var bigSphere = new BoundingSphere(new Cartesian3(0, 0, -3), 1);
    * occluder.isBoundingSphereVisible(bigSphere); //returns true
    *
    * @see Occluder#getVisibility
    */
    Occluder.prototype.isBoundingSphereVisible = function(occludee) {
        var occludeePosition = occludee.center.clone();
        var occludeeRadius = occludee.radius;

        if (this._horizonDistance !== Number.MAX_VALUE) {
            var tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempVecScratch);
            var temp = this._occluderRadius - occludeeRadius;
            temp = tempVec.magnitudeSquared() - (temp * temp);
            if (occludeeRadius < this._occluderRadius) {
                if (temp > 0.0) {
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);
                    return ((temp * temp) + (occludeeRadius * occludeeRadius)) > tempVec.magnitudeSquared();
                }
                return false;
            }

            // Prevent against the case where the occludee radius is larger than the occluder's; since this is
            // an uncommon case, the following code should rarely execute.
            if (temp > 0.0) {
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var tempVecMagnitudeSquared = tempVec.magnitudeSquared();
                var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;
                var occludeeRadiusSquared = occludeeRadius * occludeeRadius;
                if ((((this._horizonDistance * this._horizonDistance) + occluderRadiusSquared) * occludeeRadiusSquared) >
                    (tempVecMagnitudeSquared * occluderRadiusSquared)) {
                    // The occludee is close enough that the occluder cannot possible occlude the occludee
                    return true;
                }
                temp = Math.sqrt(temp) + this._horizonDistance;
                return ((temp * temp) + occludeeRadiusSquared) > tempVecMagnitudeSquared;
            }

            // The occludee completely encompasses the occluder
            return true;
        }

        return false;
    };

    /**
     * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occludeeBS
     *
     * @return {Enumeration} Visibility.NONE if the occludee is not visible,
     *                       Visibility.PARTIAL if the occludee is partially visible, or
     *                       Visibility.FULL if the occludee is fully visible.
     * @example
     * var sphere1 = new BoundingSphere(new Cartesian3(0, 0, -1.5), 0.5);
     * var sphere2 = new BoundingSphere(new Cartesian3(0, 0, -2.5), 0.5);
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluder = new Occluder(sphere1, cameraPosition);
     * occluder.getVisibility(sphere2); //returns Visibility.NONE
     *
     * @see Occluder#isVisible
     */
    Occluder.prototype.getVisibility = function(occludeeBS) {
        // If the occludee radius is larger than the occluders, this will return that
        // the entire ocludee is visible, even though that may not be the case, though this should
        // not occur too often.
        var occludeePosition = occludeeBS.center.clone();
        var occludeeRadius = occludeeBS.radius;

        if (occludeeRadius > this._occluderRadius) {
            return Visibility.FULL;
        }

        if (this._horizonDistance !== Number.MAX_VALUE) {
            // The camera is outside the occluder
            var tempVec = occludeePosition.subtract(this._occluderPosition);
            var temp = this._occluderRadius - occludeeRadius;
            var occluderToOccludeeDistSqrd = tempVec.magnitudeSquared();
            temp = occluderToOccludeeDistSqrd - (temp * temp);
            if (temp > 0.0) {
                // The occludee is not completely inside the occluder
                // Check to see if the occluder completely hides the occludee
                temp = Math.sqrt(temp) + this._horizonDistance;
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var cameraToOccludeeDistSqrd = tempVec.magnitudeSquared();
                if (((temp * temp) + (occludeeRadius * occludeeRadius)) < cameraToOccludeeDistSqrd) {
                    return Visibility.NONE;
                }

                // Check to see whether the occluder is fully or partially visible
                // when the occludee does not intersect the occluder
                temp = this._occluderRadius + occludeeRadius;
                temp = occluderToOccludeeDistSqrd - (temp * temp);
                if (temp > 0.0) {
                    // The occludee does not intersect the occluder.
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    return (cameraToOccludeeDistSqrd < ((temp * temp)) + (occludeeRadius * occludeeRadius)) ? Visibility.FULL : Visibility.PARTIAL;
                }

                //Check to see if the occluder is fully or partially visible when the occludee DOES
                //intersect the occluder
                tempVec = occludeePosition.subtract(this._horizonPlanePosition);
                return (tempVec.dot(this._horizonPlaneNormal) > -occludeeRadius) ? Visibility.PARTIAL : Visibility.FULL;
            }
        }
        return Visibility.NONE;
    };

    /**
     * Computes a point that can be used as the occludee position to the visibility functions.
     * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
     * an object that is used for visibility; however it is also possible to compute a point that if
     * seen/not seen would also indicate if an object is visible/not visible.  This function is better
     * called for objects that do not move relative to the occluder and is large, such as a chunk of
     * terrain.  You are better off not calling this and using the object's bounding sphere for objects
     * such as a satellite or ground vehicle.
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
     * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.
     * @param {Array} positions List of altitude points on the horizon near the surface of the occluder.
     *
     * @exception {DeveloperError} <code>positions</code> is a required, non-empty array.
     * @exception {DeveloperError} <code>occluderBoundingSphere</code> is required.
     * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.
     *
     * @return {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluderBoundingSphere = new BoundingSphere(new Cartesian3(0, 0, -8), 2);
     * var occluder = new Occluder(occluderBoundingSphere, cameraPosition);
     * var positions = [new Cartesian3(-0.25, 0, -5.3), new Cartesian3(0.25, 0, -5.3)];
     * var tileOccluderSphere = BoundingSphere.fromPoints(positions);
     * var occludeePosition = tileOccluderSphere.center;
     * var occludeePt = occluder.getOccludeePoint(occluderBoundingSphere, occludeePosition, positions);
     *
     */
    Occluder.getOccludeePoint = function(occluderBoundingSphere, occludeePosition, positions) {
        // Validate input data
        if (!occluderBoundingSphere) {
            throw new DeveloperError('occluderBoundingSphere is required.');
        }

        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        if (positions.length === 0) {
            throw new DeveloperError('positions must contain at least one element');
        }

        var occludeePos = Cartesian3.clone(occludeePosition);
        var occluderPosition = occluderBoundingSphere.center.clone();
        var occluderRadius = occluderBoundingSphere.radius;
        var numPositions = positions.length;

        if (occluderPosition.equals(occludeePosition)) {
            throw new DeveloperError('occludeePosition must be different than occluderBoundingSphere.center');
        }

        // Compute a plane with a normal from the occluder to the occludee position.
        var occluderPlaneNormal = occludeePos.subtract(occluderPosition).normalize();
        var occluderPlaneD = -(occluderPlaneNormal.dot(occluderPosition));

        //For each position, determine the horizon intersection. Choose the position and intersection
        //that results in the greatest angle with the occcluder plane.
        var aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);
        var dot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);
        if (!dot) {
            //The position is inside the mimimum radius, which is invalid
            return undefined;
        }
        var tempDot;
        for ( var i = 1; i < numPositions; ++i) {
            tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);
            if (!tempDot) {
                //The position is inside the minimum radius, which is invalid
                return undefined;
            }
            if (tempDot < dot) {
                dot = tempDot;
            }
        }
        //Verify that the dot is not near 90 degress
        if (dot < 0.00174532836589830883577820272085) {
            return undefined;
        }

        var distance = occluderRadius / dot;
        return occluderPosition.add(occluderPlaneNormal.multiplyByScalar(distance));
    };

    var computeOccludeePointFromExtentScratch = [];
    /**
     * Computes a point that can be used as the occludee position to the visibility functions from an extent.
     *
     * @memberof Occluder
     *
     * @param {Extent} extent The extent used to create a bounding sphere.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the extent.
     *
     * @exception {DeveloperError} extent is required.
     *
     * @return {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     */
    Occluder.computeOccludeePointFromExtent = function(extent, ellipsoid) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        var positions = extent.subsample(ellipsoid, computeOccludeePointFromExtentScratch);
        var bs = BoundingSphere.fromPoints(positions);

        // TODO: get correct ellipsoid center
        var ellipsoidCenter = Cartesian3.ZERO;
        if (!ellipsoidCenter.equals(bs.center)) {
            return Occluder.getOccludeePoint(new BoundingSphere(ellipsoidCenter, ellipsoid.getMinimumRadius()), bs.center, positions);
        }

        return undefined;
    };

    Occluder._anyRotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD) {
        var tempVec0 = occluderPlaneNormal.clone().abs();
        var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;
        if (((majorAxis === 0) && (tempVec0.z > tempVec0.x)) || ((majorAxis === 1) && (tempVec0.z > tempVec0.y))) {
            majorAxis = 2;
        }
        var tempVec1 = new Cartesian3();
        if (majorAxis === 0) {
            tempVec0.x = occluderPosition.x;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.UNIT_X;
        } else if (majorAxis === 1) {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.UNIT_Y;
        } else {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z;
            tempVec1 = Cartesian3.UNIT_Z;
        }
        var u = ((occluderPlaneNormal.dot(tempVec0)) + occluderPlaneD) / -(occluderPlaneNormal.dot(tempVec1));
        return ((tempVec0.add(tempVec1.multiplyByScalar(u))).subtract(occluderPosition)).normalize();
    };

    Occluder._rotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {
        //Determine the angle between the occluder plane normal and the position direction
        var positionDirection = position.subtract(occluderPosition);
        positionDirection = positionDirection.normalize();
        if (occluderPlaneNormal.dot(positionDirection) < 0.99999998476912904932780850903444) {
            var crossProduct = occluderPlaneNormal.cross(positionDirection);
            var length = crossProduct.magnitude();
            if (length > CesiumMath.EPSILON13) {
                return crossProduct.normalize();
            }
        }
        //The occluder plane normal and the position direction are colinear. Use any
        //vector in the occluder plane as the rotation vector
        return anyRotationVector;
    };

    Occluder._horizonToPlaneNormalDotProduct = function(occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {
        var pos = Cartesian3.clone(position);
        var occluderPosition = occluderBS.center.clone();
        var occluderRadius = occluderBS.radius;

        //Verify that the position is outside the occluder
        var positionToOccluder = occluderPosition.subtract(pos);
        var occluderToPositionDistanceSquared = positionToOccluder.magnitudeSquared();
        var occluderRadiusSquared = occluderRadius * occluderRadius;
        if (occluderToPositionDistanceSquared < occluderRadiusSquared) {
            return false;
        }

        //Horizon parameters
        var horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;
        var horizonDistance = Math.sqrt(horizonDistanceSquared);
        var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);
        var invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;
        var cosTheta = horizonDistance * invOccluderToPositionDistance;
        var horizonPlaneDistance = cosTheta * horizonDistance;
        positionToOccluder = positionToOccluder.normalize();
        var horizonPlanePosition = pos.add(positionToOccluder.multiplyByScalar(horizonPlaneDistance));
        var horizonCrossDistance = Math.sqrt(horizonDistanceSquared - (horizonPlaneDistance * horizonPlaneDistance));

        //Rotate the position to occluder vector 90 degrees
        var tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, pos, anyRotationVector);
        var horizonCrossDirection = new Cartesian3(
                (tempVec.x * tempVec.x * positionToOccluder.x) + ((tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y) + ((tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z),
                ((tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x) + (tempVec.y * tempVec.y * positionToOccluder.y) + ((tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z),
                ((tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x) + ((tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y) + (tempVec.z * tempVec.z * positionToOccluder.z));
        horizonCrossDirection = horizonCrossDirection.normalize();

        //Horizon positions
        var offset = horizonCrossDirection.multiplyByScalar(horizonCrossDistance);
        tempVec = ((horizonPlanePosition.add(offset)).subtract(occluderPosition)).normalize();
        var dot0 = occluderPlaneNormal.dot(tempVec);
        tempVec = ((horizonPlanePosition.subtract(offset)).subtract(occluderPosition)).normalize();
        var dot1 = occluderPlaneNormal.dot(tempVec);
        return (dot0 < dot1) ? dot0 : dot1;
    };

    return Occluder;
});
/*global define*/
define('Core/HermiteSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian4',
        './TridiagonalSystemSolver'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian4,
        TridiagonalSystemSolver) {
    

    /**
     * A Hermite spline is a cubic interpolating spline. Positions, tangents, and times must be defined
     * for each control point. If no tangents are specified by the control points, the end and interior
     * tangents are generated, creating a natural cubic spline. If the only tangents specified are at
     * the end control points, the interior tangents will be generated as well, creating a clamped cubic
     * spline. Otherwise, it is assumed that each control point defines a tangent at that point.
     *
     * Natural and clamped cubic splines are in the class C<sup>2</sup>.
     *
     * @alias HermiteSpline
     * @constructor
     *
     * @param {Array} controlPoints An array, of at least length 3, of objects with <code>point</code>,
     * <code>time</code>, and <code>tangent</code> properties.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see CatmullRomSpline
     *
     * @example
     * // Example 1.
     * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // Example 2.
     * // Create a Catmull-Rom spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     *
     * // Add tangents
     * controlPoints[0].tangent = new Cartesian3(1125196, -161816, 270551);
     * for (var i = 1; i < controlPoints.length - 1; ++i) {
     *     controlPoints[i].tangent = controlPoints[i + 1].point.subtract(controlPoints[i - 1].point).multiplyByScalar(0.5);
     * }
     * controlPoints[controlPoints.length - 1].tangent = new Cartesian3(1165345, 112641, 47281);
     *
     * var spline = new HermiteSpline(controlPoints);
     */
    var HermiteSpline = function(controlPoints) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError('controlPoints is required. It must be an array with at least a length of 3.');
        }

        this._points = controlPoints;

        this._lastTimeIndex = 0;

        if (!this._points[0].tangent || !this._points[this._points.length - 1].tangent) {
            this._generateNatural();
        } else if (this._points[0].tangent && !this._points[1].tangent && this._points[this._points.length - 1].tangent && !this._points[this._points.length - 2].tangent) {
            this._generateClamped();
        }
    };

    HermiteSpline.hermiteCoefficientMatrix = new Matrix4(
             2.0, -3.0,  0.0,  1.0,
            -2.0,  3.0,  0.0,  0.0,
             1.0, -2.0,  1.0,  0.0,
             1.0, -1.0,  0.0,  0.0);

    HermiteSpline.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    HermiteSpline.prototype._generateClamped = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = d[0] = 1.0;
        u[0] = 0.0;
        r[0] = this._points[0].tangent;
        for (i = 1; i < l.length - 1; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        }
        l[i] = 0.0;
        u[i] = 1.0;
        d[i] = 4.0;
        r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        d[i + 1] = 1.0;
        r[i + 1] = this._points[i + 1].tangent;

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    HermiteSpline.prototype._generateNatural = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = u[0] = 1.0;
        d[0] = 2.0;
        r[0] = this._points[1].point.subtract(this._points[0].point).multiplyByScalar(3.0);
        for (i = 1; i < l.length; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        }
        d[i] = 2.0;
        r[i] = this._points[i].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    /**
     * Returns the array of control points.
     *
     * @memberof HermiteSpline
     * @return {Array} The array of control points.
     */
    HermiteSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof HermiteSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    HermiteSpline.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian4(0.0, u * u, u);
        timeVec.x = timeVec.y * u;

        var coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByPoint(timeVec);
        var p0 = this._points[i].point.multiplyByScalar(coefs.x);
        var p1 = this._points[i + 1].point.multiplyByScalar(coefs.y);
        var p2 = this._points[i].tangent.multiplyByScalar(coefs.z);
        var p3 = this._points[i + 1].tangent.multiplyByScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return HermiteSpline;
});

/*global define*/
define('Core/CatmullRomSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian3',
        './Cartesian4',
        './HermiteSpline'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian3,
        Cartesian4,
        HermiteSpline) {
    

    /**
     * A Catmull-Rom spline is a cubic spline where the tangent at control points,
     * except the first and last, are computed using the previous and next control points.
     * Catmull-Rom splines are in the class C<sup>1</sup>.
     *
     * @alias CatmullRomSpline
     * @constructor
     *
     * @param {Array} controlPoints The array of control points. Each element of the array should be an object with <code>point</code> and <code>time</code> properties.
     * @param {Cartesian3} firstTangent The tangent of the curve at the first control point.
     * If the tangent is not given, it will be estimated.
     * @param {Cartesian3} lastTangent The tangent of the curve at the last control point.
     * If the tangent is not given, it will be estimated.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see HermiteSpline
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     */
    var CatmullRomSpline = function(controlPoints, firstTangent, lastTangent) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError('controlPoints is required and must be an array of objects with point and time properties, with a length of at least 3.');
        }

        this._points = controlPoints;
        this._lastTimeIndex = 0;

        if (firstTangent) {
            this._ti = Cartesian3.clone(firstTangent);
        } else {
            var controlPoint0 = Cartesian3.clone(controlPoints[0].point);
            var controlPoint1 = Cartesian3.clone(controlPoints[1].point);
            var controlPoint2 = Cartesian3.clone(controlPoints[2].point);

            this._ti = controlPoint1
                           .multiplyByScalar(2.0)
                           .subtract(controlPoint2)
                           .subtract(controlPoint0)
                           .multiplyByScalar(0.5);
        }

        if (firstTangent) {
            this._to = Cartesian3.clone(lastTangent);
        } else {
            var n = controlPoints.length - 1;

            var controlPointn0 = Cartesian3.clone(controlPoints[n].point);
            var controlPointn1 = Cartesian3.clone(controlPoints[n - 1].point);
            var controlPointn2 = Cartesian3.clone(controlPoints[n - 2].point);

            this._to = controlPointn0
                           .subtract(controlPointn1.multiplyByScalar(2.0))
                           .add(controlPointn2)
                           .multiplyByScalar(0.5);
        }
    };

    CatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(
            -0.5,  1.0, -0.5,  0.0,
             1.5, -2.5,  0.0,  1.0,
            -1.5,  2.0,  0.5,  0.0,
             0.5, -0.5,  0.0,  0.0);

    /**
     * Returns the array of control points.
     *
     * @memberof CatmullRomSpline
     * @return {Array} The array of control points.
     */
    CatmullRomSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Returns the tangent of the first control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the first control point.
     *
     * @see CatmullRomSpline#getEndTangent
     */
    CatmullRomSpline.prototype.getStartTangent = function() {
        return this._ti;
    };

    /**
     * Returns the tangent of the last control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the last control point.
     *
     * @see CatmullRomSpline#getStartTangent
     */
    CatmullRomSpline.prototype.getEndTangent = function() {
        return this._to;
    };

    CatmullRomSpline.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof CatmullRomSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    CatmullRomSpline.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian3(0.0, u * u, u);
        timeVec.x = timeVec.y * u;

        var p0, p1, p2, p3, coefs;
        if (i === 0) {
            p0 = this._points[0].point;
            p1 = this._points[1].point;
            p2 = this._ti;
            p3 = this._points[2].point.subtract(p0).multiplyByScalar(0.5);
            coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByPoint(timeVec);
        } else if (i === this._points.length - 2) {
            p0 = this._points[i].point;
            p1 = this._points[i + 1].point;
            p2 = p1.subtract(this._points[i - 1].point).multiplyByScalar(0.5);
            p3 = this._to;
            coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByPoint(timeVec);
        } else {
            p0 = this._points[i - 1].point;
            p1 = this._points[i].point;
            p2 = this._points[i + 1].point;
            p3 = this._points[i + 2].point;
            coefs = CatmullRomSpline.catmullRomCoefficientMatrix.multiplyByPoint(timeVec);
        }
        p0 = p0.multiplyByScalar(coefs.x);
        p1 = p1.multiplyByScalar(coefs.y);
        p2 = p2.multiplyByScalar(coefs.z);
        p3 = p3.multiplyByScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return CatmullRomSpline;
});

/*global define*/
define('Core/Transforms',[
        './defaultValue',
        './DeveloperError',
        './Math',
        './Matrix3',
        './Matrix4',
        './Cartesian2',
        './Cartesian3',
        './Cartesian4',
        './TimeConstants',
        './Ellipsoid'
    ],
    function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Matrix3,
        Matrix4,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        TimeConstants,
        Ellipsoid) {
    

    var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
    var gmstConstant1 = 8640184.812866;
    var gmstConstant2 = 0.093104;
    var gmstConstant3 = -6.2E-6;
    var rateCoef = 1.1772758384668e-19;
    var wgs84WRPrecessing = 7.2921158553E-5;
    var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;

    var eastNorthUpToFixedFrameNormal = new Cartesian3();
    var eastNorthUpToFixedFrameTangent = new Cartesian3();
    var eastNorthUpToFixedFrameBitangent = new Cartesian3();

    var northEastDownToFixedFrameNormal = new Cartesian3();
    var northEastDownToFixedFrameTangent = new Cartesian3();
    var northEastDownToFixedFrameBitangent = new Cartesian3();

    var pointToWindowCoordinatesTemp = new Cartesian4();

    /**
     * Contains functions for transforming positions to various reference frames.
     * @exports Transforms
     */
    var Transforms = {
        /**
         * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
         * centered at the provided origin to the provided ellipsoid's fixed reference frame.
         * The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local east direction.</li>
         * <li>The <code>y</code> axis points in the local north direction.</li>
         * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @exception {DeveloperError} origin is required.
         *
         * @example
         * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.WGS84;
         * var center = ellipsoid.cartographicToCartesian(Cartographic.ZERO);
         * var transform = Transforms.eastNorthUpToFixedFrame(center);
         */
        eastNorthUpToFixedFrame : function(origin, ellipsoid, result) {
            if (typeof origin === 'undefined') {
                throw new DeveloperError('origin is required.');
            }

            // If x and y are zero, assume origin is at a pole, which is a special case.
            if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
                CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
                var sign = CesiumMath.sign(origin.z);
                if (typeof result === 'undefined') {
                    return new Matrix4(
                            0.0, -sign,  0.0, origin.x,
                            1.0,   0.0,  0.0, origin.y,
                            0.0,   0.0, sign, origin.z,
                            0.0,   0.0,  0.0, 1.0);
                }
                result[0] = 0.0;
                result[1] = 1.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = -sign;
                result[5] = 0.0;
                result[6] = 0.0;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 0.0;
                result[10] = sign;
                result[11] = 0.0;
                result[12] = origin.x;
                result[13] = origin.y;
                result[14] = origin.z;
                result[15] = 1.0;
                return result;
            }

            var normal = eastNorthUpToFixedFrameNormal;
            var tangent  = eastNorthUpToFixedFrameTangent;
            var bitangent = eastNorthUpToFixedFrameBitangent;

            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            ellipsoid.geodeticSurfaceNormal(origin, normal);

            tangent.x = -origin.y;
            tangent.y = origin.x;
            tangent.z = 0.0;
            Cartesian3.normalize(tangent, tangent);

            normal.cross(tangent, bitangent);

            if (typeof result === 'undefined') {
                return new Matrix4(
                        tangent.x, bitangent.x, normal.x, origin.x,
                        tangent.y, bitangent.y, normal.y, origin.y,
                        tangent.z, bitangent.z, normal.z, origin.z,
                        0.0,       0.0,         0.0,      1.0);
            }
            result[0] = tangent.x;
            result[1] = tangent.y;
            result[2] = tangent.z;
            result[3] = 0.0;
            result[4] = bitangent.x;
            result[5] = bitangent.y;
            result[6] = bitangent.z;
            result[7] = 0.0;
            result[8] = normal.x;
            result[9] = normal.y;
            result[10] = normal.z;
            result[11] = 0.0;
            result[12] = origin.x;
            result[13] = origin.y;
            result[14] = origin.z;
            result[15] = 1.0;
            return result;
        },

        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
         * centered at the provided origin to the provided ellipsoid's fixed reference frame.
         * The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local north direction.</li>
         * <li>The <code>y</code> axis points in the local east direction.</li>
         * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @exception {DeveloperError} origin is required.
         *
         * @example
         * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.WGS84;
         * var center = ellipsoid.cartographicToCartesian(Cartographic.ZERO);
         * var transform = Transforms.northEastDownToFixedFrame(center);
         */
        northEastDownToFixedFrame : function(origin, ellipsoid, result) {
            if (typeof origin === 'undefined') {
                throw new DeveloperError('origin is required.');
            }

            if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
                CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume origin is at a pole.
                var sign = CesiumMath.sign(origin.z);
                if (typeof result === 'undefined') {
                    return new Matrix4(
                      -sign, 0.0,   0.0, origin.x,
                        0.0, 1.0,   0.0, origin.y,
                        0.0, 0.0, -sign, origin.z,
                        0.0, 0.0,   0.0, 1.0);
                }
                result[0] = -sign;
                result[1] = 0.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = 0.0;
                result[5] = 1.0;
                result[6] = 0.0;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 0.0;
                result[10] = -sign;
                result[11] = 0.0;
                result[12] = origin.x;
                result[13] = origin.y;
                result[14] = origin.z;
                result[15] = 1.0;
                return result;
            }

            var normal = northEastDownToFixedFrameNormal;
            var tangent = northEastDownToFixedFrameTangent;
            var bitangent = northEastDownToFixedFrameBitangent;

            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            ellipsoid.geodeticSurfaceNormal(origin, normal);

            tangent.x = -origin.y;
            tangent.y = origin.x;
            tangent.z = 0.0;
            Cartesian3.normalize(tangent, tangent);

            normal.cross(tangent, bitangent);

            if (typeof result === 'undefined') {
                return new Matrix4(
                        bitangent.x, tangent.x, -normal.x, origin.x,
                        bitangent.y, tangent.y, -normal.y, origin.y,
                        bitangent.z, tangent.z, -normal.z, origin.z,
                        0.0,       0.0,         0.0,      1.0);
            }
            result[0] = bitangent.x;
            result[1] = bitangent.y;
            result[2] = bitangent.z;
            result[3] = 0.0;
            result[4] = tangent.x;
            result[5] = tangent.y;
            result[6] = tangent.z;
            result[7] = 0.0;
            result[8] = -normal.x;
            result[9] = -normal.y;
            result[10] = -normal.z;
            result[11] = 0.0;
            result[12] = origin.x;
            result[13] = origin.y;
            result[14] = origin.z;
            result[15] = 1.0;
            return result;
        },

        /**
         * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
         * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
         *
         * @param {JulianDate} date The time at which to compute the rotation matrix.
         * @param {Matrix3} [result] The object onto which to store the result.
         * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
         *
         * @exception {DeveloperError} date is required.
         *
         * @example
         * //Set the view to in the inertial frame.
         * scene.setAnimation(function() {
         *     var time = new JulianDate();
         *     scene.getCamera().transform = Matrix4.fromRotationTranslation(Transforms.computeTemeToPseudoFixedMatrix(time), Cartesian3.ZERO)});;
         * });
         */
        computeTemeToPseudoFixedMatrix : function (date, result) {
            if (typeof date === 'undefined') {
                throw new DeveloperError('date is required.');
            }

            // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.
            // We do not want to use the function like convertTaiToUtc in JulianDate because
            // we explicitly do not want to fail when inside the leap second.

            var dateInUtc = date.addSeconds(-date.getTaiMinusUtc());
            var utcDayNumber = dateInUtc.getJulianDayNumber();
            var utcSecondsIntoDay = dateInUtc.getSecondsOfDay();

            var t;
            var diffDays = utcDayNumber - 2451545;
            if (utcSecondsIntoDay >= 43200.0) {
                t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            } else {
                t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            }

            var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
            var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
            var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
            var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
            var gha = angle + (ratio * secondsSinceMidnight);
            var cosGha = Math.cos(gha);
            var sinGha = Math.sin(gha);

            if (typeof result === 'undefined') {
                return new Matrix3(cosGha, sinGha, 0.0,
                                  -sinGha, cosGha, 0.0,
                                      0.0,    0.0, 1.0);
            }
            result[0] = cosGha;
            result[1] = -sinGha;
            result[2] = 0.0;
            result[3] = sinGha;
            result[4] = cosGha;
            result[5] = 0.0;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 1.0;
            return result;
        },

        /**
         * Transform a point from model coordinates to window coordinates.
         *
         * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
         * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
         * @param {Cartesian3} point The point to transform.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
         *
         * @exception {DeveloperError} modelViewProjectionMatrix is required.
         * @exception {DeveloperError} viewportTransformation is required.
         * @exception {DeveloperError} point is required.
         *
         * @see UniformState#getModelViewProjection
         * @see czm_modelViewProjection
         * @see UniformState#getViewportTransformation
         * @see czm_viewportTransformation
         */
        pointToWindowCoordinates : function (modelViewProjectionMatrix, viewportTransformation, point, result) {
            if (typeof modelViewProjectionMatrix === 'undefined') {
                throw new DeveloperError('modelViewProjectionMatrix is required.');
            }

            if (typeof viewportTransformation === 'undefined') {
                throw new DeveloperError('viewportTransformation is required.');
            }

            if (typeof point === 'undefined') {
                throw new DeveloperError('point is required.');
            }

            var tmp = pointToWindowCoordinatesTemp;

            Matrix4.multiplyByPoint(modelViewProjectionMatrix, point, tmp);
            Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
            Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
            return Cartesian2.fromCartesian4(tmp, result);
        }
    };

    return Transforms;
});

/*global define*/
define('Core/EllipsoidTangentPlane',[
        './defaultValue',
        './DeveloperError',
        './Transforms',
        './AxisAlignedBoundingBox',
        './IntersectionTests',
        './Cartesian2',
        './Cartesian3',
        './Ellipsoid',
        './Ray'
    ], function(
        defaultValue,
        DeveloperError,
        Transforms,
        AxisAlignedBoundingBox,
        IntersectionTests,
        Cartesian2,
        Cartesian3,
        Ellipsoid,
        Ray) {
    

    /**
     * A plane tangent to the provided ellipsoid at the provided origin.
     * If origin is not on the surface of the ellipsoid, it's surface projection will be used.
     * @alias EllipsoidTangentPlane
     * @constructor
     *
     * @param {Ellipsoid} ellipsoid The ellipsoid to use.
     * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.
     *
     * @exception {DeveloperError} origin is required.
     */
    var EllipsoidTangentPlane = function(origin, ellipsoid) {
        if (typeof origin === 'undefined') {
            throw new DeveloperError('origin is required.');
        }

        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

        origin = ellipsoid.scaleToGeodeticSurface(origin);
        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);
        this._ellipsoid = ellipsoid;
        this._origin = Cartesian3.clone(origin);
        this._xAxis = Cartesian3.fromCartesian4(eastNorthUp.getColumn(0));
        this._yAxis = Cartesian3.fromCartesian4(eastNorthUp.getColumn(1));
        this._normal = Cartesian3.fromCartesian4(eastNorthUp.getColumn(2));
        this._distance = -Cartesian3.dot(origin, origin); //The shortest distance from the origin to the plane.
    };

    var tmp = new AxisAlignedBoundingBox();
    /**
     * Creates a new instance from the provided ellipsoid and the center
     * point of the provided Cartesians.
     * @memberof EllipsoidTangentPlane
     *
     * @param {Ellipsoid} ellipsoid The ellipsoid to use.
     * @param {Cartesian3} cartesians The list of positions surrounding the center point.
     *
     * @exception {DeveloperError} cartesians is required.
     */
    EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {
        if (typeof cartesians === 'undefined') {
            throw new DeveloperError('cartesians is required.');
        }

        var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);
        return new EllipsoidTangentPlane(box.center, ellipsoid);
    };

    /**
     * @memberof EllipsoidTangentPlane
     * @returns {Ellipsoid} Gets the ellipsoid.
     */
    EllipsoidTangentPlane.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * @memberof EllipsoidTangentPlane
     * @returns {Cartesian3} Gets the origin.
     */
    EllipsoidTangentPlane.prototype.getOrigin = function() {
        return this._origin;
    };

    var projectPointOntoPlaneRay = new Ray();
    var projectPointOntoPlaneCartesian3 = new Cartesian3();

    /**
     * Computes the projection of the provided 3D position onto the 2D plane.
     * @memberof EllipsoidTangentPlane
     *
     * @param {Cartesian3} cartesian The point to project.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required.');
        }

        var ray = projectPointOntoPlaneRay;
        ray.origin = cartesian;
        Cartesian3.normalize(cartesian, ray.direction);

        var intersectionPoint = IntersectionTests.rayPlane(ray, this._normal, this._distance, projectPointOntoPlaneCartesian3);

        if (typeof intersectionPoint !== 'undefined') {
            var v = intersectionPoint.subtract(this._origin, intersectionPoint);
            var x = this._xAxis.dot(v);
            var y = this._yAxis.dot(v);

            if (typeof result === 'undefined') {
                return new Cartesian2(x, y);
            }
            result.x = x;
            result.y = y;
            return result;
        }
        return undefined;
    };

    /**
     * Computes the projection of the provided 3D positions onto the 2D plane.
     * @memberof EllipsoidTangentPlane
     *
     * @param {Array} cartesians The array of points to project.
     * @param {Array} [result] The array of Cartesian2 instances onto which to store results.
     * @return {Array} The modified result parameter or a new array of Cartesian2 instances if none was provided.
     *
     * @exception {DeveloperError} cartesians is required.
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {
        if (typeof cartesians === 'undefined') {
            throw new DeveloperError('cartesians is required.');
        }

        if (typeof result === 'undefined') {
            result = [];
        }

        var count = 0;
        var length = cartesians.length;
        for ( var i = 0; i < length; i++) {
            var p = this.projectPointOntoPlane(cartesians[i], result[count]);
            if (typeof p !== 'undefined') {
                result[count] = p;
                count++;
            }
        }
        result.length = count;
        return result;
    };


    var projectPointsOntoEllipsoidScratch = new Cartesian3();
    /**
     * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
     * @memberof EllipsoidTangentPlane
     *
     * @param {Array} cartesians The array of points to project.
     * @param {Array} [result] The array of Cartesian3 instances onto which to store results.
     * @return {Array} The modified result parameter or a new array of Cartesian3 instances if none was provided.
     *
     * @exception {DeveloperError} cartesians is required.
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {
        if (typeof cartesians === 'undefined') {
            throw new DeveloperError('cartesians is required.');
        }

        var length = cartesians.length;
        if (typeof result === 'undefined') {
            result = new Array(length);
        } else {
            result.length = length;
        }

        var ellipsoid = this._ellipsoid;
        var origin = this._origin;
        var xAxis = this._xAxis;
        var yAxis = this._yAxis;
        var tmp = projectPointsOntoEllipsoidScratch;

        for ( var i = 0; i < length; ++i) {
            var position = cartesians[i];
            xAxis.multiplyByScalar(position.x, tmp);
            var point = result[i] = Cartesian3.add(origin, tmp, result[i]);
            yAxis.multiplyByScalar(position.y, tmp);
            Cartesian3.add(point, tmp, point);
            ellipsoid.scaleToGeocentricSurface(point, point);
        }

        return result;
    };

    return EllipsoidTangentPlane;
});
/*global define*/
define('Core/Quaternion',[
        './Cartesian3',
        './defaultValue',
        './DeveloperError',
        './freezeObject',
        './Math',
        './Matrix3'
    ], function(
        Cartesian3,
        defaultValue,
        DeveloperError,
        freezeObject,
        CesiumMath,
        Matrix3) {
    

    /**
     * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
     * @alias Quaternion
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     */
    var Quaternion = function(x, y, z, w) {
        /**
         * The X component.
         * @type Number
         */
        this.x = defaultValue(x, 0.0);

        /**
         * The Y component.
         * @type Number
         */
        this.y = defaultValue(y, 0.0);

        /**
         * The Z component.
         * @type Number
         */
        this.z = defaultValue(z, 0.0);

        /**
         * The W component.
         * @type Number
         */
        this.w = defaultValue(w, 0.0);
    };

    var fromAxisAngleScratch;

    /**
     * Computes a quaternion representing a rotation around an axis.
     * @memberof Quaternion
     *
     * @param {Cartesian3} axis The axis of rotation.
     * @param {Number} angle The angle in radians to rotate around the axis.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} axis is required.
     * @exception {DeveloperError} angle is required and must be a number.
     */
    Quaternion.fromAxisAngle = function(axis, angle, result) {
        if (typeof axis === 'undefined') {
            throw new DeveloperError('axis is required.');
        }
        if (typeof angle !== 'number') {
            throw new DeveloperError('angle is required and must be a number.');
        }

        var halfAngle = angle / 2.0;
        var s = Math.sin(halfAngle);
        fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);

        var x = fromAxisAngleScratch.x * s;
        var y = fromAxisAngleScratch.y * s;
        var z = fromAxisAngleScratch.z * s;
        var w = Math.cos(halfAngle);
        if (typeof result === 'undefined') {
            return new Quaternion(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    var fromRotationMatrixNext = [1, 2, 0];
    var fromRotationMatrixQuat = new Array(3);
    /**
     * Computes a Quaternion from the provided Matrix3 instance.
     * @memberof Quaternion
     *
     * @param {Matrix3} matrix The rotation matrix.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} matrix is required.
     *
     * @see Matrix3.fromQuaternion
     */
    Quaternion.fromRotationMatrix = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        var root;
        var x;
        var y;
        var z;
        var w;

        var m00 = matrix[Matrix3.COLUMN0ROW0];
        var m11 = matrix[Matrix3.COLUMN1ROW1];
        var m22 = matrix[Matrix3.COLUMN2ROW2];
        var trace = m00 + m11 + m22;

        if (trace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            root = Math.sqrt(trace + 1.0); // 2w
            w = 0.5 * root;
            root = 0.5 / root; // 1/(4w)

            x = (matrix[Matrix3.COLUMN2ROW1] - matrix[Matrix3.COLUMN1ROW2]) * root;
            y = (matrix[Matrix3.COLUMN0ROW2] - matrix[Matrix3.COLUMN2ROW0]) * root;
            z = (matrix[Matrix3.COLUMN1ROW0] - matrix[Matrix3.COLUMN0ROW1]) * root;
        } else {
            // |w| <= 1/2
            var next = fromRotationMatrixNext;

            var i = 0;
            if (m11 > m00) {
                i = 1;
            }
            if (m22 > m00 && m22 > m11) {
                i = 2;
            }
            var j = next[i];
            var k = next[j];

            root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);

            var quat = fromRotationMatrixQuat;
            quat[i] = 0.5 * root;
            root = 0.5 / root;
            w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
            quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
            quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;

            x = quat[0];
            y = quat[1];
            z = quat[2];
        }

        if (typeof result === 'undefined') {
            return new Quaternion(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Duplicates a Quaternion instance.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to duplicate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.clone = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }

        if (typeof result === 'undefined') {
            return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        }

        result.x = quaternion.x;
        result.y = quaternion.y;
        result.z = quaternion.z;
        result.w = quaternion.w;
        return result;
    };

    /**
     * Computes the conjugate of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to conjugate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.conjugate = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(-quaternion.x, -quaternion.y, -quaternion.z, quaternion.w);
        }
        result.x = -quaternion.x;
        result.y = -quaternion.y;
        result.z = -quaternion.z;
        result.w = quaternion.w;
        return result;
    };

    /**
     * Computes magnitude squared for the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to conjugate.
     * @return {Number} The magnitude squared.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.magnitudeSquared = function(quaternion) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
    };

    /**
     * Computes magnitude for the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to conjugate.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.magnitude = function(quaternion) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
    };

    /**
     * Computes the normalized form of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to normalize.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.normalize = function(quaternion, result) {
        var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
        var x = quaternion.x * inverseMagnitude;
        var y = quaternion.y * inverseMagnitude;
        var z = quaternion.z * inverseMagnitude;
        var w = quaternion.w * inverseMagnitude;

        if (typeof result === 'undefined') {
            return new Quaternion(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes the inverse of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to normalize.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.inverse = function(quaternion, result) {
        var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
        result = Quaternion.conjugate(quaternion, result);
        return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
    };

    /**
     * Computes the componentwise sum of two quaternions.
     * @memberof Quaternion
     *
     * @param {Quaternion} left The first quaternion.
     * @param {Quaternion} right The second quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Quaternion.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
        result.w = left.w + right.w;
        return result;
    };

    /**
     * Computes the componentwise difference of two quaternions.
     * @memberof Quaternion
     *
     * @param {Quaternion} left The first quaternion.
     * @param {Quaternion} right The second quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Quaternion.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        result.z = left.z - right.z;
        result.w = left.w - right.w;
        return result;
    };

    /**
     * Negates the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to be negated.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.negate = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
        }
        result.x = -quaternion.x;
        result.y = -quaternion.y;
        result.z = -quaternion.z;
        result.w = -quaternion.w;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two quaternions.
     * @memberof Quaternion
     *
     * @param {Quaternion} left The first quaternion.
     * @param {Quaternion} right The second quaternion.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Quaternion.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    };


    /**
     * Computes the product of two quaternions.
     * @memberof Quaternion
     *
     * @param {Quaternion} left The first quaternion.
     * @param {Quaternion} right The second quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Quaternion.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        var leftX = left.x;
        var leftY = left.y;
        var leftZ = left.z;
        var leftW = left.w;

        var rightX = right.x;
        var rightY = right.y;
        var rightZ = right.z;
        var rightW = right.w;

        var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
        var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
        var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
        var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;

        if (typeof result === 'undefined') {
            return new Quaternion(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Multiplies the provided quaternion componentwise by the provided scalar.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Quaternion.multiplyByScalar = function(quaternion, scalar, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(quaternion.x * scalar,  quaternion.y * scalar, quaternion.z * scalar, quaternion.w * scalar);
        }
        result.x = quaternion.x * scalar;
        result.y = quaternion.y * scalar;
        result.z = quaternion.z * scalar;
        result.w = quaternion.w * scalar;
        return result;
    };

    /**
     * Divides the provided quaternion componentwise by the provided scalar.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Quaternion.divideByScalar = function(quaternion, scalar, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Quaternion(quaternion.x / scalar, quaternion.y / scalar, quaternion.z / scalar, quaternion.w / scalar);
        }
        result.x = quaternion.x / scalar;
        result.y = quaternion.y / scalar;
        result.z = quaternion.z / scalar;
        result.w = quaternion.w / scalar;
        return result;
    };

    /**
     * Computes the axis of rotation of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to use.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.getAxis = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }

        var w = quaternion.w;
        if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
            if (typeof result === 'undefined') {
                return new Cartesian3(0.0, 0.0, 0.0);
            }
            result.x = result.y = result.z = 0;
            return result;
        }

        var scalar = 1.0 / Math.sqrt(1.0 - (w * w));
        if (typeof result === 'undefined') {
            return new Cartesian3(quaternion.x * scalar, quaternion.y * scalar, quaternion.z * scalar);
        }
        result.x = quaternion.x * scalar;
        result.y = quaternion.y * scalar;
        result.z = quaternion.z * scalar;
        return result;
    };

    /**
     * Computes the angle of rotation of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} quaternion The quaternion to use.
     * @return {Number} The angle of rotation.
     *
     * @exception {DeveloperError} quaternion is required.
     */
    Quaternion.getAngle = function(quaternion) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }

        if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
            return 0.0;
        }
        return 2.0 * Math.acos(quaternion.w);
    };

    var lerpScratch;
    /**
     * Computes the linear interpolation or extrapolation at t using the provided quaternions.
     * @memberof Quaternion
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Quaternion.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
        result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
        return Quaternion.add(lerpScratch, result, result);
    };

    var slerpEndNegated;
    var slerpScaledP;
    var slerpScaledR;
    /**
     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
     * @memberof Quaternion
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Quaternion.slerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }

        var dot = Quaternion.dot(start, end);

        // The angle between start must be acute. Since q and -q represent
        // the same rotation, negate q to get the acute angle.
        var r = end;
        if (dot < 0.0) {
            dot = -dot;
            r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
        }

        // dot > 0, as the dot product approaches 1, the angle between the
        // quaternions vanishes. use linear interpolation.
        if (1.0 - dot < CesiumMath.EPSILON6) {
            return Quaternion.lerp(start, r, t);
        }

        var theta = Math.acos(dot);
        slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
        slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
        result = Quaternion.add(slerpScaledP, slerpScaledR, result);
        return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
    };

    /**
     * Compares the provided quaternions componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Quaternion
     *
     * @param {Quaternion} [left] The first quaternion.
     * @param {Quaternion} [right] The second quaternion.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Quaternion.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.z === right.z) &&
                (left.w === right.w));
    };

    /**
     * Compares the provided quaternions componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Quaternion
     *
     * @param {Quaternion} [left] The first quaternion.
     * @param {Quaternion} [right] The second quaternion.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Quaternion.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon) &&
                (Math.abs(left.z - right.z) <= epsilon) &&
                (Math.abs(left.w - right.w) <= epsilon));
    };

    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
     * @memberof Quaternion
     */
    Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
     * @memberof Quaternion
     */
    Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));

    /**
     * Duplicates this Quaternion instance.
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     */
    Quaternion.prototype.clone = function(result) {
        return Quaternion.clone(this, result);
    };

    /**
     * Computes the conjugate of this quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     */
    Quaternion.prototype.conjugate = function(result) {
        return Quaternion.conjugate(this, result);
    };

    /**
     * Computes magnitude squared for this quaternion.
     * @memberof Quaternion
     *
     * @return {Number} The magnitude squared.
     */
    Quaternion.prototype.magnitudeSquared = function() {
        return Quaternion.magnitudeSquared(this);
    };

    /**
     * Computes magnitude for this quaternion.
     * @memberof Quaternion
     *
     * @return {Number} The magnitude.
     */
    Quaternion.prototype.magnitude = function() {
        return Quaternion.magnitude(this);
    };

    /**
     * Computes the normalized form of this quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     */
    Quaternion.prototype.normalize = function(result) {
        return Quaternion.normalize(this, result);
    };

    /**
     * Computes the inverse of the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     */
    Quaternion.prototype.inverse = function(result) {
        return Quaternion.inverse(this, result);
    };

    /**
     * Computes the componentwise sum of this and the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} right The right hand side quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Quaternion.prototype.add = function(right, result) {
        return Quaternion.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this and the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} right The right hand side quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.

     * @exception {DeveloperError} right is required.
     */
    Quaternion.prototype.subtract = function(right, result) {
        return Quaternion.subtract(this, right, result);
    };

    /**
     * Negates this quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     */
    Quaternion.prototype.negate = function(result) {
        return Quaternion.negate(this, result);
    };

    /**
     * Computes the dot (scalar) product of this and the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} right The right hand side quaternion.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Quaternion.prototype.dot = function(right) {
        return Quaternion.dot(this, right);
    };


    /**
     * Computes the product of this and the provided quaternion.
     * @memberof Quaternion
     *
     * @param {Quaternion} right The right hande side quaternion.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Quaternion.prototype.multiply = function(right, result) {
        return Quaternion.multiply(this, right, result);
    };

    /**
     * Multiplies this quaternion componentwise by the provided scalar.
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Quaternion.prototype.multiplyByScalar = function(scalar, result) {
        return Quaternion.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this quaternion componentwise by the provided scalar.
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Quaternion.prototype.divideByScalar = function(scalar, result) {
        return Quaternion.divideByScalar(this, scalar, result);
    };

    /**
     * Computes the axis of rotation of this quaternion.
     * @memberof Quaternion
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    Quaternion.prototype.getAxis = function(result) {
        return Quaternion.getAxis(this, result);
    };

    /**
     * Computes the angle of rotation of this quaternion.
     * @memberof Quaternion
     *
     * @return {Number} The angle of rotation.
     */
    Quaternion.prototype.getAngle = function() {
        return Quaternion.getAngle(this);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using the provided quaternions.
     * This quaternion is assumed to be t at 0.0.
     * @memberof Quaternion
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Quaternion.prototype.lerp = function(end, t, result) {
        return Quaternion.lerp(this, end, t, result);
    };

    /**
     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
     * This quaternion is assumed to be t at 0.0.
     * @memberof Quaternion
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Quaternion} [result] The object onto which to store the result.
     * @return {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Quaternion.prototype.slerp = function(end, t, result) {
        return Quaternion.slerp(this, end, t, result);
    };

    /**
     * Compares this and the provided quaternion componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Quaternion
     *
     * @param {Quaternion} [right] The right hand side quaternion.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Quaternion.prototype.equals = function(right) {
        return Quaternion.equals(this, right);
    };

    /**
     * Compares this and the provided quaternion componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Quaternion
     *
     * @param {Quaternion} [right] The right hand side quaternion.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Quaternion.prototype.equalsEpsilon = function(right, epsilon) {
        return Quaternion.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Returns a string representing this quaternion in the format (x, y, z, w).
     * @memberof Quaternion
     *
     * @return {String} A string representing this Quaternion.
     */
    Quaternion.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    };

    return Quaternion;
});

/*global define*/
define('Core/OrientationInterpolator',[
        './DeveloperError',
        './Quaternion'
    ],
    function (
        DeveloperError,
        Quaternion) {
    

    /**
     * Smoothly interpolates orientation, represented by <code>Quaternion</code>s, over time.
     * For example, this can be used to set a camera's axes along a path.
     *
     * @alias OrientationInterpolator
     * @constructor
     *
     * @param {Array} controlPoints An array, of at least length 2, of objects with <code>orientation</code> and
     * <code>time</code> properties.
     *
     * @exception {DeveloperError} controlPoints is required. It must be an array with at least a length of 3.
     *
     * @see Quaternion
     * @see CatmullRomSpline
     * @see HermiteSpline
     */
    var OrientationInterpolator = function(controlPoints) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 2) {
            throw new DeveloperError('controlPoints is required. It must be an array with at least a length of 3.');
        }

        this._points = controlPoints;
        this._lastTimeIndex = 0;
    };

    /**
     * Returns the array of control points.
     *
     * @memberof OrientationInterpolator
     * @return {Array} The array of control points.
     */
    OrientationInterpolator.prototype.getControlPoints = function() {
        return this._points;
    };

    OrientationInterpolator.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    /**
     * Evaluates the orientation at a given time.
     *
     * @memberof OrientationInterpolator
     *
     * @param {Number} time The time at which to evaluate the orientation.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Quaternion} The orientation at the given <code>time</code>.
     */
    OrientationInterpolator.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        return this._points[i].orientation.slerp(this._points[i + 1].orientation, u);
    };

    return OrientationInterpolator;
});
/*global define*/
define('Core/Shapes',[
        './DeveloperError',
        './Math',
        './Cartesian2',
        './Cartesian3',
        './Quaternion',
        './Matrix3'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian2,
        Cartesian3,
        Quaternion,
        Matrix3) {
    

    function _computeEllipseQuadrant(cb, cbRadius, aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                     thetaPts, thetaPtsIndex, offset, clockDir, ellipsePts, ellipsePtsIndex, numPts) {
        var angle;
        var theta;
        var radius;
        var azimuth;
        var temp;
        var temp2;
        var rotAxis;
        var tempVec;

        for (var i = 0; i < numPts; i++, thetaPtsIndex += clockDir, ++ellipsePtsIndex) {
            theta = (clockDir > 0) ? (thetaPts[thetaPtsIndex] + offset) : (offset - thetaPts[thetaPtsIndex]);

            azimuth = theta + bearing;

            temp = -Math.cos(azimuth);

            rotAxis = eastVec.multiplyByScalar(temp);

            temp = Math.sin(azimuth);
            tempVec = northVec.multiplyByScalar(temp);

            rotAxis = rotAxis.add(tempVec);

            temp = Math.cos(theta);
            temp = temp * temp;

            temp2 = Math.sin(theta);
            temp2 = temp2 * temp2;

            radius = ab / Math.sqrt(bSqr * temp + aSqr * temp2);
            angle = radius / cbRadius;

            // Create the quaternion to rotate the position vector to the boundary of the ellipse.
            temp = Math.sin(angle / 2.0);

            var unitQuat = (new Quaternion(rotAxis.x * temp, rotAxis.y * temp, rotAxis.z * temp, Math.cos(angle / 2.0))).normalize();
            var rotMtx = Matrix3.fromQuaternion(unitQuat);

            var tmpEllipsePts = rotMtx.multiplyByVector(unitPos);
            var unitCart = tmpEllipsePts.normalize();
            tmpEllipsePts = unitCart.multiplyByScalar(mag);
            ellipsePts[ellipsePtsIndex] = tmpEllipsePts;
        }
    }

    /**
     * Functions to compute the boundary positions for shapes, such as circles,
     * drawn on the ellipsoid.
     *
     * @exports Shapes
     */
    var Shapes = {
        /**
         * Computes boundary points for a circle on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined circle is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled circle is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the circle will be on.
         * @param {Cartesian3} center The circle's center point in the fixed frame.
         * @param {Number} radius The radius in meters.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, and radius are required.
         * @exception {DeveloperError} radius must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @example
         * // Create a polyline of a circle
         * var polyline = new Polyline();
         * polyline.setPositions(Shapes.computeCircleBoundary(
         *   ellipsoid, ellipsoid.cartographicToCartesian(
         *     Cartographic.fromDegrees(-75.59777, 40.03883, 0.0)), 100000.0));
         */
        computeCircleBoundary : function(ellipsoid, center, radius, granularity) {
            if (!ellipsoid || !center || !radius) {
                throw new DeveloperError('ellipsoid, center, and radius are required.');
            }

            if (radius <= 0.0) {
                throw new DeveloperError('radius must be greater than zero.');
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            return this.computeEllipseBoundary(ellipsoid, center, radius, radius, 0, granularity);
        },

        /**
         * Computes boundary points for an ellipse on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined ellipse is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled ellipse is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the ellipse will be on.
         * @param {Cartesian3} center The ellipse's center point in the fixed frame.
         * @param {Number} semiMajorAxis The length of the ellipse's semi-major axis in meters.
         * @param {Number} semiMinorAxis The length of the ellipse's semi-minor axis in meters.
         * @param {Number} [bearing] The angle from north (counter-clockwise) in radians. The default is zero.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.
         * @exception {DeveloperError} Semi-major and semi-minor axes must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @return The set of points that form the ellipse's boundary.
         *
         * @example
         * // Create a filled ellipse.
         * var polygon = new Polygon();
         * polygon.setPositions(Shapes.computeEllipseBoundary(
         *   ellipsoid, ellipsoid.cartographicToCartesian(
         *      Cartographic.fromDegrees(-75.59777, 40.03883)), 500000.0, 300000.0, Math.toRadians(60)));
         */
        computeEllipseBoundary : function(ellipsoid, center, semiMajorAxis, semiMinorAxis, bearing, granularity) {
            if (!ellipsoid || !center || !semiMajorAxis || !semiMinorAxis) {
                throw new DeveloperError('ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.');
            }

            if (semiMajorAxis <= 0.0 || semiMinorAxis <= 0.0) {
                throw new DeveloperError('Semi-major and semi-minor axes must be greater than zero.');
            }

            bearing = bearing || 0.0;
            granularity = granularity || CesiumMath.toRadians(1.0);

            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            if (semiMajorAxis < semiMinorAxis) {
               var t = semiMajorAxis;
               semiMajorAxis = semiMinorAxis;
               semiMinorAxis = t;
            }

            var MAX_ANOMALY_LIMIT = 2.31;

            var aSqr = semiMajorAxis * semiMajorAxis;
            var bSqr = semiMinorAxis * semiMinorAxis;
            var ab = semiMajorAxis * semiMinorAxis;

            var value = 1.0 - (bSqr / aSqr);
            var ecc = Math.sqrt(value);

            var surfPos = Cartesian3.clone(center);
            var mag = surfPos.magnitude();

            var tempVec = new Cartesian3(0.0, 0.0, 1);
            var temp = 1.0 / mag;

            var unitPos = surfPos.multiplyByScalar(temp);
            var eastVec = tempVec.cross(surfPos).normalize();
            var northVec = unitPos.cross(eastVec);

            var numQuadrantPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);
            var deltaTheta = MAX_ANOMALY_LIMIT / (numQuadrantPts - 1);
            var thetaPts = [];
            var thetaPtsIndex = 0;

            var sampleTheta = 0.0;
            for (var i = 0; i < numQuadrantPts; i++, sampleTheta += deltaTheta, ++thetaPtsIndex) {
                thetaPts[thetaPtsIndex] = sampleTheta - ecc * Math.sin(sampleTheta);
                if (thetaPts[thetaPtsIndex] >= CesiumMath.PI_OVER_TWO) {
                    thetaPts[thetaPtsIndex] = CesiumMath.PI_OVER_TWO;
                    numQuadrantPts = i + 1;
                    break;
                }
            }

            var ellipsePts = [];

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, 0.0, 1, ellipsePts, 0, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, Math.PI, -1, ellipsePts, numQuadrantPts - 1, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, Math.PI, 1, ellipsePts, (2 * numQuadrantPts) - 2, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, CesiumMath.TWO_PI, -1, ellipsePts, (3 * numQuadrantPts) - 3, numQuadrantPts);

            ellipsePts.push(ellipsePts[0].clone()); // Duplicates first and last point for polyline

            return ellipsePts;
        }
    };

    return Shapes;
});
/*global define*/
define('Core/getImagePixels',[],function() {
    

    var context2DsByWidthAndHeight = {};

    /**
     * Extract a pixel array from a loaded image.  Draws the image
     * into a canvas so it can read the pixels back.
     *
     * @exports getImagePixels
     *
     * @param {Image} image The image to extract pixels from.
     *
     * @returns {CanvasPixelArray} The pixels of the image.
     */
    var getImagePixels = function(image, width, height) {
        if (typeof width === 'undefined') {
            width = image.width;
        }
        if (typeof height === 'undefined') {
            height = image.height;
        }

        var context2DsByHeight = context2DsByWidthAndHeight[width];
        if (typeof context2DsByHeight === 'undefined') {
            context2DsByHeight = {};
            context2DsByWidthAndHeight[width] = context2DsByHeight;
        }

        var context2d = context2DsByHeight[height];
        if (typeof context2d === 'undefined') {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            context2d = canvas.getContext('2d');
            context2d.globalCompositeOperation = 'copy';
            context2DsByHeight[height] = context2d;
        }

        context2d.drawImage(image, 0, 0, width, height);
        return context2d.getImageData(0, 0, width, height).data;
    };

    return getImagePixels;
});
/*global define*/
define('Core/isLeapYear',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * Determines if a given date is a leap year.
     *
     * @exports isLeapYear
     *
     * @param {Number} year The year to be tested.
     *
     * @return {Boolean} True if <code>year</code> is a leap yer.
     *
     * @exception {DeveloperError} year is required and must be a number.
     *
     * @example
     * var leapYear = isLeapYear(2000); // true
     */
    function isLeapYear(year) {
        if (year === null || isNaN(year)) {
            throw new DeveloperError('year is required and must be a number.');
        }
        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
    }

    return isLeapYear;
});

/*global define*/
define('Core/JulianDate',[
        './DeveloperError',
        './binarySearch',
        './TimeConstants',
        './LeapSecond',
        './TimeStandard',
        './isLeapYear'
    ], function(
        DeveloperError,
        binarySearch,
        TimeConstants,
        LeapSecond,
        TimeStandard,
        isLeapYear) {
    

    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var daysInLeapFeburary = 29;

    function convertUtcToTai(julianDate) {
        //Even though julianDate is in UTC, we'll treat it as TAI and
        //search the leap second table for it.
        var toFind = new LeapSecond(julianDate, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);

        if (index < 0) {
            index = ~index;
        }

        if (index >= leapSeconds.length) {
            index = leapSeconds.length - 1;
        }

        var offset = leapSeconds[index].offset;
        if (index > 0) {
            //Now we have the index of the closest leap second that comes on or after our UTC time.
            //However, if the difference between the UTC date being converted and the TAI
            //defined leap second is greater than the offset, we are off by one and need to use
            //the previous leap second.
            var difference = julianDate.getSecondsDifference(leapSeconds[index].julianDate);
            if (difference > offset) {
                index--;
                offset = leapSeconds[index].offset;
            }
        }

        julianDate.addSeconds(offset, julianDate);
    }

    function convertTaiToUtc(julianDate, result) {
        var toFind = new LeapSecond(julianDate, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
        if (index < 0) {
            index = ~index;
        }

        //All times before our first leap second get the first offset.
        if (index === 0) {
            return julianDate.addSeconds(-leapSeconds[0].offset, result);
        }

        //All times after our leap second get the last offset.
        if (index >= leapSeconds.length) {
            return julianDate.addSeconds(-leapSeconds[index - 1].offset, result);
        }

        //Compute the difference between the found leap second and the time we are converting.
        var difference = julianDate.getSecondsDifference(leapSeconds[index].julianDate);

        if (difference === 0) {
            //The date is in our leap second table.
            return julianDate.addSeconds(-leapSeconds[index].offset, result);
        }

        if (difference <= 1.0) {
            //The requested date is during the moment of a leap second, then we cannot convert to UTC
            return undefined;
        }

        //The time is in between two leap seconds, undex is the leap second after the date
        //we're converting, so we subtract one to get the correct LeapSecond instance.
        return julianDate.addSeconds(-leapSeconds[--index].offset, result);
    }

    function setComponents(wholeDays, secondsOfDay, julianDate) {
        var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
        wholeDays += extraDays;
        secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;

        if (secondsOfDay < 0) {
            wholeDays--;
            secondsOfDay += TimeConstants.SECONDS_PER_DAY;
        }

        if (typeof julianDate === 'undefined') {
            return new JulianDate(wholeDays, secondsOfDay, TimeStandard.TAI);
        }

        julianDate._julianDayNumber = wholeDays;
        julianDate._secondsOfDay = secondsOfDay;
        return julianDate;
    }

    function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
        // Algorithm from page 604 of the Explanatory Supplement to the
        // Astronomical Almanac (Seidelmann 1992).

        var a = ((month - 14) / 12) | 0;
        var b = year + 4800 + a;
        var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * ((b + 100) / 100)) / 4) | 0) + day - 32075;

        // JulianDates are noon-based
        hour = hour - 12;
        if (hour < 0) {
            hour += 24;
        }

        var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));

        if (secondsOfDay >= 43200.0) {
            dayNumber -= 1;
        }

        return [dayNumber, secondsOfDay];
    }

    function computeJulianDateComponentsFromDate(date) {
        return computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date
                .getUTCMilliseconds());
    }

    //Regular expressions used for ISO8601 date parsing.
    //YYYY
    var matchCalendarYear = /^(\d{4})$/;
    //YYYY-MM (YYYYMM is invalid)
    var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
    //YYYY-DDD or YYYYDDD
    var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
    //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD
    var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
    //YYYY-MM-DD or YYYYMMDD
    var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
    // Match utc offset
    var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
    // Match hours HH or HH.xxxxx
    var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
    // Match hours/minutes HH:MM HHMM.xxxxx
    var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
    // Match hours/minutes HH:MM:SS HHMMSS.xxxxx
    var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;

    var iso8601ErrorMessage = 'Valid ISO 8601 date string required.';

    /**
     * Constructs a JulianDate instance from a Julian day number, the number of seconds elapsed
     * into that day, and the time standard which the parameters are in.  Passing no parameters will
     * construct a JulianDate that represents the current system time.
     *
     * An astronomical Julian Date is the number of days since noon on January 1, -4712 (4713 BC).
     * For increased precision, this class stores the whole number part of the date and the seconds
     * part of the date in separate components.  In order to be safe for arithmetic and represent
     * leap seconds, the date is always stored in the International Atomic Time standard
     * {@link TimeStandard.TAI}.
     *
     * @alias JulianDate
     * @constructor
     * @immutable
     *
     * @param {Number} julianDayNumber The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
     * @param {Number} julianSecondsOfDay The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] The time standard in which the first two parameters are defined.
     *
     * @exception {DeveloperError} timeStandard is not a known TimeStandard.
     * @exception {DeveloperError} julianDayNumber is required.
     * @exception {DeveloperError} julianSecondsOfDay is required.
     *
     * @see JulianDate.fromDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     *
     * @example
     * // Example 1. Construct a Julian date representing the current system time.
     * var julianDate = new JulianDate();
     *
     * // Example 2. Construct a Julian date from a Julian day number and seconds of the day.
     * var julianDayNumber = 2448257;   // January 1, 1991
     * var secondsOfDay = 21600;        // 06:00:00
     * var julianDate = new JulianDate(julianDayNumber, secondsOfDay, TimeStandard.UTC);
     */
    var JulianDate = function(julianDayNumber, julianSecondsOfDay, timeStandard) {
        this._julianDayNumber = undefined;
        this._secondsOfDay = undefined;

        var wholeDays;
        var secondsOfDay;
        //If any of the properties are defined, then we are constructing from components.
        if (typeof julianDayNumber !== 'undefined' || typeof julianSecondsOfDay !== 'undefined' || typeof timeStandard !== 'undefined') {
            if (typeof timeStandard === 'undefined') {
                timeStandard = TimeStandard.UTC;
            } else if ((timeStandard !== TimeStandard.UTC) && (timeStandard !== TimeStandard.TAI)) {
                throw new DeveloperError('timeStandard is not a known TimeStandard.');
            }

            if (julianDayNumber === null || isNaN(julianDayNumber)) {
                throw new DeveloperError('julianDayNumber is required.');
            }

            if (julianSecondsOfDay === null || isNaN(julianSecondsOfDay)) {
                throw new DeveloperError('julianSecondsOfDay is required.');
            }

            //coerce to integer
            wholeDays = julianDayNumber | 0;
            //If julianDayNumber was fractional, add the number of seconds the fraction represented
            secondsOfDay = julianSecondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;
        } else {
            //Create a new date from the current time.
            var date = new Date();
            var components = computeJulianDateComponentsFromDate(date);
            wholeDays = components[0];
            secondsOfDay = components[1];
            timeStandard = TimeStandard.UTC;
        }

        setComponents(wholeDays, secondsOfDay, this);

        if (timeStandard === TimeStandard.UTC) {
            convertUtcToTai(this);
        }
    };

    /**
     * Duplicates a JulianDate instance.
     * @memberof JulianDate
     *
     * @param {Cartesian3} date The JulianDate to duplicate.
     * @param {Cartesian3} [result] The object onto which to store the JulianDate.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     *
     * @exception {DeveloperError} date is required.
     */
    JulianDate.clone = function(date, result) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date is required.');
        }
        if (typeof result === 'undefined') {
            return new JulianDate(date._julianDayNumber, date._secondsOfDay, TimeStandard.TAI);
        }
        result._julianDayNumber = date._julianDayNumber;
        result._secondsOfDay = date._secondsOfDay;
        return result;
    };

    /**
     * Creates a JulianDate instance from a JavaScript Date object.
     * While the JavaScript Date object defaults to the system's local time zone,
     * the Julian date is computed using the UTC values.
     *
     * @memberof JulianDate
     *
     * @param {Date} date The JavaScript Date object representing the time to be converted to a Julian date.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard in which this Julian date is represented.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} date must be a valid JavaScript Date.
     *
     * @see JulianDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     * @see <a href='http://www.w3schools.com/js/js_obj_date.asp'>JavaScript Date Object on w3schools</a>.
     * @see <a href='http://www.w3schools.com/jsref/jsref_obj_date.asp'>JavaScript Date Object Reference on w3schools</a>.
     *
     * @example
     * // Construct a Julian date specifying the UTC time standard
     * var date = new Date('January 1, 2011 12:00:00 EST');
     * var julianDate = JulianDate.fromDate(date, TimeStandard.UTC);
     */
    JulianDate.fromDate = function(date, timeStandard) {
        if (typeof date === 'undefined' || date === null || isNaN(date.getTime())) {
            throw new DeveloperError('date must be a valid JavaScript Date.');
        }

        var components = computeJulianDateComponentsFromDate(date);
        return new JulianDate(components[0], components[1], timeStandard);
    };

    /**
     * Creates a JulianDate instance from an ISO 8601 date string.  Unlike Date.parse,
     * this method properly accounts for all valid formats defined by the ISO 8601
     * specification.  It also properly handles leap seconds and sub-millisecond times.
     *
     * @memberof JulianDate
     *
     * @param {String} iso8601String The ISO 8601 date string representing the time to be converted to a Julian date.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} Valid ISO 8601 date string required.
     *
     * @see JulianDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromDate
     * @see LeapSecond
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     *
     * @example
     * // Example 1. Construct a Julian date in UTC at April 24th, 2012 6:08PM UTC
     * var julianDate = JulianDate.fromIso8601('2012-04-24T18:08Z');
     * // Example 2. Construct a Julian date in local time April 24th, 2012 12:00 AM
     * var localDay = JulianDate.fromIso8601('2012-04-24');
     * // Example 3. Construct a Julian date 5 hours behind UTC April 24th, 2012 5:00 pm UTC
     * var localDay = JulianDate.fromIso8601('2012-04-24T12:00-05:00');
     */
    JulianDate.fromIso8601 = function(iso8601String) {
        if (typeof iso8601String !== 'string') {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        //Comma and decimal point both indicate a fractional number according to ISO 8601,
        //start out by blanket replacing , with . which is the only valid such symbol in JS.
        iso8601String = iso8601String.replace(',', '.');

        //Split the string into its date and time components, denoted by a mandatory T
        var tokens = iso8601String.split('T'), year, month = 1, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;

        //Lacking a time is okay, but a missing date is illegal.
        var date = tokens[0];
        var time = tokens[1];
        var tmp, inLeapYear;
        if (typeof date === 'undefined') {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        var dashCount;

        //First match the date against possible regular expressions.
        tokens = date.match(matchCalendarDate);
        if (tokens !== null) {
            dashCount = date.split('-').length - 1;
            if (dashCount > 0 && dashCount !== 2) {
                throw new DeveloperError(iso8601ErrorMessage);
            }
            year = +tokens[1];
            month = +tokens[2];
            day = +tokens[3];
        } else {
            tokens = date.match(matchCalendarMonth);
            if (tokens !== null) {
                year = +tokens[1];
                month = +tokens[2];
            } else {
                tokens = date.match(matchCalendarYear);
                if (tokens !== null) {
                    year = +tokens[1];
                } else {
                    //Not a year/month/day so it must be an ordinal date.
                    var dayOfYear;
                    tokens = date.match(matchOrdinalDate);
                    if (tokens !== null) {

                        year = +tokens[1];
                        dayOfYear = +tokens[2];
                        inLeapYear = isLeapYear(year);

                        //This validation is only applicable for this format.
                        if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                    } else {
                        tokens = date.match(matchWeekDate);
                        if (tokens !== null) {
                            //ISO week date to ordinal date from
                            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775
                            year = +tokens[1];
                            var weekNumber = +tokens[2];
                            var dayOfWeek = +tokens[3] || 0;

                            dashCount = date.split('-').length - 1;
                            if (dashCount > 0 &&
                               ((typeof tokens[3] === 'undefined' && dashCount !== 1) ||
                               (typeof tokens[3] !== 'undefined' && dashCount !== 2))) {
                                throw new DeveloperError(iso8601ErrorMessage);
                            }

                            var january4 = new Date(Date.UTC(year, 0, 4));
                            dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;
                        } else {
                            //None of our regular expressions succeeded in parsing the date properly.
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                    }
                    //Split an ordinal date into month/day.
                    tmp = new Date(Date.UTC(year, 0, 1));
                    tmp.setUTCDate(dayOfYear);
                    month = tmp.getUTCMonth() + 1;
                    day = tmp.getUTCDate();
                }
            }
        }

        //Now that we have all of the date components, validate them to make sure nothing is out of range.
        inLeapYear = isLeapYear(year);
        if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        //Not move onto the time string, which is much simpler.
        var offsetIndex;
        if (typeof time !== 'undefined') {
            tokens = time.match(matchHoursMinutesSeconds);
            if (tokens !== null) {
                dashCount = time.split(':').length - 1;
                if (dashCount > 0 && dashCount !== 2) {
                    throw new DeveloperError(iso8601ErrorMessage);
                }

                hours = +tokens[1];
                minutes = +tokens[2];
                seconds = +tokens[3];
                milliseconds = +(tokens[4] || 0) * 1000.0;
                offsetIndex = 5;
            } else {
                tokens = time.match(matchHoursMinutes);
                if (tokens !== null) {
                    dashCount = time.split(':').length - 1;
                    if (dashCount > 0 && dashCount !== 1) {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }

                    hours = +tokens[1];
                    minutes = +tokens[2];
                    seconds = +(tokens[3] || 0) * 60.0;
                    offsetIndex = 4;
                } else {
                    tokens = time.match(matchHours);
                    if (tokens !== null) {
                        hours = +tokens[1];
                        minutes = +(tokens[2] || 0) * 60.0;
                        offsetIndex = 3;
                    } else {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }
                }
            }

            //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.
            if (minutes >= 60 || seconds >= 61 || hours > 24 || (hours === 24 && (minutes > 0 || seconds > 0 || milliseconds > 0))) {
                throw new DeveloperError(iso8601ErrorMessage);
            }

            //Check the UTC offset value, if no value exists, use local time
            //a Z indicates UTC, + or - are offsets.
            var offset = tokens[offsetIndex];
            var offsetHours = +(tokens[offsetIndex + 1]);
            var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
            switch (offset) {
            case '+':
                hours = hours - offsetHours;
                minutes = minutes - offsetMinutes;
                break;
            case '-':
                hours = hours + offsetHours;
                minutes = minutes + offsetMinutes;
                break;
            case 'Z':
                break;
            default:
                minutes = minutes + new Date(Date.UTC(year, month - 1, day, hours, minutes)).getTimezoneOffset();
                break;
            }
        } else {
            //If no time is specified, it is considered the beginning of the day, local time.
            minutes = minutes + new Date(Date.UTC(year, month - 1, day)).getTimezoneOffset();
        }

        //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.
        //If that's the case, we need to temporarily subtract a second in order to build a UTC date.
        //Then we add it back in after converting to TAI.
        var isLeapSecond = seconds === 60;
        if (isLeapSecond) {
            seconds--;
        }

        //Even if we successfully parsed the string into its components, after applying UTC offset or
        //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.

        //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes
        while (minutes >= 60) {
            minutes -= 60;
            hours++;
        }

        while (hours >= 24) {
            hours -= 24;
            day++;
        }

        tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
        while (day > tmp) {
            day -= tmp;
            month++;

            if (month > 12) {
                month -= 12;
                year++;
            }

            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
        }

        //If UTC offset is at the beginning/end of the day, minutes can be negative.
        while (minutes < 0) {
            minutes += 60;
            hours--;
        }

        while (hours < 0) {
            hours += 24;
            day--;
        }

        while (day < 1) {
            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
            day += tmp;
            month--;

            if (month < 1) {
                month += 12;
                year--;
            }
        }

        //Now create the JulianDate components from the Gregorian date and actually create our instance.
        var components = computeJulianDateComponents(year, month, day, hours, minutes, seconds, milliseconds);
        var result = new JulianDate(components[0], components[1], TimeStandard.UTC);

        //If we were on a leap second, add it back.
        if (isLeapSecond) {
            result.addSeconds(1, result);
        }

        return result;
    };

    /**
     * Creates a JulianDate instance from a single number representing the Julian day and fractional day.
     *
     * @memberof JulianDate
     *
     * @param {Number} totalDays The combined Julian Day Number and fractional day.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard in which the first parameter is defined.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} totalDays is required.
     *
     * @see JulianDate
     * @see JulianDate.fromDate
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     *
     * @example
     * // Construct a date which corresponds to January 1, 1991 06:00:00 UTC.
     * var julianDate = JulianDate.fromTotalDays(2448257.75, TimeStandard.UTC);
     */
    JulianDate.fromTotalDays = function(totalDays, timeStandard) {
        if (totalDays === null || isNaN(totalDays)) {
            throw new DeveloperError('totalDays is required.');
        }
        return new JulianDate(totalDays, 0, timeStandard);
    };

    /**
     * Compares two {JulianDate} instances.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} a The first instance.
     * @param {JulianDate} b The second instance.
     * @return {Number} A negative value if a is less than b, a positive value if
     *                   a is greater than b, and zero if a and b are equal.
     */
    JulianDate.compare = function(a, b) {
        var dayDifference = (a._julianDayNumber - b._julianDayNumber);
        if (dayDifference !== 0) {
            return dayDifference;
        }
        return a._secondsOfDay - b._secondsOfDay;
    };

    /**
     * Duplicates this JulianDate.
     * @memberof JulianDate
     *
     * @param {Cartesian3} [result] The object onto which to store the JulianDate.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    JulianDate.prototype.clone = function(result) {
        return JulianDate.clone(this, result);
    };

    /**
     * Returns the total number of whole and fractional days represented by this astronomical Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} The Julian date as single floating point number.
     *
     * @see JulianDate#getJulianDayNumber
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getTotalDays = function() {
        return this._julianDayNumber + (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY);
    };

    /**
     * Returns the whole number component of the Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} A whole number representing the Julian day number.
     *
     * @see JulianDate#getTotalDays
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getJulianDayNumber = function() {
        return this._julianDayNumber;
    };

    /**
     * Returns the floating point component of the Julian date representing the time of day.
     *
     * @memberof JulianDate
     *
     * @return {Number} The floating point component of the Julian date representing the time of day.
     *
     * @see JulianDate#getTotalDays
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getJulianTimeFraction = function() {
        return this._secondsOfDay / TimeConstants.SECONDS_PER_DAY;
    };

    /**
     * Return the number of seconds elapsed into the current Julian day (starting at noon).
     *
     * @memberof JulianDate
     *
     * @return {Number} The number of seconds elapsed into the current day.
     *
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getSecondsOfDay = function() {
        return this._secondsOfDay;
    };

    var toDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
    /**
     * Creates a new JavaScript Date object equivalent to the Julian date
     * (accurate to the nearest millisecond in the UTC time standard).
     *
     * @memberof JulianDate
     *
     * @return {Date} A new JavaScript Date equivalent to this Julian date.
     */
    JulianDate.prototype.toDate = function() {
        //Attempt to convert to UTC; if we are on a leap second, this will
        //return undefined.  Since JavaScript Date doesn't support leap second
        //we can just add second and re-convert.
        var thisUtc = convertTaiToUtc(this, toDateScratch);
        if (typeof thisUtc === 'undefined') {
            this.addSeconds(1, toDateScratch);
            thisUtc = convertTaiToUtc(toDateScratch, toDateScratch);
        }

        var julianDayNumber = thisUtc._julianDayNumber;
        var secondsOfDay = thisUtc._secondsOfDay;

        if (secondsOfDay >= 43200.0) {
            julianDayNumber += 1;
        }

        // Algorithm from page 604 of the Explanatory Supplement to the
        // Astronomical Almanac (Seidelmann 1992).
        var L = (julianDayNumber + 68569) | 0;
        var N = (4 * L / 146097) | 0;
        L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
        var I = ((4000 * (L + 1)) / 1461001) | 0;
        L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
        var J = ((80 * L) / 2447) | 0;
        var day = (L - (((2447 * J) / 80) | 0)) | 0;
        L = (J / 11) | 0;
        var month = (J + 2 - 12 * L) | 0;
        var year = (100 * (N - 49) + I + L) | 0;

        month--; // month field is zero-indexed

        var hours = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
        var remainingSeconds = secondsOfDay - (hours * TimeConstants.SECONDS_PER_HOUR);
        var minutes = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
        remainingSeconds = remainingSeconds - (minutes * TimeConstants.SECONDS_PER_MINUTE);
        var seconds = remainingSeconds | 0;
        var milliseconds = ((remainingSeconds - seconds) / TimeConstants.SECONDS_PER_MILLISECOND) | 0;

        // JulianDates are noon-based
        hours += 12;
        if (hours > 23) {
            hours -= 24;
        }

        return new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
    };

    /**
     * Computes the number of seconds that have elapsed from this Julian date to the <code>other</code>
     * Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getMinutesDifference
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 5, 2011 12:01:00'));
     * var difference = start.getSecondsDifference(end);    // 86460.0 seconds
     */
    JulianDate.prototype.getSecondsDifference = function(other) {
        var julianDate1 = this;
        var julianDate2 = other;
        var dayDifference = (julianDate2.getJulianDayNumber() - julianDate1.getJulianDayNumber()) * TimeConstants.SECONDS_PER_DAY;
        return (dayDifference + (julianDate2.getSecondsOfDay() - julianDate1.getSecondsOfDay()));
    };

    /**
     * Computes the number of minutes that have elapsed from this Julian date to the <code>other</code>
     * Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getSecondsDifference
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 5, 2011 12:01:00'));
     * var difference = start.getMinutesDifference(end);    // 1441.0 minutes
     */
    JulianDate.prototype.getMinutesDifference = function(other) {
        return this.getSecondsDifference(other) / TimeConstants.SECONDS_PER_MINUTE;
    };

    /**
     * Returns the number of seconds this TAI date is ahead of UTC.
     *
     * @memberof JulianDate
     *
     * @return {Number} The number of seconds this TAI date is ahead of UTC
     *
     * @see LeapSecond
     * @see TimeStandard
     *
     * @example
     * var date = new Date('August 1, 2012 12:00:00 UTC');
     * var julianDate = JulianDate.fromDate(date);
     * var difference = julianDate.getTaiMinusUtc(); //35
     */
    JulianDate.prototype.getTaiMinusUtc = function() {
        var toFind = new LeapSecond(this, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
        if (index < 0) {
            index = ~index;
            --index;
            if (index < 0) {
                index = 0;
            }
        }
        return leapSeconds[index].offset;
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> seconds later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} seconds The number of seconds to add or subtract.
     * @param {JulianDate} [result] The JulianDate to store the result into.
     *
     * @return {JulianDate} The modified result parameter or a new JulianDate instance if it was not provided.
     *
     * @exception {DeveloperError} seconds is required and must be a number.
     *
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00:00 UTC
     * date.setUTCHours(12, 0, 00, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addSeconds(95);      // July 4, 2011 @ 12:01:35 UTC
     */
    JulianDate.prototype.addSeconds = function(seconds, result) {
        if (seconds === null || isNaN(seconds)) {
            throw new DeveloperError('seconds is required and must be a number.');
        }
        return setComponents(this._julianDayNumber, this._secondsOfDay + seconds, result);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> minutes later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of minutes to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addMinutes(65);      // July 4, 2011 @ 13:05 UTC
     */
    JulianDate.prototype.addMinutes = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_MINUTE);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> hours later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of hours to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addHours(6);         // July 4, 2011 @ 18:00 UTC
     */
    JulianDate.prototype.addHours = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_HOUR);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> days later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of days to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addDays(5);         // July 9, 2011 @ 12:00 UTC
     */
    JulianDate.prototype.addDays = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newJulianDayNumber = this._julianDayNumber + duration;
        return new JulianDate(newJulianDayNumber, this._secondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns true if <code>other</code> occurs after this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically earlier than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThan
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:01:00'));
     * start.lessThan(end);     // true
     */
    JulianDate.prototype.lessThan = function(other) {
        return JulianDate.compare(this, other) < 0;
    };

    /**
     * Returns true if <code>other</code> occurs at or after this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically less than or equal to<code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#greaterThan
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:00:00'));
     * start.lessThanOrEquals(end);     // true
     */
    JulianDate.prototype.lessThanOrEquals = function(other) {
        return JulianDate.compare(this, other) <= 0;
    };

    /**
     * Returns true if <code>other</code> occurs before this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically later than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:01:00'));
     * end.greaterThan(start);      // true
     */
    JulianDate.prototype.greaterThan = function(other) {
        return JulianDate.compare(this, other) > 0;
    };

    /**
     * Returns true if <code>other</code> occurs at or before this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically later than or equal to <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThan
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:00:00'));
     * end.greaterThanOrEquals(start);      // true
     */
    JulianDate.prototype.greaterThanOrEquals = function(other) {
        return JulianDate.compare(this, other) >= 0;
    };

    /**
     * Returns <code>true</code> if this date is equivalent to the specified date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are equal; otherwise <code>false</code>.
     *
     * @see JulianDate#equalsEpsilon
     *
     * @example
     * var original = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var clone = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * original.equals(clone);      // true
     */
    JulianDate.prototype.equals = function(other) {
        return JulianDate.compare(this, other) === 0;
    };

    /**
     * Returns <code>true</code> if this date is within <code>epsilon</code> seconds of the
     * specified date.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     *
     * @exception {DeveloperError} epsilon is required and must be number.
     *
     * @see JulianDate#equals
     *
     * @example
     * var original = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var clone = JulianDate.fromDate(new Date('July 4, 2011 12:00:01'));
     * original.equalsEpsilon(clone, 2);    // true
     */
    JulianDate.prototype.equalsEpsilon = function(other, epsilon) {
        if (epsilon === null || isNaN(epsilon)) {
            throw new DeveloperError('epsilon is required and must be number.');
        }
        return Math.abs(this.getSecondsDifference(other)) <= epsilon;
    };

    //To avoid circular dependencies, we load the default list of leap seconds
    //here, rather than in the LeapSecond class itself.
    if (LeapSecond._leapSeconds.length === 0) {
        LeapSecond._leapSeconds = [
                                   new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35)  // July 1, 2012 00:00:00 UTC
                                 ];
    }

    return JulianDate;
});
/*global define*/
define('Core/Clock',[
        './DeveloperError',
        './JulianDate',
        './ClockStep',
        './ClockRange'
       ], function(
         DeveloperError,
         JulianDate,
         ClockStep,
         ClockRange) {
    

    /**
     * A simple clock for keeping track of simulated time.
     * @alias Clock
     * @constructor
     *
     * @param {Object} [template] The template object containing the properties to be set on the clock.
     * @exception {DeveloperError} startTime must come before stopTime.
     *
     * @see ClockStep
     * @see ClockRange
     * @see JulianDate
     * @see AnimationController
     *
     * @example
     * //Create a clock that loops on Christmas day 2012 and runs
     * //in real-time.  currentTime will default to startTime.
     * var clock = new Clock({
     *    startTime : JulianDate.fromIso8601("12-25-2012");
     *    stopTime : JulianDate.fromIso8601("12-26-2012");
     *    clockRange : ClockRange.LOOP;
     * });
     */
    var Clock = function(template) {
        var t = template;
        if (typeof t === 'undefined') {
            t = {};
        }

        var startTime = t.startTime;
        var startTimeUndefined = typeof startTime === 'undefined';

        var stopTime = t.stopTime;
        var stopTimeUndefined = typeof stopTime === 'undefined';

        var currentTime = t.currentTime;
        var currentTimeUndefined = typeof currentTime === 'undefined';

        if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
            currentTime = new JulianDate();
            startTime = currentTime.clone();
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined && stopTimeUndefined) {
            startTime = currentTime.clone();
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined && currentTimeUndefined) {
            startTime = stopTime.addDays(-1.0);
            currentTime = startTime.clone();
        } else if (currentTimeUndefined && stopTimeUndefined) {
            currentTime = startTime.clone();
            stopTime = startTime.addDays(1.0);
        } else if (currentTimeUndefined) {
            currentTime = startTime.clone();
        } else if (stopTimeUndefined) {
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined) {
            startTime = currentTime.clone();
        }

        if (startTime.greaterThan(stopTime)) {
            throw new DeveloperError('startTime must come before stopTime.');
        }

        var multiplier = t.multiplier;
        if (typeof multiplier === 'undefined') {
            multiplier = 1.0;
        }

        var clockStep = t.clockStep;
        if (typeof clockStep === 'undefined') {
            clockStep = ClockStep.SYSTEM_CLOCK_DEPENDENT;
        }

        var clockRange = t.clockRange;
        if (typeof clockRange === 'undefined') {
            clockRange = ClockRange.UNBOUNDED;
        }

        /**
         * The start time of the clock.
         * @type JulianDate
         */
        this.startTime = startTime;

        /**
         * The stop time of the clock.
         * @type JulianDate
         */
        this.stopTime = stopTime;

        /**
         * The current time.
         * @type JulianDate
         */
        this.currentTime = currentTime;

        /**
         * Determines how much time advances when tick is called, negative values allow for advancing backwards.
         * If <code>clockStep</code> is set to ClockStep.TICK_DEPENDENT this is the number of seconds to advance.
         * If <code>clockStep</code> is set to ClockStep.SYSTEM_CLOCK_DEPENDENT this value is multiplied by the
         * elapsed system time since the last call to tick.
         * @type Number
         */
        this.multiplier = multiplier;

        /**
         * Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
         * @type ClockStep
         */
        this.clockStep = clockStep;

        /**
         * Determines how tick should behave when <code>startTime</code> or <code>stopTime</code> is reached.
         * @type ClockRange
         */
        this.clockRange = clockRange;

        this._lastCpuTime = new Date().getTime();
    };

    /**
     * Advances the clock from the currentTime based on the current configuration options.
     * @memberof Clock
     *
     * @param {Number} [secondsToTick] optional parameter to force the clock to tick the provided number of seconds,
     * regardless of the value of <code>clockStep</code> and <code>multiplier</code>.
     * @returns {JulianDate} The new value of the <code>currentTime</code> property.
     */
    Clock.prototype.tick = function(secondsToTick) {
        return this._tick(secondsToTick, this.multiplier);
    };

    /**
     * Advances the clock in the opposite direction of the current <code>multiplier</code>.
     * If <code>multiplier</code> is positive this will advance the clock backwards one tick.
     * If <code>multiplier</code> is negative this will advance the clock forward one tick.
     * @memberof Clock
     *
     * @returns {JulianDate} The new value of Clock.currentTime
     */
    Clock.prototype.reverseTick = function() {
        return this._tick(undefined, -this.multiplier);
    };

    Clock.prototype._tick = function(secondsToTick, multiplier) {
        var startTime = this.startTime;
        var stopTime = this.stopTime;
        var currentTime = this.currentTime;
        var currentCpuTime = new Date().getTime();

        if (typeof secondsToTick === 'undefined') {
            if (this.clockStep === ClockStep.TICK_DEPENDENT) {
                currentTime = currentTime.addSeconds(multiplier);
            } else {
                var milliseconds = currentCpuTime - this._lastCpuTime;
                currentTime = currentTime.addSeconds(multiplier * (milliseconds / 1000.0));
            }
        } else {
            currentTime = currentTime.addSeconds(secondsToTick);
        }

        if (this.clockRange === ClockRange.CLAMPED) {
            if (currentTime.lessThan(startTime)) {
                currentTime = startTime;
            } else if (currentTime.greaterThan(stopTime)) {
                currentTime = stopTime;
            }
        } else if (this.clockRange === ClockRange.LOOP) {
            while (currentTime.lessThan(startTime)) {
                currentTime = stopTime.addSeconds(startTime.getSecondsDifference(currentTime));
            }
            while (currentTime.greaterThan(stopTime)) {
                currentTime = startTime.addSeconds(stopTime.getSecondsDifference(currentTime));
            }
        }

        this.currentTime = currentTime;
        this._lastCpuTime = currentCpuTime;
        return currentTime;
    };

    return Clock;
});
/*global define*/
define('Core/EventHandler',[
        './DeveloperError',
        './destroyObject',
        './Cartesian2',
        './JulianDate',
        './MouseEventType',
        './EventModifier'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        JulianDate,
        MouseEventType,
        EventModifier) {
    

    /**
     * Handles user input events. Custom functions can be added to be executed on
     * when the user enters input.
     *
     * @alias EventHandler
     *
     * @param {DOC_TBA} element The element to add events to. Defaults to document.
     * @constructor
     */
    var EventHandler = function(element) {
        this._mouseEvents = {};
        for ( var button in MouseEventType) {
            if (MouseEventType.hasOwnProperty(button)) {
                this._mouseEvents[button] = 0;
            }
        }

        this._modifiedMouseEvents = {};
        for ( var modifier in EventModifier) {
            if (EventModifier.hasOwnProperty(modifier)) {
                this._modifiedMouseEvents[modifier] = {};
                for (button in MouseEventType) {
                    if (MouseEventType.hasOwnProperty(button)) {
                        this._modifiedMouseEvents[modifier][button] = 0;
                    }
                }
            }
        }

        this._leftMouseButtonDown = false;
        this._middleMouseButtonDown = false;
        this._rightMouseButtonDown = false;
        this._seenAnyTouchEvents = false;
        this._lastMouseX = 0;
        this._lastMouseY = 0;
        this._totalPixels = 0;

        // TODO: Revisit when doing mobile development. May need to be configurable
        // or determined based on the platform?
        this._clickPixelTolerance = 5;

        this._element = element || document;

        this._register();
    };

    EventHandler.prototype._getPosition = function(event) {
        if (this._element === document) {
            return {
                x : event.clientX,
                y : event.clientY
            };
        }

        var rect = this._element.getBoundingClientRect();
        return {
            x : event.clientX - rect.left,
            y : event.clientY - rect.top
        };
    };

    /**
     * Set a function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Function} action Function to be executed when the mouse event occurs.
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} action is required.
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.setMouseAction = function(action, type, modifier) {
        if (!action) {
            throw new DeveloperError('action is required.');
        }

        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            mouseEvents[type.name] = action;
        }
    };

    /**
     * Returns the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#setMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.getMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            return mouseEvents[type.name];
        }

        return undefined;
    };

    /**
     * Removes the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#setMouseAction
     */
    EventHandler.prototype.removeMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents && mouseEvents[type.name]) {
            delete mouseEvents[type.name];
        }
    };

    EventHandler.prototype._getModifier = function(event) {
        if (event.shiftKey) {
            return EventModifier.SHIFT;
        } else if (event.ctrlKey) {
            return EventModifier.CTRL;
        } else if (event.altKey) {
            return EventModifier.ALT;
        }

        return undefined;
    };

    EventHandler.prototype._handleMouseDown = function(event) {
        var pos = this._getPosition(event);
        this._lastMouseX = pos.x;
        this._lastMouseY = pos.y;
        this._totalPixels = 0;
        if (this._seenAnyTouchEvents) {
            return;
        }

        var modifier = this._getModifier(event);
        var action;

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.MIDDLE_DOWN, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.RIGHT_DOWN, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
        event.preventDefault();
    };

    EventHandler.prototype._handleMouseUp = function(event) {
        var modifier = this._getModifier(event);
        var action, clickAction;
        if (this._seenAnyTouchEvents) {
            return;
        }

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.MIDDLE_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.MIDDLE_CLICK, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.RIGHT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.RIGHT_CLICK, modifier);
        }

        var pos = this._getPosition(event);

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }

        if (clickAction && this._totalPixels < this._clickPixelTolerance) {
            clickAction({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._handleMouseMove = function(event) {
        var pos = this._getPosition(event);
        if (this._seenAnyTouchEvents) {
            return;
        }

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        var movement = {
            startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
            endPosition : new Cartesian2(pos.x, pos.y),
            motion : new Cartesian2(0.0, 0.0)
        };

        var modifier = this._getModifier(event);
        var action = this.getMouseAction(MouseEventType.MOVE, modifier);
        if (action) {
            action(movement);
        }

        this._lastMouseX = movement.endPosition.x;
        this._lastMouseY = movement.endPosition.y;

        if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
            event.preventDefault();
        }
    };

    EventHandler.prototype._handleTouchStart = function(event) {
        var pos, numberOfTouches = event.touches.length;
        this._seenAnyTouchEvents = true;

        if (numberOfTouches === 1) {
            pos = this._getPosition(event.touches[0]);
            this._lastMouseX = pos.x;
            this._lastMouseY = pos.y;
            this._totalPixels = 0;

            var modifier = this._getModifier(event);
            var action;

            this._leftMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
            event.preventDefault();
        } else if (this._leftMouseButtonDown) {
            this._handleTouchEnd(event);
        }
    };

    EventHandler.prototype._handleTouchEnd = function(event) {
        var numberOfTouches = event.touches.length;
        var numberOfTargetTouches = event.targetTouches.length;
        var modifier = this._getModifier(event);
        var action, clickAction;

        if (this._leftMouseButtonDown) {
            this._leftMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        }

        if (numberOfTargetTouches > 0) {
            var pos = this._getPosition(event.targetTouches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }

            if (clickAction && this._totalPixels < this._clickPixelTolerance) {
                clickAction({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
        }

        if (numberOfTouches === 1) {
            this._handleTouchStart(event);
        }
    };

    EventHandler.prototype._handleTouchMove = function(event) {
        if (this._leftMouseButtonDown && (event.touches.length === 1)) {
            var pos = this._getPosition(event.touches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            var movement = {
                startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
                endPosition : new Cartesian2(pos.x, pos.y),
                motion : new Cartesian2(0.0, 0.0)
            };

            var modifier = this._getModifier(event);
            var action = this.getMouseAction(MouseEventType.MOVE, modifier);
            if (action) {
                action(movement);
            }

            this._lastMouseX = movement.endPosition.x;
            this._lastMouseY = movement.endPosition.y;

            if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
                event.preventDefault();
            }
        }
    };

    EventHandler.prototype._handleMouseWheel = function(event) {
        // Some browsers use event.detail to count the number of clicks. The sign
        // of the integer is the direction the wheel is scrolled. In that case, convert
        // to the angle it was rotated in degrees.
        var delta = event.detail ? event.detail * -120 : event.wheelDelta;

        var modifier = this._getModifier(event);
        var type = MouseEventType.WHEEL;
        var action = this.getMouseAction(type, modifier);

        if (action) {
            event.preventDefault();
            action(delta);
        }
    };

    EventHandler.prototype._handleMouseDblClick = function(event) {
        var modifier = this._getModifier(event);
        var action;
        var pos = this._getPosition(event);

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            action = this.getMouseAction(MouseEventType.LEFT_DOUBLE_CLICK, modifier);
        } else if (event.button === 1) {
            action = this.getMouseAction(MouseEventType.MIDDLE_DOUBLE_CLICK, modifier);
        } else if (event.button === 2) {
            action = this.getMouseAction(MouseEventType.RIGHT_DOUBLE_CLICK, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._register = function() {
        var that = this, useDoc = true;

        this._callbacks = [];
        if (typeof this._element.disableRootEvents !== 'undefined') {
            useDoc = false;
        }

        this._callbacks.push({
            name : 'mousedown',
            onDoc : false,
            action : function(e) {
                that._handleMouseDown(e);
            }
        });
        this._callbacks.push({
            name : 'mouseup',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseUp(e);
            }
        });
        this._callbacks.push({
            name : 'mousemove',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseMove(e);
            }
        });
        this._callbacks.push({
            name : 'dblclick',
            onDoc : false,
            action : function(e) {
                that._handleMouseDblClick(e);
            }
        });
        this._callbacks.push({
            name : 'touchstart',
            onDoc : false,
            action : function(e) {
                that._handleTouchStart(e);
            }
        });
        this._callbacks.push({
            name : 'touchend',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchEnd(e);
            }
        });
        this._callbacks.push({
            name : 'touchmove',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchMove(e);
            }
        });

        // Firefox calls the mouse wheel event 'DOMMouseScroll', all others use 'mousewheel'
        this._callbacks.push({
            name : 'mousewheel',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });
        this._callbacks.push({
            name : 'DOMMouseScroll',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });

        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.addEventListener(cback.name, cback.action, false);
            } else {
                this._element.addEventListener(cback.name, cback.action, false);
            }
        }
    };

    EventHandler.prototype._unregister = function() {
        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.removeEventListener(cback.name, cback.action, false);
            } else {
                this._element.removeEventListener(cback.name, cback.action, false);
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see EventHandler#destroy
     */
    EventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof EventHandler
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    EventHandler.prototype.destroy = function() {
        this._unregister();
        return destroyObject(this);
    };

    return EventHandler;
});

/*global define*/
define('Core/TimeInterval',[
        './DeveloperError',
        './freezeObject',
        './JulianDate',
        './TimeStandard'
    ], function(
        DeveloperError,
        freezeObject,
        JulianDate,
        TimeStandard) {
    

    /**
     * An interval defined by a start date and a stop date.  The end points are optionally included
     * in the interval.  The interval should be treated as immutable.
     *
     * @alias TimeInterval
     * @constructor
     *
     * @param {JulianDate} start The start date of the interval.
     * @param {JulianDate} stop The stop date of the interval.
     * @param {Boolean} [isStartIncluded=true] <code>true</code> if the start date is included in the interval, <code>false</code> otherwise.
     * @param {Boolean} [isStopIncluded=true] <code>true</code> if the stop date is included in the interval, <code>false</code> otherwise.
     * @param {Object} [data The data associated with this interval.
     *
     * @exception {DeveloperError} start must be specified.
     * @exception {DeveloperError} stop must be specified.
     *
     * @see TimeInterval.fromIso8601
     * @see TimeIntervalCollection
     * @see JulianDate
     *
     * @example
     * // Construct an Timeinterval closed on one end with a Color payload.
     * var interval = new TimeInterval(JulianDate.fromTotalDays(1000), JulianDate.fromTotalDays(1001), true, false, Color.WHITE);
     */
    var TimeInterval = function(start, stop, isStartIncluded, isStopIncluded, data) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start must be specified.');
        }

        if (typeof stop === 'undefined') {
            throw new DeveloperError('stop must be specified.');
        }

        if (typeof isStartIncluded === 'undefined') {
            isStartIncluded = true;
        }

        if (typeof isStopIncluded === 'undefined') {
            isStopIncluded = true;
        }

        var stopComparedToStart = JulianDate.compare(stop, start);

        /**
         * The start time of the interval.
         */
        this.start = start;
        /**
         * The stop time of the interval.
         */
        this.stop = stop;
        /**
         * The data associated with this interval.
         */
        this.data = data;
        /**
         * Indicates if <code>start</code> is included in the interval or not.
         */
        this.isStartIncluded = isStartIncluded;
        /**
         * Indicates if <code>stop</code> is included in the interval or not.
         */
        this.isStopIncluded = isStopIncluded;
        /**
         * Indicates if the interval is empty.
         */
        this.isEmpty = stopComparedToStart < 0 || (stopComparedToStart === 0 && (!isStartIncluded || !isStopIncluded));
    };

    /**
     * Creates an immutable TimeInterval from an ISO 8601 interval string.
     *
     * @memberof TimeInterval
     *
     * @param {String} iso8601String A valid ISO8601 interval.
     * @param {Boolean} [isStartIncluded=true] <code>true</code> if the start date is included in the interval, <code>false</code> otherwise.
     * @param {Boolean} [isStopIncluded=true] <code>true</code> if the stop date is included in the interval, <code>false</code> otherwise.
     * @param {Object} [data] The data associated with this interval.
     *
     * @return {TimeInterval} The new {@Link TimeInterval} instance or <code>undefined</code> if an invalid ISO8601 string is provided.
     *
     * @see TimeInterval
     * @see TimeIntervalCollection
     * @see JulianDate
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     *
     * @example
     * // Construct an open Timeinterval with a Cartesian data payload.
     * var interval = TimeInterval.fromIso8601('2012-03-15T11:02:24.55Z/2012-03-15T12:28:24.03Z', false, false, new Cartesian3(1,2,3));
     */
    TimeInterval.fromIso8601 = function(iso8601String, isStartIncluded, isStopIncluded, data) {
        var iso8601Interval = iso8601String.split('/');
        var intervalStart = JulianDate.fromIso8601(iso8601Interval[0]);
        var intervalStop = JulianDate.fromIso8601(iso8601Interval[1]);
        return new TimeInterval(intervalStart, intervalStop, isStartIncluded, isStopIncluded, data);
    };

    /**
     * Compares the provided TimeIntervals componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof TimeInterval
     *
     * @param {TimeInterval} [left] The first Cartesian.
     * @param {TimeInterval} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    TimeInterval.equals = function(left, right) {
        return left === right ||
               typeof left !== 'undefined' &&
               typeof right !== 'undefined' &&
               (left.isEmpty && right.isEmpty ||
                left.isStartIncluded === right.isStartIncluded &&
                left.isStopIncluded === right.isStopIncluded &&
                left.start.equals(right.start) &&
                left.stop.equals(right.stop));
    };

    /**
     * Compares the provided TimeIntervals componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof TimeInterval
     *
     * @param {TimeInterval} [left] The first TimeInterval.
     * @param {TimeInterval} [right] The second TimeInterval.
     * @param {Number} epsilon The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be number.
     */
    TimeInterval.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }

        return left === right ||
               typeof left !== 'undefined' &&
               typeof right !== 'undefined' &&
               (left.isEmpty && right.isEmpty ||
                left.isStartIncluded === right.isStartIncluded &&
                left.isStopIncluded === right.isStopIncluded &&
                left.start.equalsEpsilon(right.start, epsilon) &&
                left.stop.equalsEpsilon(right.stop, epsilon));
    };

    /**
     * Creates a copy of this TimeInterval.
     *
     * @returns A new TimeInterval that is equal to this interval.
     *
     * @memberof TimeInterval
     */
    TimeInterval.prototype.clone = function() {
        return new TimeInterval(this.start, this.stop, this.isStartIncluded, this.isStopIncluded, this.data);
    };

    /**
     * An empty interval.
     *
     * @memberof TimeInterval
     */
    TimeInterval.EMPTY = freezeObject(new TimeInterval(new JulianDate(0, 0, TimeStandard.TAI), new JulianDate(0, 0, TimeStandard.TAI), false, false));

    /**
     * Computes an interval which is the intersection of this interval with another while
     * also providing a means to merge the data of the two intervals.
     *
     * @param {TimeInterval} other The interval to intersect with this interval.
     * @param {Function} [mergeCallback] A callback which takes the data property from
     * both intervals as input and merges it into a single new value. If the callback is undefined,
     * this will intersect the two intervals and return the new interval with the data from this
     * interval.
     *
     * @return {TimeInterval} The new {@Link TimeInterval} that is the intersection of the two intervals,
     * with its data representing the merge of the data in the two existing intervals.
     */
    TimeInterval.prototype.intersect = function(other, mergeCallback) {
        if (typeof other === 'undefined') {
            return TimeInterval.EMPTY;
        }

        var otherStart = other.start;
        var otherStop = other.stop;
        var otherIsStartIncluded = other.isStartIncluded;
        var otherIsStopIncluded = other.isStopIncluded;

        var thisStart = this.start;
        var thisStop = this.stop;
        var thisIsStartIncluded = this.isStartIncluded;
        var thisIsStopIncluded = this.isStopIncluded;

        var outputData;
        var isStartIncluded;
        var isStopIncluded;

        if (otherStart.greaterThanOrEquals(thisStart) && thisStop.greaterThanOrEquals(otherStart)) {

            isStartIncluded = (!otherStart.equals(thisStart) && otherIsStartIncluded) || (thisIsStartIncluded && otherIsStartIncluded);

            isStopIncluded = thisIsStopIncluded && otherIsStopIncluded;

            outputData = typeof mergeCallback !== 'undefined' ? mergeCallback(this.data, other.data) : this.data;

            if (thisStop.greaterThanOrEquals(otherStop)) {
                isStopIncluded = isStopIncluded || (!otherStop.equals(thisStop) && otherIsStopIncluded);
                return new TimeInterval(otherStart, otherStop, isStartIncluded, isStopIncluded, outputData);
            }

            isStopIncluded = isStopIncluded || thisIsStopIncluded;
            return new TimeInterval(otherStart, thisStop, isStartIncluded, isStopIncluded, outputData);
        }

        if (otherStart.lessThanOrEquals(thisStart) && thisStart.lessThanOrEquals(otherStop)) {

            isStartIncluded = (otherStart.equals(thisStart) === false && thisIsStartIncluded) || (thisIsStartIncluded && otherIsStartIncluded);

            isStopIncluded = thisIsStopIncluded && otherIsStopIncluded;

            outputData = typeof mergeCallback !== 'undefined' ? mergeCallback(this.data, other.data) : this.data;
            if (thisStop.greaterThanOrEquals(otherStop)) {
                isStopIncluded = isStopIncluded || (otherStop.equals(thisStop) === false && otherIsStopIncluded);
                return new TimeInterval(thisStart, otherStop, isStartIncluded, isStopIncluded, outputData);
            }

            isStopIncluded = isStopIncluded || thisIsStopIncluded;
            return new TimeInterval(thisStart, thisStop, isStartIncluded, isStopIncluded, outputData);
        }

        return TimeInterval.EMPTY;
    };

    /**
     * Returns <code>true</code> if this interval contains the specified date.
     *
     * @memberof TimeInterval
     *
     * @param {JulianDate} date The date to check for.
     *
     * @return {Boolean} <code>true</code> if the TimeInterval contains the specified date, <code>false</code> otherwise.
     */
    TimeInterval.prototype.contains = function(date) {
        if (this.isEmpty) {
            return false;
        }

        var startComparedToDate = JulianDate.compare(this.start, date);
        // if (start == date)
        if (startComparedToDate === 0) {
            return this.isStartIncluded;
        }

        var dateComparedToStop = JulianDate.compare(date, this.stop);
        // if (date == stop)
        if (dateComparedToStop === 0) {
            return this.isStopIncluded;
        }

        // return start < date && date < stop
        return startComparedToDate < 0 && dateComparedToStop < 0;
    };

    /**
     * Compares this TimeInterval against the provided TimeInterval componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof TimeInterval
     *
     * @param {TimeInterval} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    TimeInterval.prototype.equals = function(other) {
        return TimeInterval.equals(this, other);
    };

    /**
     * Compares this TimeInterval against the provided TimeInterval componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof TimeInterval
     *
     * @param {TimeInterval} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    TimeInterval.prototype.equalsEpsilon = function(other, epsilon) {
        return TimeInterval.equalsEpsilon(this, other, epsilon);
    };

    return TimeInterval;
});
/*global define*/
define('Core/Iso8601',[
        './freezeObject',
        './JulianDate',
        './TimeInterval'
    ], function(
        freezeObject,
        JulianDate,
        TimeInterval) {
    

    var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
    var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
    var MAXIMUM_INTERVAL = freezeObject(new TimeInterval(MINIMUM_VALUE, MAXIMUM_VALUE, true, true));

    /**
     * Constants related to ISO8601 support.
     *
     * @exports Iso8601
     *
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     * @see JulianDate
     * @see TimeInterval
     */
    var Iso8601 = {
        /**
         * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
         * This is equivalent to the date string '0000-01-01T00:00:00Z'
         */
        MINIMUM_VALUE : MINIMUM_VALUE,

        /**
         * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
         * This is equivalent to the date string '9999-12-31T24:00:00Z'
         */
        MAXIMUM_VALUE : MAXIMUM_VALUE,

        /**
         * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
         * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
         */
        MAXIMUM_INTERVAL : MAXIMUM_INTERVAL
    };

    return Iso8601;
});
/*global define*/
define('Core/TimeIntervalCollection',[
        './DeveloperError',
        './binarySearch',
        './TimeInterval',
        './JulianDate'
       ], function(
         DeveloperError,
         binarySearch,
         TimeInterval,
         JulianDate) {
    

    function compareIntervalStartTimes(left, right) {
        return JulianDate.compare(left.start, right.start);
    }

    /**
     * A non-overlapping collection of TimeIntervals sorted by start date.
     *
     * @alias TimeIntervalCollection
     * @constructor
     *
     * @see TimeInterval
     * @see JulianDate
     *
     */
     var TimeIntervalCollection = function() {
        this._intervals = [];
    };

    /**
     * Gets the interval at the specified index.
     *
     * @memberof TimeIntervalCollection
     * @param {Number} index The index of the interval to retrieve.
     * @return {TimeInterval} The TimeInterval at the specified index, or undefined if no such index exists.
     * @exception {DeveloperError} index must be a number.
     */
    TimeIntervalCollection.prototype.get = function(index) {
        if (isNaN(index)) {
            throw new DeveloperError('index must be a number.');
        }
        return this._intervals[index];
    };

    /**
     * Gets the start date of the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {JulianDate} The start date of the collection or undefined if the collection is empty.
     */
    TimeIntervalCollection.prototype.getStart = function() {
        var thisIntervals = this._intervals;
        return thisIntervals.length === 0 ? undefined : thisIntervals[0].start;
    };

    /**
     * Gets the stop date of the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {JulianDate} The stop date of the collection or undefined if the collection is empty.
     */
    TimeIntervalCollection.prototype.getStop = function() {
        var thisIntervals = this._intervals;
        var length = thisIntervals.length;
        return length === 0 ? undefined : thisIntervals[length - 1].stop;
    };

    /**
     * Gets the number of intervals in the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {Number} The number of intervals in the collection.
     */
    TimeIntervalCollection.prototype.getLength = function() {
        return this._intervals.length;
    };

    /**
     * Clears the collection.
     *
     * @memberof TimeIntervalCollection
     */
    TimeIntervalCollection.prototype.clear = function() {
        this._intervals = [];
    };

    /**
     * Returns true if the collection is empty, false otherwise.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns true if the collection is empty, false otherwise.
     */
    TimeIntervalCollection.prototype.isEmpty = function() {
        return this._intervals.length === 0;
    };

    /**
     * Returns the interval which contains the specified date.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The interval containing the specified date, undefined if no such interval exists.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.findIntervalContainingDate = function(date) {
        var index = this.indexOf(date);
        return index >= 0 ? this._intervals[index] : undefined;
    };

    /**
     * Returns true if the specified date is contained in the interval collection.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns True if the specified date is contained in the interval collection, undefined otherwise.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.contains = function(date) {
        return this.indexOf(date) >= 0;
    };

    /**
     * Returns the index of the interval in the collection that contains the specified date.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The index of the interval which contains the specified date, if no such interval exists,
     * it returns a negative number which is the bitwise complement of the index of the next interval that
     * starts after the date, or if no interval starts after the specified date, the bitwise complement of
     * the length of the collection.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.indexOf = function(date) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date required');
        }
        var thisIntervals = this._intervals;
        var index = binarySearch(thisIntervals, new TimeInterval(date, date, true, true), compareIntervalStartTimes);
        if (index >= 0) {
            if (thisIntervals[index].isStartIncluded) {
                return index;
            }

            if (index > 0 &&
                thisIntervals[index - 1].stop.equals(date) &&
                thisIntervals[index - 1].isStopIncluded) {
                return index - 1;
            }
            return ~index;
        }

        index = ~index;
        if (index > 0 && (index - 1) < thisIntervals.length && thisIntervals[index - 1].contains(date)) {
            return index - 1;
        }
        return ~index;
    };

    /**
     * Returns the first interval in the collection that matches the specified parameters.
     * All parameters are optional and undefined parameters are treated as a don't care condition.
     *
     * @param {JulianDate} [start] The start of the interval.
     * @param {JulianDate} [stop] The end of the interval.
     * @param {JulianDate} [isStartIncluded] True if the start date is included.
     * @param {JulianDate} [isStopIncluded] True if the stop date is included.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The first interval in the collection that matches the specified parameters.
     */
    TimeIntervalCollection.prototype.findInterval = function(start, stop, isStartIncluded, isStopIncluded) {
        var thisIntervals = this._intervals, interval;
        for ( var i = 0, len = thisIntervals.length; i < len; i++) {
            interval = thisIntervals[i];
            if ((typeof start === 'undefined' || interval.start.equals(start)) &&
                (typeof stop === 'undefined' || interval.stop.equals(stop)) &&
                (typeof isStartIncluded === 'undefined' || interval.isStartIncluded === isStartIncluded) &&
                (typeof isStopIncluded === 'undefined' || interval.isStopIncluded === isStopIncluded)) {
                return thisIntervals[i];
            }
        }
        return undefined;
    };

    /**
     * Adds an interval to the collection, merging intervals that contain the same data and
     * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
     * The data in the new interval takes precedence over any existing intervals in the collection.
     *
     * @param {TimeInterval} interval The interval to add.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the Javascript equality operator is used.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} interval is required.
     */
    TimeIntervalCollection.prototype.addInterval = function(interval, equalsCallback) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError("interval is required");
        }
        if (!interval.isEmpty) {
            var comparison, index;
            var thisIntervals = this._intervals;

            // Handle the common case quickly: we're adding a new interval which is after all existing intervals.
            if (thisIntervals.length === 0 ||
                interval.start.greaterThan(thisIntervals[thisIntervals.length - 1].stop)) {
                thisIntervals.push(interval);
                return;
            }

            // Keep the list sorted by the start date
            index = binarySearch(thisIntervals, interval, compareIntervalStartTimes);
            if (index < 0) {
                index = ~index;
            } else {
                // interval's start date exactly equals the start date of at least one interval in the collection.
                // It could actually equal the start date of two intervals if one of them does not actually
                // include the date.  In that case, the binary search could have found either.  We need to
                // look at the surrounding intervals and their IsStartIncluded properties in order to make sure
                // we're working with the correct interval.
                if (index > 0 &&
                    interval.isStartIncluded &&
                    thisIntervals[index - 1].isStartIncluded &&
                    thisIntervals[index - 1].start.equals(interval.start)) {
                    --index;
                } else if (index < thisIntervals.length &&
                           !interval.isStartIncluded &&
                           thisIntervals[index].isStartIncluded &&
                           thisIntervals[index].start.equals(interval.start)) {
                    ++index;
                }
            }

            if (index > 0) {
                // Not the first thing in the list, so see if the interval before this one
                // overlaps this one.
                comparison = JulianDate.compare(thisIntervals[index - 1].stop, interval.start);
                if (comparison > 0 || (comparison === 0 && (thisIntervals[index - 1].isStopIncluded || interval.isStartIncluded))) {
                    // There is an overlap
                    if (typeof equalsCallback !== 'undefined' ? equalsCallback(thisIntervals[index - 1].data, interval.data) : (thisIntervals[index - 1].data === interval.data)) {
                        // Overlapping intervals have the same data, so combine them
                        if (interval.stop.greaterThan(thisIntervals[index - 1].stop)) {
                            interval = new TimeInterval(thisIntervals[index - 1].start,
                                                        interval.stop,
                                                        thisIntervals[index - 1].isStartIncluded,
                                                        interval.isStopIncluded,
                                                        interval.data);
                        } else {
                            interval = new TimeInterval(thisIntervals[index - 1].start,
                                                        thisIntervals[index - 1].stop,
                                                        thisIntervals[index - 1].isStartIncluded,
                                                        thisIntervals[index - 1].isStopIncluded || (interval.stop.equals(thisIntervals[index - 1].stop) && interval.isStopIncluded),
                                                        interval.data);
                        }
                        thisIntervals.splice(index - 1, 1);
                        --index;
                    } else {
                        // Overlapping intervals have different data.  The new interval
                        // being added 'wins' so truncate the previous interval.
                        // If the existing interval extends past the end of the new one,
                        // split the existing interval into two intervals.
                        comparison = JulianDate.compare(thisIntervals[index - 1].stop, interval.stop);
                        if (comparison > 0 || (comparison === 0 && thisIntervals[index - 1].isStopIncluded && !interval.isStopIncluded)) {
                            thisIntervals.splice(index - 1, 1,
                                                 new TimeInterval(thisIntervals[index - 1].start,
                                                                  interval.start,
                                                                  thisIntervals[index - 1].isStartIncluded,
                                                                  !interval.isStartIncluded,
                                                                  thisIntervals[index - 1].data),
                                                 new TimeInterval(interval.stop,
                                                                  thisIntervals[index - 1].stop,
                                                                  !interval.isStopIncluded,
                                                                  thisIntervals[index - 1].isStopIncluded,
                                                                  thisIntervals[index - 1].data));
                        } else {
                            thisIntervals[index - 1] = new TimeInterval(thisIntervals[index - 1].start,
                                                                        interval.start,
                                                                        thisIntervals[index - 1].isStartIncluded,
                                                                        !interval.isStartIncluded, thisIntervals[index - 1].data);
                        }
                    }
                }
            }

            while (index < thisIntervals.length) {
                // Not the last thing in the list, so see if the intervals after this one overlap this one.
                comparison = JulianDate.compare(interval.stop, thisIntervals[index].start);
                if (comparison > 0 ||
                    (comparison === 0 && (interval.isStopIncluded || thisIntervals[index].isStartIncluded))) {
                    // There is an overlap
                    if (typeof equalsCallback !== 'undefined' ? equalsCallback(thisIntervals[index].data, interval.data) : thisIntervals[index].data === interval.data) {
                        // Overlapping intervals have the same data, so combine them
                        interval = new TimeInterval(interval.start,
                                                    thisIntervals[index].stop.greaterThan(interval.stop) ? thisIntervals[index].stop : interval.stop,
                                                    interval.isStartIncluded,
                                                    thisIntervals[index].stop.greaterThan(interval.stop) ? thisIntervals[index].isStopIncluded : interval.isStopIncluded,
                                                    interval.data);
                        thisIntervals.splice(index, 1);
                    } else {
                        // Overlapping intervals have different data.  The new interval
                        // being added 'wins' so truncate the next interval.
                        thisIntervals[index] = new TimeInterval(interval.stop,
                                                                thisIntervals[index].stop,
                                                                !interval.isStopIncluded,
                                                                thisIntervals[index].isStopIncluded,
                                                                thisIntervals[index].data);
                        if (thisIntervals[index].isEmpty) {
                            thisIntervals.splice(index, 1);
                        } else {
                            // Found a partial span, so it is not possible for the next
                            // interval to be spanned at all.  Stop looking.
                            break;
                        }
                    }
                } else {
                    // Found the last one we're spanning, so stop looking.
                    break;
                }
            }

            // Add the new interval
            thisIntervals.splice(index, 0, interval);
        }
    };

    /**
     * Removes the specified interval from this interval collection, creating a hole over the specified interval.
     * The Data property of the input interval is ignored.
     *
     * @param {TimeInterval} interval The interval to remove.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns true if the interval was removed, false if no part of the interval was in the collection.
     *
     * @exception {DeveloperError} interval is required.
     */
    TimeIntervalCollection.prototype.removeInterval = function(interval) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError("interval is required");
        }

        if (interval.isEmpty) {
            return false;
        }

        var result = false;
        var thisIntervals = this._intervals;

        var index = binarySearch(thisIntervals, interval, compareIntervalStartTimes);
        if (index < 0) {
            index = ~index;
        }

        var intervalStart = interval.start;
        var intervalStop = interval.stop;
        var intervalIsStartIncluded = interval.isStartIncluded;
        var intervalIsStopIncluded = interval.isStopIncluded;

        // Check for truncation of the end of the previous interval.
        if (index > 0) {
            var indexMinus1 = thisIntervals[index - 1];
            var indexMinus1Stop = indexMinus1.stop;
            if (indexMinus1Stop.greaterThan(intervalStart) ||
                (indexMinus1Stop.equals(intervalStart) &&
                 indexMinus1.isStopIncluded && intervalIsStartIncluded)) {
                result = true;

                if (indexMinus1Stop.greaterThan(intervalStop) ||
                    (indexMinus1.isStopIncluded && !intervalIsStopIncluded && indexMinus1Stop.equals(intervalStop))) {
                    // Break the existing interval into two pieces
                    thisIntervals.splice(index, 0, new TimeInterval(intervalStop, indexMinus1Stop, !intervalIsStopIncluded, indexMinus1.isStopIncluded, indexMinus1.data));
                }
                thisIntervals[index - 1] = new TimeInterval(indexMinus1.start, intervalStart, indexMinus1.isStartIncluded, !intervalIsStartIncluded, indexMinus1.data);
            }
        }

        // Check if the Start of the current interval should remain because interval.start is the same but
        // it is not included.
        var indexInterval = thisIntervals[index];
        if (index < thisIntervals.length &&
            !intervalIsStartIncluded &&
            indexInterval.isStartIncluded &&
            intervalStart.equals(indexInterval.start)) {
            result = true;

            thisIntervals.splice(index, 0, new TimeInterval(indexInterval.start, indexInterval.start, true, true, indexInterval.data));
            ++index;
            indexInterval = thisIntervals[index];
        }

        // Remove any intervals that are completely overlapped by the input interval.
        while (index < thisIntervals.length &&
                intervalStop.greaterThan(indexInterval.stop)) {
            result = true;
            thisIntervals.splice(index, 1);
        }

        // Check for the case where the input interval ends on the same date
        // as an existing interval.
        if (index < thisIntervals.length && intervalStop.equals(indexInterval.stop)) {
            result = true;

            if (!intervalIsStopIncluded && indexInterval.isStopIncluded) {
                // Last point of interval should remain because the stop date is included in
                // the existing interval but is not included in the input interval.
                if ((index + 1) < thisIntervals.length && thisIntervals[index + 1].start.equals(intervalStop) && indexInterval.data === thisIntervals[index + 1].data) {
                    // Combine single point with the next interval
                    thisIntervals.splice(index, 1);
                    thisIntervals[index] = indexInterval = new TimeInterval(indexInterval.start, indexInterval.stop, true, indexInterval.isStopIncluded, indexInterval.data);
                } else {
                    thisIntervals[index] = indexInterval = new TimeInterval(intervalStop, intervalStop, true, true, indexInterval.data);
                }
            } else {
                // Interval is completely overlapped
                thisIntervals.splice(index, 1);
            }
        }

        // Truncate any partially-overlapped intervals.
        if (index < thisIntervals.length &&
            (intervalStop.greaterThan(indexInterval.start) ||
             (intervalStop.equals(indexInterval.start) &&
              intervalIsStopIncluded &&
              indexInterval.isStartIncluded))) {
            result = true;
            thisIntervals[index] = new TimeInterval(intervalStop, indexInterval.stop, !intervalIsStopIncluded, indexInterval.isStopIncluded, indexInterval.data);
        }

        return result;
    };

    /**
     * Creates a new TimeIntervalCollection which is the intersection of this collection
     * and the provided collection.
     *
     * @param {TimeIntervalCollection} timeIntervalCollection The collection to intersect with.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the Javascript equality operator is used.
     * @param {Function} [mergeCallback] An optional function which takes the data from two
     * TimeIntervals and returns a merged version of the data.  If this parameter is omitted,
     * the interval data from <code>this</code> collection will be used.
     *
     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} timeIntervalCollection is required.
     */
    TimeIntervalCollection.prototype.intersect = function(timeIntervalCollection, equalsCallback, mergeCallback) {
        if (typeof timeIntervalCollection === 'undefined') {
            throw new DeveloperError('timeIntervalCollection is required.');
        }
        return this._intersectInternal(timeIntervalCollection, equalsCallback, mergeCallback);
    };

    /**
     * Creates a new TimeIntervalCollection which is the intersection of this collection
     * and the provided interval.
     *
     * @param {TimeInterval} interval The interval to intersect with.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the equality operator will be used.
     * @param {Function} [mergeCallback] An optional function which takes the data from two
     * TimeIntervals and returns a merged version of the data.  If this parameter is omitted,
     * the interval data from <code>this</code> collection will be used.
     *
     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} timeIntervalCollection is required.
     */
    TimeIntervalCollection.prototype.intersectInterval = function(interval, equalsCallback, mergeCallback) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError('interval is required.');
        }
        var intervals = new TimeIntervalCollection();
        intervals.addInterval(interval);
        return this._intersectInternal(intervals, equalsCallback, mergeCallback);
    };

    TimeIntervalCollection.prototype._intersectInternal = function(intervals, equalsCallback, mergeCallback) {
        var left = 0;
        var right = 0;
        var result = new TimeIntervalCollection();
        var thisIntervals = this._intervals;
        var otherIntervals = intervals._intervals;

        while (left < thisIntervals.length && right < otherIntervals.length) {
            var leftInterval = thisIntervals[left];
            var rightInterval = otherIntervals[right];
            if (leftInterval.stop.lessThan(rightInterval.start)) {
                ++left;
            } else if (rightInterval.stop.lessThan(leftInterval.start)) {
                ++right;
            } else {
                // The following will return an intersection whose data is 'merged' if the callback is defined
                if (typeof mergeCallback !== 'undefined' ||
                   ((typeof equalsCallback !== 'undefined' && equalsCallback(leftInterval, rightInterval)) ||
                    (typeof equalsCallback === 'undefined' && rightInterval.data === leftInterval.data))) {

                    var intersection = leftInterval.intersect(rightInterval, mergeCallback);
                    if (!intersection.isEmpty) {
                        // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),
                        // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.
                        result.addInterval(intersection, equalsCallback);
                    }
                }

                if (leftInterval.stop.lessThan(rightInterval.stop) ||
                    (leftInterval.stop.equals(rightInterval.stop) &&
                     !leftInterval.isStopIncluded &&
                     rightInterval.isStopIncluded)) {
                    ++left;
                } else {
                    ++right;
                }
            }
        }
        return result;
    };

    return TimeIntervalCollection;
});

/*global define*/
define('Core/computeSunPosition',[
        './isLeapYear',
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Cartographic',
        './Matrix3',
        './JulianDate'
    ],
    function(
        isLeapYear,
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Cartographic,
        Matrix3,
        JulianDate) {
    

    var offSets = [0,  // January
                   31, // February
                   59, // March
                   90, // April
                   120,// May
                   151,// June
                   181,// July
                   212,// August
                   243,// September
                   273,// October
                   304,// November
                   334 // December
                  ];

    var scratch = new Cartesian3();
    var transform = new Matrix3(0.0, 0.0, 0.0,
                                0.0, 1.0, 0.0,
                                0.0, 0.0, 0.0);

    var AU_TO_METERS = 149597870700.0;

    var direction = new Cartesian3();

    /**
     * Computes the position of the Sun in Earth's fixed frame.
     * @exports computeSunPosition
     *
     * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} julianDate is required.
     *
     * @example
     * var sunPosition = computeSunPosition(new JulianDate());
     */
    var computeSunPosition = function(julianDate, result) {
        if (typeof julianDate === 'undefined') {
            julianDate = new JulianDate();
        }

        var T = (julianDate.getTotalDays() - 2451545.0) / 36525;
        var meanAnomaly = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(357.5277233 + 35999.05034 * T));
        var distanceToSunInAU = 1.000140612 - 0.016708617 * Math.cos(meanAnomaly) - 0.000139589 * Math.cos(2 * meanAnomaly);

        var date = julianDate.toDate();
        var month = date.getUTCMonth();
        var dayOfYear = date.getUTCDate() + offSets[month];

        if (isLeapYear(date.getUTCFullYear()) && month > 1) {
            dayOfYear++;
        }

        var temp = CesiumMath.toRadians((360.0 / 365.0) * (dayOfYear - 81.0));
        var equationOfTime = 9.87 * Math.sin(2 * temp) - 7.53 * Math.cos(temp) - 1.5 * Math.sin(temp);
        var timeFraction = julianDate.getJulianTimeFraction();
        var localTime;
        if (timeFraction >= 0.5) {
            localTime = timeFraction * 24.0 - 12.0;
        } else {
            localTime = 12.0 + timeFraction * 24.0;
        }
        var localSolarTime = localTime + (equationOfTime / 60.0);
        var hourAngle = CesiumMath.toRadians(15.0 * (12.0 - localSolarTime));
        var declinationAngle = Math.asin(0.39795 * Math.cos(CesiumMath.toRadians(0.98563 * (dayOfYear - 173.0))));

        var latitudeAngle = 0.0;

        var cosLatitudeAngle = Math.cos(latitudeAngle);
        var sinLatitudeAngle = Math.sin(latitudeAngle);

        //Since some of these are constant,
        //there's no need to set them every time.
        transform[0] = cosLatitudeAngle;
        //transform[1] = 0.0;
        transform[2] = -sinLatitudeAngle;
        //transform[3] = 0.0;
        //transform[4] = 1.0;
        //transform[5] = 0.0;
        transform[6] = sinLatitudeAngle;
        //transform[7] = 0.0;
        transform[8] = cosLatitudeAngle;

        var cosDeclinationAngle = Math.cos(declinationAngle);
        scratch.x = cosDeclinationAngle * Math.cos(hourAngle);
        scratch.y = cosDeclinationAngle * Math.sin(hourAngle);
        scratch.z = Math.sin(declinationAngle);

        Matrix3.multiplyByVector(transform, scratch, direction);
        var distance = distanceToSunInAU * AU_TO_METERS;

        return direction.multiplyByScalar(distance, result);
    };

    return computeSunPosition;
});

/*global define*/
define('Core/pointInsideTriangle2D',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     *
     * @param point
     * @param p0
     * @param p1
     * @param p2
     *
     * @exports pointInsideTriangle2D
     *
     * @exception {DeveloperError} point, p0, p1, and p2 are required.
     */
    var pointInsideTriangle2D = function(point, p0, p1, p2) {
        if (!point || !p0 || !p1 || !p2) {
            throw new DeveloperError('point, p0, p1, and p2 are required.');
        }

        // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.
        var v0 = p1.subtract(p0);
        var v1 = p2.subtract(p0);
        var v2 = point.subtract(p0);

        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);

        var q = 1.0 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * q;
        var v = (dot00 * dot12 - dot01 * dot02) * q;

        return (u > 0) && (v > 0) && (u + v < 1);
    };

    return pointInsideTriangle2D;
});

/*global define*/
define('Core/PolygonPipeline',[
        './DeveloperError',
        './Math',
        './Cartesian2',
        './Cartesian3',
        './Ellipsoid',
        './EllipsoidTangentPlane',
        './defaultValue',
        './pointInsideTriangle2D',
        './ComponentDatatype',
        './PrimitiveType',
        './Queue',
        './WindingOrder'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian2,
        Cartesian3,
        Ellipsoid,
        EllipsoidTangentPlane,
        defaultValue,
        pointInsideTriangle2D,
        ComponentDatatype,
        PrimitiveType,
        Queue,
        WindingOrder) {
    

    function DoublyLinkedList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    DoublyLinkedList.prototype.add = function(item) {
        if (item) {
            var node = {
                item : item,
                previous : this.tail,
                next : null
            };

            if (this.tail) {
                this.tail.next = node;
                this.tail = node;
            } else {
                // Insert into empty list.
                this.head = node;
                this.tail = node;
            }

            ++this.length;
        }
    };

    DoublyLinkedList.prototype.remove = function(item) {
        if (item) {
            if (item.previous && item.next) {
                item.previous.next = item.next;
                item.next.previous = item.previous;
            } else if (item.previous) {
                // Remove last node.
                item.previous.next = null;
                this.tail = item.previous;
            } else if (item.next) {
                // Remove first node.
                item.next.previous = null;
                this.head = item.next;
            } else {
                // Remove last node in linked list.
                this.head = null;
                this.tail = null;
            }

            --this.length;
        }
    };

    function isTipConvex(p0, p1, p2) {
        var u = p1.subtract(p0);
        var v = p2.subtract(p1);

        // Use the sign of the z component of the cross product
        return ((u.x * v.y) - (u.y * v.x)) >= 0.0;
    }

    /**
     * Returns the index of the vertex with the maximum X value.
     *
     * @param {Array} positions An array of the Cartesian points defining the polygon's vertices.
     * @returns {Number} The index of the positions with the maximum X value.
     *
     * @private
     */
    function getRightmostPositionIndex(positions) {
        var maximumX = positions[0].x;
        var rightmostPositionIndex = 0;
        for ( var i = 0; i < positions.length; i++) {
            if (positions[i].x > maximumX) {
                maximumX = positions[i].x;
                rightmostPositionIndex = i;
            }
        }
        return rightmostPositionIndex;
    }

    /**
     * Returns the index of the ring that contains the rightmost vertex.
     *
     * @param {Array} rings An array of arrays of Cartesians. Each array contains the vertices defining a polygon.
     * @returns {Number} The index of the ring containing the rightmost vertex.
     *
     * @private
     */
    function getRightmostRingIndex(rings) {
        var rightmostX = rings[0][0].x;
        var rightmostRingIndex = 0;
        for ( var ring = 0; ring < rings.length; ring++) {
            var maximumX = rings[ring][getRightmostPositionIndex(rings[ring])].x;
            if (maximumX > rightmostX) {
                rightmostX = maximumX;
                rightmostRingIndex = ring;
            }
        }

        return rightmostRingIndex;
    }

    /**
     * Returns a list containing the reflex vertices for a given polygon.
     *
     * @param {Array} polygon An array of Cartesian elements defining the polygon.
     * @returns {Array}
     *
     * @private
     */
    function getReflexVertices(polygon) {
        var reflexVertices = [];
        for ( var i = 0; i < polygon.length; i++) {
            var p0 = polygon[((i - 1) + polygon.length) % polygon.length];
            var p1 = polygon[i];
            var p2 = polygon[(i + 1) % polygon.length];

            if (!isTipConvex(p0, p1, p2)) {
                reflexVertices.push(p1);
            }
        }
        return reflexVertices;
    }

    /**
     * Returns true if the given point is contained in the list of positions.
     *
     * @param {Array} positions A list of Cartesian elements defining a polygon.
     * @param {Cartesian} point The point to check.
     * @returns {Boolean} <code>true></code> if <code>point</code> is found in <code>polygon</code>, <code>false</code> otherwise.
     *
     * @private
     */
    function isVertex(positions, point) {
        for ( var i = 0; i < positions.length; i++) {
            if (point.equals(positions[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * Given a point inside a polygon, find the nearest point directly to the right that lies on one of the polygon's edges.
     *
     * @param {Cartesian} point A point inside the polygon defined by <code>ring</code>.
     * @param {Array} ring A list of Cartesian points defining a polygon.
     * @param {Array} [edgeIndices]  An array containing the indices two endpoints of the edge containing the intersection.
     *
     * @returns {Cartesian} The intersection point.
     * @private
     */
    function intersectPointWithRing(point, ring, edgeIndices) {
        edgeIndices = defaultValue(edgeIndices, []);

        var minDistance = Number.MAX_VALUE;
        var rightmostVertexIndex = getRightmostPositionIndex(ring);
        var intersection = new Cartesian3(ring[rightmostVertexIndex].x, point.y, 0.0);
        edgeIndices.push(rightmostVertexIndex);
        edgeIndices.push((rightmostVertexIndex + 1) % ring.length);

        var boundaryMinX = ring[0].x;
        var boundaryMaxX = boundaryMinX;
        for ( var i = 1; i < ring.length; ++i) {
            if (ring[i].x < boundaryMinX) {
                boundaryMinX = ring[i].x;
            } else if (ring[i].x > boundaryMaxX) {
                boundaryMaxX = ring[i].x;
            }
        }
        boundaryMaxX += (boundaryMaxX - boundaryMinX);
        var point2 = new Cartesian3(boundaryMaxX, point.y, 0.0);

        // Find the nearest intersection.
        for (i = 0; i < ring.length; i++) {
            var v1 = ring[i];
            var v2 = ring[(i + 1) % ring.length];

            if (((v1.x >= point.x) || (v2.x >= point.x)) && (((v1.y >= point.y) && (v2.y <= point.y)) || ((v1.y <= point.y) && (v2.y >= point.y)))) {
                var temp = ((v2.y - v1.y) * (point2.x - point.x)) - ((v2.x - v1.x) * (point2.y - point.y));
                if (temp !== 0.0) {
                    temp = 1.0 / temp;
                    var ua = (((v2.x - v1.x) * (point.y - v1.y)) - ((v2.y - v1.y) * (point.x - v1.x))) * temp;
                    var ub = (((point2.x - point.x) * (point.y - v1.y)) - ((point2.y - point.y) * (point.x - v1.x))) * temp;
                    if ((ua >= 0.0) && (ua <= 1.0) && (ub >= 0.0) && (ub <= 1.0)) {
                        var tempIntersection = new Cartesian2(point.x + ua * (point2.x - point.x), point.y + ua * (point2.y - point.y));
                        var dist = tempIntersection.subtract(point);
                        temp = dist.magnitudeSquared();
                        if (temp < minDistance) {
                            intersection = tempIntersection;
                            minDistance = temp;
                            edgeIndices[0] = i;
                            edgeIndices[1] = (i + 1) % ring.length;
                        }
                    }
                }
            }
        }

        return intersection;
    }

    /**
     * Given an outer ring and multiple inner rings, determine the point on the outer ring that is visible
     * to the rightmost vertex of the rightmost inner ring.
     *
     * @param {Array} outerRing An array of Cartesian points defining the outer boundary of the polygon.
     * @param {Array} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.
     * @returns {Number} The index of the vertex in <code>outerRing</code> that is mutually visible to the rightmost vertex in <code>inenrRing</code>.
     *
     * @private
     */
    function getMutuallyVisibleVertexIndex(outerRing, innerRings) {
        var innerRingIndex = getRightmostRingIndex(innerRings);
        var innerRing = innerRings[innerRingIndex];
        var innerRingVertexIndex = getRightmostPositionIndex(innerRing);
        var innerRingVertex = innerRing[innerRingVertexIndex];
        var edgeIndices = [];
        var intersection = intersectPointWithRing(innerRingVertex, outerRing, edgeIndices);

        var visibleVertex;
        if (isVertex(outerRing, intersection)) {
            visibleVertex = intersection;
        } else {
            // Set P to be the edge endpoint closest to the inner ring vertex
            var d1 = (outerRing[edgeIndices[0]].subtract(innerRingVertex)).magnitudeSquared();
            var d2 = (outerRing[edgeIndices[1]].subtract(innerRingVertex)).magnitudeSquared();
            var p = (d1 < d2) ? outerRing[edgeIndices[0]] : outerRing[edgeIndices[1]];

            var reflexVertices = getReflexVertices(outerRing);
            var reflexIndex = reflexVertices.indexOf(p);
            if (reflexIndex !== -1) {
                reflexVertices.splice(reflexIndex, 1); // Do not include p if it happens to be reflex.
            }

            var pointsInside = [];
            for ( var i = 0; i < reflexVertices.length; i++) {
                var vertex = reflexVertices[i];
                if (pointInsideTriangle2D(vertex, innerRingVertex, intersection, p)) {
                    pointsInside.push(vertex);
                }
            }

            // If all reflexive vertices are outside the triangle formed by points
            // innerRingVertex, intersection and P, then P is the visible vertex.
            // Otherwise, return the reflex vertex that minimizes the angle between <1,0> and <k, reflex>.
            var minAngle = Number.MAX_VALUE;
            if (pointsInside.length > 0) {
                var v1 = new Cartesian2(1.0, 0.0, 0.0);
                for (i = 0; i < pointsInside.length; i++) {
                    var v2 = pointsInside[i].subtract(innerRingVertex);
                    var denominator = v1.magnitude() * v2.magnitude();
                    if (denominator !== 0) {
                        var angle = Math.abs(Math.acos(v1.dot(v2) / denominator));
                        if (angle < minAngle) {
                            minAngle = angle;
                            p = pointsInside[i];
                        }
                    }
                }
            }
            visibleVertex = p;
        }

        return outerRing.indexOf(visibleVertex);
    }

    /**
     * Given a polygon defined by an outer ring with one or more inner rings (holes), return a single list of points representing
     * a polygon with the rightmost hole added to it. The added hole is removed from <code>innerRings</code>.
     *
     * @param {Array} outerRing An array of Cartesian points defining the outer boundary of the polygon.
     * @param {Array} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.
     *
     * @return A single list of Cartesian points defining the polygon, including the eliminated inner ring.
     *
     * @private
     */
    function eliminateHole(outerRing, innerRings, ellipsoid) {
        // Check that the holes are defined in the winding order opposite that of the outer ring.
        var windingOrder = PolygonPipeline.computeWindingOrder2D(outerRing);
        for ( var i = 0; i < innerRings.length; i++) {
            var ring = innerRings[i];

            // Ensure each hole's first and last points are the same.
            if (!(ring[0]).equals(ring[ring.length - 1])) {
                ring.push(ring[0]);
            }

            var innerWindingOrder = PolygonPipeline.computeWindingOrder2D(ring);
            if (innerWindingOrder === windingOrder) {
                ring.reverse();
            }
        }

        // Project points onto a tangent plane to find the mutually visible vertex.
        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);
        var tangentOuterRing = tangentPlane.projectPointsOntoPlane(outerRing);
        var tangentInnerRings = [];
        for (i = 0; i < innerRings.length; i++) {
            tangentInnerRings.push(tangentPlane.projectPointsOntoPlane(innerRings[i]));
        }

        var visibleVertexIndex = getMutuallyVisibleVertexIndex(tangentOuterRing, tangentInnerRings);
        var innerRingIndex = getRightmostRingIndex(tangentInnerRings);
        var innerRingVertexIndex = getRightmostPositionIndex(tangentInnerRings[innerRingIndex]);

        var innerRing = innerRings[innerRingIndex];
        var newPolygonVertices = [];

        for (i = 0; i < outerRing.length; i++) {
            newPolygonVertices.push(outerRing[i]);
        }

        var j;
        var holeVerticesToAdd = [];

        // If the rightmost inner vertex is not the starting and ending point of the ring,
        // then some other point is duplicated in the inner ring and should be skipped once.
        if (innerRingVertexIndex !== 0) {
            for (j = 0; j <= innerRing.length; j++) {
                var index = (j + innerRingVertexIndex) % innerRing.length;
                if (index !== 0) {
                    holeVerticesToAdd.push(innerRing[index]);
                }
            }
        } else {
            for (j = 0; j < innerRing.length; j++) {
                holeVerticesToAdd.push(innerRing[(j + innerRingVertexIndex) % innerRing.length]);
            }
        }

        var lastVisibleVertexIndex = newPolygonVertices.lastIndexOf(outerRing[visibleVertexIndex]);

        holeVerticesToAdd.push(outerRing[lastVisibleVertexIndex]);

        var front = newPolygonVertices.slice(0, lastVisibleVertexIndex + 1);
        var back = newPolygonVertices.slice(lastVisibleVertexIndex + 1);
        newPolygonVertices = front.concat(holeVerticesToAdd, back);

        innerRings.splice(innerRingIndex, 1);

        return newPolygonVertices;
    }

    var scaleToGeodeticHeightN = new Cartesian3();
    var scaleToGeodeticHeightP = new Cartesian3();

    /**
     * DOC_TBA
     *
     * @exports PolygonPipeline
     */
    var PolygonPipeline = {
        /**
         * DOC_TBA
         *
         * Cleans up a simple polygon by removing duplicate adjacent positions and making
         * the first position not equal the last position.
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        cleanUp : function(positions) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var cleanedPositions = [];

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                if (!v0.equals(v1)) {
                    cleanedPositions.push(v1); // Shallow copy!
                }
            }

            return cleanedPositions;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeArea2D : function(positions) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var area = 0.0;

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                area += (v0.x * v1.y) - (v1.x * v0.y);
            }

            return area * 0.5;
        },

        /**
         * DOC_TBA
         *
         * @return {WindingOrder} DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeWindingOrder2D : function(positions) {
            var area = PolygonPipeline.computeArea2D(positions);
            return (area >= 0.0) ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        earClip2D : function(positions) {
            // PERFORMANCE_IDEA:  This is slow at n^3.  Make it faster with:
            //   * http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
            //   * http://cgm.cs.mcgill.ca/~godfried/publications/triangulation.held.ps.gz
            //   * http://blogs.agi.com/insight3d/index.php/2008/03/20/triangulation-rhymes-with-strangulation/

            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var remainingPositions = new DoublyLinkedList();

            for ( var i = 0; i < length; ++i) {
                remainingPositions.add({
                    position : positions[i],
                    index : i
                });
            }

            var indices = [];

            var previousNode = remainingPositions.head;
            var node = previousNode.next;
            var nextNode = node.next;

            var bailCount = length * length;

            while (remainingPositions.length > 3) {
                var p0 = previousNode.item.position;
                var p1 = node.item.position;
                var p2 = nextNode.item.position;

                if (isTipConvex(p0, p1, p2)) {
                    var isEar = true;

                    for ( var n = (nextNode.next ? nextNode.next : remainingPositions.head); n !== previousNode; n = (n.next ? n.next : remainingPositions.head)) {
                        if (pointInsideTriangle2D(n.item.position, p0, p1, p2)) {
                            isEar = false;
                            break;
                        }
                    }

                    if (isEar) {
                        indices.push(previousNode.item.index);
                        indices.push(node.item.index);
                        indices.push(nextNode.item.index);

                        remainingPositions.remove(node);

                        node = nextNode;
                        nextNode = nextNode.next ? nextNode.next : remainingPositions.head;
                        continue;
                    }
                }

                previousNode = previousNode.next ? previousNode.next : remainingPositions.head;
                node = node.next ? node.next : remainingPositions.head;
                nextNode = nextNode.next ? nextNode.next : remainingPositions.head;

                if (--bailCount === 0) {
                    break;
                }
            }

            var n0 = remainingPositions.head;
            var n1 = n0.next;
            var n2 = n1.next;
            indices.push(n0.item.index);
            indices.push(n1.item.index);
            indices.push(n2.item.index);

            return indices;
        },

        /**
         * DOC_TBA
         *
         * @param {DOC_TBA} positions DOC_TBA
         * @param {DOC_TBA} indices DOC_TBA
         * @param {Number} [granularity] DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} indices is required.
         * @exception {DeveloperError} At least three indices are required.
         * @exception {DeveloperError} The number of indices must be divisable by three.
         * @exception {DeveloperError} Granularity must be greater than zero.
         */
        computeSubdivision : function(positions, indices, granularity) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            if (!indices) {
                throw new DeveloperError('indices is required.');
            }

            if (indices.length < 3) {
                throw new DeveloperError('At least three indices are required.');
            }

            if (indices.length % 3 !== 0) {
                throw new DeveloperError('The number of indices must be divisable by three.');
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            // Use a queue for triangles that need (or might need) to be subdivided.
            var triangles = new Queue();

            var indicesLength = indices.length;
            for ( var j = 0; j < indicesLength; j += 3) {
                triangles.enqueue({
                    i0 : indices[j],
                    i1 : indices[j + 1],
                    i2 : indices[j + 2]
                });
            }

            // New positions due to edge splits are appended to the positions list.
            var subdividedPositions = positions.slice(0); // shadow copy!
            var subdividedIndices = [];

            // Used to make sure shared edges are not split more than once.
            var edges = {};

            var i;
            while (triangles.length > 0) {
                var triangle = triangles.dequeue();

                var v0 = subdividedPositions[triangle.i0];
                var v1 = subdividedPositions[triangle.i1];
                var v2 = subdividedPositions[triangle.i2];

                var g0 = v0.angleBetween(v1);
                var g1 = v1.angleBetween(v2);
                var g2 = v2.angleBetween(v0);

                var max = Math.max(g0, Math.max(g1, g2));
                var edge;

                if (max > granularity) {
                    if (g0 === max) {
                        edge = Math.min(triangle.i0, triangle.i1).toString() + ' ' + Math.max(triangle.i0, triangle.i1).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v0.add(v1).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i0,
                            i1 : i,
                            i2 : triangle.i2
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i1,
                            i2 : triangle.i2
                        });
                    } else if (g1 === max) {
                        edge = Math.min(triangle.i1, triangle.i2).toString() + ' ' + Math.max(triangle.i1, triangle.i2).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v1.add(v2).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i1,
                            i1 : i,
                            i2 : triangle.i0
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i2,
                            i2 : triangle.i0
                        });
                    } else if (g2 === max) {
                        edge = Math.min(triangle.i2, triangle.i0).toString() + ' ' + Math.max(triangle.i2, triangle.i0).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v2.add(v0).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i2,
                            i1 : i,
                            i2 : triangle.i1
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i0,
                            i2 : triangle.i1
                        });
                    }
                } else {
                    subdividedIndices.push(triangle.i0);
                    subdividedIndices.push(triangle.i1);
                    subdividedIndices.push(triangle.i2);
                }
            }

            // PERFORMANCE_IDEA Rather that waste time re-iterating the entire set of positions
            // here, all of the above code can be refactored to flatten as values are added
            // Removing the need for this for loop.
            var length = subdividedPositions.length;
            var flattenedPositions = new Array(length * 3);
            var q = 0;
            for (i = 0; i < length; i++) {
                var item = subdividedPositions[i];
                flattenedPositions[q++] = item.x;
                flattenedPositions[q++] = item.y;
                flattenedPositions[q++] = item.z;
            }

            return {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : flattenedPositions
                    }
                },

                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : subdividedIndices
                }]
            };
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} ellipsoid is required.
         */
        scaleToGeodeticHeight : function(mesh, height, ellipsoid) {
            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

            var n = scaleToGeodeticHeightN;
            var p = scaleToGeodeticHeightP;

            height = height || 0.0;

            if (mesh && mesh.attributes && mesh.attributes.position) {
                var positions = mesh.attributes.position.values;
                var length = positions.length;

                for ( var i = 0; i < length; i += 3) {
                    p.x = positions[i];
                    p.y = positions[i + 1];
                    p.z = positions[i + 2];

                    ellipsoid.scaleToGeodeticSurface(p, p);
                    ellipsoid.geodeticSurfaceNormal(p, n);
                    Cartesian3.multiplyByScalar(n, height, n);
                    Cartesian3.add(p, n, p);

                    positions[i] = p.x;
                    positions[i + 1] = p.y;
                    positions[i + 2] = p.z;
                }
            }

            return mesh;
        },

        /**
         * Given a polygon defined by an outer ring with one or more inner rings (holes), return a single list of points representing
         * a polygon defined by the outer ring with the inner holes removed.
         *
         * @param {Array} outerRing An array of Cartesian points defining the outer boundary of the polygon.
         * @param {Array} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.
         *
         * @return A single list of Cartesian points defining the polygon, including the eliminated inner ring.
         *
         * @exception {DeveloperError} <code>outerRing</code> is required.
         * @exception {DeveloperError} <code>outerRing</code> must not be empty.
         * @exception {DeveloperError} <code>innerRings</code> is required.
         *
         * @example
         * // Simplifying a polygon with multiple holes.
         * outerRing = PolygonPipeline.eliminateHoles(outerRing, innerRings);
         * polygon.setPositions(outerRing);
         */
        eliminateHoles : function(outerRing, innerRings, ellipsoid) {
            if (typeof outerRing === 'undefined') {
                throw new DeveloperError('outerRing is required.');
            }
            if (outerRing.length === 0) {
                throw new DeveloperError('outerRing must not be empty.');
            }
            if (typeof innerRings === 'undefined') {
                throw new DeveloperError('innerRings is required.');
            }
            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

            var innerRingsCopy = [];
            for ( var i = 0; i < innerRings.length; i++) {
                var innerRing = [];
                for ( var j = 0; j < innerRings[i].length; j++) {
                    innerRing.push(Cartesian3.clone(innerRings[i][j]));
                }
                innerRingsCopy.push(innerRing);
            }

            var newPolygonVertices = outerRing;
            while (innerRingsCopy.length > 0) {
                newPolygonVertices = eliminateHole(newPolygonVertices, innerRingsCopy, ellipsoid);
            }
            return newPolygonVertices;
        }
    };

    return PolygonPipeline;
});
/*global define*/
define('Core/requestAnimationFrame',[],function() {
    

    var requestAnimationFrameImplementation = window.requestAnimationFrame;

    // look for vendor prefixed function
    if (typeof requestAnimationFrameImplementation === 'undefined') {
        var vendors = ['webkit', 'moz', 'ms', 'o'];
        var i = 0;
        var len = vendors.length;
        while (i < len && typeof requestAnimationFrameImplementation === 'undefined') {
            requestAnimationFrameImplementation = window[vendors[i] + 'RequestAnimationFrame'];
            ++i;
        }
    }

    // build an implementation based on setTimeout
    if (typeof requestAnimationFrameImplementation === 'undefined') {
        var lastFrameTime = 0;
        requestAnimationFrameImplementation = function(callback) {
            var currentTime = Date.now();

            // schedule the callback to target 60fps, 16.7ms per frame,
            // accounting for the time taken by the callback
            var delay = Math.max(16 - (currentTime - lastFrameTime), 0);
            lastFrameTime = currentTime + delay;

            return setTimeout(function() {
                callback(lastFrameTime);
            }, delay);
        };
    }

    /**
     * A browser-independent function to request a new animation frame.  This is used to create
     * an application's draw loop as shown in the example below.
     *
     * @exports requestAnimationFrame
     *
     * @param {Function} callback The function to call when animation is ready.
     *
     * @example
     * // Create a draw loop using requestAnimationFrame. The
     * // tick callback function is called for every animation frame.
     * function tick() {
     *   scene.render();
     *   requestAnimationFrame(tick);
     * }
     * tick();
     *
     * @see <a href='http://www.w3.org/TR/animation-timing/#the-WindowAnimationTiming-interface'>The WindowAnimationTiming interface</a>
     */
    var requestAnimationFrame = function(callback) {
        // we need this extra wrapper function because the native requestAnimationFrame
        // functions must be invoked on the global scope (window), which is not the case
        // if invoked as Cesium.requestAnimationFrame(callback)
        requestAnimationFrameImplementation(callback);
    };
    return requestAnimationFrame;
});
/*global define*/
define('DynamicScene/CzmlBoolean',[],function() {
    

    /**
     * Provides methods for working with a boolean defined in CZML.
     *
     * @exports CzmlBoolean
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlBoolean = {
        /**
         * Returns the packed boolean representation contained within the provided CZML interval
         * or undefined if the interval does not contain boolean data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            /*jshint sub:true*/
            var result = czmlInterval['boolean']; // boolean is a JS reserved word
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since CZML booleans can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the boolean value contained within the unwrappedInterval.  For booleans
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlBoolean.unwrapInterval.
         * @returns The boolean value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlBoolean;
});
/*global define*/
define('DynamicScene/CzmlCartesian2',[
        '../Core/Cartesian2'
       ], function(
         Cartesian2) {
    

    var doublesPerValue = 2;

    /**
     * Provides methods for working with a Cartesian2 defined in CZML.
     *
     * @exports CzmlCartesian2
     *
     * @see Cartesian2
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartesian2 = {
        /**
         * The number of doubles per packed Cartesian2 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian2 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian2 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.cartesian2;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian2.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian2 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian2.unwrapInterval.
         * @param {Cartesian2} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian2 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian2();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            return result;
        },

        /**
         * Given a packed array of x and y values, extracts a Cartesian2 instance.
         *
         * @param {Array} array A packed array of Cartesian2 values, where every two elements represents an x,y pair.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian2 you would like.
         * @param {Cartesian2} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian2 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian2();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            return result;
        }
    };

    return CzmlCartesian2;
});
/*global define*/
define('DynamicScene/CzmlCartesian3',[
        '../Core/Cartesian3'
       ], function(
         Cartesian3) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a Cartesian3 defined in CZML.
     *
     * @exports CzmlCartesian3
     *
     * @see Cartesian3
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartesian3 = {
         /**
         * The number of doubles per packed Cartesian3 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian3 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian3 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.cartesian;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian3.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian3 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian3.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            return result;
        },

        /**
         * Given a packed array of x, y, and z values, extracts a Cartesian3 instance.
         *
         * @param {Array} array A packed array of Cartesian3 values, where every three elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian3 you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            return result;
        }
    };

    return CzmlCartesian3;
});
/*global define*/
define('DynamicScene/CzmlCartographic',[
        '../Core/Cartographic',
        '../Core/Math'
       ], function(
         Cartographic,
         CesiumMath) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a Cartographic defined in CZML.
     *
     * @exports CzmlCartographic
     *
     * @see Cartographic
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartographic = {
        /**
         * The number of doubles per packed Cartographic value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartographic representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartographic data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var cartographic = czmlInterval.cartographicRadians;
            if (typeof cartographic !== 'undefined') {
                return cartographic;
            }

            var cartographicDegrees = czmlInterval.cartographicDegrees;
            if (typeof cartographicDegrees === 'undefined') {
                return undefined;
            }

            if (!this.isSampled(cartographicDegrees)) {
                return [CesiumMath.toRadians(cartographicDegrees[0]),
                        CesiumMath.toRadians(cartographicDegrees[1]),
                        cartographicDegrees[2]];
            }

            var len = cartographicDegrees.length;
            cartographic = new Array(len);
            for ( var i = 0; i < len; i += 4) {
                cartographic[i] = cartographicDegrees[i];
                cartographic[i + 1] = CesiumMath.toRadians(cartographicDegrees[i + 1]);
                cartographic[i + 2] = CesiumMath.toRadians(cartographicDegrees[i + 2]);
                cartographic[i + 3] = cartographicDegrees[i + 3];
            }
            return cartographic;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartographic.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartographic instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartographic.unwrapInterval.
         * @param {Cartographic} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartographic instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartographic();
            }
            result.longitude = unwrappedInterval[0];
            result.latitude = unwrappedInterval[1];
            result.height = unwrappedInterval[2];
            return result;
        },

        /**
         * Given a packed array of longitude, latitude, and height values, extracts a Cartographic instance.
         *
         * @param {Array} array A packed array of Cartographic values, where every three elements represents a Cartographic.
         * @param {Number} startingIndex The index into the array that contains the longitude value of the Cartographic you would like.
         * @param {Cartographic} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartographic instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartographic();
            }
            result.longitude = array[startingIndex];
            result.latitude = array[startingIndex + 1];
            result.height = array[startingIndex + 2];
            return result;
        }
    };

    return CzmlCartographic;
});
/*global define*/
define('DynamicScene/CzmlColor',[
        '../Core/Color'
       ], function(
         Color) {
    

    var doublesPerValue = 4;

    /**
     * Provides methods for working with a Color defined in CZML.
     *
     * @exports CzmlColor
     *
     * @see Color
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlColor = {
        /**
         * The number of doubles per packed Color value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Color representation contained within the provided CZML interval
         * or undefined if the interval does not contain Color data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var rgbaf = czmlInterval.rgbaf;
            if (typeof rgbaf !== 'undefined') {
                return rgbaf;
            }

            var rgba = czmlInterval.rgba;
            if (typeof rgba === 'undefined') {
                return undefined;
            }

            if (!this.isSampled(rgba)) {
                return [Color.byteToFloat(rgba[0]),
                        Color.byteToFloat(rgba[1]),
                        Color.byteToFloat(rgba[2]),
                        Color.byteToFloat(rgba[3])];
            }

            var len = rgba.length;
            rgbaf = new Array(len);
            for ( var i = 0; i < len; i += 5) {
                rgbaf[i] = rgba[i];
                rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);
                rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);
                rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);
                rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);
            }
            return rgbaf;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlColor.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Color instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlColor.unwrapInterval.
         * @param {Color} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Color instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Color();
            }
            result.red = unwrappedInterval[0];
            result.green = unwrappedInterval[1];
            result.blue = unwrappedInterval[2];
            result.alpha = unwrappedInterval[3];
            return result;
        },


        /**
         * Given a packed array of red, green, blue, and alpha values, extracts a Color instance.
         *
         * @param {Array} array A packed array of Color values, where every four elements represents a Color.
         * @param {Number} startingIndex The index into the array that contains the red value of the Color you would like.
         * @param {Color} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Color instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Color();
            }
            result.red = array[startingIndex];
            result.green = array[startingIndex + 1];
            result.blue = array[startingIndex + 2];
            result.alpha = array[startingIndex + 3];
            return result;
        }
    };
    return CzmlColor;
});
/*global define*/
define('DynamicScene/CzmlNumber',[],function() {
    

    var doublesPerValue = 1;

    /**
     * Provides methods for working with a number defined in CZML.
     *
     * @exports CzmlNumber
     *
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlNumber = {
        /**
         * The number of doubles per packed value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed numerical representation contained within the provided CZML interval
         * or undefined if the interval does not contain numerical data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.number;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlNumber.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval);
        },

        /**
         * Returns the numerical value contained within the unwrappedInterval.  For numbers
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlNumber.unwrapInterval.
         * @returns The boolean value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        },

        /**
         * Given a packed array of numerical values, returns the number at the given index..
         *
         * @param {Array} array An array of numbers.
         * @param {Number} startingIndex The index into the array that contains the value you would like.
         * @returns The value at the specified index.
         */
        getValueFromArray : function(array, startingIndex) {
            return array[startingIndex];
        }
    };

    return CzmlNumber;
});
/*global define*/
define('DynamicScene/CzmlString',[],function() {
    

    /**
     * Provides methods for working with a string defined in CZML.
     *
     * @exports CzmlString
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlString = {
        /**
         * Returns the packed string representation contained within the provided CZML interval
         * or undefined if the interval does not contain string data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.string;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since CZML strings can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the string value contained within the unwrappedInterval.  For strings
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlString.unwrapInterval.
         * @returns The string value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlString;
});
/*global define*/
define('DynamicScene/CzmlUnitCartesian3',[
        '../Core/Cartesian3'
       ], function(
         Cartesian3) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a unit Cartesian3 defined in CZML.
     *
     * @exports CzmlUnitCartesian3
     *
     * @see Cartesian3
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitCartesian3 = {
         /**
         * The number of doubles per packed Cartesian3 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian3 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian3 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitCartesian;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitCartesian3.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian3 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitCartesian3.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            return result.normalize(result);
        },

        /**
         * Given a packed array of x, y, and z values, extracts a Cartesian3 instance.
         *
         * @param {Array} array A packed array of Cartesian3 values, where every three elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian3 you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            return result.normalize(result);
        }
    };

    return CzmlUnitCartesian3;
});
/*global define*/
define('DynamicScene/CzmlUnitQuaternion',[
        '../Core/Quaternion',
        '../Core/Cartesian3'
    ], function(
        Quaternion,
        Cartesian3) {
    

    var doublesPerCartesian = 3;
    var doublesPerQuaternion = 4;
    var axis = new Cartesian3();
    var rotationVector = new Cartesian3();
    var tmpQuaternion = new Quaternion();
    var quaternion0 = new Quaternion();
    var quaternion0Conjugate = new Quaternion();

    /**
     * Provides methods for working with a unit Quaternion defined in CZML.
     *
     * @exports CzmlUnitQuaternion
     *
     * @see Quaternion
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitQuaternion = {
        /**
         * The number of doubles per packed Quaternion value.
         */
        doublesPerValue : doublesPerQuaternion,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerCartesian,

        /**
         * Returns the packed Quaternion representation contained within the provided CZML interval
         * or undefined if the interval does not contain Quaternion data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitQuaternion;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitQuaternion.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerQuaternion;
        },

        /**
         * Given a packed array of x, y, z, and w values, creates a packed array of
         * Cartesian3 axis-angle rotations suitable for interpolation.
         *
         * @param {Array} sourceArray The packed array of quaternion values.
         * @param {Array} destinationArray The array to store the packed axis-angle rotations.
         * @param {Number} firstIndex The index of the first element to be packed.
         * @param {Number} lastIndex The index of the last element to be packed.
         */
        packValuesForInterpolation : function(sourceArray, destinationArray, firstIndex, lastIndex) {
            CzmlUnitQuaternion.getValueFromArray(sourceArray, lastIndex * doublesPerQuaternion, quaternion0Conjugate);
            quaternion0Conjugate.conjugate(quaternion0Conjugate);

            for ( var i = 0, len = lastIndex - firstIndex + 1; i < len; i++) {
                var offset = i * doublesPerCartesian;
                CzmlUnitQuaternion.getValueFromArray(sourceArray, (firstIndex + i) * doublesPerQuaternion, tmpQuaternion);

                tmpQuaternion.multiply(quaternion0Conjugate, tmpQuaternion);

                if (tmpQuaternion.w < 0) {
                    tmpQuaternion.negate(tmpQuaternion);
                }

                tmpQuaternion.getAxis(axis);
                var angle = tmpQuaternion.getAngle();
                destinationArray[offset] = axis.x * angle;
                destinationArray[offset + 1] = axis.y * angle;
                destinationArray[offset + 2] = axis.z * angle;
            }
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Quaternion instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitQuaternion.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            result.w = unwrappedInterval[3];
            return result.normalize(result);
        },

        /**
         * Given a packed array of x, y, z, and w values, extracts a Quaternion instance.
         *
         * @param {Array} array A packed array of Quaternion values, where every four elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Quaternion you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            result.w = array[startingIndex + 3];
            return result.normalize(result);
        },

        /**
         * Given a packed array of axis-angle rotations returned from CzmlUnitQuaternion.packValuesForInterpolation,
         * converts the desired index into a unit Quaternion.
         *
         * @param {Array} array The array containing the packed axis-angle rotations.
         * @param {Quaternion} result The object to store the result in, if undefined a new instance will be created.
         * @param {Array} sourceArray The source array of the original Quaternion values previously passed to CzmlUnitQuaternion.packValuesForInterpolation.
         * @param {Number} firstIndex The index previously passed to CzmlUnitQuaternion.packValuesForInterpolation.
         * @param {Number} lastIndex The index previously passed to CzmlUnitQuaternion.packValuesForInterpolation
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValueFromInterpolationResult : function(array, result, sourceArray, firstIndex, lastIndex) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            rotationVector.x = array[0];
            rotationVector.y = array[1];
            rotationVector.z = array[2];
            var magnitude = rotationVector.magnitude();

            CzmlUnitQuaternion.getValueFromArray(sourceArray, lastIndex * doublesPerQuaternion, quaternion0);

            if (magnitude === 0) {
                //Can't just use Quaternion.IDENTITY here because tmpQuaternion may be modified in the future.
                tmpQuaternion.x = tmpQuaternion.y = tmpQuaternion.z = 0.0;
                tmpQuaternion.w = 1.0;
            } else {
                Quaternion.fromAxisAngle(rotationVector, magnitude, tmpQuaternion);
            }

            return result.normalize(tmpQuaternion.multiply(quaternion0, result), result);
        }
    };

    return CzmlUnitQuaternion;
});
/*global define*/
define('DynamicScene/CzmlUnitSpherical',[
        '../Core/Spherical'
       ], function(
         Spherical) {
    

    var doublesPerValue = 2;

    /**
     * Provides methods for working with a unit Spherical defined in CZML.
     *
     * @exports CzmlUnitSpherical
     *
     * @see Spherical
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitSpherical = {
        /**
         * The number of doubles per packed Spherical value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Spherical representation contained within the provided CZML interval
         * or undefined if the interval does not contain Spherical data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitSpherical;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitSpherical.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Spherical instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitSpherical.unwrapInterval.
         * @param {Spherical} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Spherical instance if result was not defined.
         */
        getValue : function(unwrappedInterval, spherical) {
            if (typeof spherical === 'undefined') {
                spherical = new Spherical();
            }
            spherical.clock = unwrappedInterval[0];
            spherical.cone = unwrappedInterval[1];
            spherical.magnitude = 1.0;
            return spherical;
        },

        /**
         * Given a packed array of clock and cone values, extracts a Spherical instance.
         *
         * @param {Array} array A packed array of Spherical values, where every two elements represents a Spherical.
         * @param {Number} startingIndex The index into the array that contains the clock value of the Spherical you would like.
         * @param {Spherical} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Spherical instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, spherical) {
            if (typeof spherical === 'undefined') {
                spherical = new Spherical();
            }
            spherical.clock = array[startingIndex];
            spherical.cone = array[startingIndex + 1];
            spherical.magnitude = 1.0;
            return spherical;
        }
    };

    return CzmlUnitSpherical;
});
/*global define*/
define('DynamicScene/DynamicDirectionsProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Cartesian3',
        '../Core/Spherical',
        '../Core/Iso8601'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Cartesian3,
        Spherical,
        Iso8601) {
    

    function ValueHolder(czmlInterval) {
        var i;
        var len;
        var values = [];
        var tmp = czmlInterval.unitSpherical;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 2) {
                values.push(new Spherical(tmp[i], tmp[i + 1]));
            }
            this.spherical = values;
        }

        tmp = czmlInterval.unitCartesian;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 3) {
                values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2], true));
            }
            this.cartesian = values;
        }
    }

    ValueHolder.prototype.getValueSpherical = function() {
        var sphericals = this.spherical;
        if (typeof sphericals === 'undefined') {
            sphericals = [];
            this.spherical = sphericals;
            var cartesians = this.cartesian;
            for ( var i = 0, len = cartesians.length; i < len; i++) {
                sphericals.push(Spherical.fromCartesian3(cartesians[i]));
            }
        }
        return sphericals;
    };

    ValueHolder.prototype.getValueCartesian = function() {
        var cartesians = this.cartesian;
        if (typeof cartesians === 'undefined') {
            cartesians = [];
            this.cartesian = cartesians;
            var sphericals = this.spherical;
            for ( var i = 0, len = sphericals.length; i < len; i++) {
                cartesians.push(Cartesian3.fromSpherical(sphericals[i]));
            }
        }
        return cartesians;
    };

    /**
     * A dynamic property which maintains an array of directions that can change over time.
     * The directions can be represented as both Cartesian and Spherical coordinates.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     * </p>
     *
     * @alias DynamicDirectionsProperty
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicDirectionsProperty = function() {
        this._propertyIntervals = new TimeIntervalCollection();
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicDirectionsProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {DynamicObjectCollection} dynamicObjectCollection The DynamicObjectCollection to be used as a target for resolving links within this property.
     */
    DynamicDirectionsProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, dynamicObjectCollection) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, dynamicObjectCollection);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, dynamicObjectCollection);
        }
    };

    /**
     * Retrieves the values at the supplied time as Spherical coordinates.
     * @memberof DynamicDirectionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of spherical coordinates for the provided time.
     */
    DynamicDirectionsProperty.prototype.getValueSpherical = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        return interval.data.getValueSpherical();
    };

    /**
     * Retrieves the values at the supplied time as unit cartesian coordinates.
     * @memberof DynamicDirectionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of unit cartesian coordinates for the provided time.
     */
    DynamicDirectionsProperty.prototype.getValueCartesian = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        return interval.data.getValueCartesian();
    };

    DynamicDirectionsProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, dynamicObjectCollection) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        //If not, create it.
        if (typeof existingInterval === 'undefined') {
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        existingInterval.data = new ValueHolder(czmlInterval);
    };

    return DynamicDirectionsProperty;
});
/*global define*/
define('DynamicScene/DynamicProperty',[
        '../Core/DeveloperError',
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        '../Core/binarySearch',
        '../Core/HermitePolynomialApproximation',
        '../Core/LinearApproximation',
        '../Core/LagrangePolynomialApproximation'
    ], function(
        DeveloperError,
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        binarySearch,
        HermitePolynomialApproximation,
        LinearApproximation,
        LagrangePolynomialApproximation) {
    


    //CZML_TODO This is more of an idea than a to-do, but currently DynamicProperty requires
    //you know the type of data being loaded up-front by passing valueType.  We could take
    //a similar approach to DynamicMaterialProperty and have a list of potential valueTypes
    //that we check for when we encounter data.  This would make it possible to support
    //properties that are defined in a CZML document but not part of the official spec.  This
    //would be helpful in cases where a CZML document has $ or # links to other properties,
    //but that property itself is not part of another to-spec CZML object.  We could still
    //allow the user to pass a default valueType if they want to make sure the data
    //being processed is only the data of the expected type.

    //Map CZML interval types to their implementation.
    var interpolators = {
        HERMITE : HermitePolynomialApproximation,
        LAGRANGE : LagrangePolynomialApproximation,
        LINEAR : LinearApproximation
    };

    //The data associated with each DynamicProperty interval.
    function IntervalData() {
        this.interpolationAlgorithm = LinearApproximation;
        this.numberOfPoints = LinearApproximation.getRequiredDataPoints(1);
        this.interpolationDegree = 1;
        this.times = undefined;
        this.values = undefined;
        this.isSampled = false;
        this.xTable = undefined;
        this.yTable = undefined;
    }

    //Converts a CZML defined data into a JulianDate, regardless of whether it was
    //specified in epoch seconds or as an ISO8601 string.
    function czmlDateToJulianDate(date, epoch) {
        if (typeof date === 'string') {
            return JulianDate.fromIso8601(date);
        }
        return epoch.addSeconds(date);
    }

    /**
     * <p>
     * DynamicProperty represents a single value that changes over time.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     * </p>
     * <p>
     * The type of value exposed by this property must be provided during construction
     * by passing in an object which performs all the necessary operations needed to
     * properly store, retrieve, and interpolate the data.  For more specialized needs
     * other types of dynamic properties exist, such as DynamicMaterialProperty,
     * which as the name implies, handles materials.
     * </p>
     *
     * @alias DynamicProperty
     * @constructor
     *
     * @param {Object} valueType A CZML type object which contains the methods needed to interpret and interpolate CZML data of the same type.
     *
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     * @see DynamicObject
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicProperty = function(valueType) {
        if (typeof valueType === 'undefined') {
            throw new DeveloperError('valueType is required.');
        }
        this.valueType = valueType;
        this._intervals = new TimeIntervalCollection();
        this._cachedDate = undefined;
        this._cachedInterval = undefined;
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     */
    DynamicProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, sourceUri) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, sourceUri);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, sourceUri);
        }
    };

    /**
     * Returns the value of the property at the specified time.
     * @memberof DynamicProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    DynamicProperty.prototype.getValue = function(time, result) {
        var interval = this._cachedInterval;
        var thisValueType = this.valueType;
        var doublesPerValue = thisValueType.doublesPerValue;

        if (this._cachedDate !== time) {
            this._cachedDate = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._intervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }

        var intervalData = interval.data;
        var times = intervalData.times;
        var values = intervalData.values;
        if (intervalData.isSampled && times.length >= 0 && values.length > 0) {
            var index = binarySearch(times, time, JulianDate.compare);
            if (index < 0) {
                if (intervalData.numberOfPoints < 2) {
                    return undefined;
                }
                index = ~index;

                if (index >= times.length) {
                    index = times.length - 1;
                }

                var firstIndex = 0;
                var lastIndex = times.length - 1;

                var degree = intervalData.numberOfPoints - 1;
                var pointsInCollection = lastIndex - firstIndex + 1;

                if (pointsInCollection < degree + 1) {
                    // Use the entire range.
                } else {
                    var computedFirstIndex = index - ((degree / 2) | 0) - 1;
                    if (computedFirstIndex < firstIndex) {
                        computedFirstIndex = firstIndex;
                    }
                    var computedLastIndex = computedFirstIndex + degree;
                    if (computedLastIndex > lastIndex) {
                        computedLastIndex = lastIndex;
                        computedFirstIndex = computedLastIndex - degree;
                        if (computedFirstIndex < firstIndex) {
                            computedFirstIndex = firstIndex;
                        }
                    }

                    firstIndex = computedFirstIndex;
                    lastIndex = computedLastIndex;
                }

                var length = lastIndex - firstIndex + 1;

                var doublesPerInterpolationValue = thisValueType.doublesPerInterpolationValue;
                var xTable = intervalData.xTable;
                var yTable = intervalData.yTable;

                if (typeof xTable === 'undefined') {
                    xTable = intervalData.xTable = new Array(intervalData.numberOfPoints);
                    yTable = intervalData.yTable = new Array(intervalData.numberOfPoints * doublesPerInterpolationValue);
                }

                // Build the tables
                for ( var i = 0; i < length; ++i) {
                    xTable[i] = times[lastIndex].getSecondsDifference(times[firstIndex + i]);
                }
                var specializedPackFunction = thisValueType.packValuesForInterpolation;
                if (typeof specializedPackFunction === 'undefined') {
                    var destinationIndex = 0;
                    var sourceIndex = firstIndex * doublesPerValue;
                    var stop = (lastIndex + 1) * doublesPerValue;

                    while (sourceIndex < stop) {
                        yTable[destinationIndex] = values[sourceIndex];
                        sourceIndex++;
                        destinationIndex++;
                    }
                } else {
                    specializedPackFunction(values, yTable, firstIndex, lastIndex);
                }

                // Interpolate!
                var x = times[lastIndex].getSecondsDifference(time);
                var interpolationResult = intervalData.interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, doublesPerInterpolationValue);

                var specializedGetFunction = thisValueType.getValueFromInterpolationResult;
                if (typeof specializedGetFunction === 'undefined') {
                    return thisValueType.getValueFromArray(interpolationResult, 0, result);
                }
                return specializedGetFunction(interpolationResult, result, values, firstIndex, lastIndex);
            }
            return thisValueType.getValueFromArray(intervalData.values, index * doublesPerValue, result);
        }
        return thisValueType.getValue(intervalData.values, result);
    };

    DynamicProperty._mergeNewSamples = function(epoch, times, values, newData, doublesPerValue, valueType) {
        var newDataIndex = 0, i, prevItem, timesInsertionPoint, valuesInsertionPoint, timesSpliceArgs, valuesSpliceArgs, currentTime, nextTime;
        while (newDataIndex < newData.length) {
            currentTime = czmlDateToJulianDate(newData[newDataIndex], epoch);
            timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);

            if (timesInsertionPoint < 0) {
                //Doesn't exist, insert as many additional values as we can.
                timesInsertionPoint = ~timesInsertionPoint;
                timesSpliceArgs = [timesInsertionPoint, 0];

                valuesInsertionPoint = timesInsertionPoint * doublesPerValue;
                valuesSpliceArgs = [valuesInsertionPoint, 0];
                prevItem = undefined;
                nextTime = times[timesInsertionPoint + 1];
                while (newDataIndex < newData.length) {
                    currentTime = czmlDateToJulianDate(newData[newDataIndex], epoch);
                    if ((typeof prevItem !== 'undefined' && JulianDate.compare(prevItem, currentTime) >= 0) ||
                        (typeof nextTime !== 'undefined' && JulianDate.compare(currentTime, nextTime) >= 0)) {
                        break;
                    }
                    timesSpliceArgs.push(currentTime);
                    newDataIndex = newDataIndex + 1;
                    for (i = 0; i < doublesPerValue; i++) {
                        valuesSpliceArgs.push(newData[newDataIndex]);
                        newDataIndex = newDataIndex + 1;
                    }
                    prevItem = currentTime;
                }

                Array.prototype.splice.apply(values, valuesSpliceArgs);
                Array.prototype.splice.apply(times, timesSpliceArgs);
            } else {
                //Found an exact match
                for (i = 0; i < doublesPerValue; i++) {
                    newDataIndex++;
                    values[(timesInsertionPoint * doublesPerValue) + i] = newData[newDataIndex];
                }
                newDataIndex++;
            }
        }
    };

    DynamicProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, sourceUri) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL;
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        var unwrappedInterval = this.valueType.unwrapInterval(czmlInterval, sourceUri);
        if (typeof unwrappedInterval !== 'undefined') {
            this._addCzmlIntervalUnwrapped(iso8601Interval.start, iso8601Interval.stop, unwrappedInterval, czmlInterval.epoch, czmlInterval.interpolationAlgorithm, czmlInterval.interpolationDegree);
        }
    };

    DynamicProperty.prototype._addCzmlIntervalUnwrapped = function(start, stop, unwrappedInterval, epoch, interpolationAlgorithmType, interpolationDegree) {
        var thisIntervals = this._intervals;
        var existingInterval = thisIntervals.findInterval(start, stop);
        this._cachedDate = undefined;
        this._cachedInterval = undefined;

        var intervalData;
        if (typeof existingInterval === 'undefined') {
            intervalData = new IntervalData();
            existingInterval = new TimeInterval(start, stop, true, true, intervalData);
            thisIntervals.addInterval(existingInterval);
        } else {
            intervalData = existingInterval.data;
        }

        var thisValueType = this.valueType;
        if (thisValueType.isSampled(unwrappedInterval)) {
            var interpolationAlgorithm;
            if (typeof interpolationAlgorithmType !== 'undefined') {
                interpolationAlgorithm = interpolators[interpolationAlgorithmType];
                intervalData.interpolationAlgorithm = interpolationAlgorithm;
            }
            if (typeof interpolationAlgorithm !== 'undefined' && typeof interpolationDegree !== 'undefined') {
                intervalData.interpolationDegree = interpolationDegree;
                intervalData.xTable = undefined;
                intervalData.yTable = undefined;
            }

            if (!intervalData.isSampled) {
                intervalData.times = [];
                intervalData.values = [];
                intervalData.isSampled = true;
            }
            if (typeof epoch !== 'undefined') {
                epoch = JulianDate.fromIso8601(epoch);
            }
            DynamicProperty._mergeNewSamples(epoch, intervalData.times, intervalData.values, unwrappedInterval, thisValueType.doublesPerValue, thisValueType);
            intervalData.numberOfPoints = Math.min(intervalData.interpolationAlgorithm.getRequiredDataPoints(intervalData.interpolationDegree), intervalData.times.length);
        } else {
            //Packet itself is a constant value
            intervalData.times = undefined;
            intervalData.values = unwrappedInterval;
            intervalData.isSampled = false;
        }
    };

    return DynamicProperty;
});
/*global define*/
define('DynamicScene/DynamicPath',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty'],
function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlNumber,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic path, typically used in conjunction with DynamicPathVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPath
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPathVisualizer
     * @see VisualizerCollection
     * @see Polyline
     * @see CzmlDefaults
     */
    var DynamicPath = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the line's color.
         * @type DynamicProperty
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the line's outline color.
         * @type DynamicProperty
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's outline width.
         * @type DynamicProperty
         */
        this.outlineWidth = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the lines's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's width.
         * @type DynamicProperty
         */
        this.width = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the number of seconds in front of the object to show.
         * @type DynamicProperty
         */
        this.leadTime = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the the number of seconds behind the object to show.
         * @type DynamicProperty
         */
        this.trailTime = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's path.
     * If the DynamicObject does not have a path, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the path data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPath.processCzmlPacket = function(dynamicObject, packet) {
        var pathData = packet.path;
        if (typeof pathData === 'undefined') {
            return false;
        }

        var pathUpdated = false;
        var path = dynamicObject.path;
        pathUpdated = typeof path === 'undefined';
        if (pathUpdated) {
            dynamicObject.path = path = new DynamicPath();
        }

        var interval = pathData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof pathData.color !== 'undefined') {
            var color = path.color;
            if (typeof color === 'undefined') {
                path.color = color = new DynamicProperty(CzmlColor);
                pathUpdated = true;
            }
            color.processCzmlIntervals(pathData.color, interval);
        }

        if (typeof pathData.width !== 'undefined') {
            var width = path.width;
            if (typeof width === 'undefined') {
                path.width = width = new DynamicProperty(CzmlNumber);
                pathUpdated = true;
            }
            width.processCzmlIntervals(pathData.width, interval);
        }

        if (typeof pathData.outlineColor !== 'undefined') {
            var outlineColor = path.outlineColor;
            if (typeof outlineColor === 'undefined') {
                path.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                pathUpdated = true;
            }
            outlineColor.processCzmlIntervals(pathData.outlineColor, interval);
        }

        if (typeof pathData.outlineWidth !== 'undefined') {
            var outlineWidth = path.outlineWidth;
            if (typeof outlineWidth === 'undefined') {
                path.outlineWidth = outlineWidth = new DynamicProperty(CzmlNumber);
                pathUpdated = true;
            }
            outlineWidth.processCzmlIntervals(pathData.outlineWidth, interval);
        }

        if (typeof pathData.show !== 'undefined') {
            var show = path.show;
            if (typeof show === 'undefined') {
                path.show = show = new DynamicProperty(CzmlBoolean);
                pathUpdated = true;
            }
            show.processCzmlIntervals(pathData.show, interval);
        }

        if (typeof pathData.leadTime !== 'undefined') {
            var leadTime = path.leadTime;
            if (typeof leadTime === 'undefined') {
                path.leadTime = leadTime = new DynamicProperty(CzmlNumber);
                pathUpdated = true;
            }
            leadTime.processCzmlIntervals(pathData.leadTime, interval);
        }

        if (typeof pathData.trailTime !== 'undefined') {
            var trailTime = path.trailTime;
            if (typeof trailTime === 'undefined') {
                path.trailTime = trailTime = new DynamicProperty(CzmlNumber);
                pathUpdated = true;
            }
            trailTime.processCzmlIntervals(pathData.trailTime, interval);
        }

        return pathUpdated;
    };

    /**
     * Given two DynamicObjects, takes the path properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPath.mergeProperties = function(targetObject, objectToMerge) {
        var pathToMerge = objectToMerge.path;
        if (typeof pathToMerge !== 'undefined') {

            var targetpath = targetObject.path;
            if (typeof targetpath === 'undefined') {
                targetObject.path = targetpath = new DynamicPath();
            }

            targetpath.color = defaultValue(targetpath.color, pathToMerge.color);
            targetpath.width = defaultValue(targetpath.width, pathToMerge.width);
            targetpath.outlineColor = defaultValue(targetpath.outlineColor, pathToMerge.outlineColor);
            targetpath.outlineWidth = defaultValue(targetpath.outlineWidth, pathToMerge.outlineWidth);
            targetpath.show = defaultValue(targetpath.show, pathToMerge.show);
            targetpath.leadTime = defaultValue(targetpath.leadTime, pathToMerge.leadTime);
            targetpath.trailTime = defaultValue(targetpath.trailTime, pathToMerge.trailTime);
        }
    };

    /**
     * Given a DynamicObject, undefines the path associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the path from.
     *
     * @see CzmlDefaults
     */
    DynamicPath.undefineProperties = function(dynamicObject) {
        dynamicObject.path = undefined;
    };

    return DynamicPath;
});
/*global define*/
define('DynamicScene/DynamicPoint',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty'
    ], function(
         TimeInterval,
         defaultValue,
         CzmlBoolean,
         CzmlNumber,
         CzmlColor,
         DynamicProperty) {
    

    /**
     * Represents a time-dynamic point, typically used in conjunction with DynamicPointVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPoint
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPointVisualizer
     * @see VisualizerCollection
     * @see Billboard
     * @see BillboardCollection
     * @see CzmlDefaults
     */
    var DynamicPoint = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the point's color.
         * @type DynamicProperty
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the point's pixel size.
         * @type DynamicProperty
         */
        this.pixelSize = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the point's outline color.
         * @type DynamicProperty
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the point's outline width.
         * @type DynamicProperty
         */
        this.outlineWidth = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the point's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's point.
     * If the DynamicObject does not have a point, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the point data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPoint.processCzmlPacket = function(dynamicObject, packet) {
        var pointData = packet.point;
        if (typeof pointData === 'undefined') {
            return false;
        }

        var pointUpdated = false;
        var point = dynamicObject.point;
        pointUpdated = typeof point === 'undefined';
        if (pointUpdated) {
            dynamicObject.point = point = new DynamicPoint();
        }

        var interval = pointData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof pointData.color !== 'undefined') {
            var color = point.color;
            if (typeof color === 'undefined') {
                point.color = color = new DynamicProperty(CzmlColor);
                pointUpdated = true;
            }
            color.processCzmlIntervals(pointData.color, interval);
        }

        if (typeof pointData.pixelSize !== 'undefined') {
            var pixelSize = point.pixelSize;
            if (typeof pixelSize === 'undefined') {
                point.pixelSize = pixelSize = new DynamicProperty(CzmlNumber);
                pointUpdated = true;
            }
            pixelSize.processCzmlIntervals(pointData.pixelSize, interval);
        }

        if (typeof pointData.outlineColor !== 'undefined') {
            var outlineColor = point.outlineColor;
            if (typeof outlineColor === 'undefined') {
                point.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                pointUpdated = true;
            }
            outlineColor.processCzmlIntervals(pointData.outlineColor, interval);
        }

        if (typeof pointData.outlineWidth !== 'undefined') {
            var outlineWidth = point.outlineWidth;
            if (typeof outlineWidth === 'undefined') {
                point.outlineWidth = outlineWidth = new DynamicProperty(CzmlNumber);
                pointUpdated = true;
            }
            outlineWidth.processCzmlIntervals(pointData.outlineWidth, interval);
        }

        if (typeof pointData.show !== 'undefined') {
            var show = point.show;
            if (typeof show === 'undefined') {
                point.show = show = new DynamicProperty(CzmlBoolean);
                pointUpdated = true;
            }
            show.processCzmlIntervals(pointData.show, interval);
        }
        return pointUpdated;
    };

    /**
     * Given two DynamicObjects, takes the point properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPoint.mergeProperties = function(targetObject, objectToMerge) {
        var pointToMerge = objectToMerge.point;
        if (typeof pointToMerge !== 'undefined') {

            var targetPoint = targetObject.point;
            if (typeof targetPoint === 'undefined') {
                targetObject.point = targetPoint = new DynamicPoint();
            }

            targetPoint.color = defaultValue(targetPoint.color, pointToMerge.color);
            targetPoint.pixelSize = defaultValue(targetPoint.pixelSize, pointToMerge.pixelSize);
            targetPoint.outlineColor = defaultValue(targetPoint.outlineColor, pointToMerge.outlineColor);
            targetPoint.outlineWidth = defaultValue(targetPoint.outlineWidth, pointToMerge.outlineWidth);
            targetPoint.show = defaultValue(targetPoint.show, pointToMerge.show);
        }
    };

    /**
     * Given a DynamicObject, undefines the point associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the point from.
     *
     * @see CzmlDefaults
     */
    DynamicPoint.undefineProperties = function(dynamicObject) {
        dynamicObject.point = undefined;
    };

    return DynamicPoint;
});
/*global define*/
define('DynamicScene/DynamicPolyline',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty'],
function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlNumber,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic polyline, typically used in conjunction with DynamicPolylineVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPolyline
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPolylineVisualizer
     * @see VisualizerCollection
     * @see Polyline
     * @see CzmlDefaults
     */
    var DynamicPolyline = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the line's color.
         * @type DynamicProperty
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the line's outline color.
         * @type DynamicProperty
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's outline width.
         * @type DynamicProperty
         */
        this.outlineWidth = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the lines's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's width.
         * @type DynamicProperty
         */
        this.width = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's polyline.
     * If the DynamicObject does not have a polyline, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the polyline data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPolyline.processCzmlPacket = function(dynamicObject, packet) {
        var polylineData = packet.polyline;
        if (typeof polylineData === 'undefined') {
            return false;
        }

        var polylineUpdated = false;
        var polyline = dynamicObject.polyline;
        polylineUpdated = typeof polyline === 'undefined';
        if (polylineUpdated) {
            dynamicObject.polyline = polyline = new DynamicPolyline();
        }

        var interval = polylineData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof polylineData.color !== 'undefined') {
            var color = polyline.color;
            if (typeof color === 'undefined') {
                polyline.color = color = new DynamicProperty(CzmlColor);
                polylineUpdated = true;
            }
            color.processCzmlIntervals(polylineData.color, interval);
        }

        if (typeof polylineData.width !== 'undefined') {
            var width = polyline.width;
            if (typeof width === 'undefined') {
                polyline.width = width = new DynamicProperty(CzmlNumber);
                polylineUpdated = true;
            }
            width.processCzmlIntervals(polylineData.width, interval);
        }

        if (typeof polylineData.outlineColor !== 'undefined') {
            var outlineColor = polyline.outlineColor;
            if (typeof outlineColor === 'undefined') {
                polyline.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                polylineUpdated = true;
            }
            outlineColor.processCzmlIntervals(polylineData.outlineColor, interval);
        }

        if (typeof polylineData.outlineWidth !== 'undefined') {
            var outlineWidth = polyline.outlineWidth;
            if (typeof outlineWidth === 'undefined') {
                polyline.outlineWidth = outlineWidth = new DynamicProperty(CzmlNumber);
                polylineUpdated = true;
            }
            outlineWidth.processCzmlIntervals(polylineData.outlineWidth, interval);
        }

        if (typeof polylineData.show !== 'undefined') {
            var show = polyline.show;
            if (typeof show === 'undefined') {
                polyline.show = show = new DynamicProperty(CzmlBoolean);
                polylineUpdated = true;
            }
            show.processCzmlIntervals(polylineData.show, interval);
        }
        return polylineUpdated;
    };

    /**
     * Given two DynamicObjects, takes the polyline properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPolyline.mergeProperties = function(targetObject, objectToMerge) {
        var polylineToMerge = objectToMerge.polyline;
        if (typeof polylineToMerge !== 'undefined') {

            var targetPolyline = targetObject.polyline;
            if (typeof targetPolyline === 'undefined') {
                targetObject.polyline = targetPolyline = new DynamicPolyline();
            }

            targetPolyline.color = defaultValue(targetPolyline.color, polylineToMerge.color);
            targetPolyline.width = defaultValue(targetPolyline.width, polylineToMerge.width);
            targetPolyline.outlineColor = defaultValue(targetPolyline.outlineColor, polylineToMerge.outlineColor);
            targetPolyline.outlineWidth = defaultValue(targetPolyline.outlineWidth, polylineToMerge.outlineWidth);
            targetPolyline.show = defaultValue(targetPolyline.show, polylineToMerge.show);
        }
    };

    /**
     * Given a DynamicObject, undefines the polyline associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the polyline from.
     *
     * @see CzmlDefaults
     */
    DynamicPolyline.undefineProperties = function(dynamicObject) {
        dynamicObject.polyline = undefined;
    };

    return DynamicPolyline;
});
/*global define*/
define('DynamicScene/DynamicPositionProperty',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        './CzmlCartesian3',
        './CzmlCartographic',
        './DynamicProperty'
    ], function(
        DeveloperError,
        Ellipsoid,
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        Cartesian3,
        Cartographic,
        CzmlCartesian3,
        CzmlCartographic,
        DynamicProperty) {
    

    var wgs84 = Ellipsoid.WGS84;
    var potentialTypes = [CzmlCartesian3, CzmlCartographic];

    /**
     * A dynamic property which stores both Cartesian and Cartographic data
     * and can convert and return the desired type of data for a desired time.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     *
     * @alias DynamicPositionProperty
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicPositionProperty = function() {
        this._dynamicProperties = [];
        this._propertyIntervals = new TimeIntervalCollection();
        this._cachedTime = undefined;
        this._cachedInterval = undefined;
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicPositionProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     */
    DynamicPositionProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval);
        }
    };

    /**
     * Retrieves the value of the object at the supplied time as a Cartographic.
     * @memberof DynamicPositionProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Cartographic} [result] The object to store the result onto, if undefined a new instance will be created.
     * @returns The modified result property, or a new instance if result was undefined.
     */
    DynamicPositionProperty.prototype.getValueCartographic = function(time, result) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        var interval = this._cachedInterval;
        if (this._cachedTime !== time) {
            this._cachedTime = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._propertyIntervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }
        var property = interval.data;
        var valueType = property.valueType;
        if (valueType === CzmlCartographic) {
            return property.getValue(time, result);
        }
        result = interval.cachedValue = property.getValue(time, interval.cachedValue);
        if (typeof result !== 'undefined') {
            result = wgs84.cartesianToCartographic(result);
        }
        return result;
    };

    /**
     * Retrieves the value of the object at the supplied time as a Cartesian3.
     * @memberof DynamicPositionProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Cartesian3} [result] The object to store the result onto, if undefined a new instance will be created.
     * @returns The modified result property, or a new instance if result was undefined.
     */
    DynamicPositionProperty.prototype.getValueCartesian = function(time, result) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        var interval = this._cachedInterval;
        if (this._cachedTime !== time) {
            this._cachedTime = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._propertyIntervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }
        var property = interval.data;
        var valueType = property.valueType;
        if (valueType === CzmlCartesian3) {
            return property.getValue(time, result);
        }
        result = interval.cachedValue = property.getValue(time, interval.cachedValue);
        if (typeof result !== 'undefined') {
            result = wgs84.cartographicToCartesian(result);
        }
        return result;
    };

    /**
     * Retrieves all values in the provided time range.  Rather than sampling, this
     * method returns the actual data points used in the source data, with the exception
     * of start, stop and currentTime parameters, which will be sampled.
     *
     * @param {JulianDate} start The first time to retrieve values for.
     * @param {JulianDate} stop The last time to retrieve values for .
     * @param {JulianDate} [currentTime] If provided, causes the algorithm to always sample the provided time, assuming it is between start and stop.
     * @param {Array} [result] The array into which to store the result.
     * @returns The modified result array or a new instance if one was not provided.
     */
    DynamicPositionProperty.prototype.getValueRangeCartesian = function(start, stop, currentTime, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required');
        }

        if (typeof stop === 'undefined') {
            throw new DeveloperError('stop is required');
        }

        if (typeof result === 'undefined') {
            result = [];
        }

        var propertyIntervals = this._propertyIntervals;

        var startIndex = typeof start === 'undefined' ? 0 : propertyIntervals.indexOf(start);
        var stopIndex = typeof stop === 'undefined' ? propertyIntervals.length - 1 : propertyIntervals.indexOf(stop);
        if (startIndex < 0) {
            startIndex = ~startIndex;
        }

        if (startIndex === propertyIntervals.getLength()) {
            result.length = 0;
            return result;
        }

        if (stopIndex < 0) {
            stopIndex = ~stopIndex;
            if (stopIndex !== propertyIntervals.getLength()) {
                result.length = 0;
                return result;
            }
            stopIndex -= 1;
        }

        var r = 0;
        //Always step exactly on start (but only use it if it exists.)
        var tmp;
        tmp = this.getValueCartesian(start, result[r]);
        if (typeof tmp !== 'undefined') {
            result[r++] = tmp;
        }

        var scratchCartographic;
        var steppedOnNow = typeof currentTime === 'undefined' || currentTime.lessThan(start) || currentTime.greaterThan(stop);
        for ( var i = startIndex; i < stopIndex + 1; i++) {
            var current;
            var interval = propertyIntervals.get(i);
            var nextInterval = propertyIntervals.get(i + 1);
            var loopStop = stop;
            if (typeof nextInterval !== 'undefined' && stop.greaterThan(nextInterval.start)) {
                loopStop = nextInterval.start;
            }
            var property = interval.data;
            var valueType = property.valueType;
            var currentInterval = property._intervals.get(0);
            var times = currentInterval.data.times;
            if (typeof times !== 'undefined') {
                //Iterate over all interval times and add the ones that fall in our
                //time range.  Note that times can contain data outside of
                //the intervals range.  This is by design for use with interpolation.
                var t;
                if (valueType === CzmlCartesian3) {
                    for (t = 0; t < times.length; t++) {
                        current = times[t];
                        if (!steppedOnNow && current.greaterThanOrEquals(currentTime)) {
                            tmp = property.getValue(currentTime, result[r]);
                            if (typeof tmp !== 'undefined') {
                                result[r++] = tmp;
                            }
                            steppedOnNow = true;
                        }
                        if (current.greaterThan(start) && current.lessThan(loopStop)) {
                            tmp = property.getValue(current, result[r]);
                            if (typeof tmp !== 'undefined') {
                                result[r++] = tmp;
                            }
                        }
                    }
                } else {
                    for (t = 0; t < times.length; t++) {
                        current = times[t];
                        if (!steppedOnNow && current.greaterThanOrEquals(currentTime)) {
                            scratchCartographic = property.getValue(currentTime, scratchCartographic);
                            result[r++] = wgs84.cartographicToCartesian(scratchCartographic);
                            steppedOnNow = true;
                        }
                        if (current.greaterThan(start) && current.lessThan(loopStop)) {
                            scratchCartographic = property.getValue(current, scratchCartographic);
                            result[r++] = wgs84.cartographicToCartesian(scratchCartographic);
                        }
                    }
                }
            } else {
                //If times is undefined, it's because the interval contains a single position
                //at which it stays for the duration of the interval.
                current = interval.start;

                //We don't need to actually step on now in this case, since the next value
                //will be the same; but we do still need to check for it.
                steppedOnNow = steppedOnNow || current.greaterThanOrEquals(currentTime);

                //Finally, get the value at this non-sampled interval.
                if (current.lessThan(loopStop)) {
                    if (valueType === CzmlCartesian3) {
                        tmp = property.getValue(current, result[r]);
                        if (typeof tmp !== 'undefined') {
                            result[r++] = tmp;
                        }
                    } else {
                        scratchCartographic = property.getValue(current, scratchCartographic);
                        result[r++] = wgs84.cartographicToCartesian(scratchCartographic);
                    }
                }
            }
        }

        //Always step exactly on stop (but only use it if it exists.)
        tmp = this.getValueCartesian(stop, result[r]);
        if (typeof tmp !== 'undefined') {
            result[r++] = tmp;
        }

        result.length = r;
        return result;
    };

    DynamicPositionProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval) {
        this._cachedTime = undefined;
        this._cachedInterval = undefined;

        var iso8601Interval = czmlInterval.interval, property, valueType, unwrappedInterval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        if (typeof existingInterval !== 'undefined') {
            //If so, see if the new data is the same type.
            property = existingInterval.data;
            if (typeof property !== 'undefined') {
                valueType = property.valueType;
                unwrappedInterval = valueType.unwrapInterval(czmlInterval);
            }
        } else {
            //If not, create it.
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        //If the new data was a different type, unwrapping fails, look for a valueType for this type.
        if (typeof unwrappedInterval === 'undefined') {
            for ( var i = 0, len = potentialTypes.length; i < len; i++) {
                valueType = potentialTypes[i];
                unwrappedInterval = valueType.unwrapInterval(czmlInterval);
                if (typeof unwrappedInterval !== 'undefined') {
                    property = new DynamicProperty(valueType);
                    this._dynamicProperties.push(property);
                    existingInterval.data = property;
                    break;
                }
            }
        }

        //We could handle the data, add it to the property.
        if (typeof unwrappedInterval !== 'undefined') {
            property._addCzmlIntervalUnwrapped(iso8601Interval.start, iso8601Interval.stop, unwrappedInterval, czmlInterval.epoch, czmlInterval.interpolationAlgorithm, czmlInterval.interpolationDegree);
        }
    };

    return DynamicPositionProperty;
});
/*global define*/
define('DynamicScene/ReferenceProperty',[
        '../Core/defaultValue',
        '../Core/DeveloperError'
       ], function(
         defaultValue,
         DeveloperError) {
    

    function resolve(referenceProperty) {
        var targetProperty = referenceProperty._targetProperty;
        if (typeof targetProperty === 'undefined') {
            var resolveBuffer = defaultValue(referenceProperty._dynamicObjectCollection.compositeCollection, referenceProperty._dynamicObjectCollection);
            var targetObject = resolveBuffer.getObject(referenceProperty._targetObjectId);
            if (typeof targetObject !== 'undefined') {
                targetProperty = targetObject[referenceProperty._targetPropertyName];
                referenceProperty._targetProperty = targetProperty;
            }
        }
        return targetProperty;
    }

    /**
     * A dynamic property which transparently links to another property, which may
     * or may not exist yet.  It is up to the caller to know which kind of property
     * is being linked to.
     *
     * @alias ReferenceProperty
     * @constructor
     *
     * @param {DynamicObjectCollection} dynamicObjectCollection The object collection which will be used to resolve the reference.
     * @param {String} targetObjectId The id of the object which is being referenced.
     * @param {String} targetPropertyName The name of the property on the target object which we will use.
     *
     * @exception {DeveloperError} dynamicObjectCollection is required.
     * @exception {DeveloperError} targetObjectId is required.
     * @exception {DeveloperError} targetPropertyName is required.
     *
     * @see ReferenceProperty#fromString
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     */
    var ReferenceProperty = function(dynamicObjectCollection, targetObjectId, targetPropertyName) {
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }
        if (typeof targetObjectId === 'undefined') {
            throw new DeveloperError('targetObjectId is required.');
        }
        if (typeof targetPropertyName === 'undefined') {
            throw new DeveloperError('targetPropertyName is required.');
        }

        this._targetProperty = undefined;
        this._dynamicObjectCollection = dynamicObjectCollection;
        this._targetObjectId = targetObjectId;
        this._targetPropertyName = targetPropertyName;
    };

    /**
     * Creates a new reference property given the dynamic object collection that will
     * be used to resolve it and a string indicating the target object id and property,
     * delineated by a period.
     *
     * @param {DynamicObject} dynamicObjectCollection
     * @param referenceString
     *
     * @exception {DeveloperError} dynamicObjectCollection is required.
     * @exception {DeveloperError} referenceString is required.
     * @exception {DeveloperError} referenceString must contain a single . delineating the target object ID and property name.
     *
     * @see ReferenceProperty#fromString
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     *
     * @returns A new instance of ReferenceProperty.
     */
    ReferenceProperty.fromString = function(dynamicObjectCollection, referenceString) {
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }

        if (typeof referenceString === 'undefined') {
            throw new DeveloperError('referenceString is required.');
        }

        var parts = referenceString.split('.');
        if (parts.length !== 2) {
            throw new DeveloperError('referenceString must contain a single . delineating the target object ID and property name.');
        }

        return new ReferenceProperty(dynamicObjectCollection, parts[0], parts[1]);
    };

    /**
     * Retrieves the value of the property at the specified time.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValue = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValue(time, result) : undefined;
    };

    /**
     * Retrieves the Cartographic value or values of the property at the specified time if the linked property
     * is a DynamicPositionProperty or DynamicVertexPositionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueCartographic = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueCartographic(time, result) : undefined;
    };

    /**
     * Retrieves the Cartesian value or values of the property at the specified time if the linked property
     * is a DynamicPositionProperty, DynamicVertexPositionsProperty, or DynamicDirectionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueCartesian = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueCartesian(time, result) : undefined;
    };

    /**
     * Retrieves the Spherical value or values of the property at the specified time if the linked property
     * is a DynamicDirectionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueSpherical = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueSpherical(time, result) : undefined;
    };

    return ReferenceProperty;
});
/*global define*/
define('DynamicScene/DynamicVertexPositionsProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/Iso8601',
        '../Core/Ellipsoid',
        './ReferenceProperty',
        './DynamicPositionProperty'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Cartesian3,
        Cartographic,
        Iso8601,
        Ellipsoid,
        ReferenceProperty,
        DynamicPositionProperty) {
    

    var wgs84 = Ellipsoid.WGS84;

    function ValueHolder(czmlInterval) {
        var i, len, values = [], tmp;

        tmp = czmlInterval.cartesian;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 3) {
                values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2]));
            }
            this.cartesian = values;
        } else {
            tmp = czmlInterval.cartographicRadians;
            if (typeof tmp !== 'undefined') {
                for (i = 0, len = tmp.length; i < len; i += 3) {
                    values.push(new Cartographic(tmp[i], tmp[i + 1], tmp[i + 2]));
                }
                this.cartographic = values;
            } else {
                tmp = czmlInterval.cartographicDegrees;
                if (typeof tmp !== 'undefined') {
                    for (i = 0, len = tmp.length; i < len; i += 3) {
                        values.push(Cartographic.fromDegrees(tmp[i], tmp[i + 1], tmp[i + 2]));
                    }
                    this.cartographic = values;
                }
            }
        }
    }

    ValueHolder.prototype.getValueCartographic = function() {
        if (typeof this.cartographic === 'undefined') {
            this.cartographic = wgs84.cartesianArrayToCartographicArray(this.cartesian);
        }
        return this.cartographic;
    };

    ValueHolder.prototype.getValueCartesian = function() {
        if (typeof this.cartesian === 'undefined') {
            this.cartesian = wgs84.cartographicArrayToCartesianArray(this.cartographic);
        }
        return this.cartesian;
    };

    /**
     * A dynamic property which maintains an array of positions that can change over time.
     * The positions can be represented as both Cartesian and Cartographic coordinates.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     *
     * @alias DynamicVertexPositionsProperty
     * @internalconstructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     */
    var DynamicVertexPositionsProperty = function() {
        this._propertyIntervals = new TimeIntervalCollection();
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {DynamicObjectCollection} dynamicObjectCollection The DynamicObjectCollection to be used as a target for resolving links within this property.
     */
    DynamicVertexPositionsProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, dynamicObjectCollection) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, dynamicObjectCollection);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, dynamicObjectCollection);
        }
    };

    /**
     * Retrieves the values at the supplied time as Cartographic coordinates.
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of Cartographic coordinates for the provided time.
     */
    DynamicVertexPositionsProperty.prototype.getValueCartographic = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        var interval_data = interval.data;
        if (Array.isArray(interval_data)) {
            var result = [];
            for ( var i = 0, len = interval_data.length; i < len; i++) {
                var value = interval_data[i].getValueCartographic(time);
                if (typeof value !== 'undefined') {
                    result.push(value);
                }
            }
            return result;
        }

        return interval_data.getValueCartographic();

    };

    /**
     * Retrieves the values at the supplied time as Cartesian coordinates.
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of Cartesian coordinates for the provided time.
     */
    DynamicVertexPositionsProperty.prototype.getValueCartesian = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        var interval_data = interval.data;
        if (Array.isArray(interval_data)) {
            var result = [];
            for ( var i = 0, len = interval_data.length; i < len; i++) {
                var value = interval_data[i].getValueCartesian(time);
                if (typeof value !== 'undefined') {
                    result.push(value);
                }
            }
            return result;
        }

        return interval_data.getValueCartesian();
    };

    DynamicVertexPositionsProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, dynamicObjectCollection) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        //If not, create it.
        if (typeof existingInterval === 'undefined') {
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        var references = czmlInterval.references;
        if (typeof references === 'undefined') {
            existingInterval.data = new ValueHolder(czmlInterval);
        } else {
            var properties = [];
            for ( var i = 0, len = references.length; i < len; i++) {
                properties.push(ReferenceProperty.fromString(dynamicObjectCollection, references[i]));
            }
            existingInterval.data = properties;
        }
    };

    return DynamicVertexPositionsProperty;
});
/*global define*/
define('DynamicScene/DynamicObject',[
        '../Core/createGuid',
        '../Core/DeveloperError',
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './DynamicProperty',
        './DynamicPositionProperty',
        './DynamicVertexPositionsProperty',
        './CzmlUnitQuaternion',
        './CzmlCartesian3'
    ], function(
        createGuid,
        DeveloperError,
        TimeInterval,
        defaultValue,
        DynamicProperty,
        DynamicPositionProperty,
        DynamicVertexPositionsProperty,
        CzmlUnitQuaternion,
        CzmlCartesian3) {
    

    /**
     * DynamicObject instances are the primary data store for processed CZML data.
     * They are used primarily by the visualizers to create and maintain graphic
     * primitives that represent the DynamicObject's properties at a specific time.
     * @alias DynamicObject
     * @constructor
     *
     * @param {Object} [id] A unique identifier for this object.  If no id is provided, a GUID is generated.
     *
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicVertexiPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see DynamicBillboard
     * @see DynamicCone
     * @see DynamicLabel
     * @see DynamicPoint
     * @see DynamicPolygon
     * @see DynamicPolyline
     * @see DynamicPyramid
     */
    var DynamicObject = function(id) {
        this._cachedAvailabilityDate = undefined;
        this._cachedAvailabilityValue = undefined;

        if (typeof id === 'undefined') {
            id = createGuid();
        }

        /**
         * A unique id associated with this object.
         */
        this.id = id;

        //Add standard CZML properties.  Even though they won't all be used
        //for each object, having the superset explicitly listed here will allow the
        //compiler to optimize this class.  It also allows us to document them.
        //Any changes to this list should coincide with changes to CzmlDefaults.updaters

        /**
         * The availability TimeInterval, if any, associated with this object.
         * If availability is undefined, it is assumed that this object's
         * other properties will return valid data for any provided time.
         * If availability exists, the objects other properties will only
         * provide valid data if queried within the given interval.
         * @type TimeInterval
         */
        this.availability = undefined;

        /**
         * Gets or sets the position.
         * @type DynamicPositionProperty
         */
        this.position = undefined;

        /**
         * Gets or sets the orientation.
         * @type DynamicProperty
         */
        this.orientation = undefined;

        /**
         * Gets or sets the billboard.
         * @type DynamicBillboard
         */
        this.billboard = undefined;

        /**
         * Gets or sets the cone.
         * @type DynamicCone
         */
        this.cone = undefined;

        /**
         * Gets or sets the ellipsoid.
         * @type DynamicEllipsoid
         */
        this.ellipsoid = undefined;

        /**
         * Gets or sets the label.
         * @type DynamicLabel
         */
        this.label = undefined;

        /**
         * Gets or sets the path.
         * @type DynamicPath
         */
        this.path = undefined;

        /**
         * Gets or sets the point graphic.
         * @type DynamicPoint
         */
        this.point = undefined;

        /**
         * Gets or sets the polygon.
         * @type DynamicPolygon
         */
        this.polygon = undefined;

        /**
         * Gets or sets the polyline.
         * @type DynamicPolyline
         */
        this.polyline = undefined;

        /**
         * Gets or sets the pyramid.
         * @type DynamicPyramid
         */
        this.pyramid = undefined;

        /**
         * Gets or sets the vertex positions.
         * @type DynamicVertexPositionsProperty
         */
        this.vertexPositions = undefined;

        /**
         * Gets or sets the suggested initial offset for viewing this object
         * with the camera.  The offset is defined in the east-north-up reference frame.
         * @type Cartesian3
         */
        this.viewFrom = undefined;
    };

    /**
     * Given a time, returns true if this object should have data during that time.
     * @param {JulianDate} time The time to check availability for.
     * @exception {DeveloperError} time is required.
     * @returns true if the object should have data during the provided time, false otherwise.
     */
    DynamicObject.prototype.isAvailable = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }
        if (typeof this.availability === 'undefined') {
            return true;
        }
        if (this._cachedAvailabilityDate === time) {
            return this._cachedAvailabilityValue;
        }
        this._cachedAvailabilityDate = time;
        return this._cachedAvailabilityValue = this.availability.contains(time);
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's position
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the position data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicPositionProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketPosition = function(dynamicObject, packet) {
        var positionData = packet.position;
        if (typeof positionData === 'undefined') {
            return false;
        }

        var position = dynamicObject.position;
        var propertyCreated = typeof position === 'undefined';
        if (propertyCreated) {
            dynamicObject.position = position = new DynamicPositionProperty();
        }
        position.processCzmlIntervals(positionData);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's viewFrom
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the viewFrom data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketViewFrom = function(dynamicObject, packet) {
        var viewFromData = packet.viewFrom;
        if (typeof viewFromData === 'undefined') {
            return false;
        }

        var viewFrom = dynamicObject.viewFrom;
        var propertyCreated = typeof viewFrom === 'undefined';
        if (propertyCreated) {
            dynamicObject.viewFrom = viewFrom = new DynamicProperty(CzmlCartesian3);
        }
        viewFrom.processCzmlIntervals(viewFromData);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's orientation
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the orientation data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketOrientation = function(dynamicObject, packet) {
        var orientationData = packet.orientation;
        if (typeof orientationData === 'undefined') {
            return false;
        }

        var orientation = dynamicObject.orientation;
        var propertyCreated = typeof orientation === 'undefined';
        if (propertyCreated) {
            dynamicObject.orientation = orientation = new DynamicProperty(CzmlUnitQuaternion);
        }
        orientation.processCzmlIntervals(orientationData);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's vertexPositions
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the vertexPositions data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} dynamicObjectCollection The collection to use to resolve any CZML properly links.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketVertexPositions = function(dynamicObject, packet, dynamicObjectCollection) {
        var vertexPositionsData = packet.vertexPositions;
        if (typeof vertexPositionsData === 'undefined') {
            return false;
        }

        var vertexPositions = dynamicObject.vertexPositions;
        var propertyCreated = typeof dynamicObject.vertexPositions === 'undefined';
        if (propertyCreated) {
            dynamicObject.vertexPositions = vertexPositions = new DynamicVertexPositionsProperty();
        }
        vertexPositions.processCzmlIntervals(vertexPositionsData, undefined, dynamicObjectCollection);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's availability
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the availability data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketAvailability = function(dynamicObject, packet) {
        var availability = packet.availability;
        if (typeof availability === 'undefined') {
            return false;
        }

        var propertyChanged = false;
        var interval = TimeInterval.fromIso8601(availability);
        if (typeof interval !== 'undefined') {
            propertyChanged = dynamicObject._setAvailability(interval);
        }
        return propertyChanged;
    };

    /**
     * Given two DynamicObjects, takes the position, orientation, vertexPositions and availability
     * properties from the second and assigns them to the first, assuming such properties did not
     * already exist. This method is not normally called directly, but is part of the array of CZML
     * processing functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicObject.mergeProperties = function(targetObject, objectToMerge) {
        targetObject.position = defaultValue(targetObject.position, objectToMerge.position);
        targetObject.orientation = defaultValue(targetObject.orientation, objectToMerge.orientation);
        targetObject.vertexPositions = defaultValue(targetObject.vertexPositions, objectToMerge.vertexPositions);
        targetObject.viewFrom = defaultValue(targetObject.viewFrom, objectToMerge.viewFrom);
        var availability = objectToMerge.availability;
        if (typeof availability !== 'undefined') {
            targetObject._setAvailability(availability);
        }
    };

    /**
     * Given a DynamicObject, undefines the position, orientation, vertexPositions and availability
     * associated with it. This method is not normally called directly, but is part of the array of
     * CZML processing functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the billboard from.
     *
     * @see CzmlDefaults
     */
    DynamicObject.undefineProperties = function(dynamicObject) {
        dynamicObject.position = undefined;
        dynamicObject.orientation = undefined;
        dynamicObject.vertexPositions = undefined;
        dynamicObject.viewFrom = undefined;
        dynamicObject._setAvailability(undefined);
    };

    DynamicObject.prototype._setAvailability = function(availability) {
        var changed = !TimeInterval.equals(this.availability, availability);

        this.availability = availability;
        this._cachedAvailabilityDate = undefined;
        this._cachedAvailabilityValue = undefined;

        return changed;
    };

    return DynamicObject;
});
/*global define*/
define('DynamicScene/DynamicObjectCollection',[
        '../Core/Event',
        '../Core/TimeInterval',
        '../Core/Iso8601',
        '../Core/DeveloperError',
        './DynamicObject'
       ], function(
        Event,
        TimeInterval,
        Iso8601,
        DeveloperError,
        DynamicObject) {
    

    /**
     * A collection of DynamicObject instances.
     * @alias DynamicObjectCollection
     * @constructor
     */
    var DynamicObjectCollection = function() {
        this._hash = {};
        this._array = [];

        /**
         * The CompositeDynamicObjectCollection, if any, that this collection is in.
         */
        this.compositeCollection = undefined;

        /**
         * An {@link Event} that is fired whenever DynamicObjects in the collection have properties added.
         */
        this.objectPropertiesChanged = new Event();

        /**
         * An {@link Event} that is fired whenever DynamicObjects are removed from the collection.
         */
        this.objectsRemoved = new Event();
    };

    /**
     * Computes the maximum availability of the DynamicObjects in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * It will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     *
     * @returns {TimeInterval} The availability of DynamicObjects in the collection.
     */
    DynamicObjectCollection.prototype.computeAvailability = function() {
        var startTime = Iso8601.MAXIMUM_VALUE;
        var stopTime = Iso8601.MINIMUM_VALUE;
        var i;
        var len;
        var object;
        var dynamicObjects = this._array;
        for (i = 0, len = dynamicObjects.length; i < len; i++) {
            object = dynamicObjects[i];
            var availability = object.availability;
            if (typeof availability !== 'undefined') {
                var start = availability.start;
                var stop = availability.stop;
                if (start.lessThan(startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
                    startTime = object.availability.start;
                }
                if (stop.greaterThan(stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
                    stopTime = object.availability.stop;
                }
            }
        }

        if (startTime === Iso8601.MAXIMUM_VALUE) {
            startTime = Iso8601.MINIMUM_VALUE;
        }
        if (stopTime === Iso8601.MINIMUM_VALUE) {
            stopTime = Iso8601.MAXIMUM_VALUE;
        }
        return new TimeInterval(startTime, stopTime, true, true);
    };

    /**
     * Gets an object with the specified id.
     * @param {Object} id The id of the object to retrieve.
     *
     * @exception {DeveloperError} id is required.
     *
     * @returns The DynamicObject with the provided id, or undefined if no such object exists.
     */
    DynamicObjectCollection.prototype.getObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        return this._hash[id];
    };

    /**
     * Gets the array of DynamicObject instances in this composite collection.
     * @returns {Array} the array of DynamicObject instances in this composite collection.
     */
    DynamicObjectCollection.prototype.getObjects = function() {
        return this._array;
    };

    /**
     * Gets an object with the specified id or creates it and adds it to the collection if it does not exist.
     * @param {Object} id The id of the object to retrieve.
     *
     * @exception {DeveloperError} id is required.
     *
     * @returns The DynamicObject with the provided id.
     */
    DynamicObjectCollection.prototype.getOrCreateObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        var obj = this._hash[id];
        if (!obj) {
            obj = new DynamicObject(id);
            this._hash[id] = obj;
            this._array.push(obj);
        }
        return obj;
    };

    /**
     * Removes all objects from the collection.
     */
    DynamicObjectCollection.prototype.clear = function() {
        var removedObjects = this._array;
        this._hash = {};
        this._array = [];
        if (removedObjects.length > 0) {
            this.objectsRemoved.raiseEvent(this, removedObjects);
        }
    };

    return DynamicObjectCollection;
});
/*global define*/
define('Renderer/BlendEquation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendEquation
     */
    var BlendEquation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ADD : new Enumeration(0x8006, 'ADD'), // WebGL: FUNC_ADD

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SUBTRACT : new Enumeration(0x800A, 'SUBTRACT'), // WebGL: FUNC_SUBTRACT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REVERSE_SUBTRACT : new Enumeration(0x800B, 'REVERSE_SUBTRACT'), // WebGL: FUNC_REVERSE_SUBTRACT

        // No min and max like in ColladaFX GLES2 profile

        /**
         * DOC_TBA
         *
         * @param blendEquation
         *
         * @returns {Boolean}
         */
        validate : function(blendEquation) {
            return ((blendEquation === BlendEquation.ADD) ||
                    (blendEquation === BlendEquation.SUBTRACT) ||
                    (blendEquation === BlendEquation.REVERSE_SUBTRACT));
        }
    };

    return BlendEquation;
});
/*global define*/
define('Renderer/BlendFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendFunction
     */
    var BlendFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, 'ZERO'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE : new Enumeration(1, 'ONE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_COLOR : new Enumeration(0x0300, 'SOURCE_COLOR'), // WebGL: SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_COLOR : new Enumeration(0x0301, 'ONE_MINUS_SOURCE_COLOR'), // WebGL: ONE_MINUS_SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_COLOR : new Enumeration(0x0306, 'DESTINATION_COLOR'), // WebGL: DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_COLOR : new Enumeration(0x0307, 'ONE_MINUS_DESTINATION_COLOR'), // WebGL: ONE_MINUS_DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA : new Enumeration(0x0302, 'SOURCE_ALPHA'), // WebGL: SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_ALPHA : new Enumeration(0x0303, 'ONE_MINUS_SOURCE_ALPHA'), // WebGL: ONE_MINUS_SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_ALPHA : new Enumeration(0x0304, 'DESTINATION_ALPHA'), // WebGL: DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_ALPHA : new Enumeration(0x0305, 'ONE_MINUS_DESTINATION_ALPHA'), // WebGL: ONE_MINUS_DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_COLOR : new Enumeration(0x8001, 'CONSTANT_COLOR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_COLOR : new Enumeration(0x8002, 'ONE_MINUS_CONSTANT_COLOR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_ALPHA : new Enumeration(0x8003, 'CONSTANT_ALPHA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_ALPHA : new Enumeration(0x8004, 'ONE_MINUS_CONSTANT_ALPHA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA_SATURATE : new Enumeration(0x0308, 'SOURCE_ALPHA_SATURATE'), // WebGL: SRC_ALPHA_SATURATE

        /**
         * DOC_TBA
         *
         * @param blendFunction
         *
         * @returns {Boolean}
         */
        validate : function(blendFunction) {
            return ((blendFunction === BlendFunction.ZERO) ||
                    (blendFunction === BlendFunction.ONE) ||
                    (blendFunction === BlendFunction.SOURCE_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_SOURCE_COLOR) ||
                    (blendFunction === BlendFunction.DESTINATION_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_DESTINATION_COLOR) ||
                    (blendFunction === BlendFunction.SOURCE_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_SOURCE_ALPHA) ||
                    (blendFunction === BlendFunction.DESTINATION_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_DESTINATION_ALPHA) ||
                    (blendFunction === BlendFunction.CONSTANT_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_CONSTANT_COLOR) ||
                    (blendFunction === BlendFunction.CONSTANT_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_CONSTANT_ALPHA) ||
                    (blendFunction === BlendFunction.SOURCE_ALPHA_SATURATE));
        }
    };

    return BlendFunction;
});
/*global define*/
define('Renderer/BlendingState',[
        './BlendEquation',
        './BlendFunction'
    ], function(
        BlendEquation,
        BlendFunction) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendingState
     */
    var BlendingState = {
        /**
         * DOC_TBA
         */
        ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        PRE_MULTIPLIED_ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.ONE,
            functionSourceAlpha : BlendFunction.ONE,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        ADDITIVE_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE,
            functionDestinationAlpha : BlendFunction.ONE
        }
    };

    return BlendingState;
});
/*global define*/
define('Renderer/Buffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias Buffer
     * @internalConstructor
     *
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     */
    var Buffer = function(gl, bufferTarget, sizeInBytes, usage, buffer) {
        this._gl = gl;
        this._bufferTarget = bufferTarget;
        this._sizeInBytes = sizeInBytes;
        this._usage = usage;
        this._buffer = buffer;
        this._vertexArrayDestroyable = true;
    };

    /**
     * DOC_TBA
     * DOC_TBA: arrayView
     *
     * @memberof Buffer
     * @param {Number} [offsetInBytes=0] DOC_TBA
     *
     * @exception {DeveloperError} arrayView is required.
     * @exception {DeveloperError} This buffer is not large enough.
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
        if (!arrayView) {
            throw new DeveloperError('arrayView is required.');
        }

        offsetInBytes = offsetInBytes || 0;

        if (offsetInBytes + arrayView.byteLength > this._sizeInBytes) {
            throw new DeveloperError('This buffer is not large enough.');
        }

        var gl = this._gl;
        var target = this._bufferTarget;
        gl.bindBuffer(target, this._buffer);
        gl.bufferSubData(target, offsetInBytes, arrayView);
        gl.bindBuffer(target, null);
    };

    Buffer.prototype._getBuffer = function() {
        return this._buffer;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {Number} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getSizeInBytes = function() {
        return this._sizeInBytes;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {GLenum} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getUsage = function() {
        return this._usage;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.getVertexArrayDestroyable = function() {
        return this._vertexArrayDestroyable;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.setVertexArrayDestroyable = function(value) {
        this._vertexArrayDestroyable = value;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Buffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Buffer#destroy
     */
    Buffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Buffer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     *
     * @see Buffer#isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml'>glDeleteBuffers</a>
     *
     * @example
     * buffer = buffer && buffer.destroy();
     */
    Buffer.prototype.destroy = function() {
        this._gl.deleteBuffer(this._buffer);
        return destroyObject(this);
    };

    return Buffer;
});
/*global define*/
define('Renderer/BufferUsage',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BufferUsage
     */
    var BufferUsage = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STREAM_DRAW : new Enumeration(0x88E0, 'STREAM_DRAW'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STATIC_DRAW : new Enumeration(0x88E4, 'STATIC_DRAW'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DYNAMIC_DRAW : new Enumeration(0x88E8, 'DYNAMIC_DRAW'),

        /**
         * DOC_TBA
         *
         * @param bufferUsage
         *
         * @returns {Boolean}
         */
        validate : function(bufferUsage) {
            return ((bufferUsage === BufferUsage.STREAM_DRAW) ||
                    (bufferUsage === BufferUsage.STATIC_DRAW) ||
                    (bufferUsage === BufferUsage.DYNAMIC_DRAW));
        }
    };

    return BufferUsage;
});
/*global define*/
define('Renderer/ClearCommand',['../Core/DeveloperError'], function(DeveloperError) {
    

    /**
     * Represents a command to the renderer for clearing.
     *
     * @alias Command
     * @constructor
     *
     * @param {ClearState} [clearState] The clear state.
     */
    var ClearCommand = function(clearState) {
        /**
         * The clear state.  If this property is undefined, a default clear state is used.
         * @type Object
         */
        this.clearState = clearState;

        /**
         * The framebuffer to clear.
         * @type Framebuffer
         */
        this.framebuffer = undefined;
    };

    /**
     * Executes the clear command.
     *
     * @memberof ClearCommand
     *
     * @param {Context} context The renderer context in which to clear.
     * @param {Framebuffer} [framebuffer] The framebuffer to clear if one is not specified by the command.
     */
    ClearCommand.prototype.execute = function(context, framebuffer) {
        context.clear(this, framebuffer);
    };

    return ClearCommand;
});
/*global define*/
define('Renderer/CommandLists',[],function() {
    

    /**
     * Represents lists of commands for drawing for each render pass.
     *
     * @alias CommandLists
     * @constructor
     */
    var CommandLists = function() {
        /**
         * The command list for a color pass.
         * @type Array
         */
        this.colorList = [];

        /**
         * The command list for a pick pass.
         * @type Array
         */
        this.pickList = [];

        /**
         * The command list for an overlay pass.
         * @type Array
         */
        this.overlayList = [];
    };

    CommandLists.prototype.empty = function() {
        return this.colorList.length === 0 && this.pickList.length === 0 && this.overlayList.length === 0;
    };

    CommandLists.prototype.removeAll = function() {
        this.colorList.length = 0;
        this.pickList.length = 0;
        this.overlayList.length = 0;
    };

    return CommandLists;
});
/*global define*/
define('Renderer/CullFace',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CullFace
     */
    var CullFace = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT : new Enumeration(0x0404, 'FRONT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        BACK : new Enumeration(0x0405, 'BACK'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT_AND_BACK : new Enumeration(0x0408, 'FRONT_AND_BACK'),

        /**
         * DOC_TBA
         *
         * @param cullFace
         *
         * @returns {Boolean}
         */
        validate : function(cullFace) {
            return ((cullFace === CullFace.FRONT) ||
                    (cullFace === CullFace.BACK) ||
                    (cullFace === CullFace.FRONT_AND_BACK));
        }
    };

    return CullFace;
});
/*global define*/
define('Renderer/DepthFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports DepthFunction
     */
    var DepthFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, 'NEVER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, 'LESS'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, 'EQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, 'LEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, 'GREATER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, 'NOTEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, 'GEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, 'ALWAYS'),

        /**
         * DOC_TBA
         *
         * @param depthFunction
         *
         * @returns {Boolean}
         */
        validate : function(depthFunction) {
            return ((depthFunction === DepthFunction.NEVER) ||
                    (depthFunction === DepthFunction.LESS) ||
                    (depthFunction === DepthFunction.EQUAL) ||
                    (depthFunction === DepthFunction.LESS_OR_EQUAL) ||
                    (depthFunction === DepthFunction.GREATER) ||
                    (depthFunction === DepthFunction.NOT_EQUAL) ||
                    (depthFunction === DepthFunction.GREATER_OR_EQUAL) ||
                    (depthFunction === DepthFunction.ALWAYS));
        }
    };

    return DepthFunction;
});
/*global define*/
define('Renderer/DrawCommand',['../Core/DeveloperError'], function(DeveloperError) {
    

    /**
     * Represents a command to the renderer for drawing.
     *
     * @alias Command
     * @constructor
     */
    var DrawCommand = function() {
        /**
         * The bounding volume of the geometry.
         * @type DOC_TBA
         */
        this.boundingVolume = undefined;

        /**
         * The transformation from the geometry in model space to world space.
         * @type Matrix4
         */
        this.modelMatrix = undefined;

        /**
         * The type of geometry in the vertex array.
         * @type PrimitiveType
         */
        this.primitiveType = undefined;

        /**
         * The vertex array.
         * @type VertexArray
         */
        this.vertexArray = undefined;

        /**
         * The number of vertices to draw in the vertex array.
         * @type Number
         */
        this.count = undefined;

        /**
         * The offset to start drawing in the vertex array.
         * @type Number
         */
        this.offset = undefined;

        /**
         * The shader program to apply.
         * @type ShaderProgram
         */
        this.shaderProgram = undefined;

        /**
         * An object with functions whose names match the uniforms in the shader program
         * and return values to set those uniforms.
         * @type Object
         */
        this.uniformMap = undefined;

        /**
         * The render state.
         * @type Object
         *
         * @see Context#createRenderState
         */
        this.renderState = undefined;

        /**
         * The framebuffer to draw to.
         * @type Framebuffer
         */
        this.framebuffer = undefined;
    };

    /**
     * Executes the draw command.
     *
     * @memberof DrawCommand
     *
     * @param {Context} context The renderer context in which to draw.
     * @param {Framebuffer} [framebuffer] The framebuffer to which to draw if one is not specified by the command.
     */
    DrawCommand.prototype.execute = function(context, framebuffer) {
        context.draw(this, framebuffer);
    };

    return DrawCommand;
});
/*global define*/
define('Renderer/MipmapHint',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports MipmapHint
     */
    var MipmapHint = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DONT_CARE : new Enumeration(0x1100, 'DONT_CARE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FASTEST : new Enumeration(0x1101, 'FASTEST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NICEST : new Enumeration(0x1102, 'NICEST'),

        /**
         * DOC_TBA
         *
         * @param mipmapHint
         *
         * @returns {Boolean}
         */
        validate : function(mipmapHint) {
            return ((mipmapHint === MipmapHint.DONT_CARE) ||
                    (mipmapHint === MipmapHint.FASTEST) ||
                    (mipmapHint === MipmapHint.NICEST));
        }
    };

    return MipmapHint;
});
/*global define*/
define('Renderer/PixelDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelDatatype
     */
    var PixelDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, 'UNSIGNED_BYTE'),

        /**
         * An unsigned short pixel datatype used for depth textures with 16-bit depth values.
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT : new Enumeration(0x1403, 'UNSIGNED_SHORT'),

        /**
         * An unsigned int pixel datatype used for depth textures with 32-bit depth values.
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_INT : new Enumeration(0x1405, 'UNSIGNED_INT'),

        /**
         * An unsigned int pixel datatype used for depth-stencil textures with 24-bit depth and 8-bit stencil values.
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_INT_24_8_WEBGL : new Enumeration(0x84FA, 'UNSIGNED_INT_24_8_WEBGL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_4_4_4_4 : new Enumeration(0x8033, 'UNSIGNED_SHORT_4_4_4_4'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_5_5_1 : new Enumeration(0x8034, 'UNSIGNED_SHORT_5_5_5_1'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_6_5 : new Enumeration(0x8363, 'UNSIGNED_SHORT_5_6_5'),

        /**
         * DOC_TBA
         *
         * @param pixelDatatype
         *
         * @returns {Boolean}
         */
        validate : function(pixelDatatype) {
            return ((pixelDatatype === PixelDatatype.UNSIGNED_BYTE) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_INT) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8_WEBGL) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5));
        }
    };

    return PixelDatatype;
});
/*global define*/
define('Renderer/PixelFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelFormat
     */
    var PixelFormat = {
        /**
         * A pixel format containing a depth value.
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT : new Enumeration(0x1902, 'DEPTH_COMPONENT'),

        /**
         * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8_WEBGL}.
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_STENCIL : new Enumeration(0x84F9, 'DEPTH_STENCIL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALPHA : new Enumeration(0x1906, 'ALPHA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB : new Enumeration(0x1907, 'RGB'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA : new Enumeration(0x1908, 'RGBA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE : new Enumeration(0x1909, 'LUMINANCE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE_ALPHA : new Enumeration(0x190A, 'LUMINANCE_ALPHA'),

        /**
         * Returns true if the pixel format is a valid enumeration value.
         *
         * @param {PixelFormat} pixelFormat The pixel format to test.
         *
         * @returns {Boolean} Returns true if the pixel format is a valid enumeration value; otherwise, false.
         */
        validate : function(pixelFormat) {
            return ((pixelFormat === PixelFormat.DEPTH_COMPONENT) ||
                    (pixelFormat === PixelFormat.DEPTH_STENCIL) ||
                    (pixelFormat === PixelFormat.ALPHA) ||
                    (pixelFormat === PixelFormat.RGB) ||
                    (pixelFormat === PixelFormat.RGBA) ||
                    (pixelFormat === PixelFormat.LUMINANCE) ||
                    (pixelFormat === PixelFormat.LUMINANCE_ALPHA));
        },

        /**
         * Returns true if the pixel format is a color format.
         *
         * @param {PixelFormat} pixelFormat The pixel format to test.
         *
         * @returns {Boolean} Returns true if the pixel format is a color format; otherwise false.
         */
        isColorFormat : function(pixelFormat) {
            return ((pixelFormat === PixelFormat.ALPHA) ||
                    (pixelFormat === PixelFormat.RGB) ||
                    (pixelFormat === PixelFormat.RGBA) ||
                    (pixelFormat === PixelFormat.LUMINANCE) ||
                    (pixelFormat === PixelFormat.LUMINANCE_ALPHA));
        },

        /**
         * Returns true if the pixel format is a depth format.
         *
         * @param {PixelFormat} pixelFormat The pixel format to test.
         *
         * @returns {Boolean} Returns true if the pixel format is a depth format; otherwise false.
         */
        isDepthFormat : function(pixelFormat) {
            return ((pixelFormat === PixelFormat.DEPTH_COMPONENT) ||
                    (pixelFormat === PixelFormat.DEPTH_STENCIL));
        }
    };

    return PixelFormat;
});
/*global define*/
define('Renderer/Framebuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './PixelFormat'
    ], function(
        DeveloperError,
        destroyObject,
        PixelFormat) {
    

    /**
     * A framebuffer is a target for draw and clear calls.  It can contain color, depth, and stencil attachments
     * that are written to in response to these calls.  If the attachments are textures, they can be read in
     * later rendering passes.
     *
     * @alias Framebuffer
     *
     * @see Context#createFramebuffer
     *
     * @internalConstructor
     */
    var Framebuffer = function(gl, description) {
        this._gl = gl;
        this._framebuffer = gl.createFramebuffer();

        this._colorTexture = undefined;
        this._colorRenderbuffer = undefined;
        this._depthTexture = undefined;
        this._depthRenderbuffer = undefined;
        this._stencilRenderbuffer = undefined;
        this._depthStencilTexture = undefined;
        this._depthStencilRenderbuffer = undefined;

        /**
         * When true, the framebuffer owns its attachments so they will be destroyed when
         * {@link Framebuffer#destroy} is called or when a new attachment is assigned
         * to an attachment point.
         *
         * @type Boolean
         * @default true
         *
         * @see Framebuffer#destroy
         */
        this.destroyAttachments = true;

        if (description) {
            // Throw if a texture and renderbuffer are attached to the same point.  This won't
            // cause a WebGL error (because only one will be attached), but is likely a developer error.

            if (description.colorTexture && description.colorRenderbuffer) {
                throw new DeveloperError('Cannot have both a color texture and color renderbuffer attachment.');
            }

            if (description.depthTexture && description.depthRenderbuffer) {
                throw new DeveloperError('Cannot have both a depth texture and depth renderbuffer attachment.');
            }

            if (description.depthStencilTexture && description.depthStencilRenderbuffer) {
                throw new DeveloperError('Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.');
            }

            // Avoid errors defined in Section 6.5 of the WebGL spec
            var depthAttachment = (description.depthTexture || description.depthRenderbuffer);
            var depthStencilAttachment = (description.depthStencilTexture || description.depthStencilRenderbuffer);

            if (depthAttachment && depthStencilAttachment) {
                throw new DeveloperError('Cannot have both a depth and depth-stencil attachment.');
            }

            if (description.stencilRenderbuffer && depthStencilAttachment) {
                throw new DeveloperError('Cannot have both a stencil and depth-stencil attachment.');
            }

            if (depthAttachment && description.stencilRenderbuffer) {
                throw new DeveloperError('Cannot have both a depth and stencil attachment.');
            }

            ///////////////////////////////////////////////////////////////////

            if (description.colorTexture) {
                this.setColorTexture(description.colorTexture);
            }

            if (description.colorRenderbuffer) {
                this.setColorRenderbuffer(description.colorRenderbuffer);
            }

            if (description.depthTexture) {
                this.setDepthTexture(description.depthTexture);
            }

            if (description.depthRenderbuffer) {
                this.setDepthRenderbuffer(description.depthRenderbuffer);
            }

            if (description.stencilRenderbuffer) {
                this.setStencilRenderbuffer(description.stencilRenderbuffer);
            }

            if (description.depthStencilTexture) {
                this.setDepthStencilTexture(description.depthStencilTexture);
            }

            if (description.depthStencilRenderbuffer) {
                this.setDepthStencilRenderbuffer(description.depthStencilRenderbuffer);
            }
        }
    };

    Framebuffer.prototype._bind = function() {
        var gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    };

    Framebuffer.prototype._unBind = function() {
        var gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    function attachTexture(framebuffer, attachment, texture) {
        framebuffer._bind();
        var gl = framebuffer._gl;

        if (texture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, texture._getTarget(), texture._getTexture(), 0);
        } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, null, 0);
        }
        framebuffer._unBind();
    }

    function attachRenderbuffer(framebuffer, attachment, renderbuffer) {
        framebuffer._bind();
        var gl = framebuffer._gl;

        if (renderbuffer) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
        } else {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, null);
        }
        framebuffer._unBind();
    }

    function destroyAttachment(framebuffer, attachment) {
        if (framebuffer.destroyAttachments && attachment && attachment.destroy) {
            attachment.destroy();
        }
    }

    /**
     * Attaches a texture to the color attachment point.  When this framebuffer is passed to a draw
     * or clear call, the texture is the target of color output, e.g., <code>gl_FragColor</code>.
     *
     * @memberof Framebuffer
     *
     * @param {Texture} The texture to attach.  <code>undefined</code> dettaches the current texture.
     *
     * @exception {DeveloperError} The color-texture pixel-format must be a color format.
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setColorTexture = function(texture) {
        if (texture && !PixelFormat.isColorFormat(texture.getPixelFormat())) {
            throw new DeveloperError('The color-texture pixel-format must be a color format.');
        }

        attachTexture(this, this._gl.COLOR_ATTACHMENT0, texture);
        destroyAttachment(this, this._colorTexture);
        this._colorTexture = texture;
    };

    /**
     * Returns the color texture attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The color texture attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getColorTexture = function() {
        return this._colorTexture;
    };

    /**
     * Prefer {@link Framebuffer#setColorTexture}.
     *
     * @memberof Framebuffer
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setColorRenderbuffer = function(renderbuffer) {
        attachRenderbuffer(this, this._gl.COLOR_ATTACHMENT0, renderbuffer);
        destroyAttachment(this, this._colorRenderbuffer);
        this._colorRenderbuffer = renderbuffer;
    };

    /**
     * Returns the color renderbuffer attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The color renderbuffer attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getColorRenderbuffer = function() {
        return this._colorRenderbuffer;
    };

    /**
     * Attaches a texture to the depth attachment point.  When this framebuffer is passed to a draw
     * or clear call, the texture is the target of depth output.
     *
     * @memberof Framebuffer
     *
     * @param {Texture} The texture to attach.  <code>undefined</code> dettaches the current texture.
     *
     * @exception {DeveloperError} The depth-texture pixel-format must be DEPTH_COMPONENT.
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setDepthTexture = function(texture) {
        if (texture && (texture.getPixelFormat() !== PixelFormat.DEPTH_COMPONENT)) {
            throw new DeveloperError('The depth-texture pixel-format must be DEPTH_COMPONENT.');
        }

        attachTexture(this, this._gl.DEPTH_ATTACHMENT, texture);
        destroyAttachment(this, this._depthTexture);
        this._depthTexture = texture;
    };

    /**
     * Returns the depth texture attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The depth texture attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getDepthTexture = function() {
        return this._depthTexture;
    };

    /**
     * Prefer {@link Framebuffer#setDepthTexture}.
     *
     * @memberof Framebuffer
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setDepthRenderbuffer = function(renderbuffer) {
        attachRenderbuffer(this, this._gl.DEPTH_ATTACHMENT, renderbuffer);
        destroyAttachment(this, this._depthRenderbuffer);
        this._depthRenderbuffer = renderbuffer;
    };

    /**
     * Returns the depth renderbuffer attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The depth renderbuffer attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getDepthRenderbuffer = function() {
        return this._depthRenderbuffer;
    };

    /**
     * Prefer {@link Framebuffer#setDepthStencilTexture}.
     *
     * @memberof Framebuffer
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setStencilRenderbuffer = function(renderbuffer) {
        attachRenderbuffer(this, this._gl.STENCIL_ATTACHMENT, renderbuffer);
        destroyAttachment(this, this._stencilRenderbuffer);
        this._stencilRenderbuffer = renderbuffer;
    };

    /**
     * Returns the stencil renderbuffer attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The stencil renderbuffer attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getStencilRenderbuffer = function() {
        return this._stencilRenderbuffer;
    };

    /**
     * Attaches a texture to the depth-stencil attachment point.  When this framebuffer is passed to a draw
     * or clear call, the texture is the target of depth and stencil output.
     *
     * @memberof Framebuffer
     *
     * @param {Texture} The texture to attach.  <code>undefined</code> dettaches the current texture.
     *
     * @exception {DeveloperError} The depth-stencil-texture pixel-format must be DEPTH_STENCIL.
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setDepthStencilTexture = function(texture) {
        if (texture && (texture.getPixelFormat() !== PixelFormat.DEPTH_STENCIL)) {
            throw new DeveloperError('The depth-stencil pixel-format must be DEPTH_STENCIL.');
        }

        attachTexture(this, this._gl.DEPTH_STENCIL_ATTACHMENT, texture);
        destroyAttachment(this, this._depthStencilTexture);
        this._depthStencilTexture = texture;
    };

    /**
     * Returns the depth-stencil texture attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The depth-stencil texture attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getDepthStencilTexture = function() {
        return this._depthStencilTexture;
    };

    /**
     * Prefer {@link Framebuffer#setDepthStencilTexture}.
     *
     * @memberof Framebuffer
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.setDepthStencilRenderbuffer = function(renderbuffer) {
        attachRenderbuffer(this, this._gl.DEPTH_STENCIL_ATTACHMENT, renderbuffer);
        destroyAttachment(this, this._depthStencilRenderbuffer);
        this._depthStencilRenderbuffer = renderbuffer;
    };

    /**
     * Returns the depth-stencil renderbuffer attached to this framebuffer.
     *
     * @memberof Framebuffer
     *
     * @returns {Texture} The depth-stencil renderbuffer attached to this framebuffer.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.getDepthStencilRenderbuffer = function() {
        return this._depthStencilRenderbuffer;
    };

    /**
     * Returns true if the framebuffer has a depth attachment.  Depth attachments include
     * depth and depth-stencil textures, and depth and depth-stencil renderbuffers.  When
     * rendering to a framebuffer, a depth attachment is required for the depth test to have effect.
     *
     * @memberof Framebuffer
     *
     * @return {Boolean} Returns true if the framebuffer has a depth attachment; otherwise, false.
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     */
    Framebuffer.prototype.hasDepthAttachment = function() {
        return !!(this.getDepthTexture() || this.getDepthRenderbuffer() || this.getDepthStencilTexture() || this.getDepthStencilRenderbuffer());
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Framebuffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Framebuffer#destroy
     */
    Framebuffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Framebuffer attachments are only destoryed if the framebuffer owns them, i.e., {@link destroyAttachments}
     * is true.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Framebuffer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
     *
     * @see Framebuffer#isDestroyed
     * @see Framebuffer#destroyAttachments
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteFramebuffers.xml'>glDeleteFramebuffers</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml'>glDeleteRenderbuffers</a>
     *
     * @example
     * var texture = context.createTexture2D({ width : 1, height : 1 });
     * framebuffer = context.createFramebuffer({ colorTexture : texture });
     * // ...
     * framebuffer = framebuffer.destroy();
     * // texture is also destroyed.
     */
    Framebuffer.prototype.destroy = function() {
        if (this.destroyAttachments) {
            // If the color texture is a cube map face, it is owned by the cube map, and will not be destroyed.
            this._colorTexture = this._colorTexture && this._colorTexture.destroy && this._colorTexture.destroy();
            this._colorRenderbuffer = this._colorRenderbuffer && this._colorRenderbuffer.destroy();
            this._depthTexture = this._depthTexture && this._depthTexture.destroy();
            this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
            this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy();
            this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
            this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
        }

        this._gl.deleteFramebuffer(this._framebuffer);
        return destroyObject(this);
    };

    return Framebuffer;
});
/*global define*/
define('Renderer/Renderbuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias Renderbuffer
     * @internalConstructor
     *
     * @see Context#createRenderbuffer
     */
    function Renderbuffer(_gl, _format, _width, _height) {
        var _renderbuffer = _gl.createRenderbuffer();

        _gl.bindRenderbuffer(_gl.RENDERBUFFER, _renderbuffer);
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _format, _width, _height);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getFormat = function() {
            return _format;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getWidth = function() {
            return _width;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getHeight = function() {
            return _height;
        };

        this._getRenderbuffer = function() {
            return _renderbuffer;
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @memberof Renderbuffer
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see Renderbuffer.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>undefined</code>) to the object as done in the example.
         *
         * @memberof Renderbuffer
         *
         * @return {undefined}
         *
         * @exception {DeveloperError} This shader renderbuffer destroyed, i.e., destroy() was called.
         *
         * @see Renderbuffer.isDestroyed
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml'>glDeleteRenderbuffers</a>
         *
         * @example
         * renderbuffer = renderbuffer && renderbuffer.destroy();
         */
        this.destroy = function() {
            _gl.deleteRenderbuffer(_renderbuffer);
            return destroyObject(this);
        };
    }

    return Renderbuffer;
});
/*global define*/
define('Renderer/RenderbufferFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports RenderbufferFormat
     */
    var RenderbufferFormat = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA4 : new Enumeration(0x8056, 'RGBA4'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB5_A1 : new Enumeration(0x8057, 'RGB5_A1'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB565 : new Enumeration(0x8D62, 'RGB565'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT16 : new Enumeration(0x81A5, 'DEPTH_COMPONENT16'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STENCIL_INDEX8 : new Enumeration(0x8D48, 'STENCIL_INDEX8'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_STENCIL : new Enumeration(0x84F9, 'DEPTH_STENCIL'),

        /**
         * DOC_TBA
         *
         * @param renderbufferFormat
         *
         * @returns {Boolean}
         */
        validate : function(renderbufferFormat) {
            return ((renderbufferFormat === RenderbufferFormat.RGBA4) ||
                    (renderbufferFormat === RenderbufferFormat.RGB5_A1) ||
                    (renderbufferFormat === RenderbufferFormat.RGB565) ||
                    (renderbufferFormat === RenderbufferFormat.DEPTH_COMPONENT16) ||
                    (renderbufferFormat === RenderbufferFormat.STENCIL_INDEX8) ||
                    (renderbufferFormat === RenderbufferFormat.DEPTH_STENCIL));
        }
    };

    return RenderbufferFormat;
});
/*global define*/
define('Renderer/PickFramebuffer',[
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/DeveloperError',
        './ClearCommand',
        './RenderbufferFormat'
    ], function(
        defaultValue,
        destroyObject,
        Color,
        DeveloperError,
        ClearCommand,
        RenderbufferFormat) {
    

    /**
     * DOC_TBA
     *
     * @alias PickFramebuffer
     * @internalConstructor
     *
     * @see Context#createPickFramebuffer
     * @see Context#pick
     */
    var PickFramebuffer = function(context) {
        this._context = context;
        this._fb = null;
        this._width = 0;
        this._height = 0;

        // Clear to black.  Since this is the background color, no objects will be black
        this._clearCommand = new ClearCommand();
        this._clearCommand.clearState = context.createClearState({
            color : new Color(0.0, 0.0, 0.0, 1.0),
            depth : 1.0,
            stencil : 0
        });
    };

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.begin = function() {
        var context = this._context;

        // Initially create or recreate renderbuffers and framebuffer used for picking
        if (!this._fb ||
            (this._width !== context.getCanvas().clientWidth) ||
            (this._height !== context.getCanvas().clientHeight)) {
            this._width = context.getCanvas().clientWidth;
            this._height = context.getCanvas().clientHeight;

            this._fb = this._fb && this._fb.destroy();
            this._fb = context.createFramebuffer({
                colorRenderbuffer : context.createRenderbuffer(),
                depthStencilRenderbuffer : context.createRenderbuffer({
                    format : RenderbufferFormat.DEPTH_STENCIL
                })
            });
        }

        this._clearCommand.execute(context, this._fb);

        return this._fb;
    };

    var colorScratch = new Color();

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.end = function(screenSpaceRectangle) {
        if (typeof screenSpaceRectangle === 'undefined') {
            throw new DeveloperError('screenSpaceRectangle is required.');
        }

        var width = defaultValue(screenSpaceRectangle.width, 1.0);
        var height = defaultValue(screenSpaceRectangle.height, 1.0);

        var pixels = this._context.readPixels({
            x : screenSpaceRectangle.x,
            y : screenSpaceRectangle.y,
            width : width,
            height : height,
            framebuffer : this._fb
        });

        var max = Math.max(width, height);
        var length = max * max;
        var halfWidth = Math.floor(width * 0.5);
        var halfHeight = Math.floor(height * 0.5);

        var x = 0;
        var y = 0;
        var dx = 0;
        var dy = -1;

        // Spiral around the center pixel, this is a workaround until
        // we can access the depth buffer on all browsers.

        // The region does not have to square and the dimensions do not have to be odd, but
        // loop iterations would be wasted. Prefer square regions where the size is odd.
        for (var i = 0; i < length; ++i) {
            if (-halfWidth <= x && x <= halfWidth && -halfHeight <= y && y <= halfHeight) {
                var index = 4 * ((halfHeight - y) * width + x + halfWidth);

                colorScratch.red = pixels[index];
                colorScratch.green = pixels[index + 1];
                colorScratch.blue = pixels[index + 2];
                colorScratch.alpha = pixels[index + 3];

                var object = this._context.getObjectByPickId(colorScratch);
                if (typeof object !== 'undefined') {
                    return object;
                }
            }

            // if (top right || bottom left corners) || (top left corner) || (bottom right corner + (1, 0)
            // change spiral direction
            if (x === y || (x < 0 && -x === y) || (x > 0 && x === 1 - y)) {
                var temp = dx;
                dx = -dy;
                dy = temp;
            }

            x += dx;
            y += dy;
        }

        return undefined;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PickFramebuffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see PickFramebuffer#destroy
     */
    PickFramebuffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof PickFramebuffer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PickFramebuffer#isDestroyed
     *
     * @example
     * PickFramebuffer = PickFramebuffer && PickFramebuffer.destroy();
     */
    PickFramebuffer.prototype.destroy = function() {
        this._fb = this._fb && this._fb.destroy();
        return destroyObject(this);
    };

    return PickFramebuffer;
});
/*global define*/
define('Renderer/ShaderCache',[
        '../Core/destroyObject'
    ], function(
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias ShaderCache
     *
     * @internalConstructor
     *
     * @see Context#getShaderCache
     */
    var ShaderCache = function(context) {
        this._context = context;
        this._shaders = {};
        this._shadersToRelease = {};
    };

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @returns {ShaderProgram} DOC_TBA.
     */
    ShaderCache.prototype.getShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        // TODO: compare attributeLocations!
        var keyword = vertexShaderSource + fragmentShaderSource;
        var cachedShader;

        if (this._shaders[keyword]) {
            cachedShader = this._shaders[keyword];
        } else {
            var sp = this._context.createShaderProgram(vertexShaderSource, fragmentShaderSource, attributeLocations);

            cachedShader = {
                cache : this,
                shaderProgram : sp,
                keyword : keyword,
                count : 0
            };

            // A shader can't be in more than one cache.
            sp._cachedShader = cachedShader;
            this._shaders[keyword] = cachedShader;
        }

        ++cachedShader.count;
        return cachedShader.shaderProgram;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroyReleasedShaderPrograms = function() {
        var shadersToRelease = this._shadersToRelease;

        for ( var keyword in shadersToRelease) {
            if (shadersToRelease.hasOwnProperty(keyword)) {
                // Check the count again here because the shader may have been requested
                // after it was released, in which case, we are avoiding thrashing the cache.
                var cachedShader = shadersToRelease[keyword];
                if (cachedShader.count === 0) {
                    delete this._shaders[cachedShader.keyword];
                    cachedShader.shaderProgram.destroy();
                }
            }
        }

        this._shadersToRelease = {};
    };

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @parameter {ShaderProgram} shaderProgram DOC_TBA.
     */
    ShaderCache.prototype.releaseShaderProgram = function(shaderProgram) {
        if (shaderProgram) {
            var cachedShader = shaderProgram._cachedShader;
            if (cachedShader && (--cachedShader.count === 0)) {
                this._shadersToRelease[cachedShader.keyword] = cachedShader;
            }
        }

        return null;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroy = function() {
        var shaders = this._shaders;

        for ( var keyword in shaders) {
            if (shaders.hasOwnProperty(keyword)) {
                shaders[keyword].shaderProgram.destroy();
            }
        }

        return destroyObject(this);
    };

    return ShaderCache;
});
/*global define*/
define('Renderer/StencilFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilFunction
     */
    var StencilFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, 'NEVER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, 'LESS'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, 'EQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, 'LESS_OR_EQUAL'), // WebGL: LEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, 'GREATER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, 'NOT_EQUAL'), // WebGL: NOTEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, 'GREATER_OR_EQUAL'), // WebGL: GEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, 'ALWAYS'),

        /**
         * DOC_TBA
         *
         * @param stencilFunction
         *
         * @returns {Boolean}
         */
        validate : function(stencilFunction) {
            return ((stencilFunction === StencilFunction.NEVER) ||
                    (stencilFunction === StencilFunction.LESS) ||
                    (stencilFunction === StencilFunction.EQUAL) ||
                    (stencilFunction === StencilFunction.LESS_OR_EQUAL) ||
                    (stencilFunction === StencilFunction.GREATER) ||
                    (stencilFunction === StencilFunction.NOT_EQUAL) ||
                    (stencilFunction === StencilFunction.GREATER_OR_EQUAL) ||
                    (stencilFunction === StencilFunction.ALWAYS));
        }
    };

    return StencilFunction;
});
/*global define*/
define('Renderer/StencilOperation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilOperation
     */
    var StencilOperation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, 'ZERO'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        KEEP : new Enumeration(0x1E00, 'KEEP'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPLACE : new Enumeration(0x1E01, 'REPLACE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT : new Enumeration(0x1E02, 'INCREMENT'), // WebGL: INCR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT : new Enumeration(0x1E03, 'DECREMENT'), // WebGL: DECR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INVERT : new Enumeration(0x150A, 'INVERT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT_WRAP : new Enumeration(0x8507, 'INCREMENT_WRAP'), // WebGL: INCR_WRAP

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT_WRAP : new Enumeration(0x8508, 'DECREMENT_WRAP'), // WebGL: DECR_WRAP

        /**
         * DOC_TBA
         *
         * @param stencilOperation
         *
         * @returns {Boolean}
         */
        validate : function(stencilOperation) {
            return ((stencilOperation === StencilOperation.ZERO) ||
                    (stencilOperation === StencilOperation.KEEP) ||
                    (stencilOperation === StencilOperation.REPLACE) ||
                    (stencilOperation === StencilOperation.INCREMENT) ||
                    (stencilOperation === StencilOperation.DECREMENT) ||
                    (stencilOperation === StencilOperation.INVERT) ||
                    (stencilOperation === StencilOperation.INCREMENT_WRAP) ||
                    (stencilOperation === StencilOperation.DECREMENT_WRAP));
        }
    };

    return StencilOperation;
});
/*global define*/
define('Renderer/TextureAtlas',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/BoundingRectangle',
        '../Core/createGuid',
        './PixelFormat'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        BoundingRectangle,
        createGuid,
        PixelFormat) {
    

    // The atlas is made up of regions of space called nodes that contain images or child nodes.
    function TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {
        this.bottomLeft = (typeof bottomLeft !== 'undefined') ? bottomLeft : new Cartesian2();
        this.topRight = (typeof topRight !== 'undefined') ? topRight : new Cartesian2();
        this.childNode1 = childNode1;
        this.childNode2 = childNode2;
        this.imageIndex = imageIndex;
    }

    /**
     * A TextureAtlas stores multiple images in one square texture and keeps
     * track of the texture coordinates for each image. TextureAtlas is dynamic,
     * meaning new images can be added at any point in time.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @alias TextureAtlas
     *
     * @param {Context} description.context The context in which the texture gets created.
     * @param {PixelFormat} [description.pixelFormat = PixelFormat.RGBA] The pixel format of the texture.
     * @param {Number} [description.borderWidthInPixels = 1] The amount of spacing between adjacent images in pixels.
     * @param {Cartesian2} [description.initialSize = new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.
     * @param {Array} description.images Optional array of {@link Image} to be added to the atlas. Same as calling addImages(images).
     * @param {Image} description.image Optional single image to be added to the atlas. Same as calling addImage(image).
     *
     * @internalConstructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.
     * @exception {DeveloperError} initialSize must be greater than zero.
     */
    var TextureAtlas = function(description) {
        description = (typeof description !== 'undefined') ? description : {};
        var context = description.context;
        var pixelFormat = description.pixelFormat;
        var borderWidthInPixels = description.borderWidthInPixels;
        var initialSize = description.initialSize;
        var images = description.images;
        var image = description.image;

        // Context
        if (typeof context === 'undefined') {
            throw new DeveloperError('context is required.');
        }

        // Pixel Format
        pixelFormat = (typeof pixelFormat !== 'undefined') ? pixelFormat : PixelFormat.RGBA;

        // Border
        borderWidthInPixels = (typeof borderWidthInPixels !== 'undefined') ? borderWidthInPixels : 1.0;
        if (borderWidthInPixels < 0) {
            throw new DeveloperError('borderWidthInPixels must be greater than or equal to zero.');
        }

        // Initial size
        initialSize = (typeof initialSize !== 'undefined') ? initialSize : new Cartesian2(16.0, 16.0);
        if (initialSize.x < 1 || initialSize.y < 1) {
            throw new DeveloperError('initialSize must be greater than zero.');
        }

        this._context = context;
        this._pixelFormat = pixelFormat;
        this._borderWidthInPixels = borderWidthInPixels;
        this._textureCoordinates = [];
        this._guid = createGuid();

        // Create initial texture and root.
        this._texture = this._context.createTexture2D({
            width : initialSize.x,
            height : initialSize.y,
            pixelFormat : this._pixelFormat
        });
        this._root = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(initialSize.x, initialSize.y));

        // Add initial images if there are any.
        if (typeof images !== 'undefined' && (images.length > 0)) {
            this.addImages(images);
        }
        if (typeof image !== 'undefined') {
            this.addImage(image);
        }
    };

    // Builds a larger texture and copies the old texture into the new one.
    TextureAtlas.prototype._resizeAtlas = function(image) {
        var numImages = this.getNumberOfImages();
        var scalingFactor = 2.0;
        if (numImages > 0) {
            var oldAtlasWidth = this._texture.getWidth();
            var oldAtlasHeight = this._texture.getHeight();
            var atlasWidth = scalingFactor * (oldAtlasWidth + image.width + this._borderWidthInPixels);
            var atlasHeight = scalingFactor * (oldAtlasHeight + image.height + this._borderWidthInPixels);
            var widthRatio = oldAtlasWidth / atlasWidth;
            var heightRatio = oldAtlasHeight / atlasHeight;

            // Create new node structure, putting the old root node in the bottom left.
            var nodeBottomRight = new TextureAtlasNode(new Cartesian2(oldAtlasWidth + this._borderWidthInPixels, 0.0), new Cartesian2(atlasWidth, oldAtlasHeight));
            var nodeBottomHalf = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(atlasWidth, oldAtlasHeight), this._root, nodeBottomRight);
            var nodeTopHalf = new TextureAtlasNode(new Cartesian2(0.0, oldAtlasHeight + this._borderWidthInPixels), new Cartesian2(atlasWidth, atlasHeight));
            var nodeMain = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(atlasWidth, atlasHeight), nodeBottomHalf, nodeTopHalf);
            this._root = nodeMain;

            // Resize texture coordinates.
            for ( var i = 0; i < this._textureCoordinates.length; i++) {
                var texCoord = this._textureCoordinates[i];
                if (typeof texCoord !== 'undefined') {
                    texCoord.x *= widthRatio;
                    texCoord.y *= heightRatio;
                    texCoord.width *= widthRatio;
                    texCoord.height *= heightRatio;
                }
            }

            // Copy larger texture.
            var newTexture = this._context.createTexture2D({
                width : atlasWidth,
                height : atlasHeight,
                pixelFormat : this._pixelFormat
            });

            // Copy old texture into new using an fbo.
            var framebuffer = this._context.createFramebuffer({
                colorTexture : this._texture
            });
            framebuffer._bind();
            newTexture.copyFromFramebuffer(0, 0, 0, 0, oldAtlasWidth, oldAtlasHeight);
            framebuffer._unBind();
            framebuffer.destroy();
            this._texture = newTexture;
        }
        // First image exceeds initialSize
        else {
            var initialWidth = scalingFactor * (image.width + this._borderWidthInPixels);
            var initialHeight = scalingFactor * (image.height + this._borderWidthInPixels);
            this._texture = this._texture && this._texture.destroy();
            this._texture = this._context.createTexture2D({
                width : initialWidth,
                height : initialHeight,
                pixelFormat : this._pixelFormat
            });
            this._root = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(initialWidth, initialHeight));
        }
    };

    // A recursive function that finds the best place to insert
    // a new image based on existing image 'nodes'.
    // Inspired by: http://blackpawn.com/texts/lightmaps/default.html
    TextureAtlas.prototype._findNode = function (node, image) {
        if (typeof node === 'undefined') {
            return undefined;
        }

        // If a leaf node
        if (typeof node.childNode1 === 'undefined' &&
            typeof node.childNode2 === 'undefined') {

            // Node already contains an image, don't add to it.
            if (typeof node.imageIndex !== 'undefined') {
                return undefined;
            }

            var nodeWidth = node.topRight.x - node.bottomLeft.x;
            var nodeHeight = node.topRight.y - node.bottomLeft.y;
            var widthDifference = nodeWidth - image.width;
            var heightDifference = nodeHeight - image.height;

            // Node is smaller than the image.
            if (widthDifference < 0 || heightDifference < 0) {
                return undefined;
            }

            // If the node is the same size as the image, return the node
            if (widthDifference === 0 && heightDifference === 0) {
                return node;
            }

            // Vertical split (childNode1 = left half, childNode2 = right half).
            if (widthDifference > heightDifference) {
                node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y));
                // Only make a second child if the border gives enough space.
                var childNode2BottomLeftX = node.bottomLeft.x + image.width + this._borderWidthInPixels;
                if (childNode2BottomLeftX < node.topRight.x) {
                    node.childNode2 = new TextureAtlasNode(new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.topRight.y));
                }
            }
            // Horizontal split (childNode1 = bottom half, childNode2 = top half).
            else {
                node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height));
                // Only make a second child if the border gives enough space.
                var childNode2BottomLeftY = node.bottomLeft.y + image.height + this._borderWidthInPixels;
                if (childNode2BottomLeftY < node.topRight.y) {
                    node.childNode2 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY), new Cartesian2(node.topRight.x, node.topRight.y));
                }
            }
            return this._findNode(node.childNode1, image);
        }

        // If not a leaf node
        return this._findNode(node.childNode1, image) ||
               this._findNode(node.childNode2, image);
    };

    // Adds image of given index to the texture atlas. Called from addImage and addImages.
    TextureAtlas.prototype._addImage = function(image, index) {
        if (typeof image === 'undefined') {
            throw new DeveloperError('image is required.');
        }

        var node = this._findNode(this._root, image);

        // Found a node that can hold the image.
        if (typeof node !== 'undefined'){
            node.imageIndex = index;

            // Add texture coordinate and write to texture
            var atlasWidth = this._texture.getWidth();
            var atlasHeight = this._texture.getHeight();
            var nodeWidth = node.topRight.x - node.bottomLeft.x;
            var nodeHeight = node.topRight.y - node.bottomLeft.y;
            this._textureCoordinates[index] = new BoundingRectangle(
                node.bottomLeft.x / atlasWidth, node.bottomLeft.y / atlasHeight,
                nodeWidth / atlasWidth, nodeHeight / atlasHeight
            );
            this._texture.copyFrom(image, node.bottomLeft.x, node.bottomLeft.y);
        }
        // No node found, must resize the texture atlas.
        else {
            this._resizeAtlas(image);
            this._addImage(image, index);
        }
    };

    /**
     * Adds an image to the texture atlas.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @param {Image} image An image to be added to the texture atlas.
     *
     * @returns {Number} The index of the newly added image.
     *
     * @exception {DeveloperError} image is required.
     *
     * @see TextureAtlas#addImages
     *
     */
    TextureAtlas.prototype.addImage = function(image) {
        var index = this.getNumberOfImages();
        this._addImage(image, index);

        this._guid = createGuid();

        return index;
    };

    /**
     * Adds an array of images to the texture atlas.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @param {Array} images An array of {@link Image} to be added to the texture atlas.
     *
     * @returns {Number} The first index of the newly added images.
     *
     * @exception {DeveloperError} images is required and must have length greater than zero.
     *
     * @see TextureAtlas#addImage
     *
     */
    TextureAtlas.prototype.addImages = function(images) {
        // Check if image array is valid.
        if (typeof images === 'undefined' || (images.length < 1)) {
            throw new DeveloperError('images is required and must have length greater than zero.');
        }

        // Store images in containers that have an index.
        var i;
        var annotatedImages = [];
        var numberOfImages = images.length;
        var oldNumberOfImages = this.getNumberOfImages();
        for (i = 0; i < numberOfImages; ++i) {
            annotatedImages.push({
                image : images[i],
                index : i + oldNumberOfImages
            });
        }

        // Sort images by maximum to minimum side length.
        annotatedImages.sort(function(left, right) {
            return Math.max(right.image.height, right.image.width) -
                   Math.max(left.image.height, left.image.width);
        });

        // Add images to the texture atlas.
        for (i = 0; i < numberOfImages; ++i) {
            var annotatedImage = annotatedImages[i];
            this._addImage(annotatedImage.image, annotatedImage.index);
        }

        this._guid = createGuid();

        // Return index of the first added image.
        return oldNumberOfImages;
    };

    /**
     * Add a set of sub-regions to one atlas image as additional image indices.
     *
     * @memberof TextureAtlas
     *
     * @param {Image} image An image to be added to the texture atlas.
     * @param {Array} subRegions An array of {@link BoundingRectangle} sub-regions measured in pixels from the bottom-left.
     *
     * @returns {Number} The index of the first newly-added region.
     *
     * @exception {DeveloperError} image is required.
     */
    TextureAtlas.prototype.addSubRegions = function(image, subRegions) {
        var index = this.addImage(image);

        var atlasWidth = this._texture.getWidth();
        var atlasHeight = this._texture.getHeight();
        var numImages = this.getNumberOfImages();
        var numSubRegions = subRegions.length;

        var baseRegion = this._textureCoordinates[index];
        for (var i = 0; i < numSubRegions; ++i) {
            var thisRegion = subRegions[i];
            this._textureCoordinates.push(new BoundingRectangle(
                baseRegion.x + (thisRegion.x / atlasWidth),
                baseRegion.y + (thisRegion.y / atlasHeight),
                thisRegion.width / atlasWidth,
                thisRegion.height / atlasHeight
            ));
        }

        this._guid = createGuid();

        return numImages;
    };

    /**
     * Returns the amount of spacing between adjacent images in pixels.
     *
     * @memberof TextureAtlas
     *
     * @returns {Number} The border width in pixels.
     */
    TextureAtlas.prototype.getBorderWidthInPixels = function() {
        return this._borderWidthInPixels;
    };

    /**
     * Returns an array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.
     * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.
     * The coordinates are in the order that the corresponding images were added to the atlas.
     *
     * @memberof TextureAtlas
     *
     * @returns {Array} The texture coordinates.
     *
     * @see BoundingRectangle
     */
    TextureAtlas.prototype.getTextureCoordinates = function() {
        return this._textureCoordinates;
    };

    /**
     * Returns the texture that all of the images are being written to.
     *
     * @memberof TextureAtlas
     *
     * @returns {@link Texture} The texture used by the texture atlas.
     */
    TextureAtlas.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * Returns the number of images in the texture atlas. This value increases
     * every time addImage or addImages is called.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @returns {Number} The number of images in the texture atlas.
     */
    TextureAtlas.prototype.getNumberOfImages = function() {
        return this._textureCoordinates.length;
    };

    /**
     * Returns the atlas' globally unique identifier (GUID).
     * The GUID changes whenever the texture atlas is modified.
     * Classes that use a texture atlas should check if the GUID
     * has changed before processing the atlas data.
     *
     * @memberof TextureAtlas
     *
     * @returns {String} The globally unique identifier (GUID).
     */
    TextureAtlas.prototype.getGUID = function() {
        return this._guid;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof TextureAtlas
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see TextureAtlas#destroy
     */
    TextureAtlas.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof TextureAtlas
     *
     * @returns {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see TextureAtlas#isDestroyed
     *
     * @example
     * atlas = atlas && atlas.destroy();
     */
    TextureAtlas.prototype.destroy = function() {
        this._texture = this._texture && this._texture.destroy();
        return destroyObject(this);
    };

    return TextureAtlas;
});
/*global define*/
define('Renderer/TextureMagnificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMagnificationFilter
     */
    var TextureMagnificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, 'NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, 'LINEAR'),

        /**
         * DOC_TBA
         *
         * @param textureMagnificationFilter
         *
         * @returns {Boolean}
         */
        validate : function(textureMagnificationFilter) {
            return ((textureMagnificationFilter === TextureMagnificationFilter.NEAREST) ||
                    (textureMagnificationFilter === TextureMagnificationFilter.LINEAR));
        }
    };

    return TextureMagnificationFilter;
});
/*global define*/
define('Renderer/TextureMinificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMinificationFilter
     */
    var TextureMinificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, 'NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, 'LINEAR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_NEAREST : new Enumeration(0x2700, 'NEAREST_MIPMAP_NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_NEAREST : new Enumeration(0x2701, 'LINEAR_MIPMAP_NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_LINEAR : new Enumeration(0x2702, 'NEAREST_MIPMAP_LINEAR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_LINEAR : new Enumeration(0x2703, 'LINEAR_MIPMAP_LINEAR'),

        /**
         * DOC_TBA
         *
         * @param textureMinificationFilter
         *
         * @returns {Boolean}
         */
        validate : function(textureMinificationFilter) {
            return ((textureMinificationFilter === TextureMinificationFilter.NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR) ||
                    (textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR));
        }
    };

    return TextureMinificationFilter;
});
/*global define*/
define('Renderer/TextureWrap',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureWrap
     */
    var TextureWrap = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLAMP : new Enumeration(0x812F, 'CLAMP'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPEAT : new Enumeration(0x2901, 'REPEAT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIRRORED_REPEAT : new Enumeration(0x8370, 'MIRRORED_REPEAT'),

        /**
         * DOC_TBA
         *
         * @param textureWrap
         *
         * @returns {Boolean}
         */
        validate : function(textureWrap) {
            return ((textureWrap === TextureWrap.CLAMP) ||
                    (textureWrap === TextureWrap.REPEAT) ||
                    (textureWrap === TextureWrap.MIRRORED_REPEAT));
        }
    };

    return TextureWrap;
});
/*global define*/
define('Renderer/CubeMapFace',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        defaultValue,
        DeveloperError,
        destroyObject,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * A face of a cube map (+x, -x, +y, -y, +z, or -z) that can be modified and rendered to.
     *
     * @alias CubeMapFace
     * @internalConstructor
     *
     * @see CubeMap
     */
    var CubeMapFace = function(gl, texture, textureTarget, targetFace, pixelFormat, pixelDatatype, size, preMultiplyAlpha) {
        this._gl = gl;
        this._texture = texture;
        this._textureTarget = textureTarget;
        this._targetFace = targetFace;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._size = size;
        this._preMultiplyAlpha = preMultiplyAlpha;
    };

    /**
     * Copies texels from the source to the cubemap's face.
     *
     * @memberof CubeMapFace
     *
     * @param {Object} source The source ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, or an object with a width, height, and typed array as shown in the example.
     * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.
     * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.
     *
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     *
     * @example
     * // Create a cubemap with 1x1 faces, and make the +x face red.
     * var cubeMap = context.createCubeMap({
     *   width : 1,
     *   height : 1
     * });
     * cubeMap.getPositiveX().copyFrom({
     *   width : 1,
     *   height : 1,
     *   arrayBufferView : new Uint8Array([255, 0, 0, 255])
     * });
     */
    CubeMapFace.prototype.copyFrom = function(source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError('source is required.');
        }

        xOffset = defaultValue(xOffset, 0);
        yOffset = defaultValue(yOffset, 0);

        var width = source.width;
        var height = source.height;

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        //Firefox bug: texSubImage2D has overloads and can't resolve our enums, so we use + to explicitly convert to a number.
        if (source.arrayBufferView) {
            gl.texSubImage2D(this._targetFace, 0, xOffset, yOffset, width, height, +this._pixelFormat, +this._pixelDatatype, source.arrayBufferView);
        } else {
            gl.texSubImage2D(this._targetFace, 0, xOffset, yOffset, +this._pixelFormat, +this._pixelDatatype, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * Copies texels from the framebuffer to the cubemap's face.
     *
     * @memberof CubeMapFace
     *
     * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.
     * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.
     * @param {Number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
     * @param {Number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
     * @param {Number} [width=CubeMap's width] The width of the subimage to copy.
     * @param {Number} [height=CubeMap's height] The height of the subimage to copy.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     *
     * @example
     * // Copy the framebuffer contents to the +x cube map face.
     * cubeMap.getPositiveX().copyFromFramebuffer();
     */
    CubeMapFace.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = defaultValue(xOffset, 0);
        yOffset = defaultValue(yOffset, 0);
        framebufferXOffset = defaultValue(framebufferXOffset, 0);
        framebufferYOffset = defaultValue(framebufferYOffset, 0);
        width = defaultValue(width, this._size);
        height = defaultValue(height, this._size);

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(this._targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * Returns the pixel format of this cube map face.  All faces in the same cube map have the same pixel format.
     *
     * @memberof CubeMapFace
     *
     * @returns {PixelFormat} The pixel format of this cubemap face.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMapFace.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    CubeMapFace.prototype._getTexture = function() {
        return this._texture;
    };

    CubeMapFace.prototype._getTarget = function() {
        return this._targetFace;
    };

    return CubeMapFace;
});
/*global define*/
define('Renderer/CubeMap',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap',
        './CubeMapFace'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        CubeMapFace) {
    

    /**
     * A cube map with faces +x, -x, +y, -y, +z, and -z.  Cube maps are used for environment techniques like
     * approximate reflection and refraction as used in the Reflection and Refraction {@link Material}s.
     *
     * @alias CubeMap
     * @internalConstructor
     *
     * @see Context#createCubeMap
     */
    var CubeMap = function(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._size = size;
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this._positiveX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
        this._negativeX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
        this._positiveY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
        this._negativeY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
        this._positiveZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
        this._negativeZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha);

        this.setSampler();
    };

    /**
     * Returns the +x face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The +x face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPositiveX = function() {
        return this._positiveX;
    };

    /**
     * Returns the -x face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The -x face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getNegativeX = function() {
        return this._negativeX;
    };

    /**
     * Returns the +y face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The +y face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPositiveY = function() {
        return this._positiveY;
    };

    /**
     * Returns the -y face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The -y face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getNegativeY = function() {
        return this._negativeY;
    };

    /**
     * Returns the +z face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The +z face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPositiveZ = function() {
        return this._positiveZ;
    };

    /**
     * Returns the -z face of this cube map for modification, rendering to, etc.
     *
     * @memberof CubeMap
     *
     * @returns {CubeMapFace} The -z face of this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getNegativeZ = function() {
        return this._negativeZ;
    };

    /**
     * Generates a complete mipmap chain for each cubemap face.
     *
     * @memberof CubeMap
     *
     * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.
     *
     * @exception {DeveloperError} hint is invalid.
     * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     *
     * @example
     * // Generate mipmaps, and then set the sampler so mipmaps are used for
     * // minification when the cube map is sampled.
     * cubeMap.generateMipmap();
     * cubeMap.setSampler(context.createSampler({
     *   minificationFilter : TextureMinificationFilter.NEAREST_MIPMAP_LINEAR
     * }));
     */
    CubeMap.prototype.generateMipmap = function(hint) {
        if ((this._size > 1) && !CesiumMath.isPowerOfTwo(this._size)) {
            throw new DeveloperError('width and height must be a power of two to call generateMipmap().');
        }

        hint = hint || MipmapHint.DONT_CARE;
        if (!MipmapHint.validate(hint)) {
            throw new DeveloperError('hint is invalid.');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param [sampler] DOC_TBA
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * Returns the pixel format of this cube map.  All faces in the same cube map have the same pixel format.
     *
     * @memberof CubeMap
     *
     * @returns {PixelFormat} The pixel format of this cubemap.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * Returns the pixel datatype of this cube map.  All faces in the same cube map have the same pixel datatype.
     *
     * @memberof CubeMap
     *
     * @returns {PixelDatatype} The pixel datatype of this cubemap.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * Returns the width, in texels, of faces in this cube map.  All faces in the same cube map have the same width and height, and the width equals the height.
     *
     * @memberof CubeMap
     *
     * @returns {Number} The width, in texels, of faces in this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getWidth = function() {
        return this._size;
    };

    /**
     * Returns the height, in texels, of faces in this cube map.  All faces in the same cube map have the same width and height, and the width equals the height.
     *
     * @memberof CubeMap
     *
     * @returns {Number} The height, in texels, of faces in this cube map.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getHeight = function() {
        return this._size;
    };

    /**
     * Returns true if the cubemap was created with premultiplied alpha (UNPACK_PREMULTIPLY_ALPHA_WEBGL).
     *
     * @memberof CubeMap
     *
     * @returns {Boolean} true if the cubemap was created with premultiplied alpha; otherwise, false.
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    CubeMap.prototype._getTexture = function() {
        return this._texture;
    };

    CubeMap.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CubeMap
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CubeMap#destroy
     */
    CubeMap.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CubeMap
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This cube map was destroyed, i.e., destroy() was called.
     *
     * @see CubeMap#isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
     *
     * @example
     * cubeMap = cubeMap && cubeMap.destroy();
     */
    CubeMap.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        this._positiveX = destroyObject(this._positiveX);
        this._negativeX = destroyObject(this._negativeX);
        this._positiveY = destroyObject(this._positiveY);
        this._negativeY = destroyObject(this._negativeY);
        this._positiveZ = destroyObject(this._positiveZ);
        this._negativeZ = destroyObject(this._negativeZ);
        return destroyObject(this);
    };

    return CubeMap;
});
/*global define*/
define('Renderer/Texture',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Math',
        './PixelFormat',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        CesiumMath,
        PixelFormat,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * DOC_TBA
     *
     * @alias Texture
     * @internalConstructor
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     */
    var Texture = function(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._width = width;
        this._height = height;
        this._dimensions = new Cartesian2(width, height);
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this.setSampler();
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Object} source The source {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     *
     * @exception {DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.copyFrom = function(source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError('source is required.');
        }

        xOffset = xOffset || 0;
        yOffset = yOffset || 0;

        var width = source.width;
        var height = source.height;

        if (PixelFormat.isDepthFormat(this._pixelFormat)) {
            throw new DeveloperError('Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
        }

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        //Firefox bug: texSubImage2D has overloads and can't resolve our enums, so we use + to explicitly convert to a number.
        if (source.arrayBufferView) {
            gl.texSubImage2D(target, 0, xOffset, yOffset, width, height, +this._pixelFormat, +this._pixelDatatype, source.arrayBufferView);
        } else {
            gl.texSubImage2D(target, 0, xOffset, yOffset, this._pixelFormat, this._pixelDatatype, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     * @param {Number} framebufferXOffset optional
     * @param {Number} framebufferYOffset optional
     * @param {Number} width optional
     * @param {Number} height optional
     *
     * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     */
    Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._width;
        height = height || this._height;

        if (PixelFormat.isDepthFormat(this._pixelFormat)) {
            throw new DeveloperError('Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
        }

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {MipmapHint} hint optional.
     *
     * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {DeveloperError} hint is invalid.
     * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.generateMipmap = function(hint) {
        if (PixelFormat.isDepthFormat(this._pixelFormat)) {
            throw new DeveloperError('Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
        }

        if ((this._width > 1) && !CesiumMath.isPowerOfTwo(this._width)) {
            throw new DeveloperError('width must be a power of two to call generateMipmap().');
        } else if ((this._height > 1) && !CesiumMath.isPowerOfTwo(this._height)) {
            throw new DeveloperError('height must be a power of two to call generateMipmap().');
        }

        hint = hint || MipmapHint.DONT_CARE;
        if (!MipmapHint.validate(hint)) {
            throw new DeveloperError('hint is invalid.');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
    * DOC_TBA
    *
    * @memberof Texture
    *
    * @param sampler optional.
    *
    * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
    */
    Texture.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getWidth = function() {
        return this._width;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getDimensions = function() {
        return this._dimensions;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getHeight = function() {
        return this._height;
    };

    Texture.prototype._getTexture = function() {
        return this._texture;
    };

    Texture.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Texture
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Texture#destroy
     */
    Texture.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Texture
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     *
     * @see Texture#isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
     *
     * @example
     * texture = texture && texture.destroy();
     */
    Texture.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        return destroyObject(this);
    };

    return Texture;
});
/*global define*/
define('Renderer/UniformDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Indicates a GLSL uniform's datatype.
     *
     * @exports UniformDatatype
     * @see Uniform.getDatatype
     */
    var UniformDatatype = {
        /**
         * A <code>float</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT : new Enumeration(0x1406, 'FLOAT', {
            getGLSL : function() {
                return 'float';
            }
        }), // FLOAT

        /**
         * A <code>vec2</code> uniform: a two-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR2 : new Enumeration(0x8B50, 'FLOAT_VECTOR2', {
            getGLSL : function() {
                return 'vec2';
            }
        }), // FLOAT_VEC2

        /**
         * A <code>vec3</code> uniform: a three-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR3 : new Enumeration(0x8B51, 'FLOAT_VECTOR3', {
            getGLSL : function() {
                return 'vec3';
            }
        }), // FLOAT_VEC3

        /**
         * A <code>vec4</code> uniform: a four-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR4 : new Enumeration(0x8B52, 'FLOAT_VECTOR4', {
            getGLSL : function() {
                return 'vec4';
            }
        }), // FLOAT_VEC4

        /**
         * An <code>int</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        INT : new Enumeration(0x1404, 'INT', {
            getGLSL : function() {
                return 'int';
            }
        }), // INT

        /**
         * An <code>ivec2</code> uniform: a two-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR2 : new Enumeration(0x8B53, 'INT_VECTOR2', {
            getGLSL : function() {
                return 'ivec2';
            }
        }), // INT_VEC2

        /**
         * An <code>ivec3</code> uniform: a three-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR3 : new Enumeration(0x8B54, 'INT_VECTOR3', {
            getGLSL : function() {
                return 'ivec3';
            }
        }), // INT_VEC3

        /**
         * An <code>ivec4</code> uniform: a four-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR4 : new Enumeration(0x8B55, 'INT_VECTOR4', {
            getGLSL : function() {
                return 'ivec4';
            }
        }), // INT_VEC4

        /**
         * A <code>bool</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL : new Enumeration(0x8B56, 'BOOL', {
            getGLSL : function() {
                return 'bool';
            }
        }), // BOOL

        /**
         * A <code>bvec2</code> uniform: a two-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR2 : new Enumeration(0x8B57, 'BOOL_VECTOR2', {
            getGLSL : function() {
                return 'bvec2';
            }
        }), // BOOL_VEC2

        /**
         * A <code>bvec3</code> uniform: a three-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR3 : new Enumeration(0x8B58, 'BOOL_VECTOR3', {
            getGLSL : function() {
                return 'bvec3';
            }
        }), // BOOL_VEC3

        /**
         * A <code>bvec4</code> uniform: a four-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR4 : new Enumeration(0x8B59, 'BOOL_VECTOR4', {
            getGLSL : function() {
                return 'bvec4';
            }
        }), // BOOL_VEC4

        /**
         * An <code>mat2</code> uniform: a 2x2 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX2 : new Enumeration(0x8B5A, 'FLOAT_MATRIX2', {
            getGLSL : function() {
                return 'mat2';
            }
        }), // FLOAT_MAT2

        /**
         * An <code>mat3</code> uniform: a 3x3 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX3 : new Enumeration(0x8B5B, 'FLOAT_MATRIX3', {
            getGLSL : function() {
                return 'mat3';
            }
        }), // FLOAT_MAT3

        /**
         * An <code>mat4</code> uniform: a 4x4 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX4 : new Enumeration(0x8B5C, 'FLOAT_MATRIX4', {
            getGLSL : function() {
                return 'mat4';
            }
        }), // FLOAT_MAT4

        /**
         * A <code>sampler2D</code> uniform: an opaque type to access 2D textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_2D : new Enumeration(0x8B5E, 'SAMPLER_2D', {
            getGLSL : function() {
                return 'sampler2D';
            }
        }), // SAMPLER_2D

        /**
         * A <code>samplerCube</code> uniform: an opaque type to access cube-map textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_CUBE : new Enumeration(0x8B60, 'SAMPLER_CUBE', {
            getGLSL : function() {
                return 'samplerCube';
            }
        }) // SAMPLER_CUBE
    };

    return UniformDatatype;
});
/*global define*/
define('Renderer/VertexArray',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/ComponentDatatype'
    ], function(
        DeveloperError,
        destroyObject,
        ComponentDatatype) {
    

    /**
     * DOC_TBA
     *
     * @alias VertexArray
     *
     * @internalConstructor
     *
     * @see {@link Context#createVertexArray}
     * @see {@link Context#createVertexArrayFromMesh}
     */
    var VertexArray = function(gl, attributes, indexBuffer) {
        this._gl = gl;
        this._attributes = [];
        this._indexBuffer = indexBuffer;

        if (attributes) {
            for ( var i = 0; i < attributes.length; ++i) {
                try {
                    this._addAttribute(attributes[i], i);
                } catch (e) {
                    throw new DeveloperError(e.message);
                }
            }
        }

        // Verify all attribute names are unique
        var uniqueIndices = {};
        for ( var j = 0; j < this._attributes.length; ++j) {
            var index = this._attributes[j].index;
            if (uniqueIndices[index]) {
                throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
            }

            uniqueIndices[index] = true;
        }
    };

    VertexArray.prototype._addAttribute = function(attribute, index) {
        if (!attribute.vertexBuffer && !attribute.value) {
            throw new DeveloperError('attribute must have a vertexBuffer or a value.');
        }

        if (attribute.vertexBuffer && attribute.value) {
            throw new DeveloperError('attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.');
        }

        var componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;

        if ((componentsPerAttribute !== 1) &&
            (componentsPerAttribute !== 2) &&
            (componentsPerAttribute !== 3) &&
            (componentsPerAttribute !== 4)) {
            if (attribute.value) {
                throw new DeveloperError('attribute.value.length must be in the range [1, 4].');
            }

            throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
        }

        if (attribute.componentDatatype) {
            var datatype = attribute.componentDatatype;
            if (!ComponentDatatype.validate(datatype)) {
                throw new DeveloperError('attribute must have a valid componentDatatype or not specify it.');
            }
        }

        if (attribute.strideInBytes && (attribute.strideInBytes > 255)) {
            // WebGL limit.  Not in GL ES.
            throw new DeveloperError('attribute must have a strideInBytes less than or equal to 255 or not specify it.');
        }

        // Shallow copy the attribute; we do not want to copy the vertex buffer.
        var attr = {
            index : (typeof attribute.index === 'undefined') ? index : attribute.index,
            enabled : (typeof attribute.enabled === 'undefined') ? true : attribute.enabled,
            vertexBuffer : attribute.vertexBuffer,
            value : attribute.value ? attribute.value.slice(0) : undefined,
            componentsPerAttribute : componentsPerAttribute,
            componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
            normalize : attribute.normalize || false,
            offsetInBytes : attribute.offsetInBytes || 0,
            strideInBytes : attribute.strideInBytes || 0
        };

        if (attr.vertexBuffer) {
            // Common case: vertex buffer for per-vertex data
            attr.vertexAttrib = function(gl) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
                gl.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);
                gl.enableVertexAttribArray(this.index);
            };

            attr.disableVertexAttribArray = function(gl) {
                gl.disableVertexAttribArray(this.index);
            };
        } else {
            // Less common case: value array for the same data for each vertex
            switch (attr.componentsPerAttribute) {
            case 1:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib1fv(this.index, this.value);
                };
                break;
            case 2:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib2fv(this.index, this.value);
                };
                break;
            case 3:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib3fv(this.index, this.value);
                };
                break;
            case 4:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib4fv(this.index, this.value);
                };
                break;
            }

            attr.disableVertexAttribArray = function(gl) {
            };
        }

        this._attributes.push(attr);
    };

    /**
     * DOC_TBA
     *
     * index is the location in the array of attributes, not the index property of an attribute.
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getAttribute = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._attributes[index];
    };

    /**
    * DOC_TBA
    *
    * @memberof VertexArray
    *
    * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
    */
    VertexArray.prototype.getNumberOfAttributes = function() {
        return this._attributes.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} Attribute must have a vertexBuffer.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a strideInBytes less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index is already in use.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.addAttribute = function(attribute) {
        if (attribute) {
            var attributes = this._attributes;
            var index = (typeof attribute.index === 'undefined') ? attributes.length : attribute.index;
            for ( var i = 0; i < attributes.length; ++i) {
                if (index === attributes[i].index) {
                    throw new DeveloperError('Index ' + index + ' is already in use.');
                }
            }

            try {
                this._addAttribute(attribute, index);
            } catch (e) {
                throw new DeveloperError(e.message);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if the attribute was removed; false if the attribute was not found in the vertex array.
     *
     * @exception {DeveloperError} Attribute must have an index.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.removeAttribute = function(attribute) {
        if (attribute) {
            if (typeof attribute.index === 'undefined') {
                throw new DeveloperError('Attribute must have an index.');
            }

            var attributes = this._attributes;
            for ( var i = 0; i < attributes.length; ++i) {
                if (attributes[i].index === attribute.index) {
                    attributes.splice(i, 1);
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Buffer} DOC_TBA.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getIndexBuffer = function() {
        return this._indexBuffer;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.setIndexBuffer = function(indexBuffer) {
        this._indexBuffer = indexBuffer;
    };

    VertexArray.prototype._bind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        // TODO:  Performance: sort by vertex buffer?
        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.vertexAttrib(gl);
            }
        }

        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer._getBuffer());
        }
    };

    VertexArray.prototype._unBind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.disableVertexAttribArray(gl);
            }
        }
        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
    };

    /**
     * This assumes that each vertex buffer in the vertex array has the same number of vertices.
     * @private
     */
    VertexArray.prototype._getNumberOfVertices = function() {
        if (this._attributes.length > 0) {
            var attribute = this._attributes[0];
            var bytes = attribute.strideInBytes || (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);

            return attribute.vertexBuffer.getSizeInBytes() / bytes;
        }

        return 0;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see VertexArray#destroy
     */
    VertexArray.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Only call this if the vertex array owns the vertex buffers referenced by the attributes and owns its
     * index buffer; otherwise, the owner of the buffers is responsible for destroying them.  A vertex or
     * index buffer is only destroyed if it's <code>getVertexArrayDestroyable</code> function returns
     * <code>true</code> (the default).  This allows combining destroyable and non-destroyable buffers
     * in the same vertex array.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof VertexArray
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     *
     * @see VertexArray#isDestroyed
     * @see Buffer#getVertexArrayDestroyable
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml'>glDeleteBuffers</a>
     *
     * @example
     * // Destroying the vertex array implicitly calls destroy for each of its vertex
     * // buffers and its index buffer.
     * var vertexBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     * var vertexArray = context.createVertexArray();
     * vertexArray.addAttribute({ vertexBuffer : vertexBuffer, componentsPerAttribute : 3 });
     * // ...
     * vertexArray = vertexArray.destroy();
     * // Calling vertexBuffer.destroy() would throw DeveloperError at this point.
     */
    VertexArray.prototype.destroy = function() {
        var attributes = this._attributes;
        for ( var i = 0; i < attributes.length; ++i) {
            var vertexBuffer = attributes[i].vertexBuffer;
            if (vertexBuffer && !vertexBuffer.isDestroyed() && vertexBuffer.getVertexArrayDestroyable()) {
                vertexBuffer.destroy();
            }
        }

        var indexBuffer = this._indexBuffer;
        if (indexBuffer && indexBuffer.getVertexArrayDestroyable()) {
            this._indexBuffer = indexBuffer.destroy();
        }

        return destroyObject(this);
    };

    return VertexArray;
});
/*global define*/
define('Renderer/VertexArrayFacade',[
        '../Core/DeveloperError',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/ComponentDatatype',
        './BufferUsage'
    ], function(
        DeveloperError,
        defaultValue,
        destroyObject,
        ComponentDatatype,
        BufferUsage) {
    

    /**
     * DOC_TBA
     *
     * @alias VertexArrayFacade
     *
     * @constructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} At least one attribute is required.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a valid usage or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     */
    var VertexArrayFacade = function(context, attributes, sizeInVertices) {
        if (!context) {
            throw new DeveloperError('context is required.');
        }

        if (!attributes || (attributes.length === 0)) {
            throw new DeveloperError('At least one attribute is required.');
        }

        var attrs = VertexArrayFacade._verifyAttributes(attributes);

        sizeInVertices = sizeInVertices || 0;

        var attributesByPurposeAndUsage = {};
        var precreatedAttributes = [];

        var attributesByUsage;
        var attributesForUsage;
        var purpose;
        var usage;

        // Bucket the attributes first by purpose and second by usage.
        var length = attrs.length;
        for (var i = 0; i < length; ++i) {
            var attribute = attrs[i];

            // If the attribute already has a vertex buffer, we do not need
            // to manage a vertex buffer or typed array for it.
            if (attribute.vertexBuffer) {
                precreatedAttributes.push(attribute);
                continue;
            }

            purpose = attribute.purpose;
            attributesByUsage = attributesByPurposeAndUsage[purpose];
            if (typeof attributesByUsage === 'undefined') {
                attributesByUsage = attributesByPurposeAndUsage[purpose] = {};
            }

            usage = attribute.usage.toString();
            attributesForUsage = attributesByUsage[usage];
            if (typeof attributesForUsage === 'undefined') {
                attributesForUsage = attributesByUsage[usage] = [];
            }

            attributesForUsage.push(attribute);
        }

        // A function to sort attributes by the size of their components.  From left to right, a vertex
        // stores floats, shorts, and then bytes.
        function compare(left, right) {
            return right.componentDatatype.sizeInBytes - left.componentDatatype.sizeInBytes;
        }

        // Create a buffer description for each purpose/usage combination.
        this._buffersByPurposeAndUsage = {};
        this._allBuffers = [];

        for (purpose in attributesByPurposeAndUsage) {
            if (attributesByPurposeAndUsage.hasOwnProperty(purpose)) {
                attributesByUsage = attributesByPurposeAndUsage[purpose];

                var buffersByUsage = this._buffersByPurposeAndUsage[purpose];
                if (typeof buffersByUsage === 'undefined') {
                    buffersByUsage = this._buffersByPurposeAndUsage[purpose] = {};
                }

                for (usage in attributesByUsage) {
                    if (attributesByUsage.hasOwnProperty(usage)) {
                        attributesForUsage = attributesByUsage[usage];

                        attributesForUsage.sort(compare);
                        var vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(attributesForUsage);

                        var usageEnum;
                        switch (usage) {
                        case BufferUsage.STATIC_DRAW.toString():
                            usageEnum = BufferUsage.STATIC_DRAW;
                            break;
                        case BufferUsage.STREAM_DRAW.toString():
                            usageEnum = BufferUsage.STREAM_DRAW;
                            break;
                        case BufferUsage.DYNAMIC_DRAW.toString():
                            usageEnum = BufferUsage.DYNAMIC_DRAW;
                            break;
                        }

                        var buffer = {
                            purpose : purpose,

                            vertexSizeInBytes : vertexSizeInBytes,

                            vertexBuffer : undefined,
                            usage : usageEnum,
                            needsCommit : false,

                            arrayBuffer : undefined,
                            arrayViews : VertexArrayFacade._createArrayViews(attributesForUsage, vertexSizeInBytes)
                        };

                        buffersByUsage[usage] = buffer;
                        this._allBuffers.push(buffer);
                    }
                }
            }
        }

        this._size = 0;

        this._precreated = precreatedAttributes;
        this._context = context;

        /**
         * DOC_TBA
         */
        this.writers = undefined;

        /**
         * DOC_TBA
         */
        this.vaByPurpose = undefined;

        this.resize(sizeInVertices);
    };

    VertexArrayFacade._verifyAttributes = function(attributes) {
        var attrs = [];

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];

            var attr = {
                index : (typeof attribute.index === 'undefined') ? i : attribute.index,
                enabled : (typeof attribute.enabled === 'undefined') ? true : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
                normalize : attribute.normalize || false,
                purpose : defaultValue(attribute.purpose, 'all'),

                // There will be either a vertexBuffer or an [optional] usage.
                vertexBuffer : attribute.vertexBuffer,
                usage : attribute.usage || BufferUsage.STATIC_DRAW
            };
            attrs.push(attr);

            if ((attr.componentsPerAttribute !== 1) && (attr.componentsPerAttribute !== 2) && (attr.componentsPerAttribute !== 3) && (attr.componentsPerAttribute !== 4)) {
                throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
            }

            var datatype = attr.componentDatatype;
            if (!ComponentDatatype.validate(datatype)) {
                throw new DeveloperError('Attribute must have a valid componentDatatype or not specify it.');
            }

            if (!BufferUsage.validate(attr.usage)) {
                throw new DeveloperError('Attribute must have a valid usage or not specify it.');
            }
        }

        // Verify all attribute names are unique.
        // Multiple attributes can share a name as long as they have different purposes.
        var uniqueIndices = new Array(attrs.length);
        for ( var j = 0; j < attrs.length; ++j) {
            var currentAttr = attrs[j];
            var index = currentAttr.index;
            var purpose = currentAttr.purpose;

            if (purpose !== 'all') {
                var uniqueIndex = uniqueIndices[index];
                if (uniqueIndex === true) {
                    throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
                }
                if (typeof uniqueIndex !== 'undefined') {
                    if (uniqueIndex[purpose]) {
                        throw new DeveloperError('Index ' + index + ' is used by more than one attribute with the same purpose.');
                    }
                } else {
                    uniqueIndex = uniqueIndices[index] = {};
                }
                uniqueIndex[purpose] = true;
            } else {
                if (uniqueIndices[index]) {
                    throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
                }
                uniqueIndices[index] = true;
            }
        }

        return attrs;
    };

    VertexArrayFacade._vertexSizeInBytes = function(attributes) {
        var sizeInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            sizeInBytes += (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);
        }

        var maxComponentSizeInBytes = (length > 0) ? attributes[0].componentDatatype.sizeInBytes : 0; // Sorted by size
        var remainder = (maxComponentSizeInBytes > 0) ? (sizeInBytes % maxComponentSizeInBytes) : 0;
        var padding = (remainder === 0) ? 0 : (maxComponentSizeInBytes - remainder);
        sizeInBytes += padding;

        return sizeInBytes;
    };

    VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
        var views = [];
        var offsetInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            var componentDatatype = attribute.componentDatatype;

            views.push({
                index : attribute.index,
                enabled : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : componentDatatype,
                normalize : attribute.normalize,

                offsetInBytes : offsetInBytes,
                vertexSizeInComponentType : vertexSizeInBytes / componentDatatype.sizeInBytes,

                view : undefined
            });

            offsetInBytes += (attribute.componentsPerAttribute * componentDatatype.sizeInBytes);
        }

        return views;
    };

    /**
     * DOC_TBA
     *
     * Invalidates writers.  Can't render again until commit is called.
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.resize = function(sizeInVertices) {
        this._size = sizeInVertices;

        var allBuffers = this._allBuffers;
        this.writers = {};

        for (var i = 0, len = allBuffers.length; i < len; ++i) {
            var buffer = allBuffers[i];
            VertexArrayFacade._resize(buffer, this._size);

            var writersForPurpose = this.writers[buffer.purpose];
            if (typeof writersForPurpose === 'undefined') {
                writersForPurpose = this.writers[buffer.purpose] = [];
            }

            // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.
            VertexArrayFacade._appendWriters(writersForPurpose, buffer);
        }

        // VAs are recreated next time commit is called.
        this._destroyVA();
    };

    VertexArrayFacade._resize = function(buffer, size) {
        if (buffer.vertexSizeInBytes > 0) {
            // Create larger array buffer
            var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);

            // Copy contents from previous array buffer
            if (buffer.arrayBuffer) {
                var destView = new Uint8Array(arrayBuffer);
                var sourceView = new Uint8Array(buffer.arrayBuffer);
                var sourceLength = sourceView.length;
                for ( var j = 0; j < sourceLength; ++j) {
                    destView[j] = sourceView[j];
                }
            }

            // Create typed views into the new array buffer
            var views = buffer.arrayViews;
            var length = views.length;
            for ( var i = 0; i < length; ++i) {
                var view = views[i];
                view.view = view.componentDatatype.createArrayBufferView(arrayBuffer, view.offsetInBytes);
            }

            buffer.arrayBuffer = arrayBuffer;
        }
    };

    var createWriters = [
    // 1 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, attribute) {
            view[index * vertexSizeInComponentType] = attribute;
            buffer.needsCommit = true;
        };
    },

    // 2 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            buffer.needsCommit = true;
        };
    },

    // 3 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            buffer.needsCommit = true;
        };
    },

    // 4 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2, component3) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            view[i + 3] = component3;
            buffer.needsCommit = true;
        };
    }];

    VertexArrayFacade._appendWriters = function(writers, buffer) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var arrayView = arrayViews[i];
            writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.commit = function(indexBuffer) {
        var recreateVA = false;

        var allBuffers = this._allBuffers;
        var buffer;

        for (var i = 0, len = allBuffers.length; i < len; ++i) {
            buffer = allBuffers[i];
            recreateVA = this._commit(buffer) || recreateVA;
        }

        ///////////////////////////////////////////////////////////////////////

        if (recreateVA || !this.va) {
            // Using unsigned short indices, 64K vertices can be indexed by one index buffer
            var sixtyFourK = 64 * 1024;

            var buffersByPurposeAndUsage = this._buffersByPurposeAndUsage;

            this._destroyVA();
            this.vaByPurpose = {};

            for (var purpose in buffersByPurposeAndUsage) {
                if (buffersByPurposeAndUsage.hasOwnProperty(purpose)) {
                    var buffersByUsage = buffersByPurposeAndUsage[purpose];

                    var va = [];
                    var numberOfVertexArrays = Math.ceil(this._size / sixtyFourK);
                    for ( var k = 0; k < numberOfVertexArrays; ++k) {
                        var attributes = [];

                        // Add all-purpose attributes
                        var allPurposeBuffersByUsage = buffersByPurposeAndUsage.all;
                        if (allPurposeBuffersByUsage !== buffersByUsage) {
                            for (var allPurposeUsage in allPurposeBuffersByUsage) {
                                if (allPurposeBuffersByUsage.hasOwnProperty(allPurposeUsage)) {
                                    var allPurposeBuffer = allPurposeBuffersByUsage[allPurposeUsage];
                                    VertexArrayFacade._appendAttributes(attributes, allPurposeBuffer, k * (allPurposeBuffer.vertexSizeInBytes * sixtyFourK));
                                }
                            }
                        }

                        // Add purpose-specific attributes
                        for (var usage in buffersByUsage) {
                            if (buffersByUsage.hasOwnProperty(usage)) {
                                buffer = buffersByUsage[usage];
                                VertexArrayFacade._appendAttributes(attributes, buffer, k * (buffer.vertexSizeInBytes * sixtyFourK));
                            }
                        }

                        attributes = attributes.concat(this._precreated);

                        va.push({
                            va : this._context.createVertexArray(attributes, indexBuffer),
                            indicesCount : 1.5 * ((k !== (numberOfVertexArrays - 1)) ? sixtyFourK : (this._size % sixtyFourK))
                        // TODO: not hardcode 1.5
                        });
                    }

                    this.vaByPurpose[purpose] = va;
                }
            }
        }
    };

    VertexArrayFacade.prototype._commit = function(buffer) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            buffer.needsCommit = false;

            var vertexBuffer = buffer.vertexBuffer;
            var vertexBufferSizeInBytes = this._size * buffer.vertexSizeInBytes;
            if (!vertexBuffer || (vertexBuffer.getSizeInBytes() < vertexBufferSizeInBytes)) {
                if (vertexBuffer) {
                    vertexBuffer.destroy();
                }
                buffer.vertexBuffer = this._context.createVertexBuffer(buffer.arrayBuffer, buffer.usage);
                buffer.vertexBuffer.setVertexArrayDestroyable(false);

                return true; // Created new vertex buffer
            }

            buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
        }

        return false; // Did not create new vertex buffer
    };

    VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var view = arrayViews[i];

            attributes.push({
                index : view.index,
                enabled : view.enabled,
                componentsPerAttribute : view.componentsPerAttribute,
                componentDatatype : view.componentDatatype,
                normalize : view.normalize,
                vertexBuffer : buffer.vertexBuffer,
                offsetInBytes : vertexBufferOffset + view.offsetInBytes,
                strideInBytes : buffer.vertexSizeInBytes
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
        if (offsetInVertices < 0 || offsetInVertices >= this._size) {
            throw new DeveloperError('offsetInVertices must be greater than or equal to zero and less than the vertex array size.');
        }

        if (offsetInVertices + lengthInVertices > this._size) {
            throw new DeveloperError('offsetInVertices + lengthInVertices cannot exceed the vertex array size.');
        }

        var allBuffers = this._allBuffers;

        for (var i = 0, len = allBuffers.length; i < len; ++i) {
            this._subCommit(allBuffers[i], offsetInVertices, lengthInVertices);
        }
    };

    VertexArrayFacade.prototype._subCommit = function(buffer, offsetInVertices, lengthInVertices) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
            var byteLength = buffer.vertexSizeInBytes * lengthInVertices;

            // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating
            // individual attributes instead of the entire (sub-)vertex.
            //
            // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?
            buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.endSubCommits = function() {
        var allBuffers = this._allBuffers;

        for (var i = 0, len = allBuffers.length; i < len; ++i) {
            allBuffers[i].needsCommit = false;
        }
    };

    VertexArrayFacade.prototype._destroyVA = function() {
        var vaByPurpose = this.vaByPurpose;
        if (typeof vaByPurpose === 'undefined') {
            return;
        }

        for (var purpose in vaByPurpose) {
            if (vaByPurpose.hasOwnProperty(purpose)) {
                var va = vaByPurpose[purpose];
                var length = va.length;
                for (var i = 0; i < length; ++i) {
                    va[i].va.destroy();
                }
            }
        }

        this.vaByPurpose = undefined;
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.destroy = function() {
        var allBuffers = this._allBuffers;
        for (var i = 0, len = allBuffers.length; i < len; ++i) {
            var buffer = allBuffers[i];
            buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();
        }

        this._destroyVA();

        return destroyObject(this);
    };

    return VertexArrayFacade;
});
/*global define*/
define('Renderer/VertexLayout',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Determines if vertex attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.
     *
     * @exports VertexLayout
     *
     * @see Context#createVertexArrayFromMesh
     */
    var VertexLayout = {
        /**
         * Each attribute will be stored in a separate vertex buffer.  This can be slightly slower
         * than using a single interleaved vertex buffer, but it is more flexible; more easily allowing
         * the sharing of vertex buffers among vertex arrays.  It also requires much less initial CPU
         * processing than interleaving.
         *
         * @constant
         * @type {Enumeration}
         */
        SEPARATE : new Enumeration(0, 'SEPARATE'),
        /**
         * Each attribute will be interleaved in a single vertex buffer.  This can have a slight
         * performance advantage over using a separate vertex buffer per attribute, but it requires
         * extra CPU processing to initially interleave the vertex data.  This is recommended for
         * static data that will be rendered over several frames.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERLEAVED : new Enumeration(1, 'INTERLEAVED'),

        /**
         * DOC_TBA
         *
         * @param vertexLayout
         *
         * @returns {Boolean}
         */
        validate : function(vertexLayout) {
            return ((vertexLayout === VertexLayout.SEPARATE) ||
                    (vertexLayout === VertexLayout.INTERLEAVED));
        }

    };

    return VertexLayout;
});
/*global define*/
define('Scene/BingMapsStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * An enumeration of the types of imagery provided by Bing Maps.
     *
     * @exports BingMapsStyle
     *
     * @see BingMapsImageryProvider
     */
    var BingMapsStyle = {
        /**
         * Aerial imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL : new Enumeration(0, 'AERIAL', { imagerySetName : 'Aerial' }),

        /**
         * Aerial imagery with a road overlay.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL_WITH_LABELS : new Enumeration(1, 'AERIAL_WITH_LABELS', { imagerySetName : 'AerialWithLabels' }),

        /**
         * Roads without additional imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        ROAD : new Enumeration(2, 'ROAD', { imagerySetName : 'Road' }),

        /**
         * Ordnance Survey imagery
         *
         * @constant
         * @type {Enumeration}
         */
        ORDNANCE_SURVEY : new Enumeration(3, 'ORDNANCE_SURVEY', { imagerySetName : 'OrdnanceSurvey' }),

        /**
         * Collins Bart imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        COLLINS_BART : new Enumeration(4, 'COLLINS_BART', { imagerySetName : 'CollinsBart' })
    };

    return BingMapsStyle;
});
/*global define*/
define('Scene/CameraEventType',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CameraEventType
     */
    var CameraEventType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DRAG : new Enumeration(0, 'LEFT_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DRAG : new Enumeration(1, 'RIGHT_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DRAG : new Enumeration(2, 'MIDDLE_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(3, 'WHEEL')
    };

    return CameraEventType;
});
/*global define*/
define('Scene/CameraEventHandler',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Cartesian2',
        './CameraEventType'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Cartesian2,
        CameraEventType) {
    

    /**
     * DOC_TBA
     *
     * @alias CameraEventHandler
     *
     * @param {HTMLCanvasElement} canvas DOC_TBA
     * @param {CameraEventType} moveType DOC_TBA
     * @param {EventModifier} moveModifier DOC_TBA
     *
     * @exception {DeveloperError} canvas is required.
     * @exception {DeveloperError} moveType is required.
     *
     * @constructor
     *
     * @see EventHandler
     */
    var CameraEventHandler = function(canvas, moveType, moveModifier) {
        if (typeof canvas === 'undefined') {
            throw new DeveloperError('description.canvas is required.');
        }

        if (typeof moveType === 'undefined') {
            throw new DeveloperError('moveType is required.');
        }

        this._eventHandler = new EventHandler(canvas);

        this._update = true;
        this._movement = undefined;
        this._lastMovement = undefined;
        this._isDown = false;
        this._pressTime = undefined;
        this._releaseTime = undefined;

        var that = this;

        if (moveType !== CameraEventType.WHEEL) {
            var down;
            var up;
            if (moveType === CameraEventType.LEFT_DRAG) {
                down = MouseEventType.LEFT_DOWN;
                up = MouseEventType.LEFT_UP;
            } else if (moveType === CameraEventType.RIGHT_DRAG) {
                down = MouseEventType.RIGHT_DOWN;
                up = MouseEventType.RIGHT_UP;
            } else if (moveType === CameraEventType.MIDDLE_DRAG) {
                down = MouseEventType.MIDDLE_DOWN;
                up = MouseEventType.MIDDLE_UP;
            } else {
                this._eventHandler = this._eventHandler && this._eventHandler.destroy();
                throw new DeveloperError('moveType must be of type CameraEventType.');
            }

            this._eventHandler.setMouseAction(function(movement) {
                that._lastMovement = null;
                that._isDown = true;
                that._pressTime = new Date();
            }, down, moveModifier);

            this._eventHandler.setMouseAction(function(movement) {
                that._isDown = false;
                that._releaseTime = new Date();
            }, up, moveModifier);

            this._eventHandler.setMouseAction(function(movement) {
                if (that._isDown) {
                    if (!that._update) {
                        that._movement.endPosition = movement.endPosition.clone();
                    } else {
                        that._lastMovement = that._movement;
                        that._movement = movement;
                        that._update = false;
                    }
                }
            }, MouseEventType.MOVE, moveModifier);
        } else {
            this._eventHandler.setMouseAction(function(delta) {
                // TODO: magic numbers
                var arcLength = 2 * CesiumMath.toRadians(delta);
                if (!that._update) {
                    that._movement.endPosition.y = that._movement.endPosition.y + arcLength;
                } else {
                    that._movement = {
                        startPosition : new Cartesian2(0.0, 0.0),
                        endPosition : new Cartesian2(0.0, arcLength),
                        motion : new Cartesian2(0.0, 0.0)
                    };
                    that._lastMovement = that._movement; // This looks unusual, but its needed for wheel inertia.
                    that._update = false;
                }
                that._pressTime = new Date();
                that._releaseTime = new Date(that._pressTime.getTime() + Math.abs(arcLength) * 5.0);
            }, MouseEventType.WHEEL, moveModifier);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} DOC_TBA
     */
    CameraEventHandler.prototype.isMoving = function() {
        return !this._update;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getMovement = function() {
        var movement = this._movement;
        this._update = true;
        return movement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getLastMovement = function() {
        return this._lastMovement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} DOC_TBA
     *
     */
    CameraEventHandler.prototype.isButtonDown = function() {
        return this._isDown;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Date} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonPressTime = function() {
        return this._pressTime;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Date} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonReleaseTime = function() {
        return this._releaseTime;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraEventHandler#destroy
     */
    CameraEventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraEventHandler
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraEventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    CameraEventHandler.prototype.destroy = function() {
        this._eventHandler = this._eventHandler && this._eventHandler.destroy();
        return destroyObject(this);
    };

    return CameraEventHandler;
});
/*global define*/
define('Scene/CameraFlightController',[
        '../Core/destroyObject',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Cartesian3',
        '../Core/HermiteSpline'
    ], function(
        destroyObject,
        EventHandler,
        MouseEventType,
        Quaternion,
        Matrix3,
        Cartesian3,
        HermiteSpline) {
    

    /**
     * A type that defines camera behavior: the camera will follow a path from the
     * current position of the camera to an end point around an ellipsoid.
     *
     * @alias CameraFlightController
     * @internalConstructor
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used to listen for user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} ellipsoid The ellipsoid to move the camera around.
     * @param {Cartesian} destination The Cartesian point that is the end of the path.
     * @param {Number} duration The time, in seconds, to travel along the path.
     *
     * @see CameraControllerCollection#addFlight
     */
    var CameraFlightController = function(canvas, camera, ellipsoid, destination, duration, complete) {
        // get minimum altitude from which the whole ellipsoid is visible
        var radius = ellipsoid.getMaximumRadius();

        var frustum = camera.frustum;
        var near = frustum.near;
        var top = frustum.near * Math.tan(0.5 * frustum.fovy);
        var right = frustum.aspectRatio * top;

        var dx = radius * near / right;
        var dy = radius * near / top;
        var dm = Math.max(dx, dy);
        var altitude = dm - radius;

        this._camera = camera;
        this._start = new Date();
        this._end = new Date(this._start.getTime() + duration * 1000);
        this._path = this._createPath(ellipsoid, altitude, destination, duration);
        this._canceled = false;
        this._complete = complete;

        var that = this;
        var cancelFlight = function() {
            that._canceled = true;
        };

        this._handler = new EventHandler(canvas);
        this._handler.setMouseAction(cancelFlight, MouseEventType.LEFT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.RIGHT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.MIDDLE_DOWN);
    };

    CameraFlightController.prototype._createPath = function(ellipsoid, altitude, endPoint, duration) {
        var start = this._camera.position;

        var maxStartAlt = ellipsoid.getMaximumRadius() + altitude;
        var dot = start.normalize().dot(endPoint.normalize());

        var abovePercentage, incrementPercentage;
        var startAboveMaxAlt = (start.magnitude() > maxStartAlt);
        if (startAboveMaxAlt) {
            abovePercentage = 0.6;
            incrementPercentage = 0.35;
        } else {
            // TODO: revisit when hi-res imagery is implemented.
            abovePercentage = Math.max(0.1, 1.0 - Math.abs(dot));
            incrementPercentage = 0.5;
        }

        maxStartAlt = ellipsoid.getMaximumRadius() + abovePercentage * altitude;

        var aboveEnd = endPoint.normalize().multiplyByScalar(maxStartAlt);
        var afterStart = start.normalize().multiplyByScalar(maxStartAlt);

        var points, axis, angle, rotation;
        if (start.magnitude() > maxStartAlt && dot > 0) {
            var middle = start.subtract(aboveEnd).multiplyByScalar(0.5).add(aboveEnd);

            points = [{
                point : start
            }, {
                point : middle
            }, {
                point : aboveEnd
            }, {
                point : endPoint
            }];
        } else {
            points = [{
                point : start
            }];

            angle = Math.acos(afterStart.normalize().dot(aboveEnd.normalize()));
            axis = afterStart.cross(aboveEnd);

            var increment = incrementPercentage * angle;
            var startCondition = (startAboveMaxAlt) ? angle - increment : angle;
            for ( var i = startCondition; i > 0.0; i = i - increment) {
                rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, i));
                points.push({
                    point : rotation.multiplyByVector(aboveEnd)
                });
            }

            points.push({
                point : aboveEnd
            }, {
                point : endPoint
            });
        }

        var scalar = duration / (points.length - 1);
        for ( var k = 0; k < points.length; ++k) {
            points[k].time = k * scalar;
        }

        return new HermiteSpline(points);
    };

    /**
     * @private
     */
    CameraFlightController.prototype.update = function() {
        var time = new Date(),
            diff,
            position,
            normal,
            tangent,
            target;

        var now = (time.getTime() > this._end.getTime()) ? this._end : time;

        diff = ( now.getTime() - this._start.getTime()) / 1000.0;
        position = this._path.evaluate(diff);
        normal = Cartesian3.UNIT_Z.cross(position).normalize();
        tangent = position.cross(normal).normalize();
        target = Cartesian3.ZERO;
        this._camera.lookAt(position, target, tangent);

        var isComplete = (now === this._end) || this._canceled;
        if(isComplete && !this._canceled && (typeof this._complete !== 'undefined')){
            this._complete();
        }
        return !isComplete;
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFlightController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFlightController#destroy
      */
    CameraFlightController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraFlightController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFlightControllerController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFlightController.prototype.destroy = function() {
        this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFlightController;
});
/*global define*/
define('Scene/CameraHelpers',[
        '../Core/Math',
        '../Core/Cartesian2'
    ], function(
        CesiumMath,
        Cartesian2) {
    

    function move(camera, direction, rate) {
        var position = camera.position;
        var newPosition = position.add(direction.multiplyByScalar(rate));
        camera.position = newPosition;
    }

    function decay(time, coefficient) {
        if (time < 0) {
            return 0.0;
        }

        var tau = (1.0 - coefficient) * 25.0;
        return Math.exp(-tau * time);
    }

    function sameMousePosition(movement) {
        return movement.startPosition.equalsEpsilon(movement.endPosition, CesiumMath.EPSILON14);
    }

    // If the time between mouse down and mouse up is not between
    // these thresholds, the camera will not move with inertia.
    // This value is probably dependent on the browser and/or the
    // hardware. Should be investigated further.
    var inertiaMaxClickTimeThreshold = 0.4;
    var inertiaMaxTimeThreshold = 2.0;

    function maintainInertia(handler, decayCoef, action, object, lastMovementName) {
        var ts = handler.getButtonPressTime();
        var tr = handler.getButtonReleaseTime();
        var threshold = ts && tr && ((tr.getTime() - ts.getTime()) / 1000.0);
        var now = new Date();
        var fromNow = tr && ((now.getTime() - tr.getTime()) / 1000.0);
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold && fromNow <= inertiaMaxTimeThreshold) {
            var d = decay(fromNow, decayCoef);

            if (!object[lastMovementName]) {
                var lastMovement = handler.getLastMovement();
                if (!lastMovement || sameMousePosition(lastMovement)) {
                    return;
                }

                var motionX = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                var motionY = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                object[lastMovementName] = {
                    startPosition : new Cartesian2(lastMovement.startPosition.x, lastMovement.startPosition.y),
                    endPosition : new Cartesian2(lastMovement.startPosition.x + motionX * d, lastMovement.startPosition.y + motionY * d),
                    motion : new Cartesian2(motionX, motionY)
                };
            } else {
                object[lastMovementName] = {
                    startPosition : object[lastMovementName].endPosition.clone(),
                    endPosition : new Cartesian2(
                            object[lastMovementName].endPosition.x + object[lastMovementName].motion.x * d,
                            object[lastMovementName].endPosition.y + object[lastMovementName].motion.y * d),
                    motion : new Cartesian2(0.0, 0.0)
                };
            }

            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(object[lastMovementName].endPosition.x) || isNaN(object[lastMovementName].endPosition.y) || sameMousePosition(object[lastMovementName])) {
                object[lastMovementName] = undefined;
                return;
            }

            if (!handler.isButtonDown()) {
                action.apply(object, [object[lastMovementName]]);
            }
        } else {
            object[lastMovementName] = undefined;
        }
    }

    var maxHeight = 20.0;

    function handleZoom(object, movement, distanceMeasure) {
        // distanceMeasure should be the height above the ellipsoid.
        // The zoomRate slows as it approaches the surface and stops maxHeight above it.
        var zoomRate = object._zoomFactor * (distanceMeasure - maxHeight);

        if (zoomRate > object._maximumZoomRate) {
            zoomRate = object._maximumZoomRate;
        }

        var diff = movement.endPosition.y - movement.startPosition.y;
        if (diff === 0) {
            return;
        }

        var rangeWindowRatio = diff / object._canvas.clientHeight;
        var dist = zoomRate * rangeWindowRatio;

        if (dist > 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {
            return;
        }

        if (distanceMeasure - dist < maxHeight) {
            dist = distanceMeasure - maxHeight - 1.0;
        }

        if (dist > 0.0) {
            object.zoomIn(dist);
        } else {
            object.zoomOut(-dist);
        }
    }

    function zoom(camera, rate) {
        move(camera, camera.direction, rate);
    }

    return {
        move : move,
        maxHeight : maxHeight,
        handleZoom : handleZoom,
        maintainInertia : maintainInertia,
        zoom : zoom
    };
});
/*global define*/
define('Scene/CameraFreeLookController',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventModifier',
        '../Core/Quaternion',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Matrix3',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers'
    ], function(
        destroyObject,
        CesiumMath,
        EventModifier,
        Quaternion,
        Cartesian2,
        Cartesian3,
        Matrix3,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers) {
    

    var move = CameraHelpers.move;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and rotation of the axes keeping the position stationary.
     *
     * @alias CameraFreeLookController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     *
     * @internalConstructor
     */
    var CameraFreeLookController = function(canvas, camera) {
        this._canvas = canvas;
        this._camera = camera;
        this._handler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG, EventModifier.SHIFT);

        this._maximumMoveRate = 2000000.0;
        this._minimumMoveRate = 1.0 / 5000.0;
        this._maximumTurnRate = Math.PI / 8.0;
        this._minimumTurnRate = Math.PI / 120.0;

        this._moveRate = 100000.0;
        this._turnRate = Math.PI / 60.0;

        /**
         * DOC_TBD
         */
        this.horizontalRotationAxis = undefined;
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveBackward
     */
    CameraFreeLookController.prototype.moveForward = function(rate) {
        move(this._camera, this._camera.direction, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveForward
     */
    CameraFreeLookController.prototype.moveBackward = function(rate) {
        move(this._camera, this._camera.direction, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveDown
     */
    CameraFreeLookController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveUp
     */
    CameraFreeLookController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveLeft
     */
    CameraFreeLookController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveRight
     */
    CameraFreeLookController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the opposite direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookRight
     */
    CameraFreeLookController.prototype.lookLeft = function(rate) {
        this.lookRight(-rate || -this._turnRate);
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookLeft
     */
    CameraFreeLookController.prototype.lookRight = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.right, this._camera.up, turnRate);
        this._camera.direction = rotated[0];
        this._camera.right = rotated[1];
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookDown
     */
    CameraFreeLookController.prototype.lookUp = function(rate) {
        this.lookDown(-rate || -this._turnRate);
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the opposite direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookUp
     */
    CameraFreeLookController.prototype.lookDown = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.up, this._camera.right, turnRate);
        this._camera.direction = rotated[0];
        this._camera.up = rotated[1];
    };

    CameraFreeLookController.prototype._rotateTwoAxes = function(v0, v1, axis, angle) {
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));
        var u0 = rotation.multiplyByVector(v0);
        var u1 = rotation.multiplyByVector(v1);
        return [u0, u1];
    };

    /**
     * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
     *
     * @memberof CameraFreeLookController
     *
     * @param {Cartesian3} axis The axis to rotate around.
     * @param {Number} angle The angle, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookUp
     * @see CameraFreeLookController#lookDown
     * @see CameraFreeLookController#lookLeft
     * @see CameraFreeLookController#lookRight
     */
    CameraFreeLookController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = angle || this._moveRate;
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(a, turnAngle));
        var direction = rotation.multiplyByVector(this._camera.direction);
        var up = rotation.multiplyByVector(this._camera.up);
        var right = rotation.multiplyByVector(this._camera.right);
        this._camera.direction = direction;
        this._camera.up = up;
        this._camera.right = right;
    };

    /**
     * @private
     */
    CameraFreeLookController.prototype.update = function(time) {
        if (this._handler.isMoving()) {
            this._look(this._handler.getMovement());
        }

        return true;
    };

    CameraFreeLookController.prototype._look = function(movement) {
        var camera = this._camera;

        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        var tanTheta = camera.frustum.aspectRatio * tanPhi;
        var near = camera.frustum.near;

        var startNDC = new Cartesian2((2.0 / width) * movement.startPosition.x - 1.0, (2.0 / height) * (height - movement.startPosition.y) - 1.0);
        var endNDC = new Cartesian2((2.0 / width) * movement.endPosition.x - 1.0, (2.0 / height) * (height - movement.endPosition.y) - 1.0);

        var nearCenter = camera.position.add(camera.direction.multiplyByScalar(near));

        var startX = camera.right.multiplyByScalar(startNDC.x * near * tanTheta);
        startX = nearCenter.add(startX).subtract(camera.position).normalize();
        var endX = camera.right.multiplyByScalar(endNDC.x * near * tanTheta);
        endX = nearCenter.add(endX).subtract(camera.position).normalize();

        var dot = startX.dot(endX);
        var angle = 0.0;
        var axis = (typeof this.horizontalRotationAxis !== 'undefined') ? this.horizontalRotationAxis : camera.up;
        axis = (movement.startPosition.x > movement.endPosition.x) ? axis : axis.negate();
        axis = axis.normalize();
        if (dot < 1.0) { // dot is in [0, 1]
            angle = Math.acos(dot);
        }
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyByVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyByVector(camera.up);
        }

        var startY = camera.up.multiplyByScalar(startNDC.y * near * tanPhi);
        startY = nearCenter.add(startY).subtract(camera.position).normalize();
        var endY = camera.up.multiplyByScalar(endNDC.y * near * tanPhi);
        endY = nearCenter.add(endY).subtract(camera.position).normalize();

        dot = startY.dot(endY);
        angle = 0.0;
        axis = startY.cross(endY);
        if (dot < 1.0 && !axis.equalsEpsilon(Cartesian3.ZERO, CesiumMath.EPSILON14)) { // dot is in [0, 1]
            angle = Math.acos(dot);
        } else { // no rotation
            axis = Cartesian3.UNIT_X;
        }
        rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyByVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyByVector(camera.up);
        }

        camera.right = camera.direction.cross(camera.up);
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFreeLookController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFreeLookController#destroy
      */
    CameraFreeLookController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraFreeLookController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFreeLookController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFreeLookController.prototype.destroy = function() {
        this._handler = this._handler && this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFreeLookController;
});
/*global define*/
define('Scene/CameraSpindleControllerMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for describing how the <code>CameraSpindleController</code>
     * will handle mouse events.
     *
     * @exports CameraSpindleControllerMode
     *
     * @see {CameraSpindleController#mode}
     */
    var CameraSpindleControllerMode = {
        /**
         * This mode is useful for rotating around arbitrary ellipsoids.
         *
         * @constant
         * @type {Enumeration}
         */
        ROTATE : new Enumeration(0, 'ROTATE'),

        /**
         * This mode will cause the controller to rotate around an ellipsoid such that
         * the point under the mouse cursor will remain there when dragged. This mode can only
         * be used for larger ellipsoids like the WGS84 ellipsoid.
         *
         * @constant
         * @type {Enumeration}
         */
        PAN : new Enumeration(1, 'PAN'),

        /**
         * This mode will choose the best mode for the mouse input.
         *
         * @constant
         * @type {Enumeration}
         */
        AUTO : new Enumeration(2, 'AUTO')
    };

    return CameraSpindleControllerMode;
});
/*global define*/
define('Scene/CameraSpindleController',[
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleControllerMode',
        './CameraHelpers'
    ], function(
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Matrix3,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleControllerMode,
        CameraHelpers) {
    

    var handleZoom = CameraHelpers.handleZoom;
    var maintainInertia = CameraHelpers.maintainInertia;
    var zoom = CameraHelpers.zoom;

    /**
     * A type that defines camera behavior: the camera's position and axes will be rotated around the center
     * of the camera's reference frame.
     *
     * @alias CameraSpindleController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid to move around.
     *
     * @internalConstructor
     */
    var CameraSpindleController = function(canvas, camera, ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid;
        this._zoomRate = 100000.0;
        this._moveRate = Math.PI / 3600.0;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to spin because of inertia.
         * With a value of one, the camera will spin forever and
         * with value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaSpin = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        /**
         * If set, the camera will not be able to rotate past this axis in either direction.
         * If this is set while in pan mode, the position clicked on the ellipsoid
         * will not always map directly to the cursor.
         *
         * @type Cartesian3
         *
         * @see CameraSpindleController#mode
         */
        this.constrainedAxis = undefined;

        /**
         * Determines the rotation behavior on mouse events.
         *
         * @type CameraSpindleControllerMode
         */
        this.mode = CameraSpindleControllerMode.AUTO;

        var radius = this._ellipsoid.getMaximumRadius();
        this._zoomFactor = 5.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
        this._maximumRotateRate = 1.77;
        this._minimumRotateRate = 1.0 / 5000.0;

        this._spinHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);

        this._lastInertiaSpinMovement = undefined;
        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraSpindleController
     *
     * @param {Matrix4} transform DOC_TBA
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] DOC_TBA
     *
     * @example
     * // Example 1.
     * // Change the reference frame to one centered at a point on the ellipsoid's surface.
     * // Set the spindle controller's ellipsoid to a unit sphere for easy rotation around that point.
     * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
     * var transform = Transforms.eastNorthUpToFixedFrame(center);
     * scene.getCamera().getControllers().get(0).setReferenceFrame(transform, Ellipsoid.UNIT_SPHERE);
     *
     * // Example 2.
     * // Reset to the defaults.
     * scene.getCamera().getControllers().get(0).setReferenceFrame(Matrix4.IDENTITY);
     *
     */
    CameraSpindleController.prototype.setReferenceFrame = function (transform, ellipsoid) {
        this._camera.transform = transform;
        this.setEllipsoid(ellipsoid);
    };

    /**
     * Returns the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @returns {Ellipsoid} The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#setEllipsoid
     */
    CameraSpindleController.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Sets the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#getEllipsoid
     */
    CameraSpindleController.prototype.setEllipsoid = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var radius = ellipsoid.getMaximumRadius();
        this._ellipsoid = ellipsoid;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
    };

    /**
     * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
     * of the camera's position to the center of the camera's reference frame remains the same.
     *
     * @memberof CameraSpindleController
     *
     * @param {Cartesian3} axis The axis to rotate around given in world coordinates.
     * @param {Number} angle The angle, in radians, to rotate by. The direction of rotation is
     * determined by the sign of the angle.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#moveRight
    */
    CameraSpindleController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(a, turnAngle));

        var camera = this._camera;
        camera.position = rotation.multiplyByVector(camera.position);
        camera.direction = rotation.multiplyByVector(camera.direction);
        camera.up = rotation.multiplyByVector(camera.up);
        camera.right = camera.direction.cross(camera.up);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle downwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveDown = function(angle) {
        angle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        this._moveVertical(angle);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle upwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveUp = function(angle) {
        angle = (typeof angle !== 'undefined') ? -angle : -this._moveRate;
        this._moveVertical(angle);
    };

    CameraSpindleController.prototype._moveVertical = function(angle) {
        var camera = this._camera;
        var position = camera.position;
        var p = Cartesian3.normalize(position);
        if (typeof this.constrainedAxis !== 'undefined') {
            var northParallel = p.equalsEpsilon(this.constrainedAxis, CesiumMath.EPSILON2);
            var southParallel = p.equalsEpsilon(this.constrainedAxis.negate(), CesiumMath.EPSILON2);
            if ((!northParallel && !southParallel)) {
                var constrainedAxis = Cartesian3.normalize(this.constrainedAxis);

                var dot = p.dot(constrainedAxis);
                var angleToAxis = Math.acos(dot);
                if (angle > 0 && angle > angleToAxis) {
                    angle = angleToAxis;
                }

                dot = p.dot(constrainedAxis.negate());
                angleToAxis = Math.acos(dot);
                if (angle < 0 && -angle > angleToAxis) {
                    angle = -angleToAxis;
                }

                var tangent = Cartesian3.cross(constrainedAxis, p);
                this.rotate(tangent, angle);
            } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {
                this.rotate(camera.right, angle);
            }
        } else {
            this.rotate(camera.right, angle);
        }
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the right.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveRight = function(angle) {
        angle = (typeof angle !== 'undefined') ? -angle : -this._moveRate;
        this._moveHorizontal(angle);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the left.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveRight
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveLeft = function(angle) {
        angle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        this._moveHorizontal(angle);
    };

    CameraSpindleController.prototype._moveHorizontal = function(angle) {
        if (typeof this.constrainedAxis !== 'undefined') {
            this.rotate(this.constrainedAxis.normalize(), angle);
        } else {
            this.rotate(this._camera.up, angle);
        }
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomOut
     */
    CameraSpindleController.prototype.zoomIn = function(rate) {
        zoom(this._camera, (typeof rate !== 'undefined') ? rate : this._zoomRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction of
     * the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomIn
     */
    CameraSpindleController.prototype.zoomOut = function(rate) {
        zoom(this._camera, (typeof rate !== 'undefined') ? -rate : -this._zoomRate);
    };

    /**
     * @private
     */
    CameraSpindleController.prototype.update = function() {
        var spin = this._spinHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var rotating = spin && spin.isMoving() && spin.getMovement();
        var rightZooming = rightZoom && rightZoom.isMoving();
        var wheelZooming = wheelZoom && wheelZoom.isMoving();

        if (rotating) {
            this._spin(spin.getMovement());
        }

        if (spin && !rotating && this.inertiaSpin < 1.0) {
            maintainInertia(spin, this.inertiaSpin, this._spin, this, '_lastInertiaSpinMovement');
        }

        if (rightZooming) {
            this._zoom(rightZoom.getMovement());
        } else if (wheelZooming) {
            this._zoom(wheelZoom.getMovement());
        }

        if (rightZoom && !rightZooming && this.inertiaZoom < 1.0) {
            maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        if (wheelZoom && !wheelZooming && this.inertiaZoom < 1.0) {
            maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
        }

        return true;
    };

    CameraSpindleController.prototype._spin = function(movement) {
        if (this.mode === CameraSpindleControllerMode.AUTO) {
            if (typeof this._camera.pickEllipsoid(movement.startPosition, this._ellipsoid) !== 'undefined') {
                this._pan(movement);
            } else {
                this._rotate(movement);
            }
        } else if (this.mode === CameraSpindleControllerMode.ROTATE) {
            this._rotate(movement);
        } else {
            this._pan(movement);
        }
    };

    CameraSpindleController.prototype._rotate = function(movement) {
        var position = this._camera.position;
        var rho = position.magnitude();
        var rotateRate = this._rotateFactor * (rho - this._rotateRateRangeAdjustment);

        if (rotateRate > this._maximumRotateRate) {
            rotateRate = this._maximumRotateRate;
        }

        if (rotateRate < this._minimumRotateRate) {
            rotateRate = this._minimumRotateRate;
        }

        var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / this._canvas.clientWidth;
        var thetaWindowRatio = (movement.endPosition.y - movement.startPosition.y) / this._canvas.clientHeight;

        var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;
        var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;

        this._moveHorizontal(deltaPhi);
        this._moveVertical(deltaTheta);
    };

    CameraSpindleController.prototype._pan = function(movement) {
        var camera = this._camera;
        var p0 = camera.pickEllipsoid(movement.startPosition, this._ellipsoid);
        var p1 = camera.pickEllipsoid(movement.endPosition, this._ellipsoid);

        if (typeof p0 === 'undefined' || typeof p1 === 'undefined') {
            return;
        }

        var transform = camera.getInverseTransform();
        p0 = Cartesian3.fromCartesian4(transform.multiplyByPoint(p0));
        p1 = Cartesian3.fromCartesian4(transform.multiplyByPoint(p1));

        if (typeof this.constrainedAxis === 'undefined') {
            p0 = p0.normalize();
            p1 = p1.normalize();
            var dot = p0.dot(p1);
            var axis = p0.cross(p1);

            if (dot < 1.0 && !axis.equalsEpsilon(Cartesian3.ZERO, CesiumMath.EPSILON14)) { // dot is in [0, 1]
                var angle = Math.acos(dot);
                this.rotate(axis, angle);
            }
        } else {
            var startRho = p0.magnitude();
            var startPhi = Math.atan2(p0.y, p0.x);
            var startTheta = Math.acos(p0.z / startRho);

            var endRho = p1.magnitude();
            var endPhi = Math.atan2(p1.y, p1.x);
            var endTheta = Math.acos(p1.z / endRho);

            var deltaPhi = endPhi - startPhi;
            var deltaTheta = endTheta - startTheta;

            var theta = Math.acos(camera.position.z / camera.position.magnitude()) + deltaTheta;
            if (theta < 0 || theta > Math.PI) {
                deltaTheta = 0;
            }

            this._moveHorizontal(deltaPhi);
            this._moveVertical(deltaTheta);
        }
    };

    CameraSpindleController.prototype._zoom = function(movement) {
        handleZoom(this, movement, this._ellipsoid.cartesianToCartographic(this._camera.position).height);
    };

   /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraSpindleController
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraSpindleController#destroy
     */
    CameraSpindleController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraSpindleController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraSpindleController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraSpindleController.prototype.destroy = function() {
        this._spinHandler = this._spinHandler && this._spinHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        this._zoomWheel = this._zoomWheel && this._zoomWheel.destroy();
        return destroyObject(this);
    };

    return CameraSpindleController;
});
/*global define*/
define('Scene/CameraCentralBodyController',[
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/IntersectionTests',
        '../Core/Math',
        '../Core/Matrix4',
        '../Core/Ray',
        '../Core/Transforms',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraHelpers'
    ], function(
        destroyObject,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        IntersectionTests,
        CesiumMath,
        Matrix4,
        Ray,
        Transforms,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleController,
        CameraFreeLookController,
        CameraHelpers) {
    

    var maxHeight = CameraHelpers.maxHeight;

    /**
     * Defines camera movement and handles mouse events that move the camera. Moves the camera
     * position around the center of an ellipsoid or a point on the surface. Also, moves the camera viewing
     * direction.
     *
     * @alias CameraCentralBodyController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} ellipsoid The ellipsoid to move around.
     *
     * @internalConstructor
     *
     * @see CameraSpindleController
     * @see CameraFreeLookController
     */
    var CameraCentralBodyController = function(canvas, camera, ellipsoid) {
        this._canvas = canvas;
        this._camera = camera;
        this._rotateHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);

        /**
         * Rotates the camera's position and axes around the center of the ellipsoid.
         *
         * @type {CameraSpindleController}
         */
        this.spindleController = new CameraSpindleController(canvas, camera, ellipsoid);

        /**
         * Rotates the view direction about the camera's other axes. The camera's position is stationary.
         *
         * @type {CameraFreeLookController}
         */
        this.freeLookController = new CameraFreeLookController(canvas, camera);
    };

    /**
     * @private
     */
    CameraCentralBodyController.prototype.update = function() {
        var rotate = this._rotateHandler;
        var rotating = rotate.isMoving() && rotate.getMovement();

        if (rotating) {
            this._rotate(rotate.getMovement());
        }

        this.spindleController.update();
        this.freeLookController.update();

        return true;
    };

    CameraCentralBodyController.prototype._rotate = function(movement) {
        var camera = this._camera;

        var ellipsoid = this.spindleController.getEllipsoid();
        var position = camera.position;
        if (ellipsoid.cartesianToCartographic(position).height - maxHeight - 1.0 < CesiumMath.EPSILON3 &&
                movement.endPosition.y - movement.startPosition.y < 0) {
            return;
        }

        var up = camera.up;
        var right = camera.right;
        var direction = camera.direction;

        var oldTransform = camera.transform;
        var oldEllipsoid = this.spindleController.getEllipsoid();
        var oldConstrainedZ = this.spindleController.constrainedAxis;

        var ray = new Ray(this._camera.getPositionWC(), this._camera.getDirectionWC());
        var intersection = IntersectionTests.rayEllipsoid(ray, this.spindleController.getEllipsoid());
        if (typeof intersection === 'undefined') {
            return;
        }

        var center = ray.getPoint(intersection.start);
        center = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByPoint(center));
        var localTransform = Transforms.eastNorthUpToFixedFrame(center);
        var transform = localTransform.multiply(oldTransform);

        this.spindleController.constrainedAxis = Cartesian3.UNIT_Z;
        this.spindleController.setReferenceFrame(transform, Ellipsoid.UNIT_SPHERE);

        var invTransform = camera.getInverseTransform();
        camera.position = Cartesian3.fromCartesian4(invTransform.multiplyByPoint(position));
        camera.up = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));

        this.spindleController._rotate(movement);

        position = camera.position;
        up = camera.up;
        right = camera.right;
        direction = camera.direction;

        this.spindleController.constrainedAxis = oldConstrainedZ;
        this.spindleController.setReferenceFrame(oldTransform, oldEllipsoid);

        camera.position = Cartesian3.fromCartesian4(transform.multiplyByPoint(position));
        camera.up = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));

        position = ellipsoid.cartesianToCartographic(camera.position);
        if (position.height < maxHeight + 1.0) {
            position.height = maxHeight + 1.0;
            camera.position = ellipsoid.cartographicToCartesian(position);
            camera.direction = Cartesian3.fromCartesian4(transform.getColumn(3).subtract(camera.position)).normalize();
            camera.right = camera.position.negate().cross(camera.direction).normalize();
            camera.up = camera.right.cross(camera.direction);
        }
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraCentralBodyController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraCentralBodyController#destroy
      */
    CameraCentralBodyController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraCentralBodyController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraCentralBodyController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraCentralBodyController.prototype.destroy = function() {
        this._rotateHandler = this._rotateHandler && this._rotateHandler.destroy();
        this.spindleController = this.spindleController && this.spindleController.destroy();
        this.freeLookController = this.freeLookController && this.freeLookController.destroy();
        return destroyObject(this);
    };

    return CameraCentralBodyController;
});
/*global define*/
define('Scene/CentralBodySurfaceShaderSet',[
        '../Core/destroyObject'
    ], function(
        destroyObject) {
    

    /**
     * Manages the shaders used to shade the surface of a {@link CentralBody}.
     *
     * @alias CentralBodySurfaceShaderSet
     * @private
     */
    function CentralBodySurfaceShaderSet(attributeIndices) {
        this.baseVertexShaderString = undefined;
        this.baseFragmentShaderString = undefined;
        this._attributeIndices = attributeIndices;
        this._shadersByTextureCount = [];
    }

    CentralBodySurfaceShaderSet.prototype.invalidateShaders = function() {
        var shadersByTextureCount = this._shadersByTextureCount;
        for (var i = 0, len = shadersByTextureCount.length; i < len; ++i) {
            var shader = shadersByTextureCount[i];
            if (typeof shader !== 'undefined') {
                shader.release();
            }
        }
        this._shadersByTextureCount = [];
    };

    CentralBodySurfaceShaderSet.prototype.getShaderProgram = function(context, textureCount) {
        var shader = this._shadersByTextureCount[textureCount];
        if (typeof shader === 'undefined') {
            var vs = this.baseVertexShaderString;
            var fs =
                '#define TEXTURE_UNITS ' + textureCount + '\n' +
                this.baseFragmentShaderString +
                'vec3 computeDayColor(vec3 initialColor, vec2 textureCoordinates)\n' +
                '{\n' +
                '    vec3 color = initialColor;\n';

            for (var i = 0; i < textureCount; ++i) {
                fs +=
                    'color = sampleAndBlend(\n' +
                    '   color,\n' +
                    '   u_dayTextures[' + i + '],\n' +
                    '   textureCoordinates,\n' +
                    '   u_dayTextureTexCoordsExtent[' + i + '],\n' +
                    '   u_dayTextureTranslationAndScale[' + i + '],\n' +
                    '   u_dayTextureAlpha[' + i + '],\n' +
                    '   u_dayTextureBrightness[' + i + '],\n' +
                    '   u_dayTextureContrast[' + i + '],\n' +
                    '   u_dayTextureOneOverGamma[' + i + ']);\n';
            }

            fs +=
                '    return color;\n' +
                '}';

            shader = context.getShaderCache().getShaderProgram(
                vs,
                fs,
                this._attributeIndices);
            this._shadersByTextureCount[textureCount] = shader;
        }
        return shader;
    };

    CentralBodySurfaceShaderSet.prototype.destroy = function() {
        var shadersByTextureCount = this._shadersByTextureCount;
        for (var i = 0, len = shadersByTextureCount.length; i < len; ++i) {
            var shader = shadersByTextureCount[i];
            if (typeof shader !== 'undefined') {
                shader.release();
            }
        }
        return destroyObject(this);
    };

    return CentralBodySurfaceShaderSet;
});
/*global define*/
define('Scene/CompositePrimitive',[
        '../Core/createGuid',
        '../Core/destroyObject',
        '../Core/DeveloperError'
    ], function(
        createGuid,
        destroyObject,
        DeveloperError) {
    

    // PERFORMANCE_IDEA: Add hierarchical culling and state sorting.

    /**
     * DOC_TBA
     *
     * @alias CompositePrimitive
     * @constructor
     *
     * @example
     * // Example 1. Add primitives to a composite.
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     * primitives.add(billboards);
     * primitives.add(labels);
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create composites of composites.
     * var children = new CompositePrimitive();
     * children.add(billboards);
     *
     * var parent = new CompositePrimitive();
     * parent.add(children);    // Add composite
     * parent.add(labels);      // Add regular primitive
     */
    var CompositePrimitive = function() {
        this._centralBody = undefined;
        this._primitives = [];
        this._guid = createGuid();

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
         *
         * @see CompositePrimitive#destroy
         * @see CompositePrimitive#setCentralBody
         * @see CompositePrimitive#remove
         * @see CompositePrimitive#removeAll
         *
         * @example
         * // Example 1. Primitives are destroyed by default.
         * var primitives = new CompositePrimitive();
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // true
         *
         * //////////////////////////////////////////////////////////////////
         *
         * // Example 2. Do not destroy primitives in a composite.
         * var primitives = new CompositePrimitive();
         * primitives.destroyPrimitives = false;
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // false
         * labels = labels.destroy();    // explicitly destroy
         */
        this.destroyPrimitives = true;

        /**
         * Determines if primitives in this composite will be shown.
         *
         * @type Boolean
         */
        this.show = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#setCentralBody
     */
    CompositePrimitive.prototype.getCentralBody = function() {
        return this._centralBody;
    };

    /**
     * DOC_TBA
     *
     * Implicitly sets the depth-test ellipsoid.
     *
     * @memberof CompositePrimitive
     *
     * @see CompositePrimitive#depthTestEllipsoid
     * @see CompositePrimitive#getCentralBody
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @example
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     */
    CompositePrimitive.prototype.setCentralBody = function(centralBody) {
        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();
        this._centralBody = centralBody;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} primitive is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#add
     *
     * @example
     * primitives.add(billboards);
     * primitives.add(labels);
     */
    CompositePrimitive.prototype.add = function(primitive) {
        if (typeof primitive === 'undefined') {
            throw new DeveloperError('primitive is required.');
        }

        var external = (primitive._external = primitive._external || {});
        var composites = (external._composites = external._composites || {});
        composites[this._guid] = {
            composite : this
        };

        this._primitives.push(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @return {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive was not found in the composite.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#removeAll
     *
     * @example
     * primitives.add(p);
     * primitives.remove(p);  // Returns true
     */
    CompositePrimitive.prototype.remove = function(primitive) {
        // PERFORMANCE_IDEA:  We can obviously make this a lot faster.
        if (this.contains(primitive)) {
            var index = this._primitives.indexOf(primitive);
            if (index !== -1) {
                this._primitives.splice(index, 1);

                delete primitive._external._composites[this._guid];

                if (this.destroyPrimitives) {
                    primitive.destroy();
                }

                return true;
            }
            // else ... this is not possible, I swear.
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#remove
     *
     * @example
     * primitives.add(...);
     * primitives.add(...);
     * primitives.removeAll();
     */
    CompositePrimitive.prototype.removeAll = function() {
        if (this.destroyPrimitives) {
            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                primitives[i].destroy();
            }
        }
        this._primitives = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * Does not include central body.
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     */
    CompositePrimitive.prototype.contains = function(primitive) {
        return !!(primitive &&
                  primitive._external &&
                  primitive._external._composites &&
                  primitive._external._composites[this._guid]);
    };

    CompositePrimitive.prototype._getPrimitiveIndex = function(primitive) {
        if (!this.contains(primitive)) {
            throw new DeveloperError('primitive is not in this composite.');
        }

        return this._primitives.indexOf(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#raiseToTop
     * @see CompositePrimitive#lower
     * @see CompositePrimitive#lowerToBottom
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.raise = function(primitive) {
        if (typeof primitive !== 'undefined') {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                var p = primitives[index];
                primitives[index] = primitives[index + 1];
                primitives[index + 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#raise
     * @see CompositePrimitive#lower
     * @see CompositePrimitive#lowerToBottom
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.raiseToTop = function(primitive) {
        if (typeof primitive !== 'undefined') {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.push(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#lowerToBottom
     * @see CompositePrimitive#raise
     * @see CompositePrimitive#raiseToTop
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.lower = function(primitive) {
        if (typeof primitive !== 'undefined') {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                var p = primitives[index];
                primitives[index] = primitives[index - 1];
                primitives[index - 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#lower
     * @see CompositePrimitive#raise
     * @see CompositePrimitive#raiseToTop
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.lowerToBottom = function(primitive) {
        if (typeof primitive !== 'undefined') {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.unshift(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * The index is based on the order the primitives were added to the composite.
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#getLength
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._primitives[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.getLength = function() {
        return this._primitives.length;
    };

    /**
     * @private
     */
    CompositePrimitive.prototype.update = function(context, frameState, commandList) {
        if (!this.show) {
            return;
        }

        if (this._centralBody) {
            this._centralBody.update(context, frameState, commandList);
        }

        var primitives = this._primitives;
        var length = primitives.length;
        for (var i = 0; i < length; ++i) {
            var primitive = primitives[i];
            primitive.update(context, frameState, commandList);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CompositePrimitive
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CompositePrimitive#destroy
     */
    CompositePrimitive.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by each primitive in this composite.  Explicitly destroying this
     * composite allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector to destroy this composite.
     * <br /><br />
     * Since destroying a composite destroys all the contained primitives, only destroy a composite
     * when you are sure no other code is still using any of the contained primitives.
     * <br /><br />
     * Once this composite is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CompositePrimitive
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#isDestroyed
     *
     * @example
     * primitives = primitives && primitives.destroy();
     */
    CompositePrimitive.prototype.destroy = function() {
        this.removeAll();
        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();
        return destroyObject(this);
    };

    return CompositePrimitive;
});

/*global define*/
define('Scene/CullingVolume',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Intersect'
    ], function(
        defaultValue,
        DeveloperError,
        Intersect) {
    

    /**
     * The culling volume defined by planes.
     *
     * @alias OrthographicFrustum
     * @constructor
     *
     * @param Array planes An array of clipping planes.
     */
    var CullingVolume = function(planes) {
        /**
         * Each plane is represented by a Cartesian4 object, where the x, y, and z components
         * define the unit vector normal to the plane, and the w component is the distance of the
         * plane from the origin.
         * @type {Array}
         */
        this.planes = defaultValue(planes, []);
    };

    /**
     * Determines whether a bounding volume intersects the culling volume.
     * @memberof CullingVolume
     *
     * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.
     * @return {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
     *
     * @exception {DeveloperError} boundingVolume is required.
     */
    CullingVolume.prototype.getVisibility = function(boundingVolume) {
        if (typeof boundingVolume === 'undefined') {
            throw new DeveloperError('boundingVolume is required.');
        }

        var planes = this.planes;
        var intersecting = false;
        for (var k = 0, len = planes.length; k < len; ++k) {
            var result = boundingVolume.intersect(planes[k]);
            if (result === Intersect.OUTSIDE) {
                return Intersect.OUTSIDE;
            } else if (result === Intersect.INTERSECTING) {
                intersecting = true;
            }
        }

        return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
    };

    return CullingVolume;
});
/*global define*/
define('Scene/FrameState',[], function() {
    

    /**
     * State information about the current frame.  An instance of this class
     * is provided to update functions.
     *
     * @alias FrameState
     * @constructor
     */
    var FrameState = function() {
        /**
         * The current mode of the scene.
         * @type SceneMode
         */
        this.mode = undefined;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = undefined;

        /**
         * The current frame number.
         *
         * @type Number
         */
        this.frameNumber = undefined;

        /**
         * The scene's current time.
         *
         * @type JulianDate
         */
        this.time = undefined;

        this.scene2D = {
            /**
             * The projection to use in 2D mode.
             */
            projection : undefined
        };

        /**
         * The current camera.
         * @type Camera
         */
        this.camera = undefined;

        /**
         * The culling volume.
         * @type CullingVolume
         */
        this.cullingVolume = undefined;

        /**
         * The current occluder.
         * @type Occluder
         */
        this.occluder = undefined;

        this.passes = {
                /**
                 * <code>true</code> if the primitive should update for a color pass, <code>false</code> otherwise.
                 * @type Boolean
                 */
                color : false,
                /**
                 * <code>true</code> if the primitive should update for a picking pass, <code>false</code> otherwise.
                 * @type Boolean
                 */
                pick : false,
                /**
                 * <code>true</code> if the primitive should update for an overlay pass, <code>false</code> otherwise.
                 * @type Boolean
                 */
                overlay : false
        };
    };

    return FrameState;
});
/*global define*/
define('Scene/FrustumCommands',['../Core/defaultValue'], function(defaultValue) {
    

    /**
     * Defines a list of commands whose geometry are bound by near and far distances from the camera.
     * @alias FrustumCommands
     * @constructor
     *
     * @param {Number} [near=0.0] The lower bound or closest distance from the camera.
     * @param {Number} [far=0.0] The upper bound or farthest distance from the camera.
     */
    var FrustumCommands = function(near, far) {
        /**
         * The lower bound or closest distance from the camera.
         * @type {Number}
         */
        this.near = defaultValue(near, 0.0);
        /**
         * The upper bound or farthest distance from the camera.
         * @type {Number}
         */
        this.far = defaultValue(far, 0.0);
        /**
         * The list of commands.
         * @type {Array}
         */
        this.commands = [];
    };

    return FrustumCommands;
});
/*global define*/
define('Scene/HorizontalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the horizontal origin is used to display a billboard to the left or right (in
     * screen space) of the actual position.
     *
     * @exports HorizontalOrigin
     *
     * @see Billboard#setHorizontalOrigin
     */
    var HorizontalOrigin = {
        /**
         * The origin is at the horizontal center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, 'CENTER'),
        /**
         * The origin is on the left side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT : new Enumeration(1, 'LEFT'),
        /**
         * The origin is on the right side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT : new Enumeration(-1, 'RIGHT')
    };

    return HorizontalOrigin;
});
/*global define*/
define('DynamicScene/CzmlHorizontalOrigin',[
        '../Scene/HorizontalOrigin'
       ], function(
         HorizontalOrigin) {
    

    /**
     * Provides methods for working with a horizontal origin defined in CZML.
     *
     * @exports CzmlHorizontalOrigin
     *
     * @see HorizontalOrigin
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlHorizontalOrigin = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.horizontalOrigin;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the HorizontalOrigin contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlHorizontalOrigin.unwrapInterval.
         * @returns The HorizontalOrigin value.
         */
        getValue : function(unwrappedInterval) {
            return HorizontalOrigin[unwrappedInterval];
        }
    };

    return CzmlHorizontalOrigin;
});
/*global define*/
define('Scene/ImageryState',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * @private
     */
    var ImageryState = {
        UNLOADED : new Enumeration(0, 'UNLOADED'),
        TRANSITIONING : new Enumeration(1, 'TRANSITIONING'),
        RECEIVED : new Enumeration(2, 'RECEIVED'),
        TEXTURE_LOADED : new Enumeration(3, 'TEXTURE_LOADED'),
        READY : new Enumeration(4, 'READY'),
        FAILED : new Enumeration(5, 'FAILED'),
        INVALID : new Enumeration(6, 'INVALID'),
        PLACEHOLDER : new Enumeration(7, 'PLACEHOLDER')
    };

    return ImageryState;
});
/*global define*/
define('Scene/Imagery',[
        '../Core/destroyObject',
        './ImageryState'
    ], function(
        destroyObject,
        ImageryState) {
    

    /**
     * Stores details about a tile of imagery.
     *
     * @alias Imagery
     * @private
     */
    var Imagery = function(imageryLayer, x, y, level, extent) {
        this.imageryLayer = imageryLayer;
        this.x = x;
        this.y = y;
        this.level = level;

        if (level !== 0) {
            var parentX = x / 2 | 0;
            var parentY = y / 2 | 0;
            var parentLevel = level - 1;
            this.parent = imageryLayer.getImageryFromCache(parentX, parentY, parentLevel);
        }

        this.state = ImageryState.UNLOADED;
        this.imageUrl = undefined;
        this.image = undefined;
        this.texture = undefined;
        this.referenceCount = 0;

        if (typeof extent === 'undefined' && imageryLayer.getImageryProvider().isReady()) {
            var tilingScheme = imageryLayer.getImageryProvider().getTilingScheme();
            extent = tilingScheme.tileXYToExtent(x, y, level);
        }

        this.extent = extent;
    };

    Imagery.createPlaceholder = function(imageryLayer) {
        var result = new Imagery(imageryLayer, 0, 0, 0);
        result.addReference();
        result.state = ImageryState.PLACEHOLDER;
        return result;
    };

    Imagery.prototype.addReference = function() {
        ++this.referenceCount;
    };

    Imagery.prototype.releaseReference = function() {
        --this.referenceCount;

        if (this.referenceCount === 0) {
            this.imageryLayer.removeImageryFromCache(this);

            if (typeof this.parent !== 'undefined') {
                this.parent.releaseReference();
            }

            if (typeof this.image !== 'undefined' && typeof this.image.destroy !== 'undefined') {
                this.image.destroy();
            }

            if (typeof this.transformedImage !== 'undefined' && typeof this.transformedImage.destroy !== 'undefined') {
                this.transformedImage.destroy();
            }

            if (typeof this.texture !== 'undefined' && typeof this.texture.destroy !== 'undefined') {
                this.texture.destroy();
            }

            destroyObject(this);

            return 0;
        }

        return this.referenceCount;
    };

    return Imagery;
});
/*global define*/
define('Scene/LabelStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * An enumeration describing how to draw a label.
     *
     * @exports LabelStyle
     *
     * @see Label#setStyle
     */
    var LabelStyle = {
        /**
         * Fill the text of the label, but do not outline.
         *
         * @constant
         * @type {Enumeration}
         */
        FILL : new Enumeration(0, 'FILL'),

        /**
         * Outline the text of the label, but do not fill.
         *
         * @constant
         * @type {Enumeration}
         */
        OUTLINE : new Enumeration(1, 'OUTLINE'),

        /**
         * Fill and outline the text of the label.
         *
         * @constant
         * @type {Enumeration}
         */
        FILL_AND_OUTLINE : new Enumeration(2, 'FILL_AND_OUTLINE')
    };

    return LabelStyle;
});
/*global define*/
define('DynamicScene/CzmlLabelStyle',[
        '../Scene/LabelStyle'
       ], function(
         LabelStyle) {
    

    /**
     * Provides methods for working with a label style defined in CZML.
     *
     * @exports CzmlLabelStyle
     *
     * @see LabelStyle
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlLabelStyle = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.labelStyle;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the LabelStyle contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlLabelStyle.unwrapInterval.
         * @returns The LabelStyle value.
         */
        getValue : function(unwrappedInterval) {
            return LabelStyle[unwrappedInterval];
        }
    };

    return CzmlLabelStyle;
});
/*global define*/
define('Scene/NeverTileDiscardPolicy',[
    ], function(
        ) {
    

    /**
     * A {@link TileDiscardPolicy} specifying that tile images should never be discard.
     *
     * @alias NeverTileDiscardPolicy
     * @constructor
     *
     * @see DiscardMissingTileImagePolicy
     */
    var NeverTileDiscardPolicy = function(description) {
    };

    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    NeverTileDiscardPolicy.prototype.isReady = function() {
        return true;
    };

    /**
     * Given a tile image, decide whether to discard that image.
     *
     * @param {Image|Promise} image An image, or a promise that will resolve to an image.
     *
     * @returns A promise that will resolve to true if the tile should be discarded.
     */
    NeverTileDiscardPolicy.prototype.shouldDiscardImage = function(image) {
        return false;
    };

    return NeverTileDiscardPolicy;
});
/*global define*/
define('Scene/OrthographicFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Scene/CullingVolume'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Matrix4,
        CullingVolume) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias OrthographicFrustum
     * @constructor
     *
     * @example
     * var maxRadii = ellipsoid.getMaximumRadius();
     *
     * var frustum = new OrthographicFrustum();
     * frustum.right = maxRadii * CesiumMath.PI;
     * frustum.left = -c.frustum.right;
     * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
     * frustum.bottom = -c.frustum.top;
     * frustum.near = 0.01 * maxRadii;
     * frustum.far = 50.0 * maxRadii;
     */
    var OrthographicFrustum = function() {
        /**
         * The left clipping plane.
         * @type {Number}
         */
        this.left = undefined;
        this._left = undefined;

        /**
         * The right clipping plane.
         * @type {Number}
         */
        this.right = undefined;
        this._right = undefined;

        /**
         * The top clipping plane.
         * @type {Number}
         */
        this.top = undefined;
        this._top = undefined;

        /**
         * The bottom clipping plane.
         * @type {Number}
         */
        this.bottom = undefined;
        this._bottom = undefined;

        /**
         * The distance of the near plane.
         * @type {Number}
         */
        this.near = 1.0;
        this._near = this.near;

        /**
         * The distance of the far plane.
         * @type {Number}
         */
        this.far = 500000000.0;
        this._far = this.far;

        this._cullingVolume = new CullingVolume();
        this._orthographicMatrix = undefined;
    };

    /**
     * Returns the orthographic projection matrix computed from the view frustum.
     *
     * @memberof OrthographicFrustum
     *
     * @return {Matrix4} The orthographic projection matrix.
     */
    OrthographicFrustum.prototype.getProjectionMatrix = function() {
        update(this);
        return this._orthographicMatrix;
    };

    function update(frustum) {
        if (typeof frustum.right === 'undefined' || typeof frustum.left === 'undefined' ||
                typeof frustum.top === 'undefined' || typeof frustum.bottom === 'undefined' ||
                typeof frustum.near === 'undefined' || typeof frustum.far === 'undefined') {
            throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
        }

        if (frustum.top !== frustum._top || frustum.bottom !== frustum._bottom ||
                frustum.left !== frustum._left || frustum.right !== frustum._right ||
                frustum.near !== frustum._near || frustum.far !== frustum._far) {

            if (frustum.left > frustum.right) {
                throw new DeveloperError('right must be greater than left.');
            }

            if (frustum.bottom > frustum.top) {
                throw new DeveloperError('top must be greater than bottom.');
            }

            if (frustum.near <= 0 || frustum.near > frustum.far) {
                throw new DeveloperError('near must be greater than zero and less than far.');
            }

            frustum._left = frustum.left;
            frustum._right = frustum.right;
            frustum._top = frustum.top;
            frustum._bottom = frustum.bottom;
            frustum._near = frustum.near;
            frustum._far = frustum.far;
            frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(frustum.left, frustum.right, frustum.bottom, frustum.top, frustum.near, frustum.far);
        }
    }

    var getPlanesRight = new Cartesian3();
    var getPlanesNearCenter = new Cartesian3();
    var getPlanesPoint = new Cartesian3();
    /**
     * Creates a culling volume for this frustum.
     *
     * @memberof OrthographicFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     *
     * @return {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the frustum.
     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * var intersect = cullingVolume.getVisibility(boundingVolume);
     */
    OrthographicFrustum.prototype.computeCullingVolume = function(position, direction, up) {
        if (typeof position === 'undefined') {
            throw new DeveloperError('position is required.');
        }

        if (typeof direction === 'undefined') {
            throw new DeveloperError('direction is required.');
        }

        if (typeof up === 'undefined') {
            throw new DeveloperError('up is required.');
        }

        var planes = this._cullingVolume.planes;

        var t = this.top;
        var b = this.bottom;
        var r = this.right;
        var l = this.left;
        var n = this.near;
        var f = this.far;

        var right = Cartesian3.cross(direction, up, getPlanesRight);

        var nearCenter = getPlanesNearCenter;
        Cartesian3.multiplyByScalar(direction, n, nearCenter);
        Cartesian3.add(position, nearCenter, nearCenter);

        var point = getPlanesPoint;

        // Left plane
        Cartesian3.multiplyByScalar(right, l, point);
        Cartesian3.add(nearCenter, point, point);

        var plane = planes[0];
        if (typeof plane === 'undefined') {
            plane = planes[0] = new Cartesian4();
        }
        plane.x = right.x;
        plane.y = right.y;
        plane.z = right.z;
        plane.w = -Cartesian3.dot(right, point);

        // Right plane
        Cartesian3.multiplyByScalar(right, r, point);
        Cartesian3.add(nearCenter, point, point);

        plane = planes[1];
        if (typeof plane === 'undefined') {
            plane = planes[1] = new Cartesian4();
        }
        plane.x = -right.x;
        plane.y = -right.y;
        plane.z = -right.z;
        plane.w = -Cartesian3.dot(right.negate(), point);

        // Bottom plane
        Cartesian3.multiplyByScalar(up, b, point);
        Cartesian3.add(nearCenter, point, point);

        plane = planes[2];
        if (typeof plane === 'undefined') {
            plane = planes[2] = new Cartesian4();
        }
        plane.x = up.x;
        plane.y = up.y;
        plane.z = up.z;
        plane.w = -Cartesian3.dot(up, point);

        // Top plane
        Cartesian3.multiplyByScalar(up, t, point);
        Cartesian3.add(nearCenter, point, point);

        plane = planes[3];
        if (typeof plane === 'undefined') {
            plane = planes[3] = new Cartesian4();
        }
        plane.x = -up.x;
        plane.y = -up.y;
        plane.z = -up.z;
        plane.w = -Cartesian3.dot(up.negate(), point);

        // Near plane
        plane = planes[4];
        if (typeof plane === 'undefined') {
            plane = planes[4] = new Cartesian4();
        }
        plane.x = direction.x;
        plane.y = direction.y;
        plane.z = direction.z;
        plane.w = -Cartesian3.dot(direction, nearCenter);

        // Far plane
        Cartesian3.multiplyByScalar(direction, f, point);
        Cartesian3.add(position, point, point);

        plane = planes[5];
        if (typeof plane === 'undefined') {
            plane = planes[5] = new Cartesian4();
        }
        plane.x = -direction.x;
        plane.y = -direction.y;
        plane.z = -direction.z;
        plane.w = -Cartesian3.dot(direction.negate(), point);

        return this._cullingVolume;
    };

    /**
     * Returns the pixel's width and height in meters.
     *
     * @memberof OrthographicFrustum
     *
     * @param {Cartesian2} canvasDimensions A {@link Cartesian2} with width and height in the x and y properties, respectively.
     *
     * @exception {DeveloperError} canvasDimensions is required.
     * @exception {DeveloperError} canvasDimensions.x must be greater than zero.
     * @exception {DeveloperError} canvasDimensione.y must be greater than zero.
     *
     * @returns {Cartesian2} A {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * var pixelSize = camera.frustum.getPixelSize(new Cartesian2(canvas.clientWidth, canvas.clientHeight));
     */
    OrthographicFrustum.prototype.getPixelSize = function(canvasDimensions) {
        update(this);

        if (typeof canvasDimensions === 'undefined') {
            throw new DeveloperError('canvasDimensions is required.');
        }

        var width = canvasDimensions.x;
        var height = canvasDimensions.y;

        if (width <= 0) {
            throw new DeveloperError('canvasDimensions.x must be grater than zero.');
        }

        if (height <= 0) {
            throw new DeveloperError('canvasDimensions.y must be grater than zero.');
        }

        var frustumWidth = this.right - this.left;
        var frustumHeight = this.top - this.bottom;
        var pixelWidth = frustumWidth / width;
        var pixelHeight = frustumHeight / height;

        return new Cartesian2(pixelWidth, pixelHeight);
    };

    /**
     * Returns a duplicate of a OrthographicFrustum instance.
     *
     * @memberof OrthographicFrustum
     *
     * @return {OrthographicFrustum} A new copy of the OrthographicFrustum instance.
     */
    OrthographicFrustum.prototype.clone = function() {
        var frustum = new OrthographicFrustum();
        frustum.left = this.left;
        frustum.right = this.right;
        frustum.top = this.top;
        frustum.bottom = this.bottom;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * Compares the provided OrthographicFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @memberof OrthographicFrustum
     *
     * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    OrthographicFrustum.prototype.equals = function(other) {
        return (typeof other !== 'undefined' &&
                this.right === other.right &&
                this.left === other.left &&
                this.top === other.top &&
                this.bottom === other.bottom &&
                this.near === other.near &&
                this.far === other.far);
    };

    return OrthographicFrustum;
});
/*global define*/
define('Scene/PerspectiveOffCenterFrustum',[
        '../Core/DeveloperError',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Scene/CullingVolume'
    ], function(
        DeveloperError,
        defaultValue,
        destroyObject,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Matrix4,
        CullingVolume) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias PerspectiveOffCenterFrustum
     * @constructor
     *
     * @see PerspectiveFrustum
     *
     * @example
     * var frustum = new PerspectiveOffCenterFrustum();
     * frustum.right = 1.0;
     * frustum.left = -1.0;
     * frustum.top = 1.0;
     * frustum.bottom = -1.0;
     * frustum.near = 1.0;
     * frustum.far = 2.0;
     */
    var PerspectiveOffCenterFrustum = function() {
        /**
         * Defines the left clipping plane.
         * @type {Number}
         */
        this.left = undefined;
        this._left = undefined;

        /**
         * Defines the right clipping plane.
         * @type {Number}
         */
        this.right = undefined;
        this._right = undefined;

        /**
         * Defines the top clipping plane.
         * @type {Number}
         */
        this.top = undefined;
        this._top = undefined;

        /**
         * Defines the bottom clipping plane.
         * @type {Number}
         */
        this.bottom = undefined;
        this._bottom = undefined;

        /**
         * The distance of the near plane.
         * @type {Number}
         */
        this.near = 1.0;
        this._near = this.near;

        /**
         * The distance of the far plane.
         * @type {Number}
         */
        this.far = 500000000.0;
        this._far = this.far;

        this._cullingVolume = new CullingVolume();
        this._perspectiveMatrix = undefined;
        this._infinitePerspective = undefined;
    };

    /**
     * Returns the perspective projection matrix computed from the view frustum.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @return {Matrix4} The perspective projection matrix.
     *
     * @see PerspectiveOffCenterFrustum#getInfiniteProjectionMatrix
     */
    PerspectiveOffCenterFrustum.prototype.getProjectionMatrix = function() {
        update(this);
        return this._perspectiveMatrix;
    };

    /**
     * Returns the perspective projection matrix computed from the view frustum with an infinite far plane.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @return {Matrix4} The infinite perspective projection matrix.
     *
     * @see PerspectiveOffCenterFrustum#getProjectionMatrix
     */
    PerspectiveOffCenterFrustum.prototype.getInfiniteProjectionMatrix = function() {
        update(this);
        return this._infinitePerspective;
    };

    function update(frustum) {
        if (typeof frustum.right === 'undefined' || typeof frustum.left === 'undefined' ||
                typeof frustum.top === 'undefined' || typeof frustum.bottom === 'undefined' ||
                typeof frustum.near ===' undefined' || typeof frustum.far === 'undefined') {
            throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
        }

        var t = frustum.top;
        var b = frustum.bottom;
        var r = frustum.right;
        var l = frustum.left;
        var n = frustum.near;
        var f = frustum.far;

        if (t !== frustum._top || b !== frustum._bottom ||
            l !== frustum._left || r !== frustum._right ||
            n !== frustum._near || f !== frustum._far) {

            if (frustum.near <= 0 || frustum.near > frustum.far) {
                throw new DeveloperError('near must be greater than zero and less than far.');
            }

            frustum._left = l;
            frustum._right = r;
            frustum._top = t;
            frustum._bottom = b;
            frustum._near = n;
            frustum._far = f;
            frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f);
            frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n);
        }
    }

    var getPlanesRight = new Cartesian3();
    var getPlanesNearCenter = new Cartesian3();
    var getPlanesFarCenter = new Cartesian3();
    var getPlanesNormal = new Cartesian3();
    /**
     * Creates a culling volume for this frustum.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     *
     * @return {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the frustum.
     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * var intersect = cullingVolume.getVisibility(boundingVolume);
     */
    PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {
        if (typeof position === 'undefined') {
            throw new DeveloperError('position is required.');
        }

        if (typeof direction === 'undefined') {
            throw new DeveloperError('direction is required.');
        }

        if (typeof up === 'undefined') {
            throw new DeveloperError('up is required.');
        }

        var planes = this._cullingVolume.planes;

        var t = this.top;
        var b = this.bottom;
        var r = this.right;
        var l = this.left;
        var n = this.near;
        var f = this.far;

        var right = Cartesian3.cross(direction, up, getPlanesRight);

        var nearCenter = getPlanesNearCenter;
        Cartesian3.multiplyByScalar(direction, n, nearCenter);
        Cartesian3.add(position, nearCenter, nearCenter);

        var farCenter = getPlanesFarCenter;
        Cartesian3.multiplyByScalar(direction, f, farCenter);
        Cartesian3.add(position, farCenter, farCenter);

        var normal = getPlanesNormal;

        //Left plane computation
        Cartesian3.multiplyByScalar(right, l, normal);
        Cartesian3.add(nearCenter, normal, normal);
        Cartesian3.subtract(normal, position, normal);
        Cartesian3.normalize(normal, normal);
        Cartesian3.cross(normal, up, normal);

        var plane = planes[0];
        if (typeof plane === 'undefined') {
            plane = planes[0] = new Cartesian4();
        }
        plane.x = normal.x;
        plane.y = normal.y;
        plane.z = normal.z;
        plane.w = -Cartesian3.dot(normal, position);

        //Right plane computation
        Cartesian3.multiplyByScalar(right, r, normal);
        Cartesian3.add(nearCenter, normal, normal);
        Cartesian3.subtract(normal, position, normal);
        Cartesian3.normalize(normal, normal);
        Cartesian3.cross(up, normal, normal);

        plane = planes[1];
        if (typeof plane === 'undefined') {
            plane = planes[1] = new Cartesian4();
        }
        plane.x = normal.x;
        plane.y = normal.y;
        plane.z = normal.z;
        plane.w = -Cartesian3.dot(normal, position);

        //Bottom plane computation
        Cartesian3.multiplyByScalar(up, b, normal);
        Cartesian3.add(nearCenter, normal, normal);
        Cartesian3.subtract(normal, position, normal);
        Cartesian3.normalize(normal, normal);
        Cartesian3.cross(right, normal, normal);

        plane = planes[2];
        if (typeof plane === 'undefined') {
            plane = planes[2] = new Cartesian4();
        }
        plane.x = normal.x;
        plane.y = normal.y;
        plane.z = normal.z;
        plane.w = -Cartesian3.dot(normal, position);

        //Top plane computation
        Cartesian3.multiplyByScalar(up, t, normal);
        Cartesian3.add(nearCenter, normal, normal);
        Cartesian3.subtract(normal, position, normal);
        Cartesian3.normalize(normal, normal);
        Cartesian3.cross(normal, right, normal);

        plane = planes[3];
        if (typeof plane === 'undefined') {
            plane = planes[3] = new Cartesian4();
        }
        plane.x = normal.x;
        plane.y = normal.y;
        plane.z = normal.z;
        plane.w = -Cartesian3.dot(normal, position);

        //Near plane computation
        plane = planes[4];
        if (typeof plane === 'undefined') {
            plane = planes[4] = new Cartesian4();
        }
        plane.x = direction.x;
        plane.y = direction.y;
        plane.z = direction.z;
        plane.w = -Cartesian3.dot(direction, nearCenter);

        //Far plane computation
        Cartesian3.negate(direction, normal);

        plane = planes[5];
        if (typeof plane === 'undefined') {
            plane = planes[5] = new Cartesian4();
        }
        plane.x = normal.x;
        plane.y = normal.y;
        plane.z = normal.z;
        plane.w = -Cartesian3.dot(normal, farCenter);

        return this._cullingVolume;
    };

    /**
     * Returns the pixel's width and height in meters.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @param {Cartesian2} canvasDimensions A {@link Cartesian2} with width and height in the x and y properties, respectively.
     * @param {Number} [distance=near plane distance] The distance to the near plane in meters.
     *
     * @exception {DeveloperError} canvasDimensions is required.
     * @exception {DeveloperError} canvasDimensions.x must be greater than zero.
     * @exception {DeveloperError} canvasDimensione.y must be greater than zero.
     *
     * @returns {Cartesian2} A {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * var pixelSize = camera.frustum.getPixelSize(new Cartesian2(canvas.clientWidth, canvas.clientHeight));
     *
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * var position = camera.position;
     * var direction = camera.direction;
     * var toCenter = primitive.boundingVolume.center.subtract(position);      // vector from camera to a primitive
     * var toCenterProj = direction.multiplyByScalar(direction.dot(toCenter)); // project vector onto camera direction vector
     * var distance = toCenterProj.magnitude();
     * var pixelSize = camera.frustum.getPixelSize(new Cartesian2(canvas.clientWidth, canvas.clientHeight), distance);
     */
    PerspectiveOffCenterFrustum.prototype.getPixelSize = function(canvasDimensions, distance) {
        update(this);

        if (typeof canvasDimensions === 'undefined') {
            throw new DeveloperError('canvasDimensions is required.');
        }

        var width = canvasDimensions.x;
        var height = canvasDimensions.y;

        if (width <= 0) {
            throw new DeveloperError('canvasDimensions.x must be grater than zero.');
        }

        if (height <= 0) {
            throw new DeveloperError('canvasDimensions.y must be grater than zero.');
        }

        distance = defaultValue(distance, this.near);

        var inverseNear = 1.0 / this.near;
        var tanTheta = this.top * inverseNear;
        var pixelHeight = 2.0 * distance * tanTheta / height;
        tanTheta = this.right * inverseNear;
        var pixelWidth = 2.0 * distance * tanTheta / width;

        return new Cartesian2(pixelWidth, pixelHeight);
    };

    /**
     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @return {PerspectiveOffCenterFrustum} A new copy of the PerspectiveOffCenterFrustum instance.
     */
    PerspectiveOffCenterFrustum.prototype.clone = function() {
        var frustum = new PerspectiveOffCenterFrustum();
        frustum.right = this.right;
        frustum.left = this.left;
        frustum.top = this.top;
        frustum.bottom = this.bottom;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @memberof PerspectiveOffCenterFrustum
     *
     * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    PerspectiveOffCenterFrustum.prototype.equals = function(other) {
        return (typeof other !== 'undefined' &&
                this.right === other.right &&
                this.left === other.left &&
                this.top === other.top &&
                this.bottom === other.bottom &&
                this.near === other.near &&
                this.far === other.far);
    };

    return PerspectiveOffCenterFrustum;
});
/*global define*/
define('Scene/PerspectiveFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Scene/PerspectiveOffCenterFrustum'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4,
        PerspectiveOffCenterFrustum) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias PerspectiveFrustum
     * @constructor
     *
     * @see PerspectiveOffCenterFrustum
     *
     * @example
     * var frustum = new PerspectiveFrustum();
     * frustum.fovy = CesiumMath.PI_OVER_THREE;
     * frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
     * frustum.near = 1.0;
     * frustum.far = 2.0;
     */
    var PerspectiveFrustum = function() {
        this._offCenterFrustum = new PerspectiveOffCenterFrustum();

        /**
         * The angle of the field of view, in radians.
         * @type {Number}
         */
        this.fovy = undefined;
        this._fovy = undefined;

        /**
         * The aspect ratio of the frustum's width to it's height.
         * @type {Number}
         */
        this.aspectRatio = undefined;
        this._aspectRatio = undefined;

        /**
         * The distance of the near plane.
         * @type {Number}
         */
        this.near = 1.0;
        this._near = this.near;

        /**
         * The distance of the far plane.
         * @type {Number}
         */
        this.far = 500000000.0;
        this._far = this.far;
    };

    /**
     * Returns the perspective projection matrix computed from the view frustum.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {Matrix4} The perspective projection matrix.
     *
     * @see PerspectiveFrustum#getInfiniteProjectionMatrix
     */
    PerspectiveFrustum.prototype.getProjectionMatrix = function() {
        update(this);
        return this._offCenterFrustum.getProjectionMatrix();
    };

    /**
     * Returns the perspective projection matrix computed from the view frustum with an infinite far plane.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {Matrix4} The infinite perspective projection matrix.
     *
     * @see PerspectiveFrustum#getProjectionMatrix
     */
    PerspectiveFrustum.prototype.getInfiniteProjectionMatrix = function() {
        update(this);
        return this._offCenterFrustum.getInfiniteProjectionMatrix();
    };

    function update(frustum) {
        if (typeof frustum.fovy === 'undefined' || typeof frustum.aspectRatio === 'undefined' ||
                typeof frustum.near === 'undefined' || typeof frustum.far === 'undefined') {
            throw new DeveloperError('fovy, aspectRatio, near, or far parameters are not set.');
        }

        var f = frustum._offCenterFrustum;

        if (frustum.fovy !== frustum._fovy || frustum.aspectRatio !== frustum._aspectRatio ||
                frustum.near !== frustum._near || frustum.far !== frustum._far) {
            if (frustum.fovy < 0 || frustum.fovy >= Math.PI) {
                throw new DeveloperError('fovy must be in the range [0, PI).');
            }

            if (frustum.aspectRatio < 0) {
                throw new DeveloperError('aspectRatio must be positive.');
            }

            if (frustum.near < 0 || frustum.near > frustum.far) {
                throw new DeveloperError('near must be greater than zero and less than far.');
            }

            frustum._fovy = frustum.fovy;
            frustum._aspectRatio = frustum.aspectRatio;
            frustum._near = frustum.near;
            frustum._far = frustum.far;

            f.top = frustum.near * Math.tan(0.5 * frustum.fovy);
            f.bottom = -f.top;
            f.right = frustum.aspectRatio * f.top;
            f.left = -f.right;
            f.near = frustum.near;
            f.far = frustum.far;
        }
    }

    /**
     * Creates a culling volume for this frustum.
     *
     * @memberof PerspectiveFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     *
     * @return {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the frustum.
     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * var intersect = cullingVolume.getVisibility(boundingVolume);
     */
    PerspectiveFrustum.prototype.computeCullingVolume = function(position, direction, up) {
        update(this);
        return this._offCenterFrustum.computeCullingVolume(position, direction, up);
    };

    /**
     * Returns the pixel's width and height in meters.
     *
     * @memberof PerspectiveFrustum
     *
     * @param {Cartesian2} canvasDimensions A {@link Cartesian2} with width and height in the x and y properties, respectively.
     * @param {Number} [distance=near plane distance] The distance to the near plane in meters.
     *
     * @exception {DeveloperError} canvasDimensions is required.
     * @exception {DeveloperError} canvasDimensions.x must be greater than zero.
     * @exception {DeveloperError} canvasDimensione.y must be greater than zero.
     *
     * @returns {Cartesian2} A {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * var pixelSize = camera.frustum.getPixelSize({
     *     width : canvas.clientWidth,
     *     height : canvas.clientHeight
     * });
     *
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * var position = camera.position;
     * var direction = camera.direction;
     * var toCenter = primitive.boundingVolume.center.subtract(position);      // vector from camera to a primitive
     * var toCenterProj = direction.multiplyByScalar(direction.dot(toCenter)); // project vector onto camera direction vector
     * var distance = toCenterProj.magnitude();
     * var pixelSize = camera.frustum.getPixelSize({
     *     width : canvas.clientWidth,
     *     height : canvas.clientHeight
     * }, distance);
     */
    PerspectiveFrustum.prototype.getPixelSize = function(canvasDimensions, distance) {
        update(this);
        return this._offCenterFrustum.getPixelSize(canvasDimensions, distance);
    };

    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {PerspectiveFrustum} A new copy of the PerspectiveFrustum instance.
     */
    PerspectiveFrustum.prototype.clone = function() {
        var frustum = new PerspectiveFrustum();
        frustum.fovy = this.fovy;
        frustum.aspectRatio = this.aspectRatio;
        frustum.near = this.near;
        frustum.far = this.far;
        frustum._offCenterFrustum = this._offCenterFrustum.clone();
        return frustum;
    };

    /**
     * Compares the provided PerspectiveFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @memberof PerspectiveFrustum
     *
     * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    PerspectiveFrustum.prototype.equals = function(other) {
        if (typeof other === 'undefined') {
            return false;
        }

        update(this);
        update(other);

        return (this.fovy === other.fovy &&
                this.aspectRatio === other.aspectRatio &&
                this.near === other.near &&
                this.far === other.far &&
                this._offCenterFrustum.equals(other._offCenterFrustum));
    };

    return PerspectiveFrustum;
});
/*global define*/
define('Scene/Polyline',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/BoundingSphere',
        '../Core/Cartesian3',
        '../Core/Color',
        '../Core/PolylinePipeline'
    ], function(
        defaultValue,
        DeveloperError,
        destroyObject,
        BoundingSphere,
        Cartesian3,
        Color,
        PolylinePipeline) {
    

    var EMPTY_OBJECT = {};

    /**
     * DOC_TBA
     *
     * @alias Polyline
     * @internalConstructor
     */
    var Polyline = function(description, polylineCollection) {
        description = defaultValue(description, EMPTY_OBJECT);

        this._show = defaultValue(description.show, true);
        this._width = defaultValue(description.width, 1.0);
        this._outlineWidth = defaultValue(description.outlineWidth, 1.0);
        this._color = Color.clone(defaultValue(description.color, Color.WHITE));
        this._outlineColor = Color.clone(defaultValue(description.outlineColor, Color.WHITE));

        var positions = description.positions;
        if (typeof positions === 'undefined') {
            positions = [];
        }

        this._positions = positions;
        this._positionsLength = positions.length;
        this._actualLength = positions.length;

        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
        this._polylineCollection = polylineCollection;
        this._dirty = false;
        this._pickId = undefined;
        this._pickIdThis = description._pickIdThis;
        this._segments = undefined;
        this._boundingVolume = BoundingSphere.fromPoints(this._positions);
        this._boundingVolume2D = new BoundingSphere(); // modified in PolylineCollection
    };

    var SHOW_INDEX = Polyline.SHOW_INDEX = 0;
    var POSITION_INDEX = Polyline.POSITION_INDEX = 1;
    var COLOR_INDEX = Polyline.COLOR_INDEX = 2;
    var OUTLINE_COLOR_INDEX = Polyline.OUTLINE_COLOR_INDEX = 3;
    var WIDTH_INDEX = Polyline.WIDTH_INDEX = 4;
    var OUTLINE_WIDTH_INDEX = Polyline.OUTLINE_WIDTH_INDEX = 5;
    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX = 6;
    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES = 7;

    function makeDirty(polyline, propertyChanged) {
        ++polyline._propertiesChanged[propertyChanged];
        var polylineCollection = polyline._polylineCollection;
        if (typeof polylineCollection !== 'undefined') {
            polylineCollection._updatePolyline(polyline, propertyChanged);
            polyline._dirty = true;
        }
    }

    /**
     * Returns true if this polyline will be shown.  Call {@link Polyline#setShow}
     * to hide or show a polyline, instead of removing it and re-adding it to the collection.
     *
     * @memberof Polyline
     *
     * @return {Boolean} <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.
     *
     * @see Polyline#setShow
     */
    Polyline.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this polyline will be shown.  Call this to hide or show a polyline, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Polyline
     *
     * @param {Boolean} value Indicates if this polyline will be shown.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getShow
     */
    Polyline.prototype.setShow = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (value !== this._show) {
            this._show = value;
            makeDirty(this, SHOW_INDEX);
        }
    };

    /**
     * Returns the polyline's positions.
     *
     * @memberof Polyline
     *
     * @see Polyline#setPositions
     */
    Polyline.prototype.getPositions = function() {
        return this._positions;
    };

    /**
     * Defines the positions of the polyline.
     *
     * @memberof Polyline
     *
     * @param {Array} value The positions of the polyline.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getPositions
     *
     * @example
     * polyline.setPositions(
     *   ellipsoid.cartographicArrayToCartesianArray([
     *     new Cartographic3(...),
     *     new Cartographic3(...),
     *     new Cartographic3(...)
     *   ])
     * );
     */
    Polyline.prototype.setPositions = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._positionsLength !== value.length) {
            this._positionsLength = value.length;
            makeDirty(this, POSITION_SIZE_INDEX);
        }

        this._positions = value;
        this._boundingVolume = BoundingSphere.fromPoints(this._positions, this._boundingVolume);
        makeDirty(this, POSITION_INDEX);
    };

    /**
     * Returns the color of the polyline.
     *
     * @memberof Polyline
     *
     * @return {Color} The color of the polyline.
     *
     * @see Polyline#setColor
     */
    Polyline.prototype.getColor = function() {
        return this._color;
    };

    /**
     * Sets the color of the polyline.
     *
     * @memberof Polyline
     *
     * @param {Color} value The color of the polyline.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getColor
     */
    Polyline.prototype.setColor = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var color = this._color;
        if (!Color.equals(color, value)) {
            Color.clone(value, color);
            makeDirty(this, COLOR_INDEX);
        }
    };

    /**
     * Gets the width of the polyline.
     * The actual width used is clamped to the minimum and maximum width supported by
     * the WebGL implementation.  These can be queried with
     * {@link Context#getMinimumAliasedLineWidth} and {@link Context#getMaximumAliasedLineWidth}.
     *
     * @memberof Polyline
     *
     * @return {Number} The width of the polyline.
     *
     * @see Polyline#setWidth
     * @see Context#getMinimumAliasedLineWidth
     * @see Context#getMaximumAliasedLineWidth
     *
     * @example
     * // 3 pixel total width, 1 pixel interior width
     * polyline.width = 1.0;
     * polyline.outlineWidth = 3.0;
     */
    Polyline.prototype.getWidth = function() {
        return this._width;
    };

    /**
     * Sets the width of the polyline.
     * The actual width used is clamped to the minimum and maximum width supported by
     * the WebGL implementation.  These can be queried with
     * {@link Context#getMinimumAliasedLineWidth} and {@link Context#getMaximumAliasedLineWidth}.
     *
     * @param {Number} value The width of the polyline.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getWidth
     * @see Context#getMinimumAliasedLineWidth
     * @see Context#getMaximumAliasedLineWidth
     *
     * @example
     * // 3 pixel total width, 1 pixel interior width
     * polyline.width = 1.0;
     * polyline.outlineWidth = 3.0;
     */
    Polyline.prototype.setWidth = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var width = this._width;
        if (value !== width) {
            this._width = value;
            makeDirty(this, WIDTH_INDEX);
        }
    };


    /**
     * Gets the outline width of the polyline.
     * The actual width used is clamped to the minimum and maximum width supported by
     * the WebGL implementation.  These can be queried with
     * {@link Context#getMinimumAliasedLineWidth} and {@link Context#getMaximumAliasedLineWidth}.
     *
     * @return {Number} The outline width of the polyline.
     *
     * @see Polyline#setOutlineWidth
     * @see Context#getMinimumAliasedLineWidth
     * @see Context#getMaximumAliasedLineWidth
     *
     * @example
     * // 3 pixel total width, 1 pixel interior width
     * polyline.width = 1.0;
     * polyline.outlineWidth = 3.0;
     */
    Polyline.prototype.getOutlineWidth = function() {
        return this._outlineWidth;
    };

    /**
     * Sets the outline width of the polyline.
     * The actual width used is clamped to the minimum and maximum width supported by
     * the WebGL implementation.  These can be queried with
     * {@link Context#getMinimumAliasedLineWidth} and {@link Context#getMaximumAliasedLineWidth}.
     *
     * @param {Number} value The outline width of the polyline.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getOutlineWidth
     * @see Context#getMinimumAliasedLineWidth
     * @see Context#getMaximumAliasedLineWidth
     *
     * @example
     * // 3 pixel total width, 1 pixel interior width
     * polyline.width = 1.0;
     * polyline.outlineWidth = 3.0;
     */
    Polyline.prototype.setOutlineWidth = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var outlineWidth = this._outlineWidth;
        if (value !== outlineWidth) {
            this._outlineWidth = value;
            makeDirty(this, OUTLINE_WIDTH_INDEX);
        }
    };

    /**
     * Gets the outline color of the polyline.
     *
     * @memberof Polyline
     *
     * @return {Color} The outline color of the polyline.
     *
     * @see Polyline#setOutlineColor
     */
    Polyline.prototype.getOutlineColor = function() {
        return this._outlineColor;
    };

    /**
     * Sets the outline color of the polyline.
     *
     * @memberof Polyline
     *
     * @param {Color} value The outline color of the polyline.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Polyline#getOutlineColor
     */
    Polyline.prototype.setOutlineColor = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var outlineColor = this._outlineColor;
        if (!Color.equals(outlineColor, value)) {
            Color.clone(value, outlineColor);
            makeDirty(this, OUTLINE_COLOR_INDEX);
        }
    };

    Polyline.prototype.getPickId = function(context) {
        this._pickId = this._pickId || context.createPickId(this._pickIdThis || this);
        return this._pickId;
    };

    Polyline.prototype._clean = function() {
        this._dirty = false;
        var properties = this._propertiesChanged;
        for ( var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {
            properties[k] = 0;
        }
    };

    Polyline.prototype._getPositions2D = function() {
        var segments = this._segments;
        var positions = [];
        var numberOfSegments = segments.length;

        for ( var i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            var segmentLength = segment.length;
            for ( var n = 0; n < segmentLength; ++n) {
                positions.push(segment[n].cartesian);
            }
        }
        return positions;
    };

    Polyline.prototype._createSegments = function(ellipsoid) {
        return PolylinePipeline.wrapLongitude(ellipsoid, this.getPositions());
    };

    Polyline.prototype._setSegments = function(segments) {
        this._segments = segments;
        var numberOfSegments = segments.length;
        var length = 0;
        for ( var i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            var segmentLength = segment.length;
            length += segmentLength;
        }
        return length;
    };

    Polyline.prototype._getSegments = function() {
        return this._segments;
    };

    Polyline.prototype._segmentsLengthChanged = function(newSegments) {
        var origSegments = this._segments;
        if (typeof origSegments !== 'undefined') {
            var numberOfSegments = newSegments.length;
            if (numberOfSegments !== origSegments.length) {
                return true;
            }
            for ( var i = 0; i < numberOfSegments; ++i) {
                if (newSegments[i].length !== origSegments[i].length) {
                    return true;
                }
            }
            return false;
        }
        return true;
    };

    /**
     * Determines if this polyline equals another polyline.  Polylines are equal if all their properties
     * are equal.  Polylines in different collections can be equal.
     *
     * @memberof Polyline
     *
     * @param {Polyline} other The polyline to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the polylines are equal; otherwise, <code>false</code>.
     */
    Polyline.prototype.equals = function(other) {
        return this === other ||
               typeof other !== 'undefined' &&
               this._show === other._show &&
               this._width === other._width &&
               this._outlineWidth === other._outlineWidth &&
               this._horizontalOrigin === other._horizontalOrigin &&
               cartesian3ArrayEquals(this._positions, other._positions) &&
               Color.equals(this._color, other._color) &&
               Color.equals(this._outlineColor, other._outlineColor);
    };

    function cartesian3ArrayEquals(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for ( var i = 0, len = a.length; i < len; ++i) {
            if (!Cartesian3.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }

    Polyline.prototype._destroy = function() {
        this._pickId = this._pickId && this._pickId.destroy();
        this._polylineCollection = undefined;
    };

    return Polyline;
});

/*global define*/
define('Scene/Projections',[
        '../Core/DeveloperError',
        '../Core/Enumeration'
    ], function(
        DeveloperError,
        Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports Projections
     */
    var Projections = {
        WGS84 : new Enumeration(0, 'WGS84', {
            toWgs84 : function(extent, image) {
                return image;
            }
        }),
        MERCATOR : new Enumeration(1, 'MERCATOR', {
            toWgs84 : function(extent, image) {
                if (!extent || typeof extent.north === 'undefined' || typeof extent.south === 'undefined') {
                    throw new DeveloperError('extent, extent.north and extent.south are required.');
                }

                if (!image) {
                    throw new DeveloperError('image is required.');
                }

                var width = parseInt(image.width, 10);
                var height = parseInt(image.height, 10);
                var wRowBytes = width * 4; // Always 4 bytes per pixel.

                // draw image to canvas and get the pixels
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);
                var fromPixels = context.getImageData(0, 0, width, height).data;

                // create array of pixels
                var newImageData = context.createImageData(width, height);
                var toPixels = newImageData.data;

                // WGS84 parameters
                var deltaWLat = (extent.north - extent.south) / height;
                var currentWLat = extent.north - (0.5 * deltaWLat);

                // mercator parameters
                var sinTheta = Math.sin(extent.south);
                var minMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                sinTheta = Math.sin(extent.north);
                var maxMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                var invMLatDim = 1.0 / (maxMLat - minMLat);

                // first row
                var heightMinusOne = height - 1;
                var i = 0;
                for (; i < wRowBytes; ++i) {
                    toPixels[i] = fromPixels[i];
                }

                // interior rows
                var end, mLat, mRow;
                var j = 1;
                for (; j < heightMinusOne; ++j, currentWLat -= deltaWLat) {
                    sinTheta = Math.sin(currentWLat);
                    mLat = 0.5 * Math.log((1.0 + sinTheta) / (1.0 - sinTheta));
                    mRow = Math.floor(heightMinusOne - ((heightMinusOne * (mLat - minMLat) * invMLatDim)));
                    end = i + wRowBytes;
                    for ( var k = 0; i < end; ++i, ++k) {
                        toPixels[i] = fromPixels[mRow * wRowBytes + k];
                    }
                }

                // last row
                end = i + wRowBytes;
                for (j = 0; i < end; ++i, ++j) {
                    toPixels[i] = fromPixels[i];
                }

                // paint new image to canvas
                context.putImageData(newImageData, 0, 0);

                return canvas;
            }
        })
    };

    return Projections;
});
/*global define*/
define('Scene/SceneMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports SceneMode
     */
    var SceneMode = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE2D : new Enumeration(0, 'SCENE2D', {
            morphTime : 0.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COLUMBUS_VIEW : new Enumeration(1, 'COLUMBUS_VIEW', {
            morphTime : 0.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE3D : new Enumeration(2, 'SCENE3D', {
            morphTime : 1.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MORPHING : new Enumeration(3, 'MORPHING')
    };

    return SceneMode;
});
/*global define*/
define('DynamicScene/DynamicObjectView',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Ellipsoid',
        '../Core/Transforms',
        '../Scene/SceneMode'
       ], function(
         defaultValue,
         DeveloperError,
         CesiumMath,
         Cartesian2,
         Cartesian3,
         Cartesian4,
         Cartographic,
         Quaternion,
         Matrix3,
         Ellipsoid,
         Transforms,
         SceneMode) {
    

    function update2D(that, camera, objectChanged, offset, positionProperty, time, projection) {
        var viewDistance;
        var controller = that._controller2d;
        var controllerChanged = typeof controller === 'undefined' || controller !== that._lastController || controller.isDestroyed();

        //Handle case where controller was modified without our knowledge.
        if (controllerChanged) {
            var controllers = camera.getControllers();
            controllers.removeAll();
            that._lastController = that._controller2d = controller = controllers.add2D(projection);
            controller.enableTranslate = false;
            viewDistance = offset.magnitude();
        } else if (objectChanged) {
            viewDistance = offset.magnitude();
        } else {
            viewDistance = camera.position.z;
        }

        var cartographic = positionProperty.getValueCartographic(time, that._lastCartographic);
        //We are assigning the position of the camera, not of the object, so modify the height appropriately.
        cartographic.height = viewDistance;
        if (objectChanged || controllerChanged) {
            controller.setPositionCartographic(cartographic);

            //Set rotation to match offset.
            Cartesian3.normalize(offset, camera.up);
            Cartesian3.negate(camera.up, camera.up);
            Cartesian3.cross(camera.direction, camera.up, camera.right);

            //z is always zero in 2D for up and right
            camera.up.z = 0;
            Cartesian3.normalize(camera.up, camera.up);
            camera.right.z = 0;
            Cartesian3.normalize(camera.right, camera.right);

            //Remember what up was when we started, so we
            //can detect rotation when we are finished.
            Cartesian2.clone(camera.right, that._first2dUp);
        } else {
            camera.position = projection.project(cartographic);
        }

        //Store last view distance and up vector.
        that._lastDistance = camera.frustum.right - camera.frustum.left;
        Cartesian2.clone(camera.right, that._last2dUp);
    }

    var update3DTransform;
    function update3D(that, camera, objectChanged, offset, positionProperty, time, ellipsoid) {
        var controller = update3DController(that, camera, objectChanged, offset);

        var cartesian = positionProperty.getValueCartesian(time, that._lastCartesian);
        update3DTransform = Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, update3DTransform);
        controller.setReferenceFrame(update3DTransform, Ellipsoid.UNIT_SPHERE);

        var position = camera.position;
        Cartesian3.clone(position, that._lastOffset);
        that._lastDistance = Cartesian3.magnitude(position);
    }

    var updateColumbusCartesian4 = new Cartesian4(0.0, 0.0, 0.0, 1.0);
    function updateColumbus(that, camera, objectChanged, offset, positionProperty, time, ellipsoid, projection) {
        var controller = update3DController(that, camera, objectChanged, offset);

        //The swizzling here is intentional because ColumbusView uses a different coordinate system.
        var cartographic = positionProperty.getValueCartographic(time, that._lastCartographic);
        var projectedPosition = projection.project(cartographic);
        updateColumbusCartesian4.x = projectedPosition.z;
        updateColumbusCartesian4.y = projectedPosition.x;
        updateColumbusCartesian4.z = projectedPosition.y;

        var tranform = camera.transform;
        tranform.setColumn(3, updateColumbusCartesian4, tranform);
        controller.setReferenceFrame(tranform, Ellipsoid.UNIT_SPHERE);

        var position = camera.position;
        Cartesian3.clone(position, that._lastOffset);
        that._lastDistance = Cartesian3.magnitude(position);
    }

    var update3DControllerQuaternion = new Quaternion();
    var update3DControllerMatrix3 = new Matrix3();

    function update3DController(that, camera, objectChanged, offset) {
        var controller = that._controller3d;
        var controllerChanged = typeof controller === 'undefined' || controller !== that._lastController || controller.isDestroyed();

        if (controllerChanged) {
            var controllers = camera.getControllers();
            controllers.removeAll();
            that._lastController = that._controller3d = controller = controllers.addSpindle();
            controller.constrainedAxis = Cartesian3.UNIT_Z;
        }

        if (objectChanged) {
            camera.lookAt(offset, Cartesian3.ZERO, Cartesian3.UNIT_Z);
        } else if (controllerChanged) {
            //If we're switching from 2D and any rotation was applied to the camera,
            //apply that same rotation to the last offset used in 3D or Columbus view.
            var first2dUp = that._first2dUp;
            var last2dUp = that._last2dUp;
            if (!Cartesian2.equals(first2dUp, last2dUp)) {
                var startTheta = Math.acos(first2dUp.x);
                if (first2dUp.y < 0) {
                    startTheta = CesiumMath.TWO_PI - startTheta;
                }
                var endTheta = Math.acos(last2dUp.x);
                if (last2dUp.y < 0) {
                    endTheta = CesiumMath.TWO_PI - endTheta;
                }
                last2dUp.x = 0.0;
                last2dUp.y = 0.0;
                first2dUp.x = 0.0;
                first2dUp.y = 0.0;

                var theta = startTheta - endTheta;
                var rotation = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, theta, update3DControllerQuaternion);
                Matrix3.fromQuaternion(rotation, update3DControllerMatrix3).multiplyByVector(offset, offset);
            }
            offset.normalize(offset).multiplyByScalar(that._lastDistance, offset);
            camera.lookAt(offset, Cartesian3.ZERO, Cartesian3.UNIT_Z);
        }

        return controller;
    }

    var dynamicObjectViewDefaultOffset = new Cartesian3(10000, -10000, 10000);
    var dynamicObjectViewCartesian3Scratch = new Cartesian3();

    /**
     * A utility object for tracking an object with the camera.
     * @alias DynamicObject
     * @constructor
     *
     * @param {DynamicObject} dynamicObject The object to track with the camera.
     * @param {Scene} scene The scene to use.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use for orienting the camera.
     */
    var DynamicObjectView = function(dynamicObject, scene, ellipsoid) {
        /**
         * The object to track with the camera.
         * @type DynamicObject
         */
        this.dynamicObject = dynamicObject;

        /**
         * The scene in which to track the object.
         * @type Scene
         */
        this.scene = scene;

        /**
         * The ellipsoid to use for orienting the camera.
         * @type Ellipsoid
         */
        this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

        //Shadow copies of the objects so we can detect changes.
        this._lastScene = undefined;
        this._lastDynamicObject = undefined;

        //Currently camera controllers are very transient,
        //We maintain a reference to each one we create as
        //well as the last one we used in order to detect
        //when we need to re-initialize the view.
        this._lastController = undefined;
        this._controller2d = undefined;
        this._controller3d = undefined;

        //Re-usable objects to be used for retrieving position.
        this._lastCartesian = new Cartesian3();
        this._lastCartographic = new Cartographic();

        //Current distance of dynamicObject from camera so we can maintain view distance across scene modes.
        this._lastDistance = undefined;

        //Last viewing offset in 3D/Columbus view, this way we can restore to a sensible view across scene modes.
        this._lastOffset = new Cartesian3();

        //Scratch value for calculating offsets
        this._offsetScratch = new Cartesian3();

        //Tracks camera up so that we can detect 2D camera rotation and modify the 3D/Columbus view to match when switching modes.
        this._first2dUp = new Cartesian2();
        this._last2dUp = new Cartesian2();
    };

    /**
    * Should be called each animation frame to update the camera
    * to the latest settings.
    * @param {JulianDate} time The current animation time.
    *
    * @exception {DeveloperError} time is required.
    * @exception {DeveloperError} DynamicObjectView.scene is required.
    * @exception {DeveloperError} DynamicObjectView.dynamicObject is required.
    * @exception {DeveloperError} DynamicObjectView.ellipsoid is required.
    * @exception {DeveloperError} DynamicObjectView.dynamicObject.position is required.
    */
    DynamicObjectView.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        var scene = this.scene;
        if (typeof scene === 'undefined') {
            throw new DeveloperError('DynamicObjectView.scene is required.');
        }

        var dynamicObject = this.dynamicObject;
        if (typeof dynamicObject === 'undefined') {
            throw new DeveloperError('DynamicObjectView.dynamicObject is required.');
        }

        var ellipsoid = this.ellipsoid;
        if (typeof ellipsoid === 'undefined') {
            throw new DeveloperError('DynamicObjectView.ellipsoid is required.');
        }

        var positionProperty = this.dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            throw new DeveloperError('dynamicObject.position is required.');
        }

        var objectChanged = dynamicObject !== this._lastDynamicObject;

        //Determine what the current camera offset should be, this is used
        //to either set the default view when a new object is selected or
        //maintain a similar view when changing scene modes.
        var offset = this._offsetScratch;
        if (objectChanged) {
            this._lastDynamicObject = dynamicObject;

            var viewFromProperty = this.dynamicObject.viewFrom;
            if (typeof viewFromProperty === 'undefined' || typeof viewFromProperty.getValue(time, offset) === 'undefined') {
                Cartesian3.clone(dynamicObjectViewDefaultOffset, offset);
            }

            //Reset object-based cached values.
            var first2dUp = this._first2dUp;
            var last2dUp = this._last2dUp;
            first2dUp.x = first2dUp.y = 0;
            last2dUp.x = last2dUp.y = 0;
            Cartesian3.clone(offset, this._lastOffset);
            this._lastDistance = offset.magnitude();

            //If looking straight down, move the camera slightly south the avoid gimbal lock.
            if (Cartesian3.equals(offset.normalize(dynamicObjectViewCartesian3Scratch), Cartesian3.UNIT_Z)) {
                offset.y -= 0.01;
            }
        } else if (typeof this._lastOffset !== 'undefined') {
            offset = this._lastOffset;
        } else {
            Cartesian3.clone(dynamicObjectViewDefaultOffset, offset);
        }

        var sceneChanged = scene !== this._lastScene;
        if (sceneChanged) {
            //When the scene changes, we'll need to retrieve new controllers, so just wipe out our cached values.
            this._lastController = undefined;
            this._controller2d = undefined;
            this._controller3d = undefined;
            this._lastScene = scene;
        }

        var mode = scene.mode;
        if (mode === SceneMode.SCENE2D) {
            update2D(this, this.scene.getCamera(), objectChanged, offset, positionProperty, time, scene.scene2D.projection);
        } else if (mode === SceneMode.SCENE3D) {
            update3D(this, this.scene.getCamera(), objectChanged, offset, positionProperty, time, ellipsoid);
        } else if (mode === SceneMode.COLUMBUS_VIEW) {
            updateColumbus(this, this.scene.getCamera(), objectChanged, offset, positionProperty, time, ellipsoid, scene.scene2D.projection);
        }
    };

    return DynamicObjectView;
});
/*global define*/
define('Renderer/UniformState',[
        '../Core/DeveloperError',
        '../Core/defaultValue',
        '../Core/Ellipsoid',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/EncodedCartesian3',
        '../Core/BoundingRectangle',
        '../Core/Transforms',
        '../Core/computeSunPosition',
        '../Scene/SceneMode'
    ], function(
        DeveloperError,
        defaultValue,
        Ellipsoid,
        Matrix3,
        Matrix4,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        EncodedCartesian3,
        BoundingRectangle,
        Transforms,
        computeSunPosition,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @alias UniformState
     *
     * @internalConstructor
     */
    var UniformState = function() {
        this._viewport = new BoundingRectangle();
        this._viewportDirty = false;
        this._viewportOrthographicMatrix = Matrix4.IDENTITY.clone();
        this._viewportTransformation = Matrix4.IDENTITY.clone();

        this._model = Matrix4.IDENTITY.clone();
        this._view = Matrix4.IDENTITY.clone();
        this._inverseView = Matrix4.IDENTITY.clone();
        this._projection = Matrix4.IDENTITY.clone();
        this._infiniteProjection = Matrix4.IDENTITY.clone();
        this._entireFrustum = new Cartesian2();

        this._frameNumber = 1.0;
        this._time = undefined;
        this._temeToPseudoFixed = Matrix3.IDENTITY.clone();

        // Derived members
        this._inverseModelDirty = true;
        this._inverseModel = new Matrix4();

        this._viewRotation = new Matrix3();
        this._inverseViewRotation = new Matrix3();

        this._inverseProjectionDirty = true;
        this._inverseProjection = new Matrix4();

        this._modelViewDirty = true;
        this._modelView = new Matrix4();

        this._modelViewRelativeToEyeDirty = true;
        this._modelViewRelativeToEye = new Matrix4();

        this._inverseModelViewDirty = true;
        this._inverseModelView = new Matrix4();

        this._viewProjectionDirty = true;
        this._viewProjection = new Matrix4();

        this._modelViewProjectionDirty = true;
        this._modelViewProjection = new Matrix4();

        this._modelViewProjectionRelativeToEyeDirty = true;
        this._modelViewProjectionRelativeToEye = new Matrix4();

        this._modelViewInfiniteProjectionDirty = true;
        this._modelViewInfiniteProjection = new Matrix4();

        this._normalDirty = true;
        this._normal = new Matrix3();

        this._inverseNormalDirty = true;
        this._inverseNormal = new Matrix3();

        this._encodedCameraPositionMCDirty = true;
        this._encodedCameraPositionMC = new EncodedCartesian3();
        this._cameraPosition = new Cartesian3();

        this._sunDirectionWC = new Cartesian3();
        this._sunDirectionEC = new Cartesian3();
        this._moonDirectionEC = new Cartesian3();
    };

    function setView(uniformState, matrix) {
        Matrix4.clone(matrix, uniformState._view);
        Matrix4.getRotation(matrix, uniformState._viewRotation);

        uniformState._modelViewDirty = true;
        uniformState._modelViewRelativeToEyeDirty = true;
        uniformState._inverseModelViewDirty = true;
        uniformState._viewProjectionDirty = true;
        uniformState._modelViewProjectionDirty = true;
        uniformState._modelViewProjectionRelativeToEyeDirty = true;
        uniformState._modelViewInfiniteProjectionDirty = true;
        uniformState._normalDirty = true;
        uniformState._inverseNormalDirty = true;
    }

    function setInverseView(uniformState, matrix) {
        Matrix4.clone(matrix, uniformState._inverseView);
        Matrix4.getRotation(matrix, uniformState._inverseViewRotation);
    }

    function setProjection(uniformState, matrix) {
        Matrix4.clone(matrix, uniformState._projection);

        uniformState._inverseProjectionDirty = true;
        uniformState._viewProjectionDirty = true;
        uniformState._modelViewProjectionDirty = true;
        uniformState._modelViewProjectionRelativeToEyeDirty = true;
    }

    function setInfiniteProjection(uniformState, matrix) {
        Matrix4.clone(matrix, uniformState._infiniteProjection);

        uniformState._modelViewInfiniteProjectionDirty = true;
    }

    function setCameraPosition(uniformState, position) {
        Cartesian3.clone(position, uniformState._cameraPosition);
        uniformState._encodedCameraPositionMCDirty = true;
    }

    var sunPositionWC = new Cartesian3();
    var sunPositionScratch = new Cartesian3();

    function setSunAndMoonDirections(uniformState, frameState) {
        if (frameState.mode === SceneMode.SCENE3D) {
            computeSunPosition(frameState.time, sunPositionWC);

            Cartesian3.normalize(sunPositionWC, uniformState._sunDirectionWC);
            Matrix3.multiplyByVector(uniformState._viewRotation, sunPositionWC, sunPositionScratch);
            Cartesian3.normalize(sunPositionScratch, uniformState._sunDirectionEC);

            // Pseudo direction for now just for lighting
            Cartesian3.negate(uniformState._sunDirectionEC, uniformState._moonDirectionEC);
        } else {
            // Made up direction for now just for lighting

            sunPositionWC.x = 1000000.0;   // height
            sunPositionWC.y = -10000000.0; // x
            sunPositionWC.z = 0.0;         // y

            Cartesian3.normalize(sunPositionWC, uniformState._sunDirectionWC);
            Matrix3.multiplyByVector(uniformState._viewRotation, sunPositionWC, sunPositionScratch);
            Cartesian3.normalize(sunPositionScratch, uniformState._sunDirectionEC);

            sunPositionWC.x = 1000000.0;   // height
            sunPositionWC.y = 10000000.0;  // x
            sunPositionWC.z = 0.0;         // y

            Cartesian3.normalize(sunPositionWC, sunPositionScratch);
            Matrix3.multiplyByVector(uniformState._viewRotation, sunPositionScratch, sunPositionScratch);
            Cartesian3.normalize(sunPositionScratch, uniformState._moonDirectionEC);
        }
    }

    /**
     * Synchronizes the frustum's state with the uniform state.  This is called
     * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
     * are set to the right value.
     *
     * @memberof UniformState
     *
     * @param {Object} frustum The frustum to synchronize with.
     */
    UniformState.prototype.updateFrustum = function(frustum) {
        setProjection(this, frustum.getProjectionMatrix());
        if (typeof frustum.getInfiniteProjectionMatrix !== 'undefined') {
            setInfiniteProjection(this, frustum.getInfiniteProjectionMatrix());
        }
    };

    /**
     * Synchronizes frame state with the uniform state.  This is called
     * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
     * are set to the right value.
     *
     * @memberof UniformState
     *
     * @param {FrameState} frameState The frameState to synchronize with.
     */
    UniformState.prototype.update = function(frameState) {
        var camera = frameState.camera;

        setView(this, camera.getViewMatrix());
        setInverseView(this, camera.getInverseViewMatrix());
        setCameraPosition(this, camera.getPositionWC());
        setSunAndMoonDirections(this, frameState);

        this._entireFrustum.x = camera.frustum.near;
        this._entireFrustum.y = camera.frustum.far;
        this.updateFrustum(camera.frustum);

        this._frameNumber = frameState.frameNumber;
        this._time = frameState.time;
        this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(frameState.time);
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {BoundingRectangle} viewport DOC_TBA.
     *
     * @see UniformState#getViewport
     * @see czm_viewport
     */
    UniformState.prototype.setViewport = function(viewport) {
        if (!BoundingRectangle.equals(viewport, this._viewport)) {
            BoundingRectangle.clone(viewport, this._viewport);
            this._viewportDirty = true;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * return {BoundingRectangle} DOC_TBA.
     *
     * @see UniformState#setViewport
     * @see czm_viewport
     */
    UniformState.prototype.getViewport = function () {
        return this._viewport;
    };

    function cleanViewport(uniformState) {
        if (uniformState._viewportDirty) {
            var v = uniformState._viewport;
            Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0, uniformState._viewportOrthographicMatrix);
            Matrix4.computeViewportTransformation(v, 0.0, 1.0, uniformState._viewportTransformation);
            uniformState._viewportDirty = false;
        }
    }

    /**
     * DOC_TBA
     * @memberof UniformState
     *
     *
     * @see czm_viewportOrthographic
     */
    UniformState.prototype.getViewportOrthographic = function() {
        cleanViewport(this);
        return this._viewportOrthographicMatrix;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @see czm_viewportTransformation
     */
    UniformState.prototype.getViewportTransformation = function() {
        cleanViewport(this);
        return this._viewportTransformation;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getModel
     * @see czm_model
     */
    UniformState.prototype.setModel = function(matrix) {
        Matrix4.clone(matrix, this._model);

        this._inverseModelDirty = true;
        this._modelViewDirty = true;
        this._modelViewRelativeToEyeDirty = true;
        this._inverseModelViewDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewProjectionRelativeToEyeDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._encodedCameraPositionMCDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setModel
     * @see czm_model
     */
    UniformState.prototype.getModel = function() {
        return this._model;
    };

    /**
     * Returns the inverse model matrix used to define the {@link czm_inverseModel} GLSL uniform.
     *
     * @memberof UniformState
     *
     * @return {Matrix4} The inverse model matrix.
     *
     * @see UniformState#setModel
     * @see UniformState#getModel
     * @see czm_inverseModel
     */
     UniformState.prototype.getInverseModel = function() {
         if (this._inverseModelDirty) {
             this._inverseModelDirty = false;

             this._model.inverse(this._inverseModel);
         }

         return this._inverseModel;
     };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_view
     */
    UniformState.prototype.getView = function() {
        return this._view;
    };

    /**
     * Returns the 3x3 rotation matrix of the current view matrix ({@link UniformState#getView}).
     *
     * @memberof UniformState
     *
     * @return {Matrix3} The 3x3 rotation matrix of the current view matrix.
     *
     * @see UniformState#getView
     * @see czm_viewRotation
     */
    UniformState.prototype.getViewRotation = function() {
        return this._viewRotation;
    };

    /**
     * Returns the 4x4 inverse-view matrix that transforms from eye to world coordinates.
     *
     * @memberof UniformState
     *
     * @return {Matrix4} The 4x4 inverse-view matrix that transforms from eye to world coordinates.
     *
     * @see czm_inverseView
     */
    UniformState.prototype.getInverseView = function() {
        return this._inverseView;
    };

    /**
     * Returns the 3x3 rotation matrix of the current inverse-view matrix ({@link UniformState#getInverseView}).
     *
     * @memberof UniformState
     *
     * @return {Matrix3} The 3x3 rotation matrix of the current inverse-view matrix.
     *
     * @see UniformState#getInverseView
     * @see czm_inverseViewRotation
     */
    UniformState.prototype.getInverseViewRotation = function() {
        return this._inverseViewRotation;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setProjection
     * @see czm_projection
     */
    UniformState.prototype.getProjection = function() {
        return this._projection;
    };

    function cleanInverseProjection(uniformState) {
        if (uniformState._inverseProjectionDirty) {
            uniformState._inverseProjectionDirty = false;

            Matrix4.inverse(uniformState._projection, uniformState._inverseProjection);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_inverseProjection
     */
    UniformState.prototype.getInverseProjection = function() {
        cleanInverseProjection(this);
        return this._inverseProjection;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setInfiniteProjection
     * @see czm_infiniteProjection
     */
    UniformState.prototype.getInfiniteProjection = function() {
        return this._infiniteProjection;
    };

    // Derived
    function cleanModelView(uniformState) {
        if (uniformState._modelViewDirty) {
            uniformState._modelViewDirty = false;

            Matrix4.multiply(uniformState._view, uniformState._model, uniformState._modelView);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_modelView
     */
    UniformState.prototype.getModelView = function() {
        cleanModelView(this);
        return this._modelView;
    };

    function cleanModelViewRelativeToEye(uniformState) {
        if (uniformState._modelViewRelativeToEyeDirty) {
            uniformState._modelViewRelativeToEyeDirty = false;

            var mv = uniformState.getModelView();
            var mvRte = uniformState._modelViewRelativeToEye;
            mvRte[0] = mv[0];
            mvRte[1] = mv[1];
            mvRte[2] = mv[2];
            mvRte[3] = mv[3];
            mvRte[4] = mv[4];
            mvRte[5] = mv[5];
            mvRte[6] = mv[6];
            mvRte[7] = mv[7];
            mvRte[8] = mv[8];
            mvRte[9] = mv[9];
            mvRte[10] = mv[10];
            mvRte[11] = mv[11];
            mvRte[12] = 0.0;
            mvRte[13] = 0.0;
            mvRte[14] = 0.0;
            mvRte[15] = mv[15];
        }
    }

    /**
     * Returns the model-view relative to eye matrix used to define the {@link czm_modelViewRelativeToEye} GLSL uniform.
     *
     * @memberof UniformState
     *
     * @return {Matrix4} The model-view relative to eye matrix.
     *
     * @see czm_modelViewRelativeToEye
     */
    UniformState.prototype.getModelViewRelativeToEye = function() {
        cleanModelViewRelativeToEye(this);
        return this._modelViewRelativeToEye;
    };

    function cleanInverseModelView(uniformState) {
        if (uniformState._inverseModelViewDirty) {
            uniformState._inverseModelViewDirty = false;

            Matrix4.inverse(uniformState.getModelView(), uniformState._inverseModelView);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_inverseModelView
     */
    UniformState.prototype.getInverseModelView = function() {
        cleanInverseModelView(this);
        return this._inverseModelView;
    };

    function cleanViewProjection(uniformState) {
        if (uniformState._viewProjectionDirty) {
            uniformState._viewProjectionDirty = false;

            Matrix4.multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_viewProjection
     */
    UniformState.prototype.getViewProjection = function() {
        cleanViewProjection(this);
        return this._viewProjection;
    };

    function cleanModelViewProjection(uniformState) {
        if (uniformState._modelViewProjectionDirty) {
            uniformState._modelViewProjectionDirty = false;

            Matrix4.multiply(uniformState._projection, uniformState.getModelView(), uniformState._modelViewProjection);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_modelViewProjection
     */
    UniformState.prototype.getModelViewProjection = function() {
        cleanModelViewProjection(this);
        return this._modelViewProjection;
    };

    function cleanModelViewProjectionRelativeToEye(uniformState) {
        if (uniformState._modelViewProjectionRelativeToEyeDirty) {
            uniformState._modelViewProjectionRelativeToEyeDirty = false;

            Matrix4.multiply(uniformState._projection, uniformState.getModelViewRelativeToEye(), uniformState._modelViewProjectionRelativeToEye);
        }
    }

    /**
     * Returns the model-view-projection relative to eye matrix used to define the {@link czm_modelViewProjectionRelativeToEye} GLSL uniform.
     *
     * @memberof UniformState
     *
     * @return {Matrix4} The model-view-projection relative to eye matrix.
     *
     * @see czm_modelViewProjectionRelativeToEye
     */
    UniformState.prototype.getModelViewProjectionRelativeToEye = function() {
        cleanModelViewProjectionRelativeToEye(this);
        return this._modelViewProjectionRelativeToEye;
    };

    function cleanModelViewInfiniteProjection(uniformState) {
        if (uniformState._modelViewInfiniteProjectionDirty) {
            uniformState._modelViewInfiniteProjectionDirty = false;

            Matrix4.multiply(uniformState._infiniteProjection, uniformState.getModelView(), uniformState._modelViewInfiniteProjection);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see czm_modelViewProjection
     */
    UniformState.prototype.getModelViewInfiniteProjection = function() {
        cleanModelViewInfiniteProjection(this);
        return this._modelViewInfiniteProjection;
    };

    var normalScratch = new Matrix4();

    function cleanNormal(uniformState) {
        if (uniformState._normalDirty) {
            uniformState._normalDirty = false;

            Matrix4.transpose(uniformState.getInverseModelView(), normalScratch);
            Matrix4.getRotation(normalScratch, uniformState._normal);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see czm_normal
     */
    UniformState.prototype.getNormal = function() {
        cleanNormal(this);
        return this._normal;
    };

    function cleanInverseNormal(uniformState) {
        if (uniformState._inverseNormalDirty) {
            uniformState._inverseNormalDirty = false;

            Matrix4.getRotation(uniformState.getInverseModelView(), uniformState._inverseNormal);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see czm_inverseNormal
     */
    UniformState.prototype.getInverseNormal = function() {
        cleanInverseNormal(this);
        return this._inverseNormal;
    };

    /**
     * Returns the near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.
     *
     * @memberof UniformState
     *
     * @return {Cartesian2} Returns the near distance and the far distance of the frustum defined by the camera.
     *
     * @see czm_entireFrustum
     */
    UniformState.prototype.getEntireFrustum = function() {
        return this._entireFrustum;
    };

    /**
     * Returns a normalized vector to the sun in world coordinates at the current scene time.
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} A normalized vector to the sun in world coordinates at the current scene time.
     *
     * @see czm_sunDirectionWC
     */
    UniformState.prototype.getSunDirectionWC = function() {
        return this._sunDirectionWC;
    };

    /**
     * Returns a normalized vector to the sun in eye coordinates at the current scene time.
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} A normalized vector to the sun in eye coordinates at the current scene time.
     *
     * @see czm_sunDirectionEC
     */
    UniformState.prototype.getSunDirectionEC = function() {
        return this._sunDirectionEC;
    };

    /**
     * Returns a normalized vector to the moon in eye coordinates at the current scene time.
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} A normalized vector to the moon in eye coordinates at the current scene time.
     *
     * @see czm_moonDirectionEC
     */
    UniformState.prototype.getMoonDirectionEC = function() {
        return this._moonDirectionEC;
    };

    var cameraPositionMC = new Cartesian3();

    function cleanEncodedCameraPositionMC(uniformState) {
        if (uniformState._encodedCameraPositionMCDirty) {
            uniformState._encodedCameraPositionMCDirty = false;

            uniformState.getInverseModel().multiplyByPoint(uniformState._cameraPosition, cameraPositionMC);
            EncodedCartesian3.fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);
        }
    }

    /**
     * Returns the high bits of the camera position used to define the {@link czm_encodedCameraPositionMCHigh} GLSL uniform.
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} The high bits of the camera position.
     *
     * @see UniformState#getEncodedCameraPositionMCLow
     */
    UniformState.prototype.getEncodedCameraPositionMCHigh = function() {
        cleanEncodedCameraPositionMC(this);
        return this._encodedCameraPositionMC.high;
    };

    /**
     * Returns the low bits of the camera position used to define the {@link czm_encodedCameraPositionMCLow} GLSL uniform.
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} The low bits of the camera position.
     *
     * @see UniformState#getEncodedCameraPositionMCHigh
     */
    UniformState.prototype.getEncodedCameraPositionMCLow = function() {
        cleanEncodedCameraPositionMC(this);
        return this._encodedCameraPositionMC.low;
    };

    /**
     * Gets the current frame number.
     *
     * @memberof UniformState
     *
     * @return {number} A number representing the current frame number.
     *
     * @see czm_frameNumber
     */
    UniformState.prototype.getFrameNumber = function() {
        return this._frameNumber;
    };

    /**
     * Gets the scene's current time.
     *
     * @memberof UniformState
     *
     * @return {JulianDate} The scene's current time.
     */
    UniformState.prototype.getTime = function() {
        return this._time;
    };

    /**
     * Returns a 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the
     * pseudo-fixed axes at the Scene's current time.
     *
     * @memberof UniformState
     *
     * @return {Matrix3} The transform from TEME to pseudo-fixed.
     *
     * @see czm_temeToPseudoFixed
     */
    UniformState.prototype.getTemeToPseudoFixedMatrix = function() {
        return this._temeToPseudoFixed;
    };

    UniformState.prototype.getHighResolutionSnapScale = function() {
        return 1.0;
    };

    return UniformState;
});
/*global define*/
define('Scene/TerrainProvider',[
        '../Core/DeveloperError',
        '../Core/ComponentDatatype',
        '../Renderer/BufferUsage',
        '../Core/IndexDatatype'
    ], function(
        DeveloperError,
        ComponentDatatype,
        BufferUsage,
        IndexDatatype) {
    

    /**
     * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
     * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
     * interface and is not intended to be instantiated directly.
     *
     * @alias TerrainProvider
     * @constructor
     * @private
     *
     * @see EllipsoidTerrainProvider
     */
    function TerrainProvider() {
        /**
         * The tiling scheme used to tile the surface.
         *
         * @type TilingScheme
         */
        this.tilingScheme = undefined;

        this.levelZeroMaximumGeometricError = undefined;

        throw new DeveloperError('This type should not be instantiated directly.');
    }

    /**
     * Specifies the indices of the attributes of the terrain geometry.
     *
     * @memberof TerrainProvider
     */
    TerrainProvider.attributeIndices = {
        position3D : 0,
        textureCoordinates : 1
    };

    TerrainProvider.wireframe = false;

    var regularGridIndexArrays = [];

    TerrainProvider.getRegularGridIndices = function(width, height) {
        var byWidth = regularGridIndexArrays[width];
        if (typeof byWidth === 'undefined') {
            regularGridIndexArrays[width] = byWidth = [];
        }

        var indices = byWidth[height];
        if (typeof indices === 'undefined') {
            indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);

            var index = 0;
            var indicesIndex = 0;
            for ( var i = 0; i < height - 1; ++i) {
                for ( var j = 0; j < width - 1; ++j) {
                    var upperLeft = index;
                    var lowerLeft = upperLeft + width;
                    var lowerRight = lowerLeft + 1;
                    var upperRight = upperLeft + 1;

                    indices[indicesIndex++] = upperLeft;
                    indices[indicesIndex++] = lowerLeft;
                    indices[indicesIndex++] = upperRight;
                    indices[indicesIndex++] = upperRight;
                    indices[indicesIndex++] = lowerLeft;
                    indices[indicesIndex++] = lowerRight;

                    ++index;
                }
                ++index;
            }
        }

        return indices;
    };

    function addTriangle(lines, linesIndex, i0, i1, i2) {
        lines[linesIndex++] = i0;
        lines[linesIndex++] = i1;

        lines[linesIndex++] = i1;
        lines[linesIndex++] = i2;

        lines[linesIndex++] = i2;
        lines[linesIndex++] = i0;

        return linesIndex;
    }

    function trianglesToLines(triangles) {
        var count = triangles.length;
        var lines = new Uint16Array(2 * count);
        var linesIndex = 0;
        for ( var i = 0; i < count; i += 3) {
            linesIndex = addTriangle(lines, linesIndex, triangles[i], triangles[i + 1], triangles[i + 2]);
        }

        return lines;
    }

    TerrainProvider.createTileEllipsoidGeometryFromBuffers = function(context, tile, buffers) {
        var datatype = ComponentDatatype.FLOAT;
        var typedArray = buffers.vertices;
        var buffer = context.createVertexBuffer(typedArray, BufferUsage.STATIC_DRAW);
        var stride = 5 * datatype.sizeInBytes;
        var attributes = [{
            index : TerrainProvider.attributeIndices.position3D,
            vertexBuffer : buffer,
            componentDatatype : datatype,
            componentsPerAttribute : 3,
            offsetInBytes : 0,
            strideInBytes : stride
        }, {
            index : TerrainProvider.attributeIndices.textureCoordinates,
            vertexBuffer : buffer,
            componentDatatype : datatype,
            componentsPerAttribute : 2,
            offsetInBytes : 3 * datatype.sizeInBytes,
            strideInBytes : stride
        }];

        var indexBuffers = buffers.indices.indexBuffers || {};
        var indexBuffer = indexBuffers[context.getId()];
        if (typeof indexBuffer === 'undefined' || indexBuffer.isDestroyed()) {
            var indices = buffers.indices;
            if (TerrainProvider.wireframe) {
                indices = trianglesToLines(buffers.indices);
            }
            indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
            indexBuffer.setVertexArrayDestroyable(false);
            indexBuffer.referenceCount = 1;
            indexBuffers[context.getId()] = indexBuffer;
            buffers.indices.indexBuffers = indexBuffers;
        } else {
            ++indexBuffer.referenceCount;
        }

        tile.vertexArray = context.createVertexArray(attributes, indexBuffer);
    };

    /**
     * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
     * ensure that adjacent heightmap vertices are separated by no more than
     * {@link CentralBodySurface._maxScreenSpaceError} screen pixels and will probably go very slowly.
     * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
     * screen pixels between adjacent heightmap vertices and thus rendering more quickly.
     */
    TerrainProvider.heightmapTerrainQuality = 0.25;

    /**
     * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
     *
     * @param ellipsoid The ellipsoid to which the terrain is attached.
     * @param tileImageWidth The width, in pixels, of the heightmap associated with a single tile.
     * @param numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.
     * @returns {Number} An estimated geometric error.
     */
    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {
        return ellipsoid.getMaximumRadius() * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);
    };

    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     *
     * @param {Number} level The tile level for which to get the maximum geometric error.
     * @returns {Number} The maximum geometric error.
     */
    TerrainProvider.prototype.getLevelMaximumGeometricError = function(level) {
        return this.levelZeroMaximumGeometricError / (1 << level);
    };

    // Is there a limit on 'level' of the tile that can be passed in?  It seems
    // natural to have a maxLevel, but this would cause problems if we have hi-res imagery
    // and low-res terrain.  So I'd say we can continue to refine terrain tiles arbitrarily
    // until both the terrain and all the imagery layers have no more detail to give.  In that
    // case, this method is expected to be able to produce geometry for an arbitrarily-deep
    // tile tree.

    /**
     * Request the tile geometry from the remote server.  Once complete, the
     * tile state should be set to RECEIVED.  Alternatively, tile state can be set to
     * UNLOADED to indicate that the request should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Tile} The tile to request geometry for.
     */
    TerrainProvider.prototype.requestTileGeometry = function(tile) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Transform the tile geometry from the format requested from the remote server
     * into a format suitable for resource creation.  Once complete, the tile
     * state should be set to TRANSFORMED.  Alternatively, tile state can be set to
     * RECEIVED to indicate that the transformation should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Context} context The context to use to create resources.
     * @param {Tile} tile The tile to transform geometry for.
     */
    TerrainProvider.prototype.transformGeometry = function(context, tile) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Create WebGL resources for the tile using whatever data the transformGeometry step produced.
     * Once complete, the tile state should be set to READY.  Alternatively, tile state can be set to
     * TRANSFORMED to indicate that resource creation should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Context} context The context to use to create resources.
     * @param {Tile} tile The tile to create resources for.
     */
    TerrainProvider.prototype.createResources = function(context, tile) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    return TerrainProvider;
});
/*global define*/
define('Scene/TexturePool',[
        '../Core/destroyObject',
        '../Core/DeveloperError',
        '../Renderer/PixelDatatype',
        '../Renderer/PixelFormat',
        '../Renderer/Texture'
    ], function(
        destroyObject,
        DeveloperError,
        PixelDatatype,
        PixelFormat,
        Texture) {
    

    var PooledTexture;
    function createPooledTexture(texture, textureTypeKey, pool) {
        if (typeof PooledTexture === 'undefined') {
            // define the class only when needed, so we can use modern
            // language features without breaking legacy browsers at setup time.
            PooledTexture = function(texture, textureTypeKey, pool) {
                this._texture = texture;
                this._textureTypeKey = textureTypeKey;
                this._pool = pool;
            };

            // pass through all methods to the underlying texture
            Object.keys(Texture.prototype).forEach(function(methodName) {
                PooledTexture.prototype[methodName] = function() {
                    var texture = this._texture;
                    return texture[methodName].apply(texture, arguments);
                };
            });

            // except for destroy, which releases back into the pool
            PooledTexture.prototype.destroy = function() {
                var freeList = this._pool._free[this._textureTypeKey];
                if (typeof freeList === 'undefined') {
                    freeList = this._pool._free[this._textureTypeKey] = [];
                }

                if (freeList.length >= 8) {
                    this._texture.destroy();
                } else {
                    freeList.push(this);
                }
            };
        }

        return new PooledTexture(texture, textureTypeKey, pool);
    }

    /**
     * A pool of textures.  Textures created from the pool will be released back into the pool
     * when destroy() is called, so future calls to create may re-use a released texture.
     * <br/><br/>
     * Texture pools are useful when textures are being created and destroyed repeatedly.
     *
     * @alias Texture2DPool
     * @constructor
     *
     * @see Texture
     */
    var TexturePool = function() {
        this._free = {};
    };

    /**
     * Create a texture.  This function takes the same arguments as {@link Context#createTexture2D},
     * but may return a pooled texture if there are any available.  If a pooled texture is re-used,
     * and no source is provided, the new texture will still retain its old contents.
     *
     * @memberof TexturePool
     *
     * @param {Context} context The context to use to create textures when needed.
     *
     * @exception {DeveloperError} description is required.
     *
     * @see Context#createTexture2D
     */
    TexturePool.prototype.createTexture2D = function(context, description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width = typeof source !== 'undefined' ? source.width : description.width;
        var height = typeof source !== 'undefined' ? source.height : description.height;
        //coerce values to primitive numbers to make textureTypeKey smaller.
        var pixelFormat = +(description.pixelFormat || PixelFormat.RGBA);
        var pixelDatatype = +(description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE);
        var preMultiplyAlpha = +(description.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE);

        var textureTypeKey = JSON.stringify([width, height, pixelFormat, pixelDatatype, preMultiplyAlpha]);

        var freeList = this._free[textureTypeKey];
        if (typeof freeList !== 'undefined' && freeList.length > 0) {
            var texture = freeList.pop();
            if (typeof source !== 'undefined') {
                texture.copyFrom(source);
            }
            return texture;
        }

        return createPooledTexture(context.createTexture2D(description), textureTypeKey, this);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof TexturePool
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see TexturePool#destroy
     */
    TexturePool.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof TexturePool
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see TexturePool#isDestroyed
     *
     * @example
     * pool = pool && pool.destroy();
     */
    TexturePool.prototype.destroy = function() {
        var free = this._free;
        Object.keys(free).forEach(function(textureTypeKey) {
            free[textureTypeKey].forEach(function(texture) {
                texture._texture.destroy();
            });
        });
        return destroyObject(this);
    };

    return TexturePool;
});
/*global define*/
define('Scene/TileDiscardPolicy',[
        '../Core/DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * A policy for discarding tile images according to some criteria.  This type describes an
     * interface and is not intended to be instantiated directly.
     *
     * @alias TileDiscardPolicy
     * @constructor
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     */
    var TileDiscardPolicy = function(description) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Determines if the discard policy is ready to process images.
     * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.
     */
    TileDiscardPolicy.prototype.isReady = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Given a tile image, decide whether to discard that image.
     *
     * @param {Image|Promise} image An image, or a promise that will resolve to an image.
     *
     * @returns {Boolean} A promise that will resolve to true if the tile should be discarded.
     */
    TileDiscardPolicy.prototype.shouldDiscardImage = function(image) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    return TileDiscardPolicy;
});
/*global define*/
define('Scene/TileImagery',[],function() {
    

    /**
     * The assocation between a terrain tile and an imagery tile.
     *
     * @alias TileImagery
     * @private
     *
     * @param {Imagery} imagery The imagery tile.
     * @param {Cartesian4} textureCoordinateExtent The texture extent extent of the tile that is covered
     *        by the imagery, where X=west, Y=south, Z=east, W=north.
     */
    var TileImagery = function(imagery, textureCoordinateExtent) {
        this.imagery = imagery;
        this.textureCoordinateExtent = textureCoordinateExtent;
        this.originalImagery = undefined;
        this.textureTranslationAndScale = undefined;
    };

    /**
     * Frees the resources held by this instance.
     *
     * @memberof TileImagery
     */
    TileImagery.prototype.freeResources = function() {
        this.imagery.releaseReference();

        if (typeof this.originalImagery !== 'undefined') {
            this.originalImagery.releaseReference();
        }
    };

    return TileImagery;
});
/*global define*/
define('Scene/TileLoadQueue',[],function() {
    

    /**
     * A priority queue of tiles to be loaded, implemented as a linked list.
     *
     * @alias TileLoadQueue
     * @private
     */
    var TileLoadQueue = function TileLoadQueue() {
        this.head = undefined;
        this.tail = undefined;
        this._insertionPoint = undefined;
    };

    /**
     * Removes a tile from the load queue.
     *
     * @memberof TileLoadQueue
     *
     * @param {Tile} item The tile to remove from the load queue.
     */
    TileLoadQueue.prototype.remove = function(item) {
        var previous = item.loadPrevious;
        var next = item.loadNext;

        if (item === this.head) {
            this.head = next;
        } else {
            previous.loadNext = next;
        }

        if (item === this.tail) {
            this.tail = previous;
        } else {
            next.loadPrevious = previous;
        }

        item.loadPrevious = undefined;
        item.loadNext = undefined;
    };

    /**
     * Marks the point at which new tiles will be inserted into the queue, which is initially the
     * head of the queue.  As each new tile is added to or repositioned in the queue, the insertion
     * point represents the first tile that was not added or repositioned this frame.
     *
     * @memberof TileLoadQueue
     */
    TileLoadQueue.prototype.markInsertionPoint = function() {
        this._insertionPoint = this.head;
    };

    /**
     * Inserts (or repositions) a tile to place it just before the insertion point.
     *
     * @memberof TileLoadQueue
     *
     * @param {Tile} item The tile to insert or reposition.
     */
    TileLoadQueue.prototype.insertBeforeInsertionPoint = function(item) {
        var insertionPoint = this._insertionPoint;
        if (insertionPoint === item) {
            return;
        }

        if (typeof this.head === 'undefined') {
            // no other tiles in the list
            item.loadPrevious = undefined;
            item.loadNext = undefined;
            this.head = item;
            this.tail = item;
            return;
        }

        if (typeof item.loadPrevious !== 'undefined' || typeof item.loadNext !== 'undefined') {
            // tile already in the list, remove from its current location
            this.remove(item);
        }

        if (typeof insertionPoint === 'undefined') {
            item.loadPrevious = this.tail;
            item.loadNext = undefined;
            this.tail.loadNext = item;
            this.tail = item;
            return;
        }

        var insertAfter = insertionPoint.loadPrevious;
        item.loadPrevious = insertAfter;
        if (typeof insertAfter !== 'undefined') {
            insertAfter.loadNext = item;
        }

        item.loadNext = insertionPoint;
        insertionPoint.loadPrevious = item;

        if (insertionPoint === this.head) {
            this.head = item;
        }
    };

    return TileLoadQueue;
});

/*global define*/
define('Scene/TileState',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * @private
     */
    var TileState = {
        UNLOADED : new Enumeration(0, 'UNLOADED'),
        TRANSITIONING : new Enumeration(1, 'TRANSITIONING'),
        RECEIVED : new Enumeration(2, 'RECEIVED'),
        TRANSFORMED : new Enumeration(3, 'TRANSFORMED'),
        READY : new Enumeration(4, 'READY'),
        FAILED : new Enumeration(5, 'FAILED'),
        INVALID : new Enumeration(6, 'INVALID')
    };

    return TileState;
});
/*global define*/
define('Scene/Tile',[
        '../Core/DeveloperError',
        './TileState'
    ], function(
        DeveloperError,
        TileState) {
    

    /**
     * A node in the quadtree representing the surface of a {@link CentralBody}.
     * A tile holds the surface geometry for its horizontal extent and zero or
     * more imagery textures overlaid on the geometry.
     *
     * @alias Tile
     * @constructor
     * @private
     *
     * @param {TilingScheme} description.tilingScheme The tiling scheme of which the new tile is a part, such as a
     *                                                {@link WebMercatorTilingScheme} or a {@link GeographicTilingScheme}.
     * @param {Number} description.x The tile x coordinate.
     * @param {Number} description.y The tile y coordinate.
     * @param {Number} description.level The tile level-of-detail.
     * @param {Tile} description.parent The parent of this tile in a tile tree system.
     *
     * @exception {DeveloperError} Either description.extent or both description.x and description.y is required.
     * @exception {DeveloperError} description.level is required.
     */
    var Tile = function(description) {
        if (typeof description === 'undefined') {
            throw new DeveloperError('description is required.');
        }

        if (typeof description.x === 'undefined' || typeof description.y === 'undefined') {
            if (typeof description.extent === 'undefined') {
                throw new DeveloperError('Either description.extent is required or description.x and description.y are required.');
            }
        } else if (description.x < 0 || description.y < 0) {
            throw new DeveloperError('description.x and description.y must be greater than or equal to zero.');
        }

        if (typeof description.level === 'undefined' || description.zoom < 0) {
            throw new DeveloperError('description.level is required and must be greater than or equal to zero.');
        }

        if (typeof description.tilingScheme === 'undefined') {
            throw new DeveloperError('description.tilingScheme is required.');
        }

        /**
         * The tiling scheme used to tile the surface.
         * @type TilingScheme
         */
        this.tilingScheme = description.tilingScheme;

        /**
         * The x coordinate.
         * @type Number
         */
        this.x = description.x;

        /**
         * The y coordinate.
         * @type Number
         */
        this.y = description.y;

        /**
         * The level-of-detail, where zero is the coarsest, least-detailed.
         * @type Number
         */
        this.level = description.level;

        /**
         * The parent of this tile in a tiling scheme.
         * @type Tile
         */
        this.parent = description.parent;

        /**
         * The children of this tile in a tiling scheme.
         * @type Array
         */
        this.children = undefined;

        /**
         * The cartographic extent of the tile, with north, south, east and
         * west properties in radians.
         * @type Extent
         */
        this.extent = this.tilingScheme.tileXYToExtent(this.x, this.y, this.level);

        /**
         * The {@link VertexArray} defining the geometry of this tile.  This property
         * is expected to be set before the tile enter's the {@link TileState.READY}
         * {@link state}.
         * @type VertexArray
         */
        this.vertexArray = undefined;

        /**
         * The center of this tile.  The {@link vertexArray} is rendered
         * relative-to-center (RTC) using this center.  Note that the center of the
         * {@link boundingSphere3D} is not necessarily the same as this center.
         * This property is expected to be set before the tile enter's the
         * {@link TileState.READY} {@link state}.
         * @type Cartesian3
         */
        this.center = undefined;

        /**
         * The maximum height of terrain in this tile, in meters above the ellipsoid.
         * @type Number
         */
        this.maxHeight = undefined;

        /**
         * A sphere that completely contains this tile on the globe.  This property may be
         * undefined until the tile's {@link vertexArray} is loaded.
         * @type BoundingSphere
         */
        this.boundingSphere3D = undefined;

        /**
         * The current state of the tile in the tile load pipeline.
         * @type TileState
         */
        this.state = TileState.UNLOADED;

        /**
         * The previous tile in the {@link TileLoadQueue}.
         * @type Tile
         */
        this.loadPrevious = undefined;

        /**
         * The next tile in the {@link TileLoadQueue}.
         * @type Tile
         */
        this.loadNext = undefined;

        /**
         * The previous tile in the {@link TileReplacementQueue}.
         * @type Tile
         */
        this.replacementPrevious = undefined;

        /**
         * The next tile in the {@link TileReplacementQueue}.
         * @type Tile
         */
        this.replacementNext = undefined;

        /**
         * The {@link TileImagery} attached to this tile.
         * @type Array
         */
        this.imagery = [];

        /**
         * Transient data stored during the load process.  The exact content
         * of this property is a function of the tile's current {@link state} and
         * the {@link TerrainProvider} that is loading the tile.
         * @type Object
         */
        this.transientData = undefined;

        /**
         * The distance from the camera to this tile, updated when the tile is selected
         * for rendering.  We can get rid of this if we have a better way to sort by
         * distance - for example, by using the natural ordering of a quadtree.
         * @type Number
         */
        this.distance = 0.0;

        /**
         * The world coordinates of the southwest corner of the tile's extent.
         *
         * @type Cartesian3
         */
        this.southwestCornerCartesian = undefined;

        /**
         * The world coordinates of the northeast corner of the tile's extent.
         *
         * @type Cartesian3
         */
        this.northeastCornerCartesian = undefined;

        /**
         * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of
         * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         *
         * @type Cartesian3
         */
        this.westNormal = undefined;

        /**
         * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of
         * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         * Because points of constant latitude do not necessary lie in a plane, positions below this
         * plane are not necessarily inside the tile, but they are close.
         *
         * @type Cartesian3
         */
        this.southNormal = undefined;

        /**
         * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
         * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         *
         * @type Cartesian3
         */
        this.eastNormal = undefined;

        /**
         * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
         * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         * Because points of constant latitude do not necessary lie in a plane, positions below this
         * plane are not necessarily inside the tile, but they are close.
         *
         * @type Cartesian3
         */
        this.northNormal = undefined;

        /**
         * A proxy point to use for this tile for horizon culling.  If this point is below the horizon, the
         * entire tile is below the horizon as well.  The point is expressed in the ellipsoid-scaled
         * space.  To transform a point from world coordinates centered on the ellipsoid to ellipsoid-scaled
         * coordinates, multiply the world coordinates by {@link Ellipsoid#getOneOverRadii}.  See
         * <a href="http://blogs.agi.com/insight3d/index.php/2009/03/25/horizon-culling-2/">http://blogs.agi.com/insight3d/index.php/2009/03/25/horizon-culling-2/</a>
         * for information the proxy point.
         *
         * @type {Cartesian3}
         */
        this.occludeePointInScaledSpace = undefined;
    };

    /**
     * Returns an array of tiles that would be at the next level of the tile tree.
     *
     * @memberof Tile
     *
     * @return {Array} The list of child tiles.
     */
    Tile.prototype.getChildren = function() {
        if (typeof this.children === 'undefined') {
            var tilingScheme = this.tilingScheme;
            var level = this.level + 1;
            var x = this.x * 2;
            var y = this.y * 2;
            this.children = [new Tile({
                tilingScheme : tilingScheme,
                x : x,
                y : y,
                level : level,
                parent : this
            }), new Tile({
                tilingScheme : tilingScheme,
                x : x + 1,
                y : y,
                level : level,
                parent : this
            }), new Tile({
                tilingScheme : tilingScheme,
                x : x,
                y : y + 1,
                level : level,
                parent : this
            }), new Tile({
                tilingScheme : tilingScheme,
                x : x + 1,
                y : y + 1,
                level : level,
                parent : this
            })];
        }

        return this.children;
    };

    Tile.prototype.freeResources = function() {
        this.state = TileState.UNLOADED;
        this.doneLoading = false;
        this.renderable = false;

        if (typeof this.vertexArray !== 'undefined') {
            var indexBuffer = this.vertexArray.getIndexBuffer();

            this.vertexArray.destroy();
            this.vertexArray = undefined;

            if (!indexBuffer.isDestroyed() && typeof indexBuffer.referenceCount !== 'undefined') {
                --indexBuffer.referenceCount;
                if (indexBuffer.referenceCount === 0) {
                    indexBuffer.destroy();
                }
            }
        }

        if (typeof this.transientData !== 'undefined' && typeof this.transientData.destroy !== 'undefined') {
            this.transientData.destroy();
        }
        this.transientData = undefined;

        var i, len;

        var imageryList = this.imagery;
        for (i = 0, len = imageryList.length; i < len; ++i) {
            imageryList[i].freeResources();
        }
        this.imagery.length = 0;

        if (typeof this.children !== 'undefined') {
            for (i = 0, len = this.children.length; i < len; ++i) {
                this.children[i].freeResources();
            }
        }
    };

    return Tile;
});
/*global define*/
define('Scene/TileReplacementQueue',[
        './TileState'
    ], function(
        TileState) {
    

    /**
     * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue
     * is implemented as a linked list.
     *
     * @alias TileReplacementQueue
     * @private
     */
    var TileReplacementQueue = function TileReplacementQueue() {
        this.head = undefined;
        this.tail = undefined;
        this.count = 0;
        this._lastBeforeStartOfFrame = undefined;
    };

    /**
     * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the
     * list were used last frame and must not be unloaded.
     */
    TileReplacementQueue.prototype.markStartOfRenderFrame = function() {
        this._lastBeforeStartOfFrame = this.head;
    };

    /**
     * Reduces the size of the queue to a specified size by unloading the least-recently used
     * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number
     * of tiles above the specified maximum.
     *
     * @memberof TileReplacementQueue
     *
     * @param {Number} maximumTiles The maximum number of tiles in the queue.
     */
    TileReplacementQueue.prototype.trimTiles = function(maximumTiles) {
        var tileToTrim = this.tail;
        var keepTrimming = true;
        while (keepTrimming &&
               typeof this._lastBeforeStartOfFrame !== 'undefined' &&
               this.count > maximumTiles &&
               typeof tileToTrim !== 'undefined') {
            // Stop trimming after we process the last tile not used in the
            // current frame.
            keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;

            var previous = tileToTrim.replacementPrevious;
            if (tileToTrim.state !== TileState.TRANSITIONING) {
                tileToTrim.freeResources();
                this._remove(tileToTrim);
            }
            tileToTrim = previous;
        }
    };

    TileReplacementQueue.prototype._remove = function(item) {
        var previous = item.replacementPrevious;
        var next = item.replacementNext;

        if (item === this._lastBeforeStartOfFrame) {
            this._lastBeforeStartOfFrame = next;
        }

        if (item === this.head) {
            this.head = next;
        } else {
            previous.replacementNext = next;
        }

        if (item === this.tail) {
            this.tail = previous;
        } else {
            next.replacementPrevious = previous;
        }

        item.replacementPrevious = undefined;
        item.replacementNext = undefined;

        --this.count;
    };

    /**
     * Marks a tile as rendered this frame and moves it before the first tile that was not rendered
     * this frame.
     *
     * @memberof TileReplacementQueue
     *
     * @param {TileReplacementQueue} item The tile that was rendered.
     */
    TileReplacementQueue.prototype.markTileRendered = function(item) {
        var head = this.head;
        if (head === item) {
            if (item === this._lastBeforeStartOfFrame) {
                this._lastBeforeStartOfFrame = item.replacementNext;
            }
            return;
        }

        ++this.count;

        if (typeof head === 'undefined') {
            // no other tiles in the list
            item.replacementPrevious = undefined;
            item.replacementNext = undefined;
            this.head = item;
            this.tail = item;
            return;
        }

        if (typeof item.replacementPrevious !== 'undefined' || typeof item.replacementNext !== 'undefined') {
            // tile already in the list, remove from its current location
            this._remove(item);
        }

        item.replacementPrevious = undefined;
        item.replacementNext = head;
        head.replacementPrevious = item;

        this.head = item;
    };

    return TileReplacementQueue;
});

/*global define*/
define('Scene/CentralBodySurface',[
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/BoundingSphere',
        '../Core/BoundingRectangle',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/CubeMapEllipsoidTessellator',
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/EllipsoidalOccluder',
        '../Core/Intersect',
        '../Core/Matrix4',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/Queue',
        '../Core/WebMercatorProjection',
        '../Renderer/DrawCommand',
        './ImageryState',
        './SceneMode',
        './TerrainProvider',
        './TileLoadQueue',
        './TileReplacementQueue',
        './TileState'
    ], function(
        defaultValue,
        destroyObject,
        BoundingSphere,
        BoundingRectangle,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        CubeMapEllipsoidTessellator,
        DeveloperError,
        Ellipsoid,
        EllipsoidalOccluder,
        Intersect,
        Matrix4,
        MeshFilters,
        PrimitiveType,
        Queue,
        WebMercatorProjection,
        DrawCommand,
        ImageryState,
        SceneMode,
        TerrainProvider,
        TileLoadQueue,
        TileReplacementQueue,
        TileState) {
    

    /**
     * Manages and renders the terrain and imagery on the surface of a {@link CentralBody}.
     * This class should be considered an implementation detail of {@link CentralBody} and not
     * used directly.
     *
     * @alias CentralBodySurface
     * @constructor
     * @private
     */
    var CentralBodySurface = function(description) {
        if (typeof description.terrainProvider === 'undefined') {
            throw new DeveloperError('description.terrainProvider is required.');
        }
        if (typeof description.imageryLayerCollection === 'undefined') {
            throw new DeveloperError('description.imageryLayerCollection is required.');
        }

        this._terrainProvider = description.terrainProvider;
        this._imageryLayerCollection = description.imageryLayerCollection;
        this._maxScreenSpaceError = defaultValue(description.maxScreenSpaceError, 2);

        this._imageryLayerCollection.layerAdded.addEventListener(CentralBodySurface.prototype._onLayerAdded, this);
        this._imageryLayerCollection.layerRemoved.addEventListener(CentralBodySurface.prototype._onLayerRemoved, this);
        this._imageryLayerCollection.layerMoved.addEventListener(CentralBodySurface.prototype._onLayerMoved, this);
        this._imageryLayerCollection.layerShownOrHidden.addEventListener(CentralBodySurface.prototype._onLayerShownOrHidden, this);

        this._layerOrderChanged = false;

        var terrainTilingScheme = this._terrainProvider.tilingScheme;
        this._levelZeroTiles = terrainTilingScheme.createLevelZeroTiles();

        this._tilesToRenderByTextureCount = [];
        this._tileCommands = [];
        this._tileCommandUniformMaps = [];
        this._tileTraversalQueue = new Queue();
        this._tileLoadQueue = new TileLoadQueue();
        this._tileReplacementQueue = new TileReplacementQueue();

        // The number of milliseconds each frame to allow for processing the tile load queue.
        // At least one tile will be processed per frame (assuming that any need processing),
        // even if this value is 0.
        this._loadQueueTimeSlice = 5;

        var ellipsoid = terrainTilingScheme.getEllipsoid();
        this._ellipsoidalOccluder = new EllipsoidalOccluder(ellipsoid, Cartesian3.ZERO);

        this._debug = {
            enableDebugOutput : false,
            boundingSphereTile : undefined,
            boundingSphereVA : undefined,

            maxDepth : 0,
            tilesVisited : 0,
            tilesCulled : 0,
            tilesRendered : 0,
            texturesRendered : 0,
            tilesWaitingForChildren : 0,

            lastMaxDepth : -1,
            lastTilesVisited : -1,
            lastTilesCulled : -1,
            lastTilesRendered : -1,
            lastTexturesRendered : -1,
            lastTilesWaitingForChildren : -1,

            suspendLodUpdate : false
        };
    };

    CentralBodySurface.prototype.update = function(context, frameState, colorCommandList, centralBodyUniformMap, shaderSet, renderState, mode, projection) {
        updateLayers(this);
        selectTilesForRendering(this, context, frameState);
        processTileLoadQueue(this, context, frameState);
        createRenderCommandsForSelectedTiles(this, context, frameState, shaderSet, mode, projection, centralBodyUniformMap, colorCommandList, renderState);
        debugCreateRenderCommandsForTileBoundingSphere(this, context, frameState, centralBodyUniformMap, shaderSet, renderState, colorCommandList);
    };

    CentralBodySurface.prototype._onLayerAdded = function(layer, index) {
        if (typeof this._levelZeroTiles === 'undefined') {
            return;
        }

        // create TileImagerys for this layer for all previously loaded tiles
        if (layer.show) {
            var tile = this._tileReplacementQueue.head;
            while (typeof tile !== 'undefined') {
                if (layer._createTileImagerySkeletons(tile, this._terrainProvider)) {
                    tile.doneLoading = false;
                }
                tile = tile.replacementNext;
            }

            this._layerOrderChanged = true;
        }
    };

    CentralBodySurface.prototype._onLayerRemoved = function(layer, index) {
        if (typeof this._levelZeroTiles === 'undefined') {
            return;
        }

        // destroy TileImagerys for this layer for all previously loaded tiles
        var tile = this._tileReplacementQueue.head;
        while (typeof tile !== 'undefined') {
            var tileImageryCollection = tile.imagery;

            var startIndex = -1;
            var numDestroyed = 0;
            for ( var i = 0, len = tileImageryCollection.length; i < len; ++i) {
                var tileImagery = tileImageryCollection[i];
                var imagery = tileImagery.imagery;
                if (imagery.imageryLayer === layer) {
                    if (startIndex === -1) {
                        startIndex = i;
                    }

                    tileImagery.freeResources();
                    ++numDestroyed;
                } else if (startIndex !== -1) {
                    // iterated past the section of TileImagerys belonging to this layer, no need to continue.
                    break;
                }
            }

            if (startIndex !== -1) {
                tileImageryCollection.splice(startIndex, numDestroyed);
            }
            // If the base layer has been removed, mark the tile as non-renderable.
            if (layer.isBaseLayer()) {
                tile.renderable = false;
            }

            tile = tile.replacementNext;
        }
    };

    CentralBodySurface.prototype._onLayerMoved = function(layer, newIndex, oldIndex) {
        if (typeof this._levelZeroTiles === 'undefined') {
            return;
        }

        this._layerOrderChanged = true;
    };

    CentralBodySurface.prototype._onLayerShownOrHidden = function(layer, index, show) {
        if (typeof this._levelZeroTiles === 'undefined') {
            return;
        }

        if (show) {
            this._onLayerAdded(layer, index);
        } else {
            this._onLayerRemoved(layer, index);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CentralBodySurface
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CentralBodySurface#destroy
     */
    CentralBodySurface.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CentralBodySurface
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CentralBodySurface#isDestroyed
     */
    CentralBodySurface.prototype.destroy = function() {
        var levelZeroTiles = this._levelZeroTiles;
        for (var i = 0; i < levelZeroTiles.length; ++i) {
            levelZeroTiles[i].freeResources();
        }

        if (typeof this._terrainProvider.destroy !== 'undefined') {
            this._terrainProvider.destroy();
        }

        this._imageryLayerCollection.destroy();

        var debug = this._debug;
        if (typeof debug !== 'undefined') {
            if (typeof debug.boundingSphereVA !== 'undefined') {
                debug.boundingSphereVA.destroy();
            }
        }

        return destroyObject(this);
    };

    function sortTileImageryByLayerIndex(a, b) {
        return a.imagery.imageryLayer._layerIndex - b.imagery.imageryLayer._layerIndex;
    }

    function updateLayers(surface) {
        surface._imageryLayerCollection._update();

        if (surface._layerOrderChanged) {
            surface._layerOrderChanged = false;

            // Sort the TileImagery instances in each tile by the layer index.
            var tile = surface._tileReplacementQueue.head;
            while (typeof tile !== 'undefined') {
                tile.imagery.sort(sortTileImageryByLayerIndex);
                tile = tile.replacementNext;
            }
        }
    }

    function selectTilesForRendering(surface, context, frameState) {
        var debug = surface._debug;

        if (debug.suspendLodUpdate) {
            return;
        }

        var i, len;

        // Clear the render list.
        var tilesToRenderByTextureCount = surface._tilesToRenderByTextureCount;
        for (i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {
            var tiles = tilesToRenderByTextureCount[i];
            if (typeof tiles !== 'undefined') {
                tiles.length = 0;
            }
        }

        // We can't render anything before the level zero tiles exist.
        if (typeof surface._levelZeroTiles === 'undefined') {
            return;
        }

        var traversalQueue = surface._tileTraversalQueue;
        traversalQueue.clear();

        debug.maxDepth = 0;
        debug.tilesVisited = 0;
        debug.tilesCulled = 0;
        debug.tilesRendered = 0;
        debug.texturesRendered = 0;
        debug.tilesWaitingForChildren = 0;

        surface._tileLoadQueue.markInsertionPoint();
        surface._tileReplacementQueue.markStartOfRenderFrame();

        var cameraPosition = frameState.camera.getPositionWC();

        var ellipsoid = surface._terrainProvider.tilingScheme.getEllipsoid();
        var cameraPositionCartographic = ellipsoid.cartesianToCartographic(cameraPosition);

        surface._ellipsoidalOccluder.setCameraPosition(cameraPosition);

        var tile;

        // Enqueue the root tiles that are renderable and visible.
        var levelZeroTiles = surface._levelZeroTiles;
        for (i = 0, len = levelZeroTiles.length; i < len; ++i) {
            tile = levelZeroTiles[i];
            if (!tile.doneLoading) {
                queueTileLoad(surface, tile);
            }
            if (tile.renderable && isTileVisible(surface, frameState, tile)) {
                traversalQueue.enqueue(tile);
            } else {
                ++debug.tilesCulled;
            }
        }

        // Traverse the tiles in breadth-first order.
        // This ordering allows us to load bigger, lower-detail tiles before smaller, higher-detail ones.
        // This maximizes the average detail across the scene and results in fewer sharp transitions
        // between very different LODs.
        while (typeof (tile = traversalQueue.dequeue()) !== 'undefined') {
            ++debug.tilesVisited;

            surface._tileReplacementQueue.markTileRendered(tile);

            if (tile.level > debug.maxDepth) {
                debug.maxDepth = tile.level;
            }

            // There are a few different algorithms we could use here.
            // This one doesn't load children unless we refine to them.
            // We may want to revisit this in the future.

            if (screenSpaceError(surface, context, frameState, cameraPosition, cameraPositionCartographic, tile) < surface._maxScreenSpaceError) {
                // This tile meets SSE requirements, so render it.
                addTileToRenderList(surface, tile);
            } else if (queueChildrenLoadAndDetermineIfChildrenAreAllRenderable(surface, frameState, tile)) {
                // SSE is not good enough and children are loaded, so refine.
                var children = tile.children;
                // PERFORMANCE_IDEA: traverse children front-to-back so we can avoid sorting by distance later.
                for (i = 0, len = children.length; i < len; ++i) {
                    if (isTileVisible(surface, frameState, children[i])) {
                        traversalQueue.enqueue(children[i]);
                    } else {
                        ++debug.tilesCulled;
                    }
                }
            } else {
                ++debug.tilesWaitingForChildren;
                // SSE is not good enough but not all children are loaded, so render this tile anyway.
                addTileToRenderList(surface, tile);
            }
        }

        if (debug.enableDebugOutput) {
            if (debug.tilesVisited !== debug.lastTilesVisited ||
                debug.tilesRendered !== debug.lastTilesRendered ||
                debug.texturesRendered !== debug.lastTexturesRendered ||
                debug.tilesCulled !== debug.lastTilesCulled ||
                debug.maxDepth !== debug.lastMaxDepth ||
                debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren) {

                /*global console*/
                console.log('Visited ' + debug.tilesVisited + ', Rendered: ' + debug.tilesRendered + ', Textures: ' + debug.texturesRendered + ', Culled: ' + debug.tilesCulled + ', Max Depth: ' + debug.maxDepth + ', Waiting for children: ' + debug.tilesWaitingForChildren);

                debug.lastTilesVisited = debug.tilesVisited;
                debug.lastTilesRendered = debug.tilesRendered;
                debug.lastTexturesRendered = debug.texturesRendered;
                debug.lastTilesCulled = debug.tilesCulled;
                debug.lastMaxDepth = debug.maxDepth;
                debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;
            }
        }
    }

    function screenSpaceError(surface, context, frameState, cameraPosition, cameraPositionCartographic, tile) {
        if (frameState.mode === SceneMode.SCENE2D) {
            return screenSpaceError2D(surface, context, frameState, cameraPosition, cameraPositionCartographic, tile);
        }

        var extent = tile.extent;

        var latitudeFactor = 1.0;

        // Adjust by latitude in 3D only.
        if (frameState.mode === SceneMode.SCENE3D) {
            var latitudeClosestToEquator = 0.0;
            if (extent.south > 0.0) {
                latitudeClosestToEquator = extent.south;
            } else if (extent.north < 0.0) {
                latitudeClosestToEquator = extent.north;
            }

            latitudeFactor = Math.cos(latitudeClosestToEquator);
        }

        var maxGeometricError = latitudeFactor * surface._terrainProvider.getLevelMaximumGeometricError(tile.level);


        var distance = Math.sqrt(distanceSquaredToTile(frameState, cameraPosition, cameraPositionCartographic, tile));
        tile.distance = distance;

        var canvas = context.getCanvas();
        var height = canvas.clientHeight;

        var camera = frameState.camera;
        var frustum = camera.frustum;
        var fovy = frustum.fovy;

        // PERFORMANCE_IDEA: factor out stuff that's constant across tiles.
        return (maxGeometricError * height) / (2 * distance * Math.tan(0.5 * fovy));
    }

    function screenSpaceError2D(surface, context, frameState, cameraPosition, cameraPositionCartographic, tile) {
        var camera = frameState.camera;
        var frustum = camera.frustum;
        var canvas = context.getCanvas();
        var width = canvas.clientWidth;
        var height = canvas.clientHeight;

        var maxGeometricError = surface._terrainProvider.getLevelMaximumGeometricError(tile.level);
        var pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);
        return maxGeometricError / pixelSize;
    }

    function addTileToRenderList(surface, tile) {
        var readyTextureCount = 0;
        var tileImageryCollection = tile.imagery;
        for ( var i = 0, len = tileImageryCollection.length; i < len; ++i) {
            var tileImagery = tileImageryCollection[i];
            if (tileImagery.imagery.state === ImageryState.READY) {
                ++readyTextureCount;
            }
        }

        var tileSet = surface._tilesToRenderByTextureCount[readyTextureCount];
        if (typeof tileSet === 'undefined') {
            tileSet = [];
            surface._tilesToRenderByTextureCount[readyTextureCount] = tileSet;
        }

        tileSet.push(tile);

        var debug = surface._debug;
        ++debug.tilesRendered;
        debug.texturesRendered += readyTextureCount;
    }

    var boundingSphereScratch = new BoundingSphere();

    function isTileVisible(surface, frameState, tile) {
        var cullingVolume = frameState.cullingVolume;

        var boundingVolume = tile.boundingSphere3D;

        if (frameState.mode !== SceneMode.SCENE3D) {
            boundingVolume = boundingSphereScratch;
            BoundingSphere.fromExtent2D(tile.extent, frameState.scene2D.projection, boundingVolume);
            boundingVolume.center = new Cartesian3(0.0, boundingVolume.center.x, boundingVolume.center.y);

            if (frameState.mode === SceneMode.MORPHING) {
                boundingVolume = BoundingSphere.union(tile.boundingSphere3D, boundingVolume, boundingVolume);
            }
        }

        if (cullingVolume.getVisibility(boundingVolume) === Intersect.OUTSIDE) {
            return false;
        }

        if (frameState.mode === SceneMode.SCENE3D) {
            var occludeePointInScaledSpace = tile.occludeePointInScaledSpace;
            if (typeof occludeePointInScaledSpace === 'undefined') {
                return true;
            }

            return surface._ellipsoidalOccluder.isScaledSpacePointVisible(occludeePointInScaledSpace);
        }

        return true;
    }

    var southwestCornerScratch = new Cartesian3(0.0, 0.0, 0.0);
    var northeastCornerScratch = new Cartesian3(0.0, 0.0, 0.0);
    var negativeUnitY = Cartesian3.UNIT_Y.negate();
    var negativeUnitZ = Cartesian3.UNIT_Z.negate();
    var vectorScratch = new Cartesian3(0.0, 0.0, 0.0);

    function distanceSquaredToTile(frameState, cameraCartesianPosition, cameraCartographicPosition, tile) {
        var southwestCornerCartesian = tile.southwestCornerCartesian;
        var northeastCornerCartesian = tile.northeastCornerCartesian;
        var westNormal = tile.westNormal;
        var southNormal = tile.southNormal;
        var eastNormal = tile.eastNormal;
        var northNormal = tile.northNormal;
        var maxHeight = tile.maxHeight;

        if (frameState.mode !== SceneMode.SCENE3D) {
            southwestCornerCartesian = frameState.scene2D.projection.project(tile.extent.getSouthwest(), southwestCornerScratch);
            southwestCornerCartesian.z = southwestCornerCartesian.y;
            southwestCornerCartesian.y = southwestCornerCartesian.x;
            southwestCornerCartesian.x = 0.0;
            northeastCornerCartesian = frameState.scene2D.projection.project(tile.extent.getNortheast(), northeastCornerScratch);
            northeastCornerCartesian.z = northeastCornerCartesian.y;
            northeastCornerCartesian.y = northeastCornerCartesian.x;
            northeastCornerCartesian.x = 0.0;
            westNormal = negativeUnitY;
            eastNormal = Cartesian3.UNIT_Y;
            southNormal = negativeUnitZ;
            northNormal = Cartesian3.UNIT_Z;
            maxHeight = 0.0;
        }

        var vectorFromSouthwestCorner = cameraCartesianPosition.subtract(southwestCornerCartesian, vectorScratch);
        var distanceToWestPlane = vectorFromSouthwestCorner.dot(westNormal);
        var distanceToSouthPlane = vectorFromSouthwestCorner.dot(southNormal);

        var vectorFromNortheastCorner = cameraCartesianPosition.subtract(northeastCornerCartesian, vectorScratch);
        var distanceToEastPlane = vectorFromNortheastCorner.dot(eastNormal);
        var distanceToNorthPlane = vectorFromNortheastCorner.dot(northNormal);

        var cameraHeight;
        if (frameState.mode === SceneMode.SCENE3D) {
            cameraHeight = cameraCartographicPosition.height;
        } else {
            cameraHeight = cameraCartesianPosition.x;
        }
        var distanceFromTop = cameraHeight - maxHeight;

        var result = 0.0;

        if (distanceToWestPlane > 0.0) {
            result += distanceToWestPlane * distanceToWestPlane;
        } else if (distanceToEastPlane > 0.0) {
            result += distanceToEastPlane * distanceToEastPlane;
        }

        if (distanceToSouthPlane > 0.0) {
            result += distanceToSouthPlane * distanceToSouthPlane;
        } else if (distanceToNorthPlane > 0.0) {
            result += distanceToNorthPlane * distanceToNorthPlane;
        }

        if (distanceFromTop > 0.0) {
            result += distanceFromTop * distanceFromTop;
        }

        return result;
    }

    function queueChildrenLoadAndDetermineIfChildrenAreAllRenderable(surface, frameState, tile) {
        if (tile.level === surface._terrainProvider.maxLevel) {
            return false;
        }

        var allRenderable = true;

        var children = tile.getChildren();
        for (var i = 0, len = children.length; i < len; ++i) {
            var child = children[i];
            surface._tileReplacementQueue.markTileRendered(child);
            if (!child.doneLoading) {
                queueTileLoad(surface, child);
            }
            if (!child.renderable) {
                allRenderable = false;
            }
        }

        return allRenderable;
    }

    function queueTileLoad(surface, tile) {
        surface._tileLoadQueue.insertBeforeInsertionPoint(tile);
    }

    function processTileLoadQueue(surface, context, frameState) {
        var tileLoadQueue = surface._tileLoadQueue;
        var terrainProvider = surface._terrainProvider;

        var tile = tileLoadQueue.head;
        if (typeof tile === 'undefined') {
            return;
        }

        var startTime = Date.now();
        var timeSlice = surface._loadQueueTimeSlice;
        var endTime = startTime + timeSlice;

        do {
            var i, len;

            // Transition terrain states.
            if (tile.state === TileState.UNLOADED) {
                tile.state = TileState.TRANSITIONING;
                terrainProvider.requestTileGeometry(tile);

                // If we've made it past the UNLOADED state, add this tile to the replacement queue
                // (replacing another tile if necessary), and create skeletons for the imagery.
                if (tile.state !== TileState.UNLOADED) {
                    surface._tileReplacementQueue.markTileRendered(tile);

                    // Arbitrarily limit the number of loaded tiles to 100, or however
                    // many tiles were traversed this frame, whichever is greater.
                    surface._tileReplacementQueue.trimTiles(100);

                    var imageryLayerCollection = surface._imageryLayerCollection;
                    for (i = 0, len = imageryLayerCollection.getLength(); i < len; ++i) {
                        var layer = imageryLayerCollection.get(i);
                        if (layer.show) {
                            layer._createTileImagerySkeletons(tile, terrainProvider);
                        }
                    }

                }
            }

            if (tile.state === TileState.RECEIVED) {
                tile.state = TileState.TRANSITIONING;
                terrainProvider.transformGeometry(context, tile);
            }

            if (tile.state === TileState.TRANSFORMED) {
                tile.state = TileState.TRANSITIONING;
                terrainProvider.createResources(context, tile);
            }
            // TODO: we should handle failed terrain.  But it doesn't matter for now
            //       because EllipsoidTerrainProvider won't fail.

            var doneLoading = tile.state === TileState.READY;

            var didSomeWork = false;

            // Transition imagery states
            var tileImageryCollection = tile.imagery;
            for (i = 0, len = tileImageryCollection.length; i < len; ++i) {
                if (didSomeWork && Date.now() >= endTime) {
                    break;
                }

                var tileImagery = tileImageryCollection[i];
                var imagery = tileImagery.imagery;
                var imageryLayer = imagery.imageryLayer;

                if (imagery.state === ImageryState.PLACEHOLDER) {
                    if (imageryLayer.getImageryProvider().isReady()) {
                        // Remove the placeholder and add the actual skeletons (if any)
                        // at the same position.  Then continue the loop at the same index.
                        tileImagery.freeResources();
                        tileImageryCollection.splice(i, 1);
                        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);
                        --i;
                        len = tileImageryCollection.length;
                    }
                    didSomeWork = true;
                }

                if (imagery.state === ImageryState.UNLOADED) {
                    imagery.state = ImageryState.TRANSITIONING;
                    imageryLayer._requestImagery(imagery);
                    didSomeWork = true;
                }

                if (imagery.state === ImageryState.RECEIVED) {
                    imagery.state = ImageryState.TRANSITIONING;
                    imageryLayer._createTexture(context, imagery);
                    didSomeWork = true;
                }

                if (imagery.state === ImageryState.TEXTURE_LOADED) {
                    imagery.state = ImageryState.TRANSITIONING;
                    imageryLayer._reprojectTexture(context, imagery);
                    didSomeWork = true;
                }

                if (imagery.state === ImageryState.FAILED || imagery.state === ImageryState.INVALID) {
                    // re-associate TileImagery with a parent Imagery that is not failed or invalid.
                    var parent = imagery.parent;
                    while (typeof parent !== 'undefined' && (parent.state === ImageryState.FAILED || parent.state === ImageryState.INVALID)) {
                        parent = parent.parent;
                    }

                    // If there's no valid parent, remove this TileImagery from the tile.
                    if (typeof parent === 'undefined') {
                        tileImagery.freeResources();
                        tileImageryCollection.splice(i, 1);
                        --i;
                        len = tileImageryCollection.length;
                        continue;
                    }

                    // use that parent imagery instead, storing the original imagery
                    // in originalImagery to keep it alive
                    tileImagery.originalImagery = imagery;

                    parent.addReference();
                    tileImagery.imagery = parent;
                    imagery = parent;

                    didSomeWork = true;
                }

                var imageryDoneLoading = imagery.state === ImageryState.READY;

                if (imageryDoneLoading && typeof tileImagery.textureTranslationAndScale === 'undefined') {
                    tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);

                    didSomeWork = true;
                }

                doneLoading = doneLoading && imageryDoneLoading;
            }

            // The tile becomes renderable when the terrain and all imagery data are loaded.
            if (i === len && doneLoading) {
                tile.renderable = true;
                tile.doneLoading = true;
                tileLoadQueue.remove(tile);
            }

            tile = tile.loadNext;
        } while (Date.now() < endTime && typeof tile !== 'undefined');
    }

    // This is debug code to render the bounding sphere of the tile in
    // CentralBodySurface._debug.boundingSphereTile.
    CentralBodySurface.prototype.debugShowBoundingSphereOfTileAt = function(cartographicPick) {
        // Find the tile in the render list that overlaps this extent
        var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;
        var result;
        var tile;
        for (var i = 0; i < tilesToRenderByTextureCount.length && typeof result === 'undefined'; ++i) {
            var tileSet = tilesToRenderByTextureCount[i];
            if (typeof tileSet === 'undefined') {
                continue;
            }
            for (var j = 0; j < tileSet.length; ++j) {
                tile = tileSet[j];
                if (tile.extent.contains(cartographicPick)) {
                    result = tile;
                    break;
                }
            }
        }

        if (typeof result !== 'undefined') {
            console.log('x: ' + result.x + ' y: ' + result.y + ' level: ' + result.level);
        }

        this._debug.boundingSphereTile = result;
        this._debug.boundingSphereVA = undefined;
    };

    function debugCreateRenderCommandsForTileBoundingSphere(surface, context, frameState, centralBodyUniformMap, shaderSet, renderState, colorCommandList) {
        if (typeof surface._debug !== 'undefined' && typeof surface._debug.boundingSphereTile !== 'undefined') {
            if (!surface._debug.boundingSphereVA) {
                var radius = surface._debug.boundingSphereTile.boundingSphere3D.radius;
                var sphere = CubeMapEllipsoidTessellator.compute(new Ellipsoid(radius, radius, radius), 10);
                MeshFilters.toWireframeInPlace(sphere);
                surface._debug.boundingSphereVA = context.createVertexArrayFromMesh({
                    mesh : sphere,
                    attributeIndices : MeshFilters.createAttributeIndices(sphere)
                });
            }

            var rtc2 = surface._debug.boundingSphereTile.center;

            var uniformMap2 = createTileUniformMap();
            mergeUniformMap(uniformMap2, centralBodyUniformMap);

            uniformMap2.center3D = rtc2;

            var viewMatrix = frameState.camera.getViewMatrix();

            var centerEye2 = viewMatrix.multiplyByVector(new Cartesian4(rtc2.x, rtc2.y, rtc2.z, 1.0));
            uniformMap2.modifiedModelView = viewMatrix.setColumn(3, centerEye2, uniformMap2.modifiedModelView);

            uniformMap2.dayTextures[0] = context.getDefaultTexture();
            uniformMap2.dayTextureTranslationAndScale[0] = new Cartesian4(0.0, 0.0, 1.0, 1.0);
            uniformMap2.dayTextureTexCoordsExtent[0] = new Cartesian4(0.0, 0.0, 1.0, 1.0);
            uniformMap2.dayTextureAlpha[0] = 1.0;

            var boundingSphereCommand = new DrawCommand();
            boundingSphereCommand.shaderProgram = shaderSet.getShaderProgram(context, 1);
            boundingSphereCommand.renderState = renderState;
            boundingSphereCommand.primitiveType = PrimitiveType.LINES;
            boundingSphereCommand.vertexArray = surface._debug.boundingSphereVA;
            boundingSphereCommand.uniformMap = uniformMap2;

            colorCommandList.push(boundingSphereCommand);
        }
    }

    CentralBodySurface.prototype.debugToggleLodUpdate = function(frameState) {
        this._debug.suspendLodUpdate = !this._debug.suspendLodUpdate;
    };

    function tileDistanceSortFunction(a, b) {
        return a.distance - b.distance;
    }

    function createTileUniformMap() {
        return {
            u_center3D : function() {
                return this.center3D;
            },
            u_tileExtent : function() {
                return this.tileExtent;
            },
            u_modifiedModelView : function() {
                return this.modifiedModelView;
            },
            u_dayTextures : function() {
                return this.dayTextures;
            },
            u_dayTextureTranslationAndScale : function() {
                return this.dayTextureTranslationAndScale;
            },
            u_dayTextureTexCoordsExtent : function() {
                return this.dayTextureTexCoordsExtent;
            },
            u_dayTextureAlpha : function() {
                return this.dayTextureAlpha;
            },
            u_dayTextureBrightness : function() {
                return this.dayTextureBrightness;
            },
            u_dayTextureContrast : function() {
                return this.dayTextureContrast;
            },
            u_dayTextureOneOverGamma : function() {
                return this.dayTextureOneOverGamma;
            },
            u_dayIntensity : function() {
                return this.dayIntensity;
            },
            u_southAndNorthLatitude : function() {
                return this.southAndNorthLatitude;
            },
            u_southMercatorYLowAndHighAndOneOverHeight : function() {
               return this.southMercatorYLowAndHighAndOneOverHeight;
            },

            center3D : undefined,
            modifiedModelView : new Matrix4(),
            tileExtent : new Cartesian4(),

            dayTextures : [],
            dayTextureTranslationAndScale : [],
            dayTextureTexCoordsExtent : [],
            dayTextureAlpha : [],
            dayTextureBrightness : [],
            dayTextureContrast : [],
            dayTextureOneOverGamma : [],
            dayIntensity : 0.0,

            southAndNorthLatitude : new Cartesian2(0.0, 0.0),
            southMercatorYLowAndHighAndOneOverHeight : new Cartesian3(0.0, 0.0, 0.0)
        };
    }

    function mergeUniformMap(target, source) {
        for (var property in source) {
            if (source.hasOwnProperty(property)) {
                target[property] = source[property];
            }
        }
    }

    var float32ArrayScratch = typeof Float32Array !== 'undefined' ? new Float32Array(1) : undefined;
    var modifiedModelViewScratch = new Matrix4();
    var tileExtentScratch = new Cartesian4();
    var rtcScratch = new Cartesian3();
    var centerEyeScratch = new Cartesian4();

    function createRenderCommandsForSelectedTiles(surface, context, frameState, shaderSet, mode, projection, centralBodyUniformMap, colorCommandList, renderState) {
        var viewMatrix = frameState.camera.getViewMatrix();

        var maxTextures = context.getMaximumTextureImageUnits();

        var tileCommands = surface._tileCommands;
        var tileCommandUniformMaps = surface._tileCommandUniformMaps;
        var tileCommandIndex = -1;

        var tilesToRenderByTextureCount = surface._tilesToRenderByTextureCount;
        for (var tileSetIndex = 0, tileSetLength = tilesToRenderByTextureCount.length; tileSetIndex < tileSetLength; ++tileSetIndex) {
            var tileSet = tilesToRenderByTextureCount[tileSetIndex];
            if (typeof tileSet === 'undefined' || tileSet.length === 0) {
                continue;
            }

            tileSet.sort(tileDistanceSortFunction);

            var shaderProgram = shaderSet.getShaderProgram(context, tileSetIndex);

            for (var i = 0, len = tileSet.length; i < len; i++) {
                var tile = tileSet[i];

                var rtc = tile.center;

                // Not used in 3D.
                var tileExtent = tileExtentScratch;

                // Only used for Mercator projections.
                var southLatitude = 0.0;
                var northLatitude = 0.0;
                var southMercatorYHigh = 0.0;
                var southMercatorYLow = 0.0;
                var oneOverMercatorHeight = 0.0;

                if (mode !== SceneMode.SCENE3D) {
                    var southwest = projection.project(tile.extent.getSouthwest());
                    var northeast = projection.project(tile.extent.getNortheast());

                    tileExtent.x = southwest.x;
                    tileExtent.y = southwest.y;
                    tileExtent.z = northeast.x;
                    tileExtent.w = northeast.y;

                    // In 2D and Columbus View, use the center of the tile for RTC rendering.
                    if (mode !== SceneMode.MORPHING) {
                        rtc = rtcScratch;
                        rtc.x = 0.0;
                        rtc.y = (tileExtent.z + tileExtent.x) * 0.5;
                        rtc.z = (tileExtent.w + tileExtent.y) * 0.5;
                        tileExtent.x -= rtc.y;
                        tileExtent.y -= rtc.z;
                        tileExtent.z -= rtc.y;
                        tileExtent.w -= rtc.z;
                    }

                    if (projection instanceof WebMercatorProjection) {
                        southLatitude = tile.extent.south;
                        northLatitude = tile.extent.north;

                        var southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);
                        var northMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude);

                        float32ArrayScratch[0] = southMercatorY;
                        southMercatorYHigh = float32ArrayScratch[0];
                        southMercatorYLow = southMercatorY - float32ArrayScratch[0];

                        oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);
                    }
                }

                var centerEye = centerEyeScratch;
                centerEye.x = rtc.x;
                centerEye.y = rtc.y;
                centerEye.z = rtc.z;
                centerEye.w = 1.0;

                Matrix4.multiplyByVector(viewMatrix, centerEye, centerEye);
                viewMatrix.setColumn(3, centerEye, modifiedModelViewScratch);

                var tileImageryCollection = tile.imagery;
                var imageryIndex = 0;
                var imageryLen = tileImageryCollection.length;

                do {
                    var numberOfDayTextures = 0;

                    ++tileCommandIndex;
                    var command = tileCommands[tileCommandIndex];
                    if (typeof command === 'undefined') {
                        command = new DrawCommand();
                        tileCommands[tileCommandIndex] = command;
                        tileCommandUniformMaps[tileCommandIndex] = createTileUniformMap();
                    }
                    var uniformMap = tileCommandUniformMaps[tileCommandIndex];

                    mergeUniformMap(uniformMap, centralBodyUniformMap);

                    uniformMap.center3D = tile.center;

                    Cartesian4.clone(tileExtent, uniformMap.tileExtent);
                    uniformMap.southAndNorthLatitude.x = southLatitude;
                    uniformMap.southAndNorthLatitude.y = northLatitude;
                    uniformMap.southMercatorYLowAndHighAndOneOverHeight.x = southMercatorYLow;
                    uniformMap.southMercatorYLowAndHighAndOneOverHeight.y = southMercatorYHigh;
                    uniformMap.southMercatorYLowAndHighAndOneOverHeight.z = oneOverMercatorHeight;
                    Matrix4.clone(modifiedModelViewScratch, uniformMap.modifiedModelView);

                    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {
                        var tileImagery = tileImageryCollection[imageryIndex];
                        var imagery = tileImagery.imagery;
                        var imageryLayer = imagery.imageryLayer;
                        ++imageryIndex;

                        if (imagery.state !== ImageryState.READY) {
                            continue;
                        }

                        if (typeof tileImagery.textureTranslationAndScale === 'undefined') {
                            tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);
                        }

                        uniformMap.dayTextures[numberOfDayTextures] = imagery.texture;
                        uniformMap.dayTextureTranslationAndScale[numberOfDayTextures] = tileImagery.textureTranslationAndScale;
                        uniformMap.dayTextureTexCoordsExtent[numberOfDayTextures] = tileImagery.textureCoordinateExtent;

                        if (typeof imageryLayer.alpha === 'function') {
                            uniformMap.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha(frameState, imageryLayer, imagery.x, imagery.y, imagery.level);
                        } else {
                            uniformMap.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha;
                        }

                        if (typeof imageryLayer.brightness === 'function') {
                            uniformMap.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness(frameState, imageryLayer, imagery.x, imagery.y, imagery.level);
                        } else {
                            uniformMap.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness;
                        }

                        if (typeof imageryLayer.contrast === 'function') {
                            uniformMap.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast(frameState, imageryLayer, imagery.x, imagery.y, imagery.level);
                        } else {
                            uniformMap.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast;
                        }

                        if (typeof imageryLayer.gamma === 'function') {
                            uniformMap.dayTextureOneOverGamma[numberOfDayTextures] = 1.0 / imageryLayer.gamma(frameState, imageryLayer, imagery.x, imagery.y, imagery.level);
                        } else {
                            uniformMap.dayTextureOneOverGamma[numberOfDayTextures] = 1.0 / imageryLayer.gamma;
                        }

                        ++numberOfDayTextures;
                    }

                    // trim texture array to the used length so we don't end up using old textures
                    // which might get destroyed eventually
                    uniformMap.dayTextures.length = numberOfDayTextures;

                    colorCommandList.push(command);

                    command.shaderProgram = shaderProgram;
                    command.renderState = renderState;
                    command.primitiveType = TerrainProvider.wireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;
                    command.vertexArray = tile.vertexArray;
                    command.uniformMap = uniformMap;

                    var boundingVolume = tile.boundingSphere3D;

                    if (frameState.mode !== SceneMode.SCENE3D) {
                        // TODO: If we show terrain heights in Columbus View, the bounding sphere
                        //       needs to be expanded to include the heights.
                        boundingVolume = BoundingSphere.fromExtent2D(tile.extent, frameState.scene2D.projection);
                        boundingVolume.center = new Cartesian3(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y);

                        if (frameState.mode === SceneMode.MORPHING) {
                            boundingVolume = BoundingSphere.union(tile.boundingSphere3D, boundingVolume, boundingVolume);
                        }
                    }

                    command.boundingVolume = boundingVolume;

                } while (imageryIndex < imageryLen);
            }
        }

        // trim command list to the number actually needed
        tileCommands.length = Math.max(0, tileCommandIndex);
    }

    return CentralBodySurface;
});

/*global define*/
define('Scene/TilingScheme',[
        '../Core/DeveloperError',
        './Tile'
    ], function(
        DeveloperError,
        Tile) {
    

    /**
     * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
     * the coarsest, least-detailed level, the number of tiles is configurable.
     * At level of detail one, each of the level zero tiles has four children, two in each direction.
     * At level of detail two, each of the level one tiles has four children, two in each direction.
     * This continues for as many levels as are present in the geometry or imagery source.
     *
     * @alias TilingScheme
     * @constructor
     *
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     */
    var TilingScheme = function TilingScheme(description) {
        throw new DeveloperError('This type should not be instantiated directly.  Instead, use WebMercatorTilingScheme or GeographicTilingScheme.');
    };

    /**
     * Gets the ellipsoid that is tiled by this tiling scheme.
     *
     * @memberof TilingScheme
     *
     * @returns {Ellipsoid} The ellipsoid.
     */
    TilingScheme.prototype.getEllipsoid = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the extent, in radians, covered by this tiling scheme.
     *
     * @memberof TilingScheme
     *
     * @returns {Extent} The extent.
     */
    TilingScheme.prototype.getExtent = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the map projection used by this tiling scheme.
     *
     * @memberof TilingScheme
     *
     * @returns {Projection} The map projection.
     */
    TilingScheme.prototype.getProjection = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     *
     * @memberof TilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the X direction at the given level.
     */
    TilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     *
     * @memberof TilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the Y direction at the given level.
     */
    TilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Creates the tile or tiles at level of detail zero, the coarsest, least detailed level.
     *
     * @memberof TilingScheme
     *
     * @returns {Array} An array containing the tiles at level of detail zero, starting with the
     * tile in the northwest corner and followed by the tile (if any) to its east.
     */
    TilingScheme.prototype.createLevelZeroTiles = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Transforms an extent specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     *
     * @memberof TilingScheme
     *
     * @param {Extent} extent The extent to transform.
     * @param {Extent} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns {Extent} The specified 'result', or a new object containing the native extent if 'result'
     *          is undefined.
     */
    TilingScheme.prototype.extentToNativeExtent = function(extent, result) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Converts tile x, y coordinates and level to an extent expressed in the native coordinates
     * of the tiling scheme.
     *
     * @memberof TilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    TilingScheme.prototype.tileXYToNativeExtent = function(x, y, level, result) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Converts tile x, y coordinates and level to a cartographic extent in radians.
     *
     * @memberof TilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    TilingScheme.prototype.tileXYToExtent = function(x, y, level, result) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     *
     * @memberof TilingScheme
     *
     * @param {Cartographic} position The position.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Cartesian} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    TilingScheme.prototype.positionToTileXY = function(position, level, result) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Creates a rectangular set of tiles for level of detail zero, the coarsest, least detailed level.
     *
     * @memberof TilingScheme
     *
     * @param {TilingScheme} tilingScheme The tiling scheme for which the tiles are to be created.
     * @param {Number} numberOfLevelZeroTilesX The number of tiles in the X direction at level zero of
     *        the tile tree.
     * @param {Number} numberOfLevelZeroTilesY The number of tiles in the Y direction at level zero of
     *        the tile tree.
     * @returns {Array} An array containing the tiles at level of detail zero, starting with the
     * tile in the northwest corner and followed by the tile (if any) to its east.
     *
     * @exception {DeveloperError} <code>tilingScheme</code> is required.
     * @exception {DeveloperError} <code>numberOfLevelZeroTilesX</code> is required.
     * @exception {DeveloperError} <code>numberOfLevelZeroTilesY</code> is required.
     */
    TilingScheme.createRectangleOfLevelZeroTiles = function(tilingScheme, numberOfLevelZeroTilesX, numberOfLevelZeroTilesY) {
        if (typeof tilingScheme === 'undefined') {
            throw new DeveloperError('tilingScheme is required.');
        }
        if (typeof numberOfLevelZeroTilesX === 'undefined') {
            throw new DeveloperError('numberOfLevelZeroTilesX is required.');
        }
        if (typeof numberOfLevelZeroTilesY === 'undefined') {
            throw new DeveloperError('numberOfLevelZeroTilesY is required.');
        }

        var result = new Array(numberOfLevelZeroTilesX * numberOfLevelZeroTilesY);

        var index = 0;
        for (var y = 0; y < numberOfLevelZeroTilesY; ++y) {
            for (var x = 0; x < numberOfLevelZeroTilesX; ++x) {
                result[index++] = new Tile({
                    tilingScheme : tilingScheme,
                    x : x,
                    y : y,
                    level : 0
                });
            }
        }

        return result;
    };

    return TilingScheme;
});
/*global define*/
define('Scene/GeographicTilingScheme',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/Cartesian2',
        '../Core/Ellipsoid',
        '../Core/Extent',
        '../Core/GeographicProjection',
        './TilingScheme'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Cartesian2,
        Ellipsoid,
        Extent,
        GeographicProjection,
        TilingScheme) {
    

    /**
     * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
     * longitude and latitude are directly mapped to X and Y.  This projection is commonly
     * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
     *
     * @alias GeographicTilingScheme
     * @constructor
     *
     * @param {Ellipsoid} [description.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to
     * the WGS84 ellipsoid.
     * @param {Extent} [description.extent=Extent.MAX_VALUE] The extent, in radians, covered by the tiling scheme.
     * @param {Number} [description.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of
     * the tile tree.
     * @param {Number} [description.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of
     * the tile tree.
     */
    var GeographicTilingScheme = function GeographicTilingScheme(description) {
        description = defaultValue(description, {});

        this._ellipsoid = defaultValue(description.ellipsoid, Ellipsoid.WGS84);
        this._extent = defaultValue(description.extent, Extent.MAX_VALUE);
        this._projection = new GeographicProjection(this._ellipsoid);
        this._numberOfLevelZeroTilesX = defaultValue(description.numberOfLevelZeroTilesX, 2);
        this._numberOfLevelZeroTilesY = defaultValue(description.numberOfLevelZeroTilesY, 1);
    };

    /**
     * Gets the ellipsoid that is tiled by this tiling scheme.
     *
     * @memberof GeographicTilingScheme
     *
     * @returns {Ellipsoid} The ellipsoid.
     */
    GeographicTilingScheme.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Gets the extent, in radians, covered by this tiling scheme.
     *
     * @memberof GeographicTilingScheme
     *
     * @returns {Extent} The extent.
     */
    GeographicTilingScheme.prototype.getExtent = function() {
        return this._extent;
    };

    /**
     * Gets the map projection used by this tiling scheme.
     *
     * @memberof GeographicTilingScheme
     *
     * @returns {Projection} The map projection.
     */
    GeographicTilingScheme.prototype.getProjection = function() {
        return this._projection;
    };

    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the X direction at the given level.
     */
    GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
        return this._numberOfLevelZeroTilesX << level;
    };

    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the Y direction at the given level.
     */
    GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
        return this._numberOfLevelZeroTilesY << level;
    };

    /**
     * Creates the tile or tiles at level of detail zero, the coarsest, least detailed level.
     *
     * @memberof GeographicTilingScheme
     *
     * @return {Array} An array containing the tiles at level of detail zero, starting with the
     * tile in the northwest corner of the globe and followed by the tile (if any) to its east.
     */
    GeographicTilingScheme.prototype.createLevelZeroTiles = function() {
        return TilingScheme.createRectangleOfLevelZeroTiles(this, this._numberOfLevelZeroTilesX, this._numberOfLevelZeroTilesY);
    };

    /**
     * Transforms an extent specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Extent} extent The extent to transform.
     * @param {Extent} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns {Extent} The specified 'result', or a new object containing the native extent if 'result'
     *          is undefined.
     *
     * @exception {DeveloperError} <code>extent</code> is required.
     */
    GeographicTilingScheme.prototype.extentToNativeExtent = function(extent, result) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        var west = CesiumMath.toDegrees(extent.west);
        var south = CesiumMath.toDegrees(extent.south);
        var east = CesiumMath.toDegrees(extent.east);
        var north = CesiumMath.toDegrees(extent.north);

        if (typeof result === 'undefined') {
            return new Extent(west, south, east, north);
        }

        result.west = west;
        result.south = south;
        result.east = east;
        result.north = north;
        return result;
    };

    /**
     * Converts tile x, y coordinates and level to an extent expressed in the native coordinates
     * of the tiling scheme.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    GeographicTilingScheme.prototype.tileXYToNativeExtent = function(x, y, level, result) {
        var extentRadians = this.tileXYToExtent(x, y, level, result);
        extentRadians.west = CesiumMath.toDegrees(extentRadians.west);
        extentRadians.south = CesiumMath.toDegrees(extentRadians.south);
        extentRadians.east = CesiumMath.toDegrees(extentRadians.east);
        extentRadians.north = CesiumMath.toDegrees(extentRadians.north);
        return extentRadians;
    };

    /**
     * Converts tile x, y coordinates and level to a cartographic extent in radians.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    GeographicTilingScheme.prototype.tileXYToExtent = function(x, y, level, result) {
        var extent = this._extent;

        var xTiles = this.getNumberOfXTilesAtLevel(level);
        var yTiles = this.getNumberOfYTilesAtLevel(level);

        var xTileWidth = (extent.east - extent.west) / xTiles;
        var west = x * xTileWidth + extent.west;
        var east = (x + 1) * xTileWidth + extent.west;

        var yTileHeight = (extent.north - extent.south) / yTiles;
        var north = extent.north - y * yTileHeight;
        var south = extent.north - (y + 1) * yTileHeight;

        if (typeof result === 'undefined') {
            result = new Extent(west, south, east, north);
        }

        result.west = west;
        result.south = south;
        result.east = east;
        result.north = north;
        return result;
    };

    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Cartographic} position The position.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Cartesian} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {
        var extent = this._extent;
        if (position.latitude > extent.north ||
            position.latitude < extent.south ||
            position.longitude < extent.west ||
            position.longitude > extent.east) {
            // outside the bounds of the tiling scheme
            return undefined;
        }

        var xTiles = this.getNumberOfXTilesAtLevel(level);
        var yTiles = this.getNumberOfYTilesAtLevel(level);

        var xTileWidth = (extent.east - extent.west) / xTiles;
        var yTileHeight = (extent.north - extent.south) / yTiles;

        var xTileCoordinate = (position.longitude - extent.west) / xTileWidth | 0;
        if (xTileCoordinate >= xTiles) {
            xTileCoordinate = xTiles - 1;
        }

        var yTileCoordinate = (extent.north - position.latitude) / yTileHeight | 0;
        if (yTileCoordinate >= yTiles) {
            yTileCoordinate = yTiles - 1;
        }

        if (typeof result === 'undefined') {
            return new Cartesian2(xTileCoordinate, yTileCoordinate);
        }

        result.x = xTileCoordinate;
        result.y = yTileCoordinate;
        return result;
    };

    return GeographicTilingScheme;
});
/*global define*/
define('Scene/VerticalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The vertical location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the vertical origin is used to display a billboard above or below (in
     * screen space) of the actual position.
     *
     * @exports VerticalOrigin
     *
     * @see Billboard#setVerticalOrigin
     */
    var VerticalOrigin = {
        /**
         * The origin is at the vertical center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, 'CENTER'),
        /**
         * The origin is at the bottom of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        BOTTOM : new Enumeration(1, 'BOTTOM'),
        /**
         * The origin is at the top of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        TOP : new Enumeration(-1, 'TOP')
    };

    return VerticalOrigin;
});
/*global define*/
define('DynamicScene/CzmlVerticalOrigin',[
        '../Scene/VerticalOrigin'
       ], function(
         VerticalOrigin) {
    

    /**
     * Provides methods for working with a vertical origin defined in CZML.
     *
     * @exports CzmlVerticalOrigin
     *
     * @see VerticalOrigin
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     */
    var CzmlVerticalOrigin = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.verticalOrigin;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the VerticalOrigin contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlVerticalOrigin.unwrapInterval.
         * @returns The VerticalOrigin value.
         */
        getValue : function(unwrappedInterval) {
            return VerticalOrigin[unwrappedInterval];
        }
    };

    return CzmlVerticalOrigin;
});
/*global define*/
define('DynamicScene/DynamicLabel',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlCartesian2',
        './CzmlCartesian3',
        './CzmlNumber',
        './CzmlString',
        './CzmlHorizontalOrigin',
        './CzmlVerticalOrigin',
        './CzmlLabelStyle',
        './CzmlColor',
        './DynamicProperty'
       ], function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlCartesian2,
        CzmlCartesian3,
        CzmlNumber,
        CzmlString,
        CzmlHorizontalOrigin,
        CzmlVerticalOrigin,
        CzmlLabelStyle,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic label, typically used in conjunction with DynamicLabelVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicLabel
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicLabelVisualizer
     * @see VisualizerCollection
     * @see Label
     * @see LabelCollection
     * @see CzmlDefaults
     */
    var DynamicLabel = function() {
        /**
         * A DynamicProperty of type CzmlString which determines the label's text.
         * @type DynamicProperty
         */
        this.text = undefined;
        /**
         * A DynamicProperty of type CzmlString which determines the label's font.
         * @type DynamicProperty
         */
        this.font = undefined;
        /**
         * A DynamicProperty of type CzmlLabelStyle which determines the label's style.
         * @type DynamicProperty
         */
        this.style = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the label's fill color.
         * @type DynamicProperty
         */
        this.fillColor = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the label's outline color.
         * @type DynamicProperty
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlHorizontalOrigin which determines the label's horizontal origin.
         * @type DynamicProperty
         */
        this.horizontalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlVerticalOrigin which determines the label's vertical origin.
         * @type DynamicProperty
         */
        this.verticalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian3 which determines the label's eye offset.
         * @type DynamicProperty
         */
        this.eyeOffset = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian2 which determines the label's pixel offset.
         * @type DynamicProperty
         */
        this.pixelOffset = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the label's scale.
         * @type DynamicProperty
         */
        this.scale = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the label's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's label.
     * If the DynamicObject does not have a label, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the label data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicLabel.processCzmlPacket = function(dynamicObject, packet) {
        var labelData = packet.label;
        if (typeof labelData === 'undefined') {
            return false;
        }

        var labelUpdated = false;
        var label = dynamicObject.label;
        labelUpdated = typeof label === 'undefined';
        if (labelUpdated) {
            dynamicObject.label = label = new DynamicLabel();
        }

        var interval = labelData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof labelData.fillColor !== 'undefined') {
            var fillColor = label.fillColor;
            if (typeof fillColor === 'undefined') {
                label.fillColor = fillColor = new DynamicProperty(CzmlColor);
                labelUpdated = true;
            }
            fillColor.processCzmlIntervals(labelData.fillColor, interval);
        }

        if (typeof labelData.outlineColor !== 'undefined') {
            var outlineColor = label.outlineColor;
            if (typeof outlineColor === 'undefined') {
                label.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                labelUpdated = true;
            }
            outlineColor.processCzmlIntervals(labelData.outlineColor, interval);
        }

        if (typeof labelData.eyeOffset !== 'undefined') {
            var eyeOffset = label.eyeOffset;
            if (typeof eyeOffset === 'undefined') {
                label.eyeOffset = eyeOffset = new DynamicProperty(CzmlCartesian3);
                labelUpdated = true;
            }
            eyeOffset.processCzmlIntervals(labelData.eyeOffset, interval);
        }

        if (typeof labelData.horizontalOrigin !== 'undefined') {
            var horizontalOrigin = label.horizontalOrigin;
            if (typeof horizontalOrigin === 'undefined') {
                label.horizontalOrigin = horizontalOrigin = new DynamicProperty(CzmlHorizontalOrigin);
                labelUpdated = true;
            }
            horizontalOrigin.processCzmlIntervals(labelData.horizontalOrigin, interval);
        }

        if (typeof labelData.text !== 'undefined') {
            var text = label.text;
            if (typeof text === 'undefined') {
                label.text = text = new DynamicProperty(CzmlString);
                labelUpdated = true;
            }
            text.processCzmlIntervals(labelData.text, interval);
        }

        if (typeof labelData.pixelOffset !== 'undefined') {
            var pixelOffset = label.pixelOffset;
            if (typeof pixelOffset === 'undefined') {
                label.pixelOffset = pixelOffset = new DynamicProperty(CzmlCartesian2);
                labelUpdated = true;
            }
            pixelOffset.processCzmlIntervals(labelData.pixelOffset, interval);
        }

        if (typeof labelData.scale !== 'undefined') {
            var scale = label.scale;
            if (typeof scale === 'undefined') {
                label.scale = scale = new DynamicProperty(CzmlNumber);
                labelUpdated = true;
            }
            scale.processCzmlIntervals(labelData.scale, interval);
        }

        if (typeof labelData.show !== 'undefined') {
            var show = label.show;
            if (typeof show === 'undefined') {
                label.show = show = new DynamicProperty(CzmlBoolean);
                labelUpdated = true;
            }
            show.processCzmlIntervals(labelData.show, interval);
        }

        if (typeof labelData.verticalOrigin !== 'undefined') {
            var verticalOrigin = label.verticalOrigin;
            if (typeof verticalOrigin === 'undefined') {
                label.verticalOrigin = verticalOrigin = new DynamicProperty(CzmlVerticalOrigin);
                labelUpdated = true;
            }
            verticalOrigin.processCzmlIntervals(labelData.verticalOrigin, interval);
        }

        if (typeof labelData.font !== 'undefined') {
            var font = label.font;
            if (typeof font === 'undefined') {
                label.font = font = new DynamicProperty(CzmlString);
                labelUpdated = true;
            }
            font.processCzmlIntervals(labelData.font, interval);
        }

        if (typeof labelData.style !== 'undefined') {
            var style = label.style;
            if (typeof style === 'undefined') {
                label.style = style = new DynamicProperty(CzmlLabelStyle);
                labelUpdated = true;
            }
            style.processCzmlIntervals(labelData.style, interval);
        }
        return labelUpdated;
    };

    /**
     * Given two DynamicObjects, takes the label properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicLabel.mergeProperties = function(targetObject, objectToMerge) {
        var labelToMerge = objectToMerge.label;
        if (typeof labelToMerge !== 'undefined') {

            var targetLabel = targetObject.label;
            if (typeof targetLabel === 'undefined') {
                targetObject.label = targetLabel = new DynamicLabel();
            }

            targetLabel.text = defaultValue(targetLabel.text, labelToMerge.text);
            targetLabel.font = defaultValue(targetLabel.font, labelToMerge.font);
            targetLabel.show = defaultValue(targetLabel.show, labelToMerge.show);
            targetLabel.style = defaultValue(targetLabel.style, labelToMerge.style);
            targetLabel.fillColor = defaultValue(targetLabel.fillColor, labelToMerge.fillColor);
            targetLabel.outlineColor = defaultValue(targetLabel.outlineColor, labelToMerge.outlineColor);
            targetLabel.scale = defaultValue(targetLabel.scale, labelToMerge.scale);
            targetLabel.horizontalOrigin = defaultValue(targetLabel.horizontalOrigin, labelToMerge.horizontalOrigin);
            targetLabel.verticalOrigin = defaultValue(targetLabel.verticalOrigin, labelToMerge.verticalOrigin);
            targetLabel.eyeOffset = defaultValue(targetLabel.eyeOffset, labelToMerge.eyeOffset);
            targetLabel.pixelOffset = defaultValue(targetLabel.pixelOffset, labelToMerge.pixelOffset);
        }
    };

    /**
     * Given a DynamicObject, undefines the label associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the label from.
     *
     * @see CzmlDefaults
     */
    DynamicLabel.undefineProperties = function(dynamicObject) {
        dynamicObject.label = undefined;
    };

    return DynamicLabel;
});
/*global define*/
define('Scene/Billboard',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Math',
        './HorizontalOrigin',
        './VerticalOrigin',
        './SceneMode'
    ], function(
        defaultValue,
        DeveloperError,
        Color,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        CesiumMath,
        HorizontalOrigin,
        VerticalOrigin,
        SceneMode) {
    

    var EMPTY_OBJECT = {};

    /**
     * A viewport-aligned image positioned in the 3D scene, that is created
     * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
     * properties are set by calling {@link BillboardCollection#add}.  Any of the billboard's
     * properties can be changed at any time by calling the billboard's corresponding
     * <code>set</code> function, e.g., {@link Billboard#setShow}.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.png' width='400' height='300' /><br />
     * Example billboards
     * </div>
     *
     * @alias Billboard
     *
     * @performance Calling any <code>get</code> function, e.g., {@link Billboard#getShow}, is constant time.
     * Calling a <code>set</code> function, e.g., {@link Billboard#setShow}, is constant time but results in
     * CPU to GPU traffic when {@link BillboardCollection#update} is called.  The per-billboard traffic is
     * the same regardless of how many properties were updated.  If most billboards in a collection need to be
     * updated, it may be more efficient to clear the collection with {@link BillboardCollection#removeAll}
     * and add new billboards instead of modifying each one.
     *
     * @see BillboardCollection
     * @see BillboardCollection#add
     * @see Label
     *
     * @internalConstructor
     */
    var Billboard = function(description, billboardCollection) {
        description = defaultValue(description, EMPTY_OBJECT);

        this._show = defaultValue(description.show, true);

        this._position = Cartesian3.clone(defaultValue(description.position, Cartesian3.ZERO));
        this._actualPosition = this._position.clone(); // For columbus view and 2D

        this._pixelOffset = Cartesian2.clone(defaultValue(description.pixelOffset, Cartesian2.ZERO));
        this._eyeOffset = Cartesian3.clone(defaultValue(description.eyeOffset, Cartesian3.ZERO));
        this._verticalOrigin = defaultValue(description.verticalOrigin, VerticalOrigin.CENTER);
        this._horizontalOrigin = defaultValue(description.horizontalOrigin, HorizontalOrigin.CENTER);
        this._scale = defaultValue(description.scale, 1.0);
        this._imageIndex = defaultValue(description.imageIndex, -1);
        this._color = Color.clone(defaultValue(description.color, Color.WHITE));

        this._pickId = undefined;
        this._pickIdThis = description._pickIdThis;
        this._billboardCollection = billboardCollection;
        this._dirty = false;
        this._index = -1; //Used only by BillboardCollection
    };

    var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
    var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
    var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
    var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
    Billboard.NUMBER_OF_PROPERTIES = 9;

    function makeDirty(billboard, propertyChanged) {
        var billboardCollection = billboard._billboardCollection;
        if (typeof billboardCollection !== 'undefined') {
            billboardCollection._updateBillboard(billboard, propertyChanged);
            billboard._dirty = true;
        }
    }

    Billboard.prototype.getPickId = function(context) {
        this._pickId = this._pickId || context.createPickId(this._pickIdThis || this);
        return this._pickId;
    };

    /**
     * Returns true if this billboard will be shown.  Call {@link Billboard#setShow}
     * to hide or show a billboard, instead of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @return {Boolean} <code>true</code> if this billboard will be shown; otherwise, <code>false</code>.
     *
     * @see Billboard#setShow
     */
    Billboard.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this billboard will be shown.  Call this to hide or show a billboard, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @param {Boolean} value Indicates if this billboard will be shown.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getShow
     */
    Billboard.prototype.setShow = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (value !== this._show) {
            this._show = value;
            makeDirty(this, SHOW_INDEX);
        }
    };

    /**
     * Returns the Cartesian position of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The Cartesian position of this billboard.
     *
     * @see Billboard#setPosition
     */
    Billboard.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this billboard.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the billboard's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getPosition
     *
     * @example
     * // Example 1. Set a billboard's position using a Cartesian3.
     * b.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * // Example 2. Set a billboard's position using an object literal.
     * b.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0
     * });
     */
    Billboard.prototype.setPosition = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var position = this._position;
        if (!Cartesian3.equals(position, value)) {
            Cartesian3.clone(value, position);
            Cartesian3.clone(value, this._actualPosition);

            makeDirty(this, POSITION_INDEX);
        }
    };

    Billboard.prototype._getActualPosition = function() {
        return this._actualPosition;
    };

    Billboard.prototype._setActualPosition = function(value) {
        Cartesian3.clone(value, this._actualPosition);
        makeDirty(this, POSITION_INDEX);
    };

    /**
     * Returns the pixel offset from the origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian2} The pixel offset of this billboard.
     *
     * @see Billboard#setPixelOffset
     */
    Billboard.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
     * to align multiple billboards and labels at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the billboard's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>b.setPixelOffset({ x : 50, y : -25 });</code><br/><img src='images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The billboard's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getPixelOffset
     * @see Label#setPixelOffset
     */
    Billboard.prototype.setPixelOffset = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var pixelOffset = this._pixelOffset;
        if (!Cartesian2.equals(pixelOffset, value)) {
            Cartesian2.clone(value, pixelOffset);
            makeDirty(this, PIXEL_OFFSET_INDEX);
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @see Billboard#setEyeOffset
     */
    Billboard.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
     * arrange a billboard above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the billboard's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>b.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getEyeOffset
     */
    Billboard.prototype.setEyeOffset = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var eyeOffset = this._eyeOffset;
        if (!Cartesian3.equals(eyeOffset, value)) {
            Cartesian3.clone(value, eyeOffset);
            makeDirty(this, EYE_OFFSET_INDEX);
        }
    };

    /**
     * Returns the horizontal origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {HorizontalOrigin} The horizontal origin of this billboard.
     *
     * @see Billboard#setHorizontalOrigin
     */
    Billboard.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this billboard, which determines if the billboard is
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getHorizontalOrigin
     * @see Billboard#setVerticalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setHorizontalOrigin = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._horizontalOrigin !== value) {
            this._horizontalOrigin = value;
            makeDirty(this, HORIZONTAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the vertical origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {VerticalOrigin} The vertical origin of this billboard.
     *
     * @see Billboard#setVerticalOrigin
     */
    Billboard.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this billboard, which determines if the billboard is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getVerticalOrigin
     * @see Billboard#setHorizontalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setVerticalOrigin = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._verticalOrigin !== value) {
            this._verticalOrigin = value;
            makeDirty(this, VERTICAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the billboard's image size in pixels.
     *
     * @memberof Billboard
     *
     * @return {Number} The scale used to size the billboard.
     *
     * @see Billboard#setScale
     */
    Billboard.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the billboard's image size in pixels.
     * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
     * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
     * the billboard.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Number} value The scale used to size the billboard.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getScale
     * @see Billboard#setImageIndex
     */
    Billboard.prototype.setScale = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._scale !== value) {
            this._scale = value;
            makeDirty(this, SCALE_INDEX);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#setImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.getImageIndex = function() {
        return this._imageIndex;
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#getImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.setImageIndex = function(value) {
        if (typeof value !== 'number') {
            throw new DeveloperError('value is required and must be a number.');
        }

        if (this._imageIndex !== value) {
            this._imageIndex = value;
            makeDirty(this, IMAGE_INDEX_INDEX);
        }
    };

    /**
     * Returns the color that is multiplied with the billboard's texture.  The red, green, blue, and alpha values
     * are indicated by the returned object's <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>
     * properties, which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @return {Number} The color that is multiplied with the billboard's texture.
     *
     * @see Billboard#setColor
     */
    Billboard.prototype.getColor = function() {
        return this._color;
    };

    /**
     * Sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
     * the same white texture may be used by many different billboards, each with a different color, to create
     * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
     * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
     * <td align='center'><code>alpha : 0.5</code><br/><img src='images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
     * </tr></table>
     * </div>
     * <br />
     * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
     * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
     * (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @param {Object} value The color's red, green, blue, and alpha components.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Billboard#getColor
     *
     * @example
     * // Example 1. Assign yellow.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 0.0,
     *   alpha : 1.0
     * });
     *
     * // Example 2. Make a billboard 50% translucent.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 1.0,
     *   alpha : 0.5
     * });
     */
    Billboard.prototype.setColor = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var color = this._color;
        if (!Color.equals(color, value)) {
            Color.clone(value, color);
            makeDirty(this, COLOR_INDEX);
        }
    };

    var tempCartesian4 = new Cartesian4();
    Billboard._computeActualPosition = function(position, frameState, morphTime, modelMatrix) {
        var mode = frameState.mode;

        if (mode === SceneMode.SCENE3D) {
            return position;
        }

        var projection = frameState.scene2D.projection;
        var cartographic, projectedPosition;

        modelMatrix.multiplyByPoint(position, tempCartesian4);

        if (mode === SceneMode.MORPHING) {
            cartographic = projection.getEllipsoid().cartesianToCartographic(tempCartesian4);
            projectedPosition = projection.project(cartographic);

            var x = CesiumMath.lerp(projectedPosition.z, tempCartesian4.x, morphTime);
            var y = CesiumMath.lerp(projectedPosition.x, tempCartesian4.y, morphTime);
            var z = CesiumMath.lerp(projectedPosition.y, tempCartesian4.z, morphTime);
            return new Cartesian3(x, y, z);
        }

        cartographic = projection.getEllipsoid().cartesianToCartographic(tempCartesian4);
        projectedPosition = projection.project(cartographic);

        if (mode === SceneMode.SCENE2D) {
            return new Cartesian3(0.0, projectedPosition.x, projectedPosition.y);
        } else if (mode === SceneMode.COLUMBUS_VIEW) {
            return new Cartesian3(projectedPosition.z, projectedPosition.x, projectedPosition.y);
        }
    };

    Billboard._computeScreenSpacePosition = function(modelMatrix, position, eyeOffset, pixelOffset, clampToPixel, uniformState) {
        // This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl

        // Model to eye coordinates
        var mv = uniformState.getView().multiply(modelMatrix);
        var positionEC = mv.multiplyByPoint(position);

        // Apply eye offset, e.g., czm_eyeOffset
        var zEyeOffset = eyeOffset.multiplyComponents(positionEC.normalize());
        positionEC.x += eyeOffset.x + zEyeOffset.x;
        positionEC.y += eyeOffset.y + zEyeOffset.y;
        positionEC.z += zEyeOffset.z;

        // Eye to window coordinates, e.g., czm_eyeToWindowCoordinates
        var q = uniformState.getProjection().multiplyByVector(positionEC); // clip coordinates
        q.x /= q.w; // normalized device coordinates
        q.y /= q.w;
        q.z /= q.w;
        var positionWC = uniformState.getViewportTransformation().multiplyByPoint(q); // window coordinates

        // Apply pixel offset
        var po = pixelOffset.multiplyByScalar(uniformState.getHighResolutionSnapScale());
        positionWC.x += po.x;
        positionWC.y += po.y;

        if (clampToPixel) {
            return new Cartesian2(Math.floor(positionWC.x), Math.floor(positionWC.y));
        }

        return new Cartesian2(positionWC.x, positionWC.y);
    };

    /**
     * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Billboard
     *
     * @param {UniformState} uniformState The same state object passed to {@link BillboardCollection#update}.
     *
     * @return {Cartesian2} The screen-space position of the billboard.
     *
     * @exception {DeveloperError} Billboard must be in a collection.
     * @exception {DeveloperError} uniformState is required.
     *
     * @see Billboard#setEyeOffset
     * @see Billboard#setPixelOffset
     *
     * @example
     * console.log(b.computeScreenSpacePosition(scene.getUniformState()).toString());
     */
    Billboard.prototype.computeScreenSpacePosition = function(uniformState) {
        var billboardCollection = this._billboardCollection;
        if (typeof billboardCollection === 'undefined') {
            throw new DeveloperError('Billboard must be in a collection.  Was it removed?');
        }

        if (!uniformState) {
            throw new DeveloperError('uniformState is required.');
        }

        return Billboard._computeScreenSpacePosition(billboardCollection.modelMatrix, this._actualPosition, this._eyeOffset, this._pixelOffset, this.clampToPixel, uniformState);
    };

    /**
     * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
     * are equal.  Billboards in different collections can be equal.
     *
     * @memberof Billboard
     *
     * @param {Billboard} other The billboard to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
     */
    Billboard.prototype.equals = function(other) {
        return this === other ||
               typeof other !== 'undefined' &&
               this._show === other._show &&
               this._imageIndex === other._imageIndex &&
               this._scale === other._scale &&
               this._verticalOrigin === other._verticalOrigin &&
               this._horizontalOrigin === other._horizontalOrigin &&
               Cartesian3.equals(this._position, other._position) &&
               Color.equals(this._color, other._color) &&
               Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&
               Cartesian3.equals(this._eyeOffset, other._eyeOffset);
    };

    Billboard.prototype._destroy = function() {
        this._pickId = this._pickId && this._pickId.destroy();
        this._billboardCollection = undefined;
    };

    return Billboard;
});
/*global define*/
define('Scene/Label',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Color',
        './Billboard',
        './LabelStyle',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        defaultValue,
        DeveloperError,
        Cartesian2,
        Cartesian3,
        Color,
        Billboard,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    

    var EMPTY_OBJECT = {};

    function rebindAllGlyphs(label) {
        if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
            // only push label if it's not already been marked dirty
            label._labelCollection._labelsToUpdate.push(label);
        }
        label._rebindAllGlyphs = true;
    }

    function repositionAllGlyphs(label) {
        if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
            // only push label if it's not already been marked dirty
            label._labelCollection._labelsToUpdate.push(label);
        }
        label._repositionAllGlyphs = true;
    }

    /**
     * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor
     * should not be used directly, instead create labels by calling {@link LabelCollection#add}.
     *
     * @alias Label
     * @internalConstructor
     *
     * @see LabelCollection
     * @see LabelCollection#add
     */
    var Label = function(description, labelCollection, index) {
        description = defaultValue(description, EMPTY_OBJECT);

        this._text = defaultValue(description.text, '');
        this._show = defaultValue(description.show, true);
        this._font = defaultValue(description.font, '30px sans-serif');
        this._fillColor = Color.clone(defaultValue(description.fillColor, Color.WHITE));
        this._outlineColor = Color.clone(defaultValue(description.outlineColor, Color.BLACK));
        this._style = defaultValue(description.style, LabelStyle.FILL);
        this._verticalOrigin = defaultValue(description.verticalOrigin, VerticalOrigin.BOTTOM);
        this._horizontalOrigin = defaultValue(description.horizontalOrigin, HorizontalOrigin.LEFT);
        this._pixelOffset = Cartesian2.clone(defaultValue(description.pixelOffset, Cartesian2.ZERO));
        this._eyeOffset = Cartesian3.clone(defaultValue(description.eyeOffset, Cartesian3.ZERO));
        this._position = Cartesian3.clone(defaultValue(description.position, Cartesian3.ZERO));
        this._scale = defaultValue(description.scale, 1.0);

        this._labelCollection = labelCollection;
        this._index = index;
        this._glyphs = [];

        this._rebindAllGlyphs = true;
        this._repositionAllGlyphs = true;
    };

    /**
     * Returns true if this label will be shown.  Call {@link Label#setShow}
     * to hide or show a label, instead of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @return {Boolean} <code>true</code> if this label will be shown; otherwise, <code>false</code>.
     *
     * @see Label#setShow
     */
    Label.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this label will be shown.  Call this to hide or show a label, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @param {Boolean} value Indicates if this label will be shown.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getShow
     */
    Label.prototype.setShow = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (value !== this._show) {
            this._show = value;

            var glyphs = this._glyphs;
            for ( var i = 0, len = glyphs.length; i < len; i++) {
                var glyph = glyphs[i];
                if (typeof glyph.billboard !== 'undefined') {
                    glyph.billboard.setShow(value);
                }
            }
        }
    };

    /**
     * Returns the Cartesian position of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The Cartesian position of this label.
     *
     * @see Label#setPosition
     */
    Label.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this label.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the label's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getPosition
     *
     * @example
     * // Example 1. Set a label's position using a Cartesian3.
     * l.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Set a label's position using an object literal.
     * l.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0
     * });
     */
    Label.prototype.setPosition = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var position = this._position;
        if (!Cartesian3.equals(position, value)) {
            Cartesian3.clone(value, position);

            var glyphs = this._glyphs;
            for ( var i = 0, len = glyphs.length; i < len; i++) {
                var glyph = glyphs[i];
                if (typeof glyph.billboard !== 'undefined') {
                    glyph.billboard.setPosition(value);
                }
            }
        }
    };

    /**
     * Gets the text of this label.
     *
     * @memberof Label
     *
     * @see Label#setText
     */
    Label.prototype.getText = function() {
        return this._text;
    };

    /**
     * Sets the text of this label.
     *
     * @memberof Label
     *
     * @param {String} value The text.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getText
     */
    Label.prototype.setText = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (value !== this._text) {
            this._text = value;
            rebindAllGlyphs(this);
        }
    };

    /**
     * Gets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
     *
     * @memberof Label
     *
     * @see Label#setFont
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles'>HTML canvas 2D context text styles</a>
     */
    Label.prototype.getFont = function() {
        return this._font;
    };

    /**
     * Sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
     *
     * @memberof Label
     *
     * @param {String} value The font.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getFont
     * @see Label#setFillColor
     * @see Label#setOutlineColor
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles'>HTML canvas 2D context text styles</a>
     */
    Label.prototype.setFont = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._font !== value) {
            this._font = value;
            rebindAllGlyphs(this);
        }
    };

    /**
     * Gets the fill color of this label.
     *
     * @memberof Label
     *
     * @see Label#setFillColor
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles'>HTML canvas 2D context fill and stroke styles</a>
     */
    Label.prototype.getFillColor = function() {
        return this._fillColor;
    };

    /**
     * Sets the fill color of this label.
     *
     * @memberof Label
     *
     * @param {Color} value The fill color.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getFillColor
     * @see Label#setOutlineColor
     * @see Label#setFont
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles'>HTML canvas 2D context fill and stroke styles</a>
     */
    Label.prototype.setFillColor = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var fillColor = this._fillColor;
        if (!Color.equals(fillColor, value)) {
            Color.clone(value, fillColor);
            rebindAllGlyphs(this);
        }
    };

    /**
     * Gets the outline color of this label.
     *
     * @memberof Label
     *
     * @see Label#setOutlineColor
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles'>HTML canvas 2D context fill and stroke styles</a>
     */
    Label.prototype.getOutlineColor = function() {
        return this._outlineColor;
    };

    /**
     * Sets the outline color of this label.
     *
     * @memberof Label
     *
     * @param {Color} value The fill color.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getOutlineColor
     * @see Label#setFillColor
     * @see Label#setFont
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles'>HTML canvas 2D context fill and stroke styles</a>
     */
    Label.prototype.setOutlineColor = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var outlineColor = this._outlineColor;
        if (!Color.equals(outlineColor, value)) {
            Color.clone(value, outlineColor);
            rebindAllGlyphs(this);
        }
    };

    /**
     * Gets the style of this label.
     *
     * @memberof Label
     *
     * @see Label#setStyle
     */
    Label.prototype.getStyle = function() {
        return this._style;
    };

    /**
     * Sets the style of this label.
     *
     * @memberof Label
     *
     * @param {LabelStyle} value The style.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getStyle
     * @see Label#setOutlineColor
     * @see Label#setFillColor
     */
    Label.prototype.setStyle = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._style !== value) {
            this._style = value;
            rebindAllGlyphs(this);
        }
    };

    /**
     * Returns the pixel offset from the origin of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian2} The pixel offset of this label.
     *
     * @see Label#setPixelOffset
     */
    Label.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this label.  This is commonly used
     * to align multiple labels and billboards at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the label's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>l.setPixelOffset({ x : 25, y : -75 });</code><br/><img src='images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The label's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getPixelOffset
     * @see Billboard#setPixelOffset
     */
    Label.prototype.setPixelOffset = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var pixelOffset = this._pixelOffset;
        if (!Cartesian2.equals(pixelOffset, value)) {
            Cartesian2.clone(value, pixelOffset);
            repositionAllGlyphs(this);
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @see Label#setEyeOffset
     */
    Label.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
     * arrange a label above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the label's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the label is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>l.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getEyeOffset
     */
    Label.prototype.setEyeOffset = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        var eyeOffset = this._eyeOffset;
        if (!Cartesian3.equals(eyeOffset, value)) {
            Cartesian3.clone(value, eyeOffset);

            var glyphs = this._glyphs;
            for ( var i = 0, len = glyphs.length; i < len; i++) {
                var glyph = glyphs[i];
                if (typeof glyph.billboard !== 'undefined') {
                    glyph.billboard.setEyeOffset(value);
                }
            }
        }
    };

    /**
     * Returns the horizontal origin of this label.
     *
     * @memberof Label
     *
     * @return {HorizontalOrigin} The horizontal origin of this label.
     *
     * @see Label#setHorizontalOrigin
     */
    Label.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this label, which determines if the label is drawn
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getHorizontalOrigin
     * @see Label#setVerticalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setHorizontalOrigin = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._horizontalOrigin !== value) {
            this._horizontalOrigin = value;
            repositionAllGlyphs(this);
        }
    };

    /**
     * Returns the vertical origin of this label.
     *
     * @memberof Label
     *
     * @return {VerticalOrigin} The vertical origin of this label.
     *
     * @see Label#setVerticalOrigin
     */
    Label.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this label, which determines if the label is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getVerticalOrigin
     * @see Label#setHorizontalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setVerticalOrigin = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._verticalOrigin !== value) {
            this._verticalOrigin = value;
            repositionAllGlyphs(this);
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the label's size in pixels.
     *
     * @memberof Label
     *
     * @return {Number} The scale used to size the label.
     *
     * @see Label#setScale
     */
    Label.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the label's size in pixels.
     * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
     * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
     * the label.
     * <br /><br />
     * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
     * use a larger font size when calling {@link Label#setFont} instead.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Label.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Label
     *
     * @param {Number} value The scale used to size the label.
     *
     * @exception {DeveloperError} value is required.
     *
     * @see Label#getScale
     * @see Label#setFont
     */
    Label.prototype.setScale = function(value) {
        if (typeof value === 'undefined') {
            throw new DeveloperError('value is required.');
        }

        if (this._scale !== value) {
            this._scale = value;

            var glyphs = this._glyphs;
            for ( var i = 0, len = glyphs.length; i < len; i++) {
                var glyph = glyphs[i];
                if (typeof glyph.billboard !== 'undefined') {
                    glyph.billboard.setScale(value);
                }
            }

            repositionAllGlyphs(this);
        }
    };

    /**
     * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Label
     *
     * @param {UniformState} uniformState The same state object passed to {@link LabelCollection#update}.
     * @param {FrameState} frameState The same state object passed to {@link LabelCollection#update}.
     *
     * @return {Cartesian2} The screen-space position of the label.
     *
     * @exception {DeveloperError} uniformState is required.
     * @exception {DeveloperError} frameState is required.
     *
     * @see Label#setEyeOffset
     * @see Label#setPixelOffset
     *
     * @example
     * console.log(l.computeScreenSpacePosition(scene.getUniformState(), scene.getFrameState()).toString());
     */
    Label.prototype.computeScreenSpacePosition = function(uniformState, frameState) {
        if (typeof uniformState === 'undefined') {
            throw new DeveloperError('uniformState is required.');
        }
        if (typeof frameState === 'undefined') {
            throw new DeveloperError('frameState is required.');
        }

        var labelCollection = this._labelCollection;
        var modelMatrix = labelCollection.modelMatrix;
        var actualPosition = Billboard._computeActualPosition(this._position, frameState, labelCollection.morphTime, modelMatrix);

        return Billboard._computeScreenSpacePosition(modelMatrix, actualPosition, this._eyeOffset, this._pixelOffset, labelCollection.clampToPixel, uniformState);
    };

    /**
     * Determines if this label equals another label.  Labels are equal if all their properties
     * are equal.  Labels in different collections can be equal.
     *
     * @memberof Label
     *
     * @param {Label} other The label to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.
     */
    Label.prototype.equals = function(other) {
        return this === other ||
               typeof other !== 'undefined' &&
               this._show === other._show &&
               this._scale === other._scale &&
               this._style === other._style &&
               this._verticalOrigin === other._verticalOrigin &&
               this._horizontalOrigin === other._horizontalOrigin &&
               this._text === other._text &&
               this._font === other._font &&
               Cartesian3.equals(this._position, other._position) &&
               Color.equals(this._fillColor, other._fillColor) &&
               Color.equals(this._outlineColor, other._outlineColor) &&
               Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&
               Cartesian3.equals(this._eyeOffset, other._eyeOffset);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Label
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     */
    Label.prototype.isDestroyed = function() {
        return false;
    };

    return Label;
});
/*global define*/
define('Scene/WebMercatorTilingScheme',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/Extent',
        '../Core/Cartesian2',
        '../Core/Cartographic',
        '../Core/WebMercatorProjection',
        './TilingScheme'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        Ellipsoid,
        Extent,
        Cartesian2,
        Cartographic,
        WebMercatorProjection,
        TilingScheme) {
    

    /**
     * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
     * the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
     *
     * @alias WebMercatorTilingScheme
     * @constructor
     *
     * @param {Ellipsoid} [description.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to
     * the WGS84 ellipsoid.
     * @param {Number} [description.numberOfLevelZeroTilesX=1] The number of tiles in the X direction at level zero of
     *        the tile tree.
     * @param {Number} [description.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of
     *        the tile tree.
     * @param {Cartesian2} [description.extentSouthwestInMeters] The southwest corner of the extent covered by the
     *        tiling scheme, in meters.  If this parameter or extentNortheastInMeters is not specified, the entire
     *        globe is covered in the longitude direction and an equal distance is covered in the latitude
     *        direction, resulting in a square projection.
     * @param {Cartesian2} [description.extentNortheastInMeters] The northeast corner of the extent covered by the
     *        tiling scheme, in meters.  If this parameter or extentSouthwestInMeters is not specified, the entire
     *        globe is covered in the longitude direction and an equal distance is covered in the latitude
     *        direction, resulting in a square projection.
     */
    var WebMercatorTilingScheme = function WebMercatorTilingScheme(description) {
        description = defaultValue(description, {});

        this._ellipsoid = defaultValue(description.ellipsoid, Ellipsoid.WGS84);
        this._numberOfLevelZeroTilesX = defaultValue(description.numberOfLevelZeroTilesX, 1);
        this._numberOfLevelZeroTilesY = defaultValue(description.numberOfLevelZeroTilesY, 1);

        this._projection = new WebMercatorProjection(this._ellipsoid);

        if (typeof description.extentSouthwestInMeters !== 'undefined' &&
            typeof description.extentNortheastInMeters !== 'undefined') {
            this._extentSouthwestInMeters = description.extentSouthwestInMeters;
            this._extentNortheastInMeters = description.extentNortheastInMeters;
        } else {
            var semimajorAxisTimesPi = this._ellipsoid.getMaximumRadius() * Math.PI;
            this._extentSouthwestInMeters = new Cartesian2(-semimajorAxisTimesPi, -semimajorAxisTimesPi);
            this._extentNortheastInMeters = new Cartesian2(semimajorAxisTimesPi, semimajorAxisTimesPi);
        }

        var southwest = this._projection.unproject(this._extentSouthwestInMeters);
        var northeast = this._projection.unproject(this._extentNortheastInMeters);
        this._extent = new Extent(southwest.longitude, southwest.latitude,
                                  northeast.longitude, northeast.latitude);
    };

    /**
     * Gets the ellipsoid that is tiled by this tiling scheme.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @returns {Ellipsoid} The ellipsoid.
     */
    WebMercatorTilingScheme.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Gets the extent, in radians, covered by this tiling scheme.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @returns {Extent} The extent.
     */
    WebMercatorTilingScheme.prototype.getExtent = function() {
        return this._extent;
    };

    /**
     * Gets the map projection used by this tiling scheme.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @returns {Projection} The map projection.
     */
    WebMercatorTilingScheme.prototype.getProjection = function() {
        return this._projection;
    };

    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the X direction at the given level.
     */
    WebMercatorTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
        return this._numberOfLevelZeroTilesX << level;
    };

    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @param {Number} level The level-of-detail.
     * @returns {Number} The number of tiles in the Y direction at the given level.
     */
    WebMercatorTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
        return this._numberOfLevelZeroTilesY << level;
    };

    /**
     * Creates the tile or tiles at level of detail zero, the coarsest, least detailed level.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @returns {Array} An array containing the tiles at level of detail zero, starting with the
     * tile in the northwest corner of the globe and followed by the tile (if any) to its east.
     */
    WebMercatorTilingScheme.prototype.createLevelZeroTiles = function() {
        return TilingScheme.createRectangleOfLevelZeroTiles(this, this._numberOfLevelZeroTilesX, this._numberOfLevelZeroTilesY);
    };

    /**
     * Transforms an extent specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @param {Extent} extent The extent to transform.
     * @param {Extent} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns {Extent} The specified 'result', or a new object containing the native extent if 'result'
     *          is undefined.
     */
    WebMercatorTilingScheme.prototype.extentToNativeExtent = function(extent, result) {
        var projection = this._projection;
        var southwest = projection.project(extent.getSouthwest());
        var northeast = projection.project(extent.getNortheast());

        if (typeof result === 'undefined') {
            return new Extent(southwest.x, southwest.y, northeast.x, northeast.y);
        }

        result.west = southwest.x;
        result.south = southwest.y;
        result.east = northeast.x;
        result.north = northeast.y;
        return result;
    };

    /**
     * Converts tile x, y coordinates and level to an extent expressed in the native coordinates
     * of the tiling scheme.
     *
     * @memberof WebMercatorTilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    WebMercatorTilingScheme.prototype.tileXYToNativeExtent = function(x, y, level, result) {
        var xTiles = this.getNumberOfXTilesAtLevel(level);
        var yTiles = this.getNumberOfYTilesAtLevel(level);

        var xTileWidth = (this._extentNortheastInMeters.x - this._extentSouthwestInMeters.x) / xTiles;
        var west = this._extentSouthwestInMeters.x + x * xTileWidth;
        var east = this._extentSouthwestInMeters.x + (x + 1) * xTileWidth;

        var yTileHeight = (this._extentNortheastInMeters.y - this._extentSouthwestInMeters.y) / yTiles;
        var north = this._extentNortheastInMeters.y - y * yTileHeight;
        var south = this._extentNortheastInMeters.y - (y + 1) * yTileHeight;

        if (typeof result === 'undefined') {
            return new Extent(west, south, east, north);
        }

        result.west = west;
        result.south = south;
        result.east = east;
        result.north = north;
        return result;
    };

    /**
     * Converts tile x, y coordinates and level to a cartographic extent in radians.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Number} x The integer x coordinate of the tile.
     * @param {Number} y The integer y coordinate of the tile.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Extent} The specified 'result', or a new object containing the extent
     *          if 'result' is undefined.
     */
    WebMercatorTilingScheme.prototype.tileXYToExtent = function(x, y, level, result) {
        var nativeExtent = this.tileXYToNativeExtent(x, y, level, result);

        var projection = this._projection;
        var southwest = projection.unproject(new Cartesian2(nativeExtent.west, nativeExtent.south));
        var northeast = projection.unproject(new Cartesian2(nativeExtent.east, nativeExtent.north));

        nativeExtent.west = southwest.longitude;
        nativeExtent.south = southwest.latitude;
        nativeExtent.east = northeast.longitude;
        nativeExtent.north = northeast.latitude;
        return nativeExtent;
    };

    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     *
     * @memberof GeographicTilingScheme
     *
     * @param {Cartographic} position The position.
     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
     * @param {Cartesian} [result] The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     *
     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    WebMercatorTilingScheme.prototype.positionToTileXY = function(position, level, result) {
        var extent = this._extent;
        if (position.latitude > extent.north ||
            position.latitude < extent.south ||
            position.longitude < extent.west ||
            position.longitude > extent.east) {
            // outside the bounds of the tiling scheme
            return undefined;
        }

        var xTiles = this.getNumberOfXTilesAtLevel(level);
        var yTiles = this.getNumberOfYTilesAtLevel(level);

        var overallWidth = this._extentNortheastInMeters.x - this._extentSouthwestInMeters.x;
        var xTileWidth = overallWidth / xTiles;
        var overallHeight = this._extentNortheastInMeters.y - this._extentSouthwestInMeters.y;
        var yTileHeight = overallHeight / yTiles;

        var projection = this._projection;

        var webMercatorPosition = projection.project(position);
        var distanceFromWest = webMercatorPosition.x - this._extentSouthwestInMeters.x;
        var distanceFromNorth = this._extentNortheastInMeters.y - webMercatorPosition.y;

        var xTileCoordinate = distanceFromWest / xTileWidth | 0;
        if (xTileCoordinate >= xTiles) {
            xTileCoordinate = xTiles - 1;
        }
        var yTileCoordinate = distanceFromNorth / yTileHeight | 0;
        if (yTileCoordinate >= yTiles) {
            yTileCoordinate = yTiles - 1;
        }

        if (typeof result === 'undefined') {
            return new Cartesian2(xTileCoordinate, yTileCoordinate);
        }

        result.x = xTileCoordinate;
        result.y = yTileCoordinate;
        return result;
    };

    return WebMercatorTilingScheme;
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/BillboardCollectionFS',[],function() {
    
    return "uniform sampler2D u_atlas;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
#ifdef RENDER_FOR_PICK\n\
varying vec4 v_pickColor;\n\
#else\n\
varying vec4 v_color;\n\
#endif\n\
\n\
void main()\n\
{\n\
#ifdef RENDER_FOR_PICK\n\
    vec4 vertexColor = vec4(1.0, 1.0, 1.0, 1.0);\n\
#else\n\
    vec4 vertexColor = v_color;\n\
#endif\n\
    \n\
    vec4 color = texture2D(u_atlas, v_textureCoordinates) * vertexColor;\n\
    if (color.a == 0.0)\n\
    {\n\
        discard;\n\
    }\n\
    \n\
#ifdef RENDER_FOR_PICK\n\
    gl_FragColor = v_pickColor;\n\
#else\n\
    gl_FragColor = color;\n\
#endif\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/BillboardCollectionVS',[],function() {
    
    return "attribute vec3 positionHigh;\n\
attribute vec3 positionLow;\n\
attribute vec2 direction;                       // in screen space\n\
attribute vec4 textureCoordinatesAndImageSize;  // size in normalized texture coordinates\n\
attribute vec3 originAndShow;                   // show is 0.0 (false) or 1.0 (true)\n\
attribute vec2 pixelOffset;\n\
attribute vec4 eyeOffsetAndScale;                       // eye offset in meters\n\
\n\
#ifdef RENDER_FOR_PICK\n\
attribute vec4 pickColor;\n\
#else\n\
attribute vec4 color;\n\
#endif\n\
\n\
uniform vec2 u_atlasSize;\n\
uniform float u_clampToPixel; // clamp is 1.0 (true) or 0.0 (false)\n\
\n\
uniform float u_morphTime;\n\
\n\
const vec2 czm_highResolutionSnapScale = vec2(1.0, 1.0);    // TODO\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
#ifdef RENDER_FOR_PICK\n\
varying vec4 v_pickColor;\n\
#else\n\
varying vec4 v_color;\n\
#endif\n\
\n\
void main() \n\
{\n\
    // Modifying this shader may also require modifications to Billboard.computeScreenSpacePosition\n\
    \n\
    // unpack attributes\n\
    vec3 eyeOffset = eyeOffsetAndScale.xyz;\n\
    float scale = eyeOffsetAndScale.w;\n\
    vec2 textureCoordinates = textureCoordinatesAndImageSize.xy;\n\
    vec2 imageSize = textureCoordinatesAndImageSize.zw;\n\
    vec2 origin = originAndShow.xy;\n\
    float show = originAndShow.z;\n\
    \n\
    ///////////////////////////////////////////////////////////////////////////\n\
    \n\
    vec4 p = vec4(czm_translateRelativeToEye(positionHigh, positionLow), 1.0);\n\
    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\
    positionEC = czm_eyeOffset(positionEC, eyeOffset);\n\
    positionEC.xyz *= show;\n\
    \n\
    ///////////////////////////////////////////////////////////////////////////     \n\
    \n\
    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n\
    \n\
    vec2 halfSize = u_atlasSize * imageSize * 0.5 * scale * czm_highResolutionSnapScale;\n\
    halfSize *= ((direction * 2.0) - 1.0);\n\
\n\
    positionWC.xy += (origin * abs(halfSize)) + halfSize;\n\
    positionWC.xy += (pixelOffset * czm_highResolutionSnapScale);\n\
    positionWC.xy = mix(positionWC.xy, floor(positionWC.xy), u_clampToPixel);\n\
\n\
    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\n\
    v_textureCoordinates = textureCoordinates;\n\
\n\
#ifdef RENDER_FOR_PICK\n\
    v_pickColor = pickColor;\n\
#else\n\
    v_color = color;\n\
#endif\n\
}\n\
";
});
/*global define*/
define('Scene/BillboardCollection',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/EncodedCartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Core/BoundingSphere',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CommandLists',
        '../Renderer/DrawCommand',
        '../Renderer/VertexArrayFacade',
        './SceneMode',
        './Billboard',
        './HorizontalOrigin',
        '../Shaders/BillboardCollectionVS',
        '../Shaders/BillboardCollectionFS'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        CesiumMath,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        EncodedCartesian3,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        BoundingSphere,
        BlendingState,
        BufferUsage,
        CommandLists,
        DrawCommand,
        VertexArrayFacade,
        SceneMode,
        Billboard,
        HorizontalOrigin,
        BillboardCollectionVS,
        BillboardCollectionFS) {
    

    var SHOW_INDEX = Billboard.SHOW_INDEX;
    var POSITION_INDEX = Billboard.POSITION_INDEX;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;
    var SCALE_INDEX = Billboard.SCALE_INDEX;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;
    var COLOR_INDEX = Billboard.COLOR_INDEX;
    var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;

    // PERFORMANCE_IDEA:  Use vertex compression so we don't run out of
    // vec4 attributes (WebGL minimum: 8)
    var attributeIndices = {
        positionHigh : 0,
        positionLow : 1,
        pixelOffset : 2,
        eyeOffsetAndScale : 3,
        textureCoordinatesAndImageSize : 4,
        originAndShow : 5,
        direction : 6,
        pickColor : 7,  // pickColor and color shared an index because pickColor is only used during
        color : 7       // the 'pick' pass and 'color' is only used during the 'color' pass.
    };

    // Identifies to the VertexArrayFacade the attributes that are used only for the pick
    // pass or only for the color pass.
    var allPassPurpose = 'all';
    var colorPassPurpose = 'color';
    var pickPassPurpose = 'pick';

    /**
     * A renderable collection of billboards.  Billboards are viewport-aligned
     * images positioned in the 3D scene.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.png' width='400' height='300' /><br />
     * Example billboards
     * </div>
     * <br /><br />
     * Billboards are added and removed from the collection using {@link BillboardCollection#add}
     * and {@link BillboardCollection#remove}.  All billboards in a collection reference images
     * from the same texture atlas, which is assigned using {@link BillboardCollection#setTextureAtlas}.
     *
     * @alias BillboardCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many billboards, to
     * many collections with only a few billboards each.  Organize collections so that billboards
     * with the same update frequency are in the same collection, i.e., billboards that do not
     * change should be in one collection; billboards that change every frame should be in another
     * collection; and so on.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard
     * @see TextureAtlas
     * @see LabelCollection
     *
     * @example
     * // Create a billboard collection with two billboards
     * var billboards = new BillboardCollection();
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 },
     *   imageIndex : 0
     * });
     * billboards.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 },
     *   imageIndex : 1
     * });
     */
    var BillboardCollection = function() {
        this._textureAtlas = undefined;
        this._textureAtlasGUID = undefined;
        this._destroyTextureAtlas = true;
        this._sp = undefined;
        this._rs = undefined;
        this._vaf = undefined;
        this._rsPick = undefined;
        this._spPick = undefined;

        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;
        this._createVertexArray = false;

        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);

        this._maxSize = 0.0;
        this._maxEyeOffset = 0.0;
        this._maxScale = 1.0;
        this._maxPixelOffset = 0.0;
        this._allHorizontalCenter = true;

        this._baseVolume = new BoundingSphere();
        this._baseVolume2D = new BoundingSphere();
        this._boundingVolume = new BoundingSphere();

        this._commandLists = new CommandLists();

        /**
         * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
         * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link czm_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see czm_model
         *
         * @example
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * billboards.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * billboards.add({ imageIndex: 0, position : new Cartesian3(0.0, 0.0, 0.0) }); // center
         * billboards.add({ imageIndex: 0, position : new Cartesian3(1000000.0, 0.0, 0.0) }); // east
         * billboards.add({ imageIndex: 0, position : new Cartesian3(0.0, 1000000.0, 0.0) }); // north
         * billboards.add({ imageIndex: 0, position : new Cartesian3(0.0, 0.0, 1000000.0) }); // up
         * ]);
         */
        this.modelMatrix = Matrix4.IDENTITY.clone();
        this._modelMatrix = Matrix4.IDENTITY.clone();

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        /**
         * If true, aligns all billboards to a pixel in screen space,
         * providing a crisper image at the cost of jumpier motion.
         * Defaults to false.
         *
         * @type Boolean
         */
        this.clampToPixel = false;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = this._mode.morphTime;

        // The buffer usage for each attribute is determined based on the usage of the attribute over time.
        this._buffersUsage = [
                              BufferUsage.STATIC_DRAW, // SHOW_INDEX
                              BufferUsage.STATIC_DRAW, // POSITION_INDEX
                              BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // SCALE_INDEX
                              BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX
                              BufferUsage.STATIC_DRAW // COLOR_INDEX
                          ];

        var that = this;
        this._uniforms = {
            u_atlas : function() {
                return that._textureAtlas.getTexture();
            },
            u_atlasSize : function() {
                return that._textureAtlas.getTexture().getDimensions();
            },
            u_clampToPixel : function() {
                return that.clampToPixel ? 1.0 : 0.0;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
    };

    /**
     * Creates and adds a billboard with the specified initial properties to the collection.
     * The added billboard is returned so it can be modified or removed from the collection later.
     *
     * @memberof BillboardCollection
     *
     * @param {Object}[billboard=undefined] A template describing the billboard's properties as shown in Example 1.
     *
     * @return {Billboard} The billboard that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, add as many billboards as possible before calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#remove
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     *
     * @example
     * // Example 1:  Add a billboard, specifying all the default values.
     * var b = billboards.add({
     *   show : true,
     *   position : new Cartesian3(0.0, 0.0, 0.0),
     *   pixelOffset : new Cartesian2(0.0, 0.0),
     *   eyeOffset : new Cartesian3(0.0, 0.0, 0.0),
     *   horizontalOrigin : HorizontalOrigin.CENTER,
     *   verticalOrigin : VerticalOrigin.CENTER,
     *   scale : 1.0,
     *   imageIndex : 0,
     *   color : new Color(1.0, 1.0, 1.0, 1.0)
     * });
     *
     * // Example 2:  Specify only the billboard's cartographic position.
     * var b = billboards.add({
     *   position : ellipsoid.cartographicToCartesian(new Cartographic(longitude, latitude, height))
     * });
     */
    BillboardCollection.prototype.add = function(billboard) {
        var b = new Billboard(billboard, this);
        b._index = this._billboards.length;

        this._billboards.push(b);
        this._createVertexArray = true;

        return b;
    };

    /**
     * Removes a billboard from the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Billboard} billboard The billboard to remove.
     *
     * @return {Boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many billboards as possible before calling <code>update</code>.
     * If you intend to temporarily hide a billboard, it is usually more efficient to call
     * {@link Billboard#setShow} instead of removing and re-adding the billboard.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     * @see Billboard#setShow
     *
     * @example
     * var b = billboards.add(...);
     * billboards.remove(b);  // Returns true
     */
    BillboardCollection.prototype.remove = function(billboard) {
        if (this.contains(billboard)) {
            this._billboards[billboard._index] = null; // Removed later
            this._billboardsRemoved = true;
            this._createVertexArray = true;
            billboard._destroy();
            return true;
        }

        return false;
    };

    /**
     * Removes all billboards from the collection.
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#update
     *
     * @example
     * billboards.add(...);
     * billboards.add(...);
     * billboards.removeAll();
     */
    BillboardCollection.prototype.removeAll = function() {
        this._destroyBillboards();
        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;

        this._createVertexArray = true;
    };

    function removeBillboards(billboardCollection) {
        if (billboardCollection._billboardsRemoved) {
            billboardCollection._billboardsRemoved = false;

            var newBillboards = [];
            var billboards = billboardCollection._billboards;
            var length = billboards.length;
            for (var i = 0, j = 0; i < length; ++i) {
                var billboard = billboards[i];
                if (billboard) {
                    billboard._index = j++;
                    newBillboards.push(billboard);
                }
            }

            billboardCollection._billboards = newBillboards;
        }
    }

    BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
        if (!billboard._dirty) {
            this._billboardsToUpdate.push(billboard);
        }

        ++this._propertiesChanged[propertyChanged];
    };

    /**
     * Check whether this collection contains a given billboard.
     *
     * @memberof BillboardCollection
     *
     * @param {Billboard} billboard The billboard to check for.
     *
     * @return {Boolean} true if this collection contains the billboard, false otherwise.
     *
     * @see BillboardCollection#get
     */
    BillboardCollection.prototype.contains = function(billboard) {
        return typeof billboard !== 'undefined' && billboard._billboardCollection === this;
    };

    /**
     * Returns the billboard in the collection at the specified index.  Indices are zero-based
     * and increase as billboards are added.  Removing a billboard shifts all billboards after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link BillboardCollection#getLength} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Billboard} The billboard at the specified index.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getLength
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        removeBillboards(this);
        return this._billboards[index];
    };

    /**
     * Returns the number of billboards in this collection.  This is commonly used with
     * {@link BillboardCollection#get} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @return {Number} The number of billboards in this collection.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#get
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.getLength = function() {
        removeBillboards(this);
        return this._billboards.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard#setImageIndex
     */
    BillboardCollection.prototype.getTextureAtlas = function() {
        return this._textureAtlas;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getTextureAtlas
     * @see Billboard#setImageIndex
     *
     * @example
     * // Assigns a texture atlas with two images to a billboard collection.
     * // Two billboards, each referring to one of the images, are then
     * // added to the collection.
     * var billboards = new BillboardCollection();
     * var images = [image0, image1];
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.add({
     *   // ...
     *   imageIndex : 0
     * });
     * billboards.add({
     *   // ...
     *   imageIndex : 1
     * });
     */
    BillboardCollection.prototype.setTextureAtlas = function(value) {
        if (this._textureAtlas !== value) {
            this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
            this._textureAtlas = value;
            this._createVertexArray = true; // New per-billboard texture coordinates
        }
    };

    /**
     * Returns <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @memberof BillboardCollection
     *
     * @return <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setDestroyTextureAtlas
     */
    BillboardCollection.prototype.getDestroyTextureAtlas = function() {
        return this._destroyTextureAtlas;
    };

    /**
     * Determines if the texture atlas is destroyed when the collection is destroyed.  If the texture
     * atlas is used by more than one collection, set this to <code>false</code>, and explicitly
     * destroy the atlas to avoid attempting to destroy it multiple times.
     *
     * @memberof BillboardCollection
     *
     * @param {Boolean} value Indicates if the texture atlas is destroyed when the collection is destroyed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getDestroyTextureAtlas
     * @see BillboardCollection#setTextureAtlas
     * @see BillboardCollection#destroy
     *
     * @example
     * // Destroy a billboard collection but not its texture atlas.
     *
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.setDestroyTextureAtlas(false);
     * billboards = billboards.destroy();
     * console.log(atlas.isDestroyed()); // False
     */
    BillboardCollection.prototype.setDestroyTextureAtlas = function(value) {
        this._destroyTextureAtlas = value;
    };

    function getDirectionsVertexBuffer(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.directionsVertexBuffer) {
            return c.directionsVertexBuffer;
        }

        c.directionsVertexBuffer = c.directionsVertexBuffer && c.directionsVertexBuffer.destroy();

        var directions = new Uint8Array(sixteenK * 4 * 2);
        for (var i = 0, j = 0; i < sixteenK; ++i) {
            directions[j++] = 0;
            directions[j++] = 0;

            directions[j++] = 255;
            directions[j++] = 0.0;

            directions[j++] = 255;
            directions[j++] = 255;

            directions[j++] = 0.0;
            directions[j++] = 255;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.directionsVertexBuffer = context.createVertexBuffer(directions, BufferUsage.STATIC_DRAW);
        c.directionsVertexBuffer.setVertexArrayDestroyable(false);
        return c.directionsVertexBuffer;
    }

    function getIndexBuffer(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.indexBuffer) {
            return c.indexBuffer;
        }

        var length = sixteenK * 6;
        var indices = new Uint16Array(length);
        for (var i = 0, j = 0; i < length; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;

            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
        c.indexBuffer.setVertexArrayDestroyable(false);
        return c.indexBuffer;
    }

    BillboardCollection.prototype.computeNewBuffersUsage = function() {
        var buffersUsage = this._buffersUsage;
        var usageChanged = false;

        // PERFORMANCE_IDEA: Better heuristic to avoid ping-ponging.  What about DYNAMIC_STREAM?
        var properties = this._propertiesChanged;
        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            var newUsage = (properties[k] === 0) ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;
            usageChanged = usageChanged || (buffersUsage[k] !== newUsage);
            buffersUsage[k] = newUsage;
        }

        return usageChanged;
    };

    function createVAF(context, numberOfBillboards, buffersUsage) {
        // Different billboard collections share the same vertex buffer for directions.
        var directionVertexBuffer = getDirectionsVertexBuffer(context);

        return new VertexArrayFacade(context, [{
            index : attributeIndices.positionHigh,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[POSITION_INDEX]
        }, {
            index : attributeIndices.positionLow,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[POSITION_INDEX]
        }, {
            index : attributeIndices.pixelOffset,
            componentsPerAttribute : 2,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[PIXEL_OFFSET_INDEX]
        }, {
            index : attributeIndices.eyeOffsetAndScale,
            componentsPerAttribute : 4,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[SCALE_INDEX] // buffersUsage[EYE_OFFSET_INDEX] ignored
        }, {
            index : attributeIndices.textureCoordinatesAndImageSize,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_SHORT,
            usage : buffersUsage[IMAGE_INDEX_INDEX]
        }, {
            index : attributeIndices.pickColor,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : BufferUsage.STATIC_DRAW,
            purpose : pickPassPurpose
        }, {
            index : attributeIndices.color,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : buffersUsage[COLOR_INDEX],
            purpose : colorPassPurpose
        }, {
            index : attributeIndices.originAndShow,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.BYTE,
            usage : buffersUsage[SHOW_INDEX] // buffersUsage[HORIZONTAL_ORIGIN_INDEX] and buffersUsage[VERTICAL_ORIGIN_INDEX] ignored
        }, {
            index : attributeIndices.direction,
            vertexBuffer : directionVertexBuffer,
            componentsPerAttribute : 2,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE
        }], 4 * numberOfBillboards); // 4 vertices per billboard
    }

    ///////////////////////////////////////////////////////////////////////////

    // Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.

    // PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,
    // instead of storing it in a vertex buffer.

    var writePositionScratch = new EncodedCartesian3();

    function writePosition(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var position = billboard._getActualPosition();

        if (billboardCollection._mode === SceneMode.SCENE3D) {
            billboardCollection._baseVolume.expand(position, billboardCollection._baseVolume);
        }

        EncodedCartesian3.fromCartesian(position, writePositionScratch);

        var allPurposeWriters = vafWriters[allPassPurpose];
        var positionHighWriter = allPurposeWriters[attributeIndices.positionHigh];
        var high = writePositionScratch.high;
        positionHighWriter(i + 0, high.x, high.y, high.z);
        positionHighWriter(i + 1, high.x, high.y, high.z);
        positionHighWriter(i + 2, high.x, high.y, high.z);
        positionHighWriter(i + 3, high.x, high.y, high.z);

        var positionLowWriter = allPurposeWriters[attributeIndices.positionLow];
        var low = writePositionScratch.low;
        positionLowWriter(i + 0, low.x, low.y, low.z);
        positionLowWriter(i + 1, low.x, low.y, low.z);
        positionLowWriter(i + 2, low.x, low.y, low.z);
        positionLowWriter(i + 3, low.x, low.y, low.z);
    }

    function writePixelOffset(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pixelOffset = billboard.getPixelOffset();
        billboardCollection._maxPixelOffset = Math.max(billboardCollection._maxPixelOffset, pixelOffset.x, pixelOffset.y);

        var allPurposeWriters = vafWriters[allPassPurpose];
        var writer = allPurposeWriters[attributeIndices.pixelOffset];
        writer(i + 0, pixelOffset.x, pixelOffset.y);
        writer(i + 1, pixelOffset.x, pixelOffset.y);
        writer(i + 2, pixelOffset.x, pixelOffset.y);
        writer(i + 3, pixelOffset.x, pixelOffset.y);
    }

    function writeEyeOffsetAndScale(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var eyeOffset = billboard.getEyeOffset();
        var scale = billboard.getScale();
        billboardCollection._maxEyeOffset = Math.max(billboardCollection._maxEyeOffset, Math.abs(eyeOffset.x), Math.abs(eyeOffset.y), Math.abs(eyeOffset.z));
        billboardCollection._maxScale = Math.max(billboardCollection._maxScale, scale);

        var allPurposeWriters = vafWriters[allPassPurpose];
        var writer = allPurposeWriters[attributeIndices.eyeOffsetAndScale];
        writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
    }

    function writePickColor(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pickColor = billboard.getPickId(context).unnormalizedRgb;

        var pickWriters = vafWriters[pickPassPurpose];
        var writer = pickWriters[attributeIndices.pickColor];
        writer(i + 0, pickColor.red, pickColor.green, pickColor.blue, 255);
        writer(i + 1, pickColor.red, pickColor.green, pickColor.blue, 255);
        writer(i + 2, pickColor.red, pickColor.green, pickColor.blue, 255);
        writer(i + 3, pickColor.red, pickColor.green, pickColor.blue, 255);
    }

    function writeColor(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var color = billboard.getColor();

        var colorWriters = vafWriters[colorPassPurpose];
        var writer = colorWriters[attributeIndices.color];
        writer(i + 0, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        writer(i + 1, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        writer(i + 2, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        writer(i + 3, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
    }

    function writeOriginAndShow(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var horizontalOrigin = billboard.getHorizontalOrigin().value;
        var verticalOrigin = billboard.getVerticalOrigin().value;
        var show = billboard.getShow();

        // If the color alpha is zero, do not show this billboard.  This lets us avoid providing
        // color during the pick pass and also eliminates a discard in the fragment shader.
        if (billboard.getColor().alpha === 0.0) {
            show = false;
        }

        billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin.CENTER.value;

        var allPurposeWriters = vafWriters[allPassPurpose];
        var writer = allPurposeWriters[attributeIndices.originAndShow];
        writer(i + 0, horizontalOrigin, verticalOrigin, show);
        writer(i + 1, horizontalOrigin, verticalOrigin, show);
        writer(i + 2, horizontalOrigin, verticalOrigin, show);
        writer(i + 3, horizontalOrigin, verticalOrigin, show);
    }

    function writeTextureCoordinatesAndImageSize(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var bottomLeftX = 0;
        var bottomLeftY = 0;
        var width = 0;
        var height = 0;
        var index = billboard.getImageIndex();
        if (index !== -1) {
            var imageRectangle = textureAtlasCoordinates[index];
            if (typeof imageRectangle === 'undefined') {
                throw new DeveloperError('Invalid billboard image index: ' + index);
            }
            bottomLeftX = imageRectangle.x;
            bottomLeftY = imageRectangle.y;
            width = imageRectangle.width;
            height = imageRectangle.height;
        }
        var topRightX = bottomLeftX + width;
        var topRightY = bottomLeftY + height;

        billboardCollection._maxSize = Math.max(billboardCollection._maxSize, width, height);

        var allPurposeWriters = vafWriters[allPassPurpose];
        var writer = allPurposeWriters[attributeIndices.textureCoordinatesAndImageSize];
        writer(i + 0, bottomLeftX * 65535, bottomLeftY * 65535, width * 65535, height * 65535); // Lower Left
        writer(i + 1, topRightX * 65535, bottomLeftY * 65535, width * 65535, height * 65535); // Lower Right
        writer(i + 2, topRightX * 65535, topRightY * 65535, width * 65535, height * 65535); // Upper Right
        writer(i + 3, bottomLeftX * 65535, topRightY * 65535, width * 65535, height * 65535); // Upper Left
    }

    function writeBillboard(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
        writePosition(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writePixelOffset(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writeEyeOffsetAndScale(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writePickColor(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writeColor(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writeOriginAndShow(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
        writeTextureCoordinatesAndImageSize(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    }

    function recomputeActualPositions(billboardCollection, billboards, frameState, morphTime, modelMatrix, recomputeBoundingVolume) {
        var boundingVolume;
        if (frameState.mode === SceneMode.SCENE3D) {
            boundingVolume = billboardCollection._baseVolume;
        } else {
            boundingVolume = billboardCollection._baseVolume2D;
        }

        var length = billboards.length;
        var positions = new Array(length);
        for (var i = 0; i < length; ++i) {
            var billboard = billboards[i];
            var position = billboard.getPosition();
            var actualPosition = Billboard._computeActualPosition(position, frameState, morphTime, modelMatrix);
            billboard._setActualPosition(actualPosition);

            if (recomputeBoundingVolume) {
                positions[i] = actualPosition;
            } else {
                boundingVolume.expand(actualPosition, boundingVolume);
            }
        }

        if (recomputeBoundingVolume) {
            BoundingSphere.fromPoints(positions, boundingVolume);
        }
    }

    function updateMode(billboardCollection, frameState) {
        var mode = frameState.mode;
        var projection = frameState.scene2D.projection;

        var billboards = billboardCollection._billboards;
        var billboardsToUpdate = billboardCollection._billboardsToUpdate;
        var morphTime = billboardCollection.morphTime;
        var modelMatrix = billboardCollection._modelMatrix;

        if (billboardCollection._mode !== mode ||
                billboardCollection._projection !== projection ||
            mode !== SceneMode.SCENE3D &&
            !modelMatrix.equals(billboardCollection.modelMatrix)) {

            billboardCollection._mode = mode;
            billboardCollection._projection = projection;
            billboardCollection.modelMatrix.clone(modelMatrix);
            billboardCollection._createVertexArray = true;

            if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {
                recomputeActualPositions(billboardCollection, billboards, frameState, morphTime, modelMatrix, true);
            }
        } else if (mode === SceneMode.MORPHING) {
            recomputeActualPositions(billboardCollection, billboards, frameState, morphTime, modelMatrix, true);
        } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {
            recomputeActualPositions(billboardCollection, billboardsToUpdate, frameState, morphTime, modelMatrix, false);
        }
    }

    var scratchCanvasDimensions = new Cartesian2();
    var scratchToCenter = new Cartesian3();
    var scratchProj = new Cartesian3();
    function updateBoundingVolume(collection, context, frameState, boundingVolume) {
        var camera = frameState.camera;
        var frustum = camera.frustum;

        var textureDimensions = collection._textureAtlas.getTexture().getDimensions();
        var textureSize = Math.max(textureDimensions.x, textureDimensions.y);

        var pixelScale;
        var size;
        var offset;

        var toCenter = camera.getPositionWC().subtract(boundingVolume.center, scratchToCenter);
        var proj = camera.getDirectionWC().multiplyByScalar(toCenter.dot(camera.getDirectionWC()), scratchProj);
        var distance = Math.max(0.0, proj.magnitude() - boundingVolume.radius);

        var canvas = context.getCanvas();
        scratchCanvasDimensions.x = canvas.clientWidth;
        scratchCanvasDimensions.y = canvas.clientHeight;
        var pixelSize = frustum.getPixelSize(scratchCanvasDimensions, distance);
        pixelScale = Math.max(pixelSize.x, pixelSize.y);

        size = pixelScale * collection._maxScale * collection._maxSize * textureSize;
        if (collection._allHorizontalCenter) {
            size *= 0.5;
        }

        offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;
        boundingVolume.radius += size + offset;
    }

    /**
     * @private
     */
    BillboardCollection.prototype.update = function(context, frameState, commandList) {
        var textureAtlas = this._textureAtlas;
        if (typeof textureAtlas === 'undefined') {
            // Can't write billboard vertices until we have texture coordinates
            // provided by a texture atlas
            return;
        }

        var textureAtlasCoordinates = textureAtlas.getTextureCoordinates();
        if (textureAtlasCoordinates.length === 0) {
            // Can't write billboard vertices until we have texture coordinates
            // provided by a texture atlas
            return;
        }

        removeBillboards(this);
        updateMode(this, frameState);

        var billboards = this._billboards;
        var length = billboards.length;
        var properties = this._propertiesChanged;

        var textureAtlasGUID = textureAtlas.getGUID();
        var createVertexArray = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
        this._textureAtlasGUID = textureAtlasGUID;

        var vafWriters;

        // PERFORMANCE_IDEA: Round robin multiple buffers.
        if (createVertexArray || this.computeNewBuffersUsage()) {
            this._createVertexArray = false;

            this._vaf = this._vaf && this._vaf.destroy();

            if (length > 0) {
                // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.
                this._vaf = createVAF(context, billboards.length, this._buffersUsage);
                vafWriters = this._vaf.writers;

                // Rewrite entire buffer if billboards were added or removed.
                for (var i = 0; i < length; ++i) {
                    var billboard = this._billboards[i];
                    billboard._dirty = false; // In case it needed an update.
                    writeBillboard(this, context, textureAtlasCoordinates, vafWriters, billboard);
                }

                // Different billboard collections share the same index buffer.
                this._vaf.commit(getIndexBuffer(context));
            }

            this._billboardsToUpdate = [];
        } else {
            // Billboards were modified, but none were added or removed.

            var billboardsToUpdate = this._billboardsToUpdate;
            var updateLength = billboardsToUpdate.length;

            if (updateLength) {
                var writers = [];

                if (properties[POSITION_INDEX]) {
                    writers.push(writePosition);
                }

                if (properties[PIXEL_OFFSET_INDEX]) {
                    writers.push(writePixelOffset);
                }

                if (properties[EYE_OFFSET_INDEX] || properties[SCALE_INDEX]) {
                    writers.push(writeEyeOffsetAndScale);
                }

                if (properties[IMAGE_INDEX_INDEX]) {
                    writers.push(writeTextureCoordinatesAndImageSize);
                }

                if (properties[COLOR_INDEX]) {
                    writers.push(writeColor);
                }

                if (properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {
                    writers.push(writeOriginAndShow);
                }

                vafWriters = this._vaf.writers;

                if ((updateLength / length) > 0.1) {
                    // If more than 10% of billboard change, rewrite the entire buffer.

                    // PERFORMANCE_IDEA:  I totally made up 10% :).

                    for (var m = 0; m < updateLength; ++m) {
                        var b = billboardsToUpdate[m];
                        b._dirty = false;

                        for ( var n = 0; n < writers.length; ++n) {
                            writers[n](this, context, textureAtlasCoordinates, vafWriters, b);
                        }
                    }
                    this._vaf.commit(getIndexBuffer(context));
                } else {
                    for (var h = 0; h < updateLength; ++h) {
                        var bb = billboardsToUpdate[h];
                        bb._dirty = false;

                        for ( var o = 0; o < writers.length; ++o) {
                            writers[o](this, context, textureAtlasCoordinates, vafWriters, bb);
                        }
                        this._vaf.subCommit(bb._index * 4, 4);
                    }
                    this._vaf.endSubCommits();
                }

                this._billboardsToUpdate = [];
            }
        }

        for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }

        if (typeof this._vaf === 'undefined' || typeof this._vaf.vaByPurpose === 'undefined') {
            return;
        }

        var boundingVolume;
        var modelMatrix = Matrix4.IDENTITY;
        if (frameState.mode === SceneMode.SCENE3D) {
            modelMatrix = this.modelMatrix;
            boundingVolume = BoundingSphere.clone(this._baseVolume, this._boundingVolume);
        } else if (typeof this._baseVolume2D !== 'undefined') {
            boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);
        }
        updateBoundingVolume(this, context, frameState, boundingVolume);

        var pass = frameState.passes;
        var va;
        var vaLength;
        var commands;
        var command;
        var j;
        this._commandLists.removeAll();
        if (pass.color) {
            if (typeof this._sp === 'undefined') {
                this._rs = context.createRenderState({
                    depthTest : {
                        enabled : true
                    },
                    blending : BlendingState.ALPHA_BLEND
                });

                this._sp = context.getShaderCache().getShaderProgram(BillboardCollectionVS, BillboardCollectionFS, attributeIndices);
            }

            va = this._vaf.vaByPurpose[colorPassPurpose];
            vaLength = va.length;

            commands = this._commandLists.colorList;
            commands.length = vaLength;
            for (j = 0; j < vaLength; ++j) {
                command = commands[j];
                if (typeof command === 'undefined') {
                    command = commands[j] = new DrawCommand();
                }

                command.boundingVolume = boundingVolume;
                command.modelMatrix = modelMatrix;
                command.primitiveType = PrimitiveType.TRIANGLES;
                command.count = va[j].indicesCount;
                command.shaderProgram = this._sp;
                command.uniformMap = this._uniforms;
                command.vertexArray = va[j].va;
                command.renderState = this._rs;
            }
        }
        if (pass.pick) {
            if (typeof this._spPick === 'undefined') {
                this._rsPick = context.createRenderState({
                    depthTest : {
                        enabled : true
                    }
                });

                this._spPick = context.getShaderCache().getShaderProgram(
                        '#define RENDER_FOR_PICK 1\n' + BillboardCollectionVS,
                        '#define RENDER_FOR_PICK 1\n' + BillboardCollectionFS,
                        attributeIndices);
            }

            va = this._vaf.vaByPurpose[pickPassPurpose];
            vaLength = va.length;

            commands = this._commandLists.pickList;
            commands.length = vaLength;
            for (j = 0; j < vaLength; ++j) {
                command = commands[j];
                if (typeof command === 'undefined') {
                    command = commands[j] = new DrawCommand();
                }

                command.boundingVolume = boundingVolume;
                command.modelMatrix = modelMatrix;
                command.primitiveType = PrimitiveType.TRIANGLES;
                command.count = va[j].indicesCount;
                command.shaderProgram = this._spPick;
                command.uniformMap = this._uniforms;
                command.vertexArray = va[j].va;
                command.renderState = this._rsPick;
            }
        }

        if (!this._commandLists.empty()) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof BillboardCollection
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see BillboardCollection#destroy
     */
    BillboardCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof BillboardCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#isDestroyed
     *
     * @example
     * billboards = billboards && billboards.destroy();
     */
    BillboardCollection.prototype.destroy = function() {
        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vaf = this._vaf && this._vaf.destroy();
        this._destroyBillboards();

        return destroyObject(this);
    };

    BillboardCollection.prototype._destroyBillboards = function() {
        var billboards = this._billboards;
        var length = billboards.length;
        for (var i = 0; i < length; ++i) {
            if (billboards[i]) {
                billboards[i]._destroy();
            }
        }
    };

    return BillboardCollection;
});

// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/BuiltinFunctions',[],function() {
    
    return "/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_infinity\n\
 * @glslConstant \n\
 */\n\
const float czm_infinity = 5906376272000.0; // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon1\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon1 = 0.1;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon2\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon2 = 0.01;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon3\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon3 = 0.001;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon4\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon4 = 0.0001;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon5\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon5 = 0.00001;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon6\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon6 = 0.000001;\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_epsilon7\n\
 * @glslConstant \n\
 */\n\
const float czm_epsilon7 = 0.0000001;\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_equalsEpsilon\n\
 * @glslFunction\n\
 */\n\
bool czm_equalsEpsilon(float left, float right, float epsilon) {\n\
    return (abs(left - right) <= epsilon);\n\
}\n\
\n\
bool czm_equalsEpsilon(float left, float right) {\n\
    // Workaround bug in Opera Next 12.  Do not delegate to the other czm_equalsEpsilon.\n\
    return (abs(left - right) <= czm_epsilon7);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * Returns the transpose of the matrix.  The input <code>matrix</code> can be \n\
 * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n\
 *\n\
 * @name czm_transpose\n\
 * @glslFunction\n\
 *\n\
 * @param {} matrix The matrix to transpose.\n\
 *\n\
 * @returns {} The transposed matrix.\n\
 *\n\
 * @example\n\
 * // GLSL declarations\n\
 * mat2 czm_transpose(mat2 matrix);\n\
 * mat3 czm_transpose(mat3 matrix);\n\
 * mat4 czm_transpose(mat4 matrix);\n\
 *\n\
 * // Tranpose a 3x3 rotation matrix to find its inverse.\n\
 * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n\
 *     positionMC, normalEC);\n\
 * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n\
 */\n\
mat2 czm_transpose(mat2 matrix)\n\
{\n\
    return mat2(\n\
        matrix[0][0], matrix[1][0],\n\
        matrix[0][1], matrix[1][1]);\n\
}\n\
\n\
mat3 czm_transpose(mat3 matrix)\n\
{\n\
    return mat3(\n\
        matrix[0][0], matrix[1][0], matrix[2][0],\n\
        matrix[0][1], matrix[1][1], matrix[2][1],\n\
        matrix[0][2], matrix[1][2], matrix[2][2]);\n\
}\n\
\n\
mat4 czm_transpose(mat4 matrix)\n\
{\n\
    return mat4(\n\
        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n\
        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n\
        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n\
        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * Transforms a position from model to window coordinates.  The transformation\n\
 * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n\
 * The transform from normalized device coordinates to window coordinates is\n\
 * done using {@link czm_viewportTransformation}, which assumes a depth range\n\
 * of <code>near = 0</code> and <code>far = 1</code>.\n\
 * <br /><br />\n\
 * This transform is useful when there is a need to manipulate window coordinates\n\
 * in a vertex shader as done by {@link BillboardCollection}.\n\
 * <br /><br />\n\
 * This function should not be confused with {@link czm_viewportOrthographic},\n\
 * which is an orthographic projection matrix that transforms from window \n\
 * coordinates to clip coordinates.\n\
 *\n\
 * @name czm_modelToWindowCoordinates\n\
 * @glslFunction\n\
 *\n\
 * @param {vec4} position The position in model coordinates to transform.\n\
 *\n\
 * @returns {vec4} The transformed position in window coordinates.\n\
 *\n\
 * @see czm_eyeToWindowCoordinates\n\
 * @see czm_modelViewProjection\n\
 * @see czm_viewportTransformation\n\
 * @see czm_viewportOrthographic\n\
 * @see BillboardCollection\n\
 *\n\
 * @example\n\
 * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n\
 */\n\
vec4 czm_modelToWindowCoordinates(vec4 position)\n\
{\n\
    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n\
    q.xyz /= q.w;                                                // normalized device coordinates\n\
    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n\
    return q;\n\
}\n\
\n\
/**\n\
 * Transforms a position from eye to window coordinates.  The transformation\n\
 * from eye to clip coordinates is done using {@link czm_projection}.\n\
 * The transform from normalized device coordinates to window coordinates is\n\
 * done using {@link czm_viewportTransformation}, which assumes a depth range\n\
 * of <code>near = 0</code> and <code>far = 1</code>.\n\
 * <br /><br />\n\
 * This transform is useful when there is a need to manipulate window coordinates\n\
 * in a vertex shader as done by {@link BillboardCollection}.\n\
 *\n\
 * @name czm_eyeToWindowCoordinates\n\
 * @glslFunction\n\
 *\n\
 * @param {vec4} position The position in eye coordinates to transform.\n\
 *\n\
 * @returns {vec4} The transformed position in window coordinates.\n\
 *\n\
 * @see czm_modelToWindowCoordinates\n\
 * @see czm_projection\n\
 * @see czm_viewportTransformation\n\
 * @see BillboardCollection\n\
 *\n\
 * @example\n\
 * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n\
 */\n\
vec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n\
{\n\
    vec4 q = czm_projection * positionEC;                       // clip coordinates\n\
    q.xyz /= q.w;                                                // normalized device coordinates\n\
    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n\
    return q;\n\
}\n\
\n\
/**\n\
 * Transforms a position from window to eye coordinates.\n\
 * The transform from window to normalized device coordinates is done using components\n\
 * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n\
 * the inverse of <code>czm_viewportTransformation</code>. The transformation from \n\
 * normalized device coordinates to clip coordinates is done using <code>positionWC.w</code>,\n\
 * which is expected to be the scalar used in the perspective divide. The transformation\n\
 * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n\
 *\n\
 * @name czm_windowToEyeCoordinates\n\
 * @glslFunction\n\
 *\n\
 * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n\
 *\n\
 * @returns {vec4} The transformed position in eye coordinates.\n\
 *\n\
 * @see czm_modelToWindowCoordinates\n\
 * @see czm_eyeToWindowCoordinates\n\
 * @see czm_inverseProjection\n\
 * @see czm_viewport\n\
 * @see czm_viewportTransformation\n\
 *\n\
 * @example\n\
 * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n\
 */\n\
vec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n\
{\n\
    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\n\
    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\n\
    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\
    vec4 q = vec4(x, y, z, 1.0);\n\
    q /= fragmentCoordinate.w;\n\
    q = czm_inverseProjection * q;\n\
    return q;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_eyeOffset\n\
 * @glslFunction\n\
 *\n\
 * @param {vec4} positionEC DOC_TBA.\n\
 * @param {vec3} eyeOffset DOC_TBA.\n\
 *\n\
 * @returns {vec4} DOC_TBA.\n\
 */\n\
vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n\
{\n\
    // This equation is approximate in x and y.\n\
    vec4 p = positionEC;\n\
    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n\
    p.xy += eyeOffset.xy + zEyeOffset.xy;\n\
    p.z += zEyeOffset.z;\n\
    return p;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_geodeticSurfaceNormal\n\
 * @glslFunction\n\
 *\n\
 * @param {vec3} positionOnEllipsoid DOC_TBA\n\
 * @param {vec3} ellipsoidCenter DOC_TBA\n\
 * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n\
 * \n\
 * @returns {vec3} DOC_TBA.\n\
 */\n\
vec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n\
{\n\
    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidWgs84TextureCoordinates\n\
 * @glslFunction\n\
 */\n\
vec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n\
{\n\
    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n\
}\n\
\n\
/**\n\
 * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n\
 * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n\
 * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n\
 * <br /><br />\n\
 * The ellipsoid is assumed to be centered at the model coordinate's origin.\n\
 *\n\
 * @name czm_eastNorthUpToEyeCoordinates\n\
 * @glslFunction\n\
 *\n\
 * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n\
 * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n\
 *\n\
 * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n\
 *\n\
 * @example\n\
 * // Transform a vector defined in the east-north-up coordinate \n\
 * // system, (0, 0, 1) which is the surface normal, to eye \n\
 * // coordinates.\n\
 * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n\
 * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n\
 */\n\
mat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n\
{\n\
    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n\
    vec3 tangentEC = normalize(czm_normal * tangentMC);                  // normalized surface tangent in eye coordiantes\n\
    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\
\n\
    return mat3(\n\
        tangentEC.x,   tangentEC.y,   tangentEC.z,\n\
        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n\
        normalEC.x,    normalEC.y,    normalEC.z);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * Used as input to every material's czm_getMaterial function. \n\
 *\n\
 * @name czm_materialInput\n\
 * @glslStruct\n\
 *\n\
 * @property {float} s 1D texture coordinates.\n\
 * @property {vec2} st 2D texture coordinates.\n\
 * @property {vec3} str 3D texture coordinates.\n\
 * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n\
 * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n\
 * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n\
 * @property {vec3} positionMC Position in model coordinates.\n\
 */\n\
struct czm_materialInput\n\
{\n\
    float s;\n\
    vec2 st;\n\
    vec3 str;\n\
    vec3 normalEC;\n\
    mat3 tangentToEyeMatrix;\n\
    vec3 positionToEyeEC;\n\
    vec3 positionMC;\n\
};\n\
\n\
/**\n\
 * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n\
 *\n\
 * @name czm_material\n\
 * @glslStruct\n\
 *\n\
 * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n\
 * @property {float} specular Intensity of incoming light reflecting in a single direction.\n\
 * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n\
 * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n\
 * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n\
 * @property {float} alpha Opacity of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n\
 */\n\
struct czm_material\n\
{\n\
    vec3 diffuse;\n\
    float specular;\n\
    float shininess;\n\
    vec3 normal;\n\
    vec3 emission;\n\
    float alpha;\n\
};\n\
\n\
/**\n\
 * An czm_material with default values. Every material's czm_getMaterial\n\
 * should use this default material as a base for the material it returns.\n\
 * The default normal value is given by materialInput.normalEC.\n\
 *\n\
 * @name czm_getDefaultMaterial\n\
 * @glslFunction \n\
 *\n\
 * @param {czm_materialInput} input The input used to construct the default material.\n\
 * \n\
 * @returns {czm_material} The default material.\n\
 *\n\
 * @see czm_materialInput\n\
 * @see czm_material\n\
 * @see czm_getMaterial\n\
 */\n\
czm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material;\n\
    material.diffuse = vec3(0.0);\n\
    material.specular = 0.0;\n\
    material.shininess = 1.0;\n\
    material.normal = materialInput.normalEC;\n\
    material.emission = vec3(0.0);\n\
    material.alpha = 1.0;\n\
    return material;\n\
}\n\
\n\
float getLambertDiffuse(vec3 lightDirection, czm_material material)\n\
{\n\
    return max(dot(lightDirection, material.normal), 0.0);\n\
}\n\
\n\
float getSpecular(vec3 lightDirection, vec3 toEye, czm_material material)\n\
{\n\
    vec3 toReflectedLight = reflect(-lightDirection, material.normal);\n\
    float specular = max(dot(toReflectedLight, toEye), 0.0);\n\
\n\
    return pow(specular, material.shininess);\n\
}\n\
\n\
/**\n\
 * Computes a color using the Phong lighting model.\n\
 *\n\
 * @name czm_phong\n\
 * @glslFunction\n\
 *\n\
 * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n\
 * @param {czm_material} material The fragment's material.\n\
 * \n\
 * @returns {vec4} The computed color.\n\
 * \n\
 * @example\n\
 * vec3 positionToEyeEC = // ...\n\
 * czm_material material = // ...\n\
 * gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
 *\n\
 * @see czm_getMaterial\n\
 */\n\
vec4 czm_phong(vec3 toEye, czm_material material)\n\
{\n\
    // Diffuse from directional light sources at eye (for top-down and horizon views)\n\
    float diffuse = getLambertDiffuse(vec3(0.0, 0.0, 1.0), material) + getLambertDiffuse(vec3(0.0, 1.0, 0.0), material);\n\
\n\
    // Specular from sun and pseudo-moon\n\
    float specular = getSpecular(czm_sunDirectionEC, toEye, material) + getSpecular(czm_moonDirectionEC, toEye, material);\n\
\n\
    vec3 ambient = vec3(0.0);\n\
    vec3 color = ambient + material.emission;\n\
    color += material.diffuse * diffuse;\n\
    color += material.specular * specular;\n\
\n\
    return vec4(color, material.alpha);\n\
}\n\
\n\
/**\n\
 * Computes the luminance of a color. \n\
 *\n\
 * @name czm_luminance\n\
 * @glslFunction\n\
 *\n\
 * @param {vec3} rgb The color.\n\
 * \n\
 * @returns {float} The luminance.\n\
 *\n\
 * @example\n\
 * float light = luminance(vec3(0.0)); // 0.0\n\
 * float dark = luminance(vec3(1.0));  // ~1.0 \n\
 */\n\
float czm_luminance(vec3 rgb)\n\
{\n\
    // Algorithm from Chapter 10 of Graphics Shaders.\n\
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\
    return dot(rgb, W);\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_multiplyWithColorBalance\n\
 * @glslFunction\n\
 */\n\
vec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n\
{\n\
    // Algorithm from Chapter 10 of Graphics Shaders.\n\
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\
    \n\
    vec3 target = left * right;\n\
    float leftLuminance = dot(left, W);\n\
    float rightLuminance = dot(right, W);\n\
    float targetLuminance = dot(target, W);\n\
    \n\
    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n\
 * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n\
 * for any latitude up to (but not including) 90 degrees, but it makes sense\n\
 * to cut it off sooner because it grows exponentially with increasing latitude.\n\
 * The logic behind this particular cutoff value, which is the one used by\n\
 * Google Maps, Bing Maps, and Esri, is that it makes the projection\n\
 * square.  That is, the extent is equal in the X and Y directions.\n\
 *\n\
 * The constant value is computed as follows:\n\
 *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n\
 *\n\
 * @name czm_webMercatorMaxLatitude\n\
 * @glslConstant\n\
 */\n\
const float czm_webMercatorMaxLatitude = 1.4844222297453323669610967939;\n\
\n\
/**\n\
 * Specifies a flat, 2D map.\n\
 *\n\
 * @name czm_scene2D\n\
 * @glslConstant \n\
 */\n\
const int czm_scene2D = 0;\n\
\n\
/**\n\
 * Specifies 2.D Columbus View.\n\
 *\n\
 * @name czm_columbusView\n\
 * @glslConstant \n\
 */\n\
const int czm_columbusView = 1;\n\
\n\
/**\n\
 * Specifies a 3D globe.\n\
 *\n\
 * @name czm_scene3D\n\
 * @glslConstant \n\
 */\n\
const int czm_scene3D = 2;\n\
\n\
/**\n\
 * Specifies that the scene is morphing between modes.\n\
 * \n\
 * @name czm_morphing\n\
 * @glslConstant\n\
 */\n\
const int czm_morphing = 3;\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_columbusViewMorph\n\
 * @glslFunction\n\
 */\n\
vec4 czm_columbusViewMorph(vec3 position2D, vec3 position3D, float time)\n\
{\n\
    // Just linear for now.\n\
    vec3 p = mix(position2D, position3D, time);\n\
    return vec4(p, 1.0);\n\
} \n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ray\n\
 * @glslStruct\n\
 */\n\
struct czm_ray\n\
{\n\
    vec3 origin;\n\
    vec3 direction;\n\
};\n\
\n\
/**\n\
 * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n\
 *\n\
 * @name czm_pointAlongRay\n\
 * @glslFunction\n\
 *\n\
 * @param {czm_ray} ray The ray to compute the point along.\n\
 * @param {float} time The time along the ray.\n\
 * \n\
 * @returns {vec3} The point along the ray at the given time.\n\
 * \n\
 * @example\n\
 * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n\
 * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n\
 */\n\
vec3 czm_pointAlongRay(czm_ray ray, float time)\n\
{\n\
    return ray.origin + (time * ray.direction);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_raySegment\n\
 * @glslStruct\n\
 */\n\
struct czm_raySegment\n\
{\n\
    float start;\n\
    float stop;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_emptyRaySegment\n\
 * @glslConstant \n\
 */\n\
const czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_fullRaySegment\n\
 * @glslConstant \n\
 */\n\
const czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n\
\n\
/**\n\
 * Determines if a time interval is empty.\n\
 *\n\
 * @name czm_isEmpty\n\
 * @glslFunction \n\
 * \n\
 * @param {czm_raySegment} interval The interval to test.\n\
 * \n\
 * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n\
 *\n\
 * @example\n\
 * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n\
 * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n\
 * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n\
 */\n\
bool czm_isEmpty(czm_raySegment interval)\n\
{\n\
    return (interval.stop < 0.0);\n\
}\n\
\n\
/**\n\
 * Determines if a time interval is empty.\n\
 *\n\
 * @name czm_isFull\n\
 * @glslFunction \n\
 * \n\
 * @param {czm_raySegment} interval The interval to test.\n\
 * \n\
 * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n\
 *\n\
 * @example\n\
 * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n\
 * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n\
 * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n\
 */\n\
bool czm_isFull(czm_raySegment interval)\n\
{\n\
    return (interval.start == 0.0 && interval.stop == czm_infinity);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoid\n\
 * @glslStruct\n\
 */\n\
struct czm_ellipsoid\n\
{\n\
    vec3 center;\n\
    vec3 radii;\n\
    vec3 inverseRadii;\n\
    vec3 inverseRadiiSquared;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidNew\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n\
{\n\
    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n\
    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n\
    czm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n\
    return temp;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidContainsPoint\n\
 * @glslFunction\n\
 *\n\
 */\n\
bool czm_ellipsoidContainsPoint(czm_ellipsoid ellipsoid, vec3 point)\n\
{\n\
    vec3 scaled = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n\
    return (dot(scaled, scaled) <= 1.0);\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 *\n\
 * @name czm_rayEllipsoidIntersectionInterval\n\
 * @glslFunction\n\
 */\n\
czm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, czm_ellipsoid ellipsoid)\n\
{\n\
   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n\
    vec3 q = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n\
    vec3 w = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\
   \n\
    q = q - ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ellipsoid.center, 1.0)).xyz;\n\
    \n\
    float q2 = dot(q, q);\n\
    float qw = dot(q, w);\n\
    \n\
    if (q2 > 1.0) // Outside ellipsoid.\n\
    {\n\
        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n\
        {\n\
            return czm_emptyRaySegment;\n\
        }\n\
        else // qw < 0.0.\n\
        {\n\
            float qw2 = qw * qw;\n\
            float difference = q2 - 1.0; // Positively valued.\n\
            float w2 = dot(w, w);\n\
            float product = w2 * difference;\n\
            \n\
            if (qw2 < product) // Imaginary roots (0 intersections).\n\
            {\n\
                return czm_emptyRaySegment;     \n\
            }   \n\
            else if (qw2 > product) // Distinct roots (2 intersections).\n\
            {\n\
                float discriminant = qw * qw - product;\n\
                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n\
                float root0 = temp / w2;\n\
                float root1 = difference / temp;\n\
                if (root0 < root1)\n\
                {\n\
                    czm_raySegment i = czm_raySegment(root0, root1);\n\
                    return i;\n\
                }\n\
                else\n\
                {\n\
                    czm_raySegment i = czm_raySegment(root1, root0);\n\
                    return i;\n\
                }\n\
            }\n\
            else // qw2 == product.  Repeated roots (2 intersections).\n\
            {\n\
                float root = sqrt(difference / w2);\n\
                czm_raySegment i = czm_raySegment(root, root);\n\
                return i;\n\
            }\n\
        }\n\
    }\n\
    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n\
    {\n\
        float difference = q2 - 1.0; // Negatively valued.\n\
        float w2 = dot(w, w);\n\
        float product = w2 * difference; // Negatively valued.\n\
        if (qw < 0.0) // Looking inward.\n\
        {\n\
            float discriminant = qw * qw - product;\n\
            float temp = qw - sqrt(discriminant); // Avoid cancellation.  Negatively valued.\n\
            czm_raySegment i = czm_raySegment(0.0, difference / temp);\n\
            return i;\n\
        }\n\
        else if (qw > 0.0) // Looking outward.\n\
        {\n\
            float discriminant = qw * qw - product;\n\
            float temp = qw + sqrt(discriminant); // Avoid cancellation. Positively valued.\n\
            czm_raySegment i = czm_raySegment(0.0, temp / w2);\n\
            return i;\n\
        }\n\
        else // qw == 0.0 // Looking tangent.\n\
        {\n\
            float temp = sqrt(-product);\n\
            czm_raySegment i = czm_raySegment(0.0, temp / w2);\n\
            return i;\n\
        }\n\
    }\n\
    else // q2 == 1.0. On ellipsoid.\n\
    {\n\
        if (qw < 0.0) // Looking inward.\n\
        {\n\
            float w2 = dot(w, w);\n\
            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n\
            return i;\n\
        }\n\
        else // qw >= 0.0.  Looking outward or tangent.\n\
        {\n\
            return czm_emptyRaySegment;\n\
        }\n\
    }\n\
}\n\
\n\
/**\n\
 * Returns the WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n\
 *\n\
 * @name czm_getWgs84EllipsoidEC\n\
 * @glslFunction\n\
 *\n\
 * @returns {czm_ellipsoid} The WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n\
 *\n\
 * @see Ellipsoid.getWgs84\n\
 *\n\
 * @example\n\
 * czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
 */\n\
czm_ellipsoid czm_getWgs84EllipsoidEC()\n\
{\n\
    return czm_ellipsoidNew(\n\
        czm_view[3].xyz,                               // center\n\
        vec3(6378137.0, 6378137.0, 6356752.314245));   // radii\n\
}\n\
\n\
/**\n\
 * Computes the fraction of a Web Wercator extent at which a given geodetic latitude is located.\n\
 *\n\
 * @name czm_latitudeToWebMercatorFraction\n\
 * @glslFunction\n\
 *\n\
 * @param {float} The geodetic latitude, in radians.\n\
 * @param {float} The low portion of the Web Mercator coordinate of the southern boundary of the extent.\n\
 * @param {float} The high portion of the Web Mercator coordinate of the southern boundary of the extent.\n\
 * @param {float} The total height of the extent in Web Mercator coordinates.\n\
 *\n\
 * @returns {float} The fraction of the extent at which the latitude occurs.  If the latitude is the southern\n\
 *          boundary of the extent, the return value will be zero.  If it is the northern boundary, the return\n\
 *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n\
 */ \n\
float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorYLow, float southMercatorYHigh, float oneOverMercatorHeight)\n\
{\n\
    float sinLatitude = sin(latitude);\n\
    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n\
    \n\
    // mercatorY - southMercatorY in simulated double precision.\n\
    float t1 = 0.0 - southMercatorYLow;\n\
    float e = t1 - 0.0;\n\
    float t2 = ((-southMercatorYLow - e) + (0.0 - (t1 - e))) + mercatorY - southMercatorYHigh;\n\
    float highDifference = t1 + t2;\n\
    float lowDifference = t2 - (highDifference - t1);\n\
    \n\
    return highDifference * oneOverMercatorHeight + lowDifference * oneOverMercatorHeight;\n\
}\n\
\n\
/**\n\
 * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n\
 * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n\
 * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n\
 * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n\
 * respectively.\n\
 * <p>\n\
 * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n\
 * described in <a href=\"http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/\">Precisions, Precisions</a>.\n\
 * </p>\n\
 *\n\
 * @name czm_translateRelativeToEye\n\
 * @glslFunction\n\
 *\n\
 * @param {vec3} high The position's high bits.\n\
 * @param {vec3} low The position's low bits.\n\
 * @returns {vec3} The position translated to be relative to the camera's position.\n\
 *\n\
 * @example\n\
 * attribute vec3 positionHigh;\n\
 * attribute vec3 positionLow;\n\
 * \n\
 * void main() \n\
 * {\n\
 *   vec3 p = czm_translateRelativeToEye(positionHigh, positionLow);\n\
 *   gl_Position = czm_modelViewProjectionRelativeToEye * vec4(p, 1.0);\n\
 * }\n\
 *\n\
 * @see czm_modelViewRelativeToEye\n\
 * @see czm_modelViewProjectionRelativeToEye\n\
 * @see EncodedCartesian3\n\
 */\n\
vec3 czm_translateRelativeToEye(vec3 high, vec3 low)\n\
{\n\
    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n\
    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\
\n\
    return highDifference + lowDifference;\n\
}\n\
";
});
/*global define*/
define('Renderer/ShaderProgram',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix2',
        '../Core/Matrix3',
        '../Core/Matrix4',
        './UniformDatatype',
        '../Shaders/BuiltinFunctions'
    ], function(
        DeveloperError,
        RuntimeError,
        destroyObject,
        CesiumMath,
        Matrix2,
        Matrix3,
        Matrix4,
        UniformDatatype,
        ShadersBuiltinFunctions) {
    
    /*global console*/

    var allAutomaticUniforms = {
        /**
         * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
         * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
         * and <code>w</code> components, respectively.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_viewport</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewport
         * @glslUniform
         *
         * @see Context#getViewport
         *
         * @example
         * // GLSL declaration
         * uniform vec4 czm_viewport;
         *
         * // Scale the window coordinate components to [0, 1] by dividing
         * // by the viewport's width and height.
         * vec2 v = gl_FragCoord.xy / czm_viewport.zw;
         */
        czm_viewport : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR4;
            },

            getValue : function(uniformState) {
                var v = uniformState.getViewport();
                return {
                    x : v.x,
                    y : v.y,
                    z : v.width,
                    w : v.height
                };
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
         * transforms window coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.
         * <br /><br />
         * This transform is useful when a vertex shader inputs or manipulates window coordinates
         * as done by {@link BillboardCollection}.
         * <br /><br />
         * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.
         * The former transforms from normalized device coordinates to window coordinates; the later transforms
         * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_viewportOrthographic</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewportOrthographic
         * @glslUniform
         *
         * @see UniformState#getViewportOrthographic
         * @see czm_viewport
         * @see czm_viewportTransformation
         * @see BillboardCollection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_viewportOrthographic;
         *
         * // Example
         * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
         */
        czm_viewportOrthographic : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getViewportOrthographic();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 transformation matrix that
         * transforms normalized device coordinates to window coordinates.  The context's
         * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
         * and <code>far = 1</code>.
         * <br /><br />
         * This transform is useful when there is a need to manipulate window coordinates
         * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
         * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}
         * will be used to transform directly from model to window coordinates.
         * <br /><br />
         * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.
         * The former transforms from normalized device coordinates to window coordinates; the later transforms
         * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_viewportTransformation</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewportTransformation
         * @glslUniform
         *
         * @see UniformState#getViewportTransformation
         * @see czm_viewport
         * @see czm_viewportOrthographic
         * @see czm_modelToWindowCoordinates
         * @see BillboardCollection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_viewportTransformation;
         *
         * // Use czm_viewportTransformation as part of the
         * // transform from model to window coordinates.
         * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates
         * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
         * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
         */
        czm_viewportTransformation : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getViewportTransformation();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model transformation matrix that
         * transforms model coordinates to world coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_model</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_model
         * @glslUniform
         *
         * @see UniformState#getModel
         * @see czm_inverseModel
         * @see czm_modelView
         * @see czm_modelViewProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_model;
         *
         * // Example
         * vec4 worldPosition = czm_model * modelPosition;
         */
        czm_model : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModel();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model transformation matrix that
         * transforms world coordinates to model coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseModel</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseModel
         * @glslUniform
         *
         * @see UniformState#getInverseModel
         * @see czm_model
         * @see czm_inverseModelView
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_inverseModel;
         *
         * // Example
         * vec4 modelPosition = czm_inverseModel * worldPosition;
         */
        czm_inverseModel : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseModel();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 view transformation matrix that
         * transforms world coordinates to eye coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_view</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_view
         * @glslUniform
         *
         * @see UniformState#getView
         * @see czm_viewRotation
         * @see czm_modelView
         * @see czm_viewProjection
         * @see czm_modelViewProjection
         * @see czm_inverseView
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_view;
         *
         * // Example
         * vec4 eyePosition = czm_view * worldPosition;
         */
        czm_view : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getView();
            }
        },

        /**
         * An automatic GLSL uniform representing a 3x3 view rotation matrix that
         * transforms vectors in world coordinates to eye coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_viewRotation</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewRotation
         * @glslUniform
         *
         * @see UniformState#getViewRotation
         * @see czm_view
         * @see czm_inverseView
         * @see czm_inverseViewRotation
         *
         * @example
         * // GLSL declaration
         * uniform mat3 czm_viewRotation;
         *
         * // Example
         * vec3 eyeVector = czm_viewRotation * worldVector;
         */
        czm_viewRotation : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX3;
            },

            getValue : function(uniformState) {
                return uniformState.getViewRotation();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 transformation matrix that
         * transforms from eye coordinates to world coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseView</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseView
         * @glslUniform
         *
         * @see UniformState#getInverseView
         * @see czm_view
         * @see czm_inverseNormal
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_inverseView;
         *
         * // Example
         * vec4 worldPosition = czm_inverseView * eyePosition;
         */
        czm_inverseView : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseView();
            }
        },

        /**
         * An automatic GLSL uniform representing a 3x3 rotation matrix that
         * transforms vectors from eye coordinates to world coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseViewRotation</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseViewRotation
         * @glslUniform
         *
         * @see UniformState#getInverseView
         * @see czm_view
         * @see czm_viewRotation
         * @see czm_inverseViewRotation
         *
         * @example
         * // GLSL declaration
         * uniform mat3 czm_inverseViewRotation;
         *
         * // Example
         * vec4 worldVector = czm_inverseViewRotation * eyeVector;
         */
        czm_inverseViewRotation : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX3;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseViewRotation();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
         * transforms eye coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_projection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_projection
         * @glslUniform
         *
         * @see UniformState#getProjection
         * @see czm_viewProjection
         * @see czm_modelViewProjection
         * @see czm_infiniteProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_projection;
         *
         * // Example
         * gl_Position = czm_projection * eyePosition;
         */
        czm_projection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
         * transforms from clip coordinates to eye coordinates. Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseProjection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseProjection
         * @glslUniform
         *
         * @see UniformState#getInverseProjection
         * @see czm_projection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_inverseProjection;
         *
         * // Example
         * vec4 eyePosition = czm_inverseProjection * clipPosition;
         */
        czm_inverseProjection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
         * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
         * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
         * are not clipped by the far plane.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_infiniteProjection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_infiniteProjection
         * @glslUniform
         *
         * @see UniformState#getInfiniteProjection
         * @see czm_projection
         * @see czm_modelViewInfiniteProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_infiniteProjection;
         *
         * // Example
         * gl_Position = czm_infiniteProjection * eyePosition;
         */
        czm_infiniteProjection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getInfiniteProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
         * transforms model coordinates to eye coordinates.
         * <br /><br />
         * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and
         * normals should be transformed using {@link czm_normal}.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_modelView</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_modelView
         * @glslUniform
         *
         * @see UniformState#getModelView
         * @see czm_model
         * @see czm_view
         * @see czm_modelViewProjection
         * @see czm_normal
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_modelView;
         *
         * // Example
         * vec4 eyePosition = czm_modelView * modelPosition;
         *
         * // The above is equivalent to, but more efficient than:
         * vec4 eyePosition = czm_view * czm_model * modelPosition;
         */
        czm_modelView : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModelView();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
         * transforms model coordinates, relative to the eye, to eye coordinates.  This is used
         * in conjunction with {@link czm_translateRelativeToEye}.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_modelViewRelativeToEye</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_modelViewRelativeToEye
         * @glslUniform
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_modelViewRelativeToEye;
         *
         * // Example
         * attribute vec3 positionHigh;
         * attribute vec3 positionLow;
         *
         * void main()
         * {
         *   vec3 p = czm_translateRelativeToEye(positionHigh, positionLow);
         *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * vec4(p, 1.0));
         * }
         *
         * @see czm_modelViewProjectionRelativeToEye
         * @see czm_translateRelativeToEye
         * @see EncodedCartesian3
         */
        czm_modelViewRelativeToEye : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModelViewRelativeToEye();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 transformation matrix that
         * transforms from eye coordinates to model coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseModelView</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseModelView
         * @glslUniform
         *
         * @see UniformState#getInverseModelView
         * @see czm_modelView
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_inverseModelView;
         *
         * // Example
         * vec4 modelPosition = czm_inverseModelView * eyePosition;
         */
        czm_inverseModelView : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseModelView();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
         * transforms world coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_viewProjection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewProjection
         * @glslUniform
         *
         * @see UniformState#getViewProjection
         * @see czm_view
         * @see czm_projection
         * @see czm_modelViewProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_viewProjection;
         *
         * // Example
         * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;
         *
         * // The above is equivalent to, but more efficient than:
         * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
         */
        czm_viewProjection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getViewProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
         * transforms model coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_modelViewProjection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_modelViewProjection
         * @glslUniform
         *
         * @see UniformState#getModelViewProjection
         * @see czm_model
         * @see czm_view
         * @see czm_projection
         * @see czm_modelView
         * @see czm_viewProjection
         * @see czm_modelViewInfiniteProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_modelViewProjection;
         *
         * // Example
         * vec4 gl_Position = czm_modelViewProjection * modelPosition;
         *
         * // The above is equivalent to, but more efficient than:
         * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
         */
        czm_modelViewProjection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModelViewProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
         * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in
         * conjunction with {@link czm_translateRelativeToEye}.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_modelViewProjectionRelativeToEye</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_modelViewProjectionRelativeToEye
         * @glslUniform
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_modelViewProjectionRelativeToEye;
         *
         * // Example
         * attribute vec3 positionHigh;
         * attribute vec3 positionLow;
         *
         * void main()
         * {
         *   vec3 p = czm_translateRelativeToEye(positionHigh, positionLow);
         *   gl_Position = czm_modelViewProjectionRelativeToEye * vec4(p, 1.0);
         * }
         *
         * @see czm_modelViewRelativeToEye
         * @see czm_translateRelativeToEye
         * @see EncodedCartesian3
         */
        czm_modelViewProjectionRelativeToEye : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModelViewProjectionRelativeToEye();
            }
        },

        /**
         * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
         * transforms model coordinates to clip coordinates.  Clip coordinates is the
         * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
         * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
         * proxy geometry to ensure that triangles are not clipped by the far plane.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_modelViewInfiniteProjection</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_modelViewInfiniteProjection
         * @glslUniform
         *
         * @see UniformState#getModelViewInfiniteProjection
         * @see czm_model
         * @see czm_view
         * @see czm_infiniteProjection
         * @see czm_modelViewProjection
         *
         * @example
         * // GLSL declaration
         * uniform mat4 czm_modelViewInfiniteProjection;
         *
         * // Example
         * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;
         *
         * // The above is equivalent to, but more efficient than:
         * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;
         */
        czm_modelViewInfiniteProjection : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX4;
            },

            getValue : function(uniformState) {
                return uniformState.getModelViewInfiniteProjection();
            }
        },

        /**
         * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
         * transforms normal vectors in model coordinates to eye coordinates.
         * <br /><br />
         * Positions should be transformed to eye coordinates using {@link czm_modelView} and
         * normals should be transformed using <code>czm_normal</code>.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_normal</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_normal
         * @glslUniform
         *
         * @see UniformState#getNormal
         * @see czm_inverseNormal
         * @see czm_modelView
         *
         * @example
         * // GLSL declaration
         * uniform mat3 czm_normal;
         *
         * // Example
         * vec3 eyeNormal = czm_normal * normal;
         */
        czm_normal : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX3;
            },

            getValue : function(uniformState) {
                return uniformState.getNormal();
            }
        },

        /**
         * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
         * transforms normal vectors in eye coordinates to model coordinates.  This is
         * in the opposite transform provided by {@link czm_normal}.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_inverseNormal</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_inverseNormal
         * @glslUniform
         *
         * @see UniformState#getInverseNormal
         * @see czm_normal
         * @see czm_modelView
         * @see czm_inverseView
         *
         * @example
         * // GLSL declaration
         * uniform mat3 czm_inverseNormal;
         *
         * // Example
         * vec3 normalMC = czm_inverseNormal * normalEC;
         */
        czm_inverseNormal : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX3;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseNormal();
            }
        },

        /**
         * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
         * of the frustum defined by the camera.  This is the largest possible frustum, not an individual
         * frustum used for mult-frustum rendering.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_entireFrustum</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_entireFrustum
         * @glslUniform
         *
         * @see UniformState#getEntireFrustum
         *
         * @example
         * // GLSL declaration
         * uniform vec2 czm_entireFrustum;
         *
         * // Example
         * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;
         */
        czm_entireFrustum : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR2;
            },

            getValue : function(uniformState) {
                return uniformState.getEntireFrustum();
            }
        },

        /**
         * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.
         * This is commonly used for directional lighting computations.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_sunDirectionEC</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_sunDirectionEC
         * @glslUniform
         *
         * @see UniformState#getSunDirectionEC
         * @see czm_moonDirectionEC
         * @see czm_sunDirectionWC
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_sunDirectionEC;
         *
         * // Example
         * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);
         */
        czm_sunDirectionEC : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getSunDirectionEC();
            }
        },

        /**
         * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.
         * This is commonly used for directional lighting computations.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_sunDirectionWC</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_sunDirectionWC
         * @glslUniform
         *
         * @see UniformState#getSunDirectionWC
         * @see czm_sunDirectionEC
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_sunDirectionWC;
         */
        czm_sunDirectionWC : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getSunDirectionWC();
            }
        },

        /**
         * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.
         * This is commonly used for directional lighting computations.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_moonDirectionEC</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_moonDirectionEC
         * @glslUniform
         *
         * @see UniformState#getMoonDirectionEC
         * @see czm_sunDirectionEC
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_moonDirectionEC;
         *
         * // Example
         * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);
         */
        czm_moonDirectionEC : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getMoonDirectionEC();
            }
        },

        /**
         * An automatic GLSL uniform representing the high bits of the camera position in model
         * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
         * as described in <a href="http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/">Precisions, Precisions</a>.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_encodedCameraPositionMCHigh</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_encodedCameraPositionMCHigh
         * @glslUniform
         *
         * @see czm_encodedCameraPositionMCLow
         * @see czm_modelViewRelativeToEye
         * @see czm_modelViewProjectionRelativeToEye
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_encodedCameraPositionMCHigh;
         */
        czm_encodedCameraPositionMCHigh : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getEncodedCameraPositionMCHigh();
            }
        },

        /**
         * An automatic GLSL uniform representing the low bits of the camera position in model
         * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
         * as described in <a href="http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/">Precisions, Precisions</a>.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_encodedCameraPositionMCHigh</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_encodedCameraPositionMCLow
         * @glslUniform
         *
         * @see czm_encodedCameraPositionMCHigh
         * @see czm_modelViewRelativeToEye
         * @see czm_modelViewProjectionRelativeToEye
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_encodedCameraPositionMCLow;
         */
        czm_encodedCameraPositionMCLow : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getEncodedCameraPositionMCLow();
            }
        },

        /**
         * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_sunDirectionWC</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_viewerPositionWC
         * @glslUniform
         *
         * @example
         * // GLSL declaration
         * uniform vec3 czm_viewerPositionWC;
         */
        czm_viewerPositionWC : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_VECTOR3;
            },

            getValue : function(uniformState) {
                return uniformState.getInverseView().getTranslation();
            }
        },

        /**
         * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented
         * every frame.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_frameNumber</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_frameNumber
         * @glslUniform
         *
         * @example
         * // GLSL declaration
         * uniform float czm_frameNumber;
         */
        czm_frameNumber : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT;
            },

            getValue : function(uniformState) {
                return uniformState.getFrameNumber();
            }
        },

        /**
         * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms
         * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.
         * <br /><br />
         * Like all automatic uniforms, <code>czm_temeToPseudoFixed</code> does not need to be explicitly declared.
         * However, it can be explicitly declared when a shader is also used by other applications such
         * as a third-party authoring tool.
         *
         * @alias czm_temeToPseudoFixed
         * @glslUniform
         *
         * @see UniformState#getTemeToPseudoFixedMatrix
         * @see Transforms.computeTemeToPseudoFixedMatrix
         *
         * @example
         * // GLSL declaration
         * uniform mat3 czm_temeToPseudoFixed;
         *
         * // Example
         * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;
         */
        czm_temeToPseudoFixed : {
            getSize : function() {
                return 1;
            },

            getDatatype : function() {
                return UniformDatatype.FLOAT_MATRIX3;
            },

            getValue : function(uniformState) {
                return uniformState.getTemeToPseudoFixedMatrix();
            }
        }
    };

    function getUniformDatatype(gl, activeUniformType) {
        switch (activeUniformType) {
        case gl.FLOAT:
            return function() {
                return UniformDatatype.FLOAT;
            };
        case gl.FLOAT_VEC2:
            return function() {
                return UniformDatatype.FLOAT_VECTOR2;
            };
        case gl.FLOAT_VEC3:
            return function() {
                return UniformDatatype.FLOAT_VECTOR3;
            };
        case gl.FLOAT_VEC4:
            return function() {
                return UniformDatatype.FLOAT_VECTOR4;
            };
        case gl.INT:
            return function() {
                return UniformDatatype.INT;
            };
        case gl.INT_VEC2:
            return function() {
                return UniformDatatype.INT_VECTOR2;
            };
        case gl.INT_VEC3:
            return function() {
                return UniformDatatype.INT_VECTOR3;
            };
        case gl.INT_VEC4:
            return function() {
                return UniformDatatype.INT_VECTOR4;
            };
        case gl.BOOL:
            return function() {
                return UniformDatatype.BOOL;
            };
        case gl.BOOL_VEC2:
            return function() {
                return UniformDatatype.BOOL_VECTOR2;
            };
        case gl.BOOL_VEC3:
            return function() {
                return UniformDatatype.BOOL_VECTOR3;
            };
        case gl.BOOL_VEC4:
            return function() {
                return UniformDatatype.BOOL_VECTOR4;
            };
        case gl.FLOAT_MAT2:
            return function() {
                return UniformDatatype.FLOAT_MATRIX2;
            };
        case gl.FLOAT_MAT3:
            return function() {
                return UniformDatatype.FLOAT_MATRIX3;
            };
        case gl.FLOAT_MAT4:
            return function() {
                return UniformDatatype.FLOAT_MATRIX4;
            };
        case gl.SAMPLER_2D:
            return function() {
                return UniformDatatype.SAMPLER_2D;
            };
        case gl.SAMPLER_CUBE:
            return function() {
                return UniformDatatype.SAMPLER_CUBE;
            };
        default:
            throw new RuntimeError('Unrecognized uniform type: ' + activeUniformType);
        }
    }

    /**
     * A shader program's uniform, including the uniform's value.  This is most commonly used to change
     * the value of a uniform, but can also be used retrieve a uniform's name and datatype,
     * which is useful for creating user interfaces for tweaking shaders.
     * <br /><br />
     * Do not create a uniform object with the <code>new</code> keyword; a shader program's uniforms
     * are available via {@link ShaderProgram#getAllUniforms}.
     * <br /><br />
     * Changing a uniform's value will affect future calls to {@link Context#draw}
     * that use the corresponding shader program.
     * <br /><br />
     * The datatype of the <code>value</code> property depends on the datatype
     * used in the GLSL declaration as shown in the examples in the table below.
     * <br /><br />
     * <table border='1'>
     * <tr>
     * <td>GLSL</td>
     * <td>JavaScript</td>
     * </tr>
     * <tr>
     * <td><code>uniform float u_float; </code></td>
     * <td><code> sp.getAllUniforms().u_float.value = 1.0;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec2 u_vec2; </code></td>
     * <td><code> sp.getAllUniforms().u_vec2.value = new Cartesian2(1.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec3 u_vec3; </code></td>
     * <td><code> sp.getAllUniforms().u_vec3.value = new Cartesian3(1.0, 2.0, 3.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec4 u_vec4; </code></td>
     * <td><code> sp.getAllUniforms().u_vec4.value = new Cartesian4(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform int u_int; </code></td>
     * <td><code> sp.getAllUniforms().u_int.value = 1;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec2 u_ivec2; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec2.value = new Cartesian2(1, 2);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec3 u_ivec3; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec3.value = new Cartesian3(1, 2, 3);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec4 u_ivec4; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec4.value = new Cartesian4(1, 2, 3, 4);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bool u_bool; </code></td>
     * <td><code> sp.getAllUniforms().u_bool.value = true;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec2 u_bvec2; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec2.value = new Cartesian2(true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec3 u_bvec3; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec3.value = new Cartesian3(true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec4 u_bvec4; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat2 u_mat2; </code></td>
     * <td><code> sp.getAllUniforms().u_mat2.value = new Matrix2(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat3 u_mat3; </code></td>
     * <td><code> sp.getAllUniforms().u_mat3.value = new Matrix3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat4 u_mat4; </code></td>
     * <td><code> sp.getAllUniforms().u_mat4.value = new Matrix4(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform sampler2D u_texture; </code></td>
     * <td><code> sp.getAllUniforms().u_texture.value = context.createTexture2D(...);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform samplerCube u_cubeMap; </code></td>
     * <td><code> sp.getAllUniforms().u_cubeMap.value = context.createCubeMap(...);</code></td>
     * </tr>
     * </table>
     * <br />
     * When the GLSL uniform is declared as an array, <code>value</code> is also an array as shown in Example 2.
     * Individual members of a <code>struct uniform</code> can be accessed as done in Example 3.
     * <br /><br />
     * Uniforms whose names starting with <code>czm_</code>, such as {@link czm_viewProjection}, are called
     * automatic uniforms; they are implicitly declared and automatically assigned to in
     * <code>Context.draw</code> based on the {@link UniformState}.
     *
     * @alias Uniform
     * @internalConstructor
     *
     * @see Uniform#value
     * @see UniformDatatype
     * @see ShaderProgram#getAllUniforms
     * @see UniformState
     * @see Context#draw
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     *
     * @example
     * // Example 1. Create a shader program and set its
     * // one uniform, a 4x4 matrix, to the identity matrix
     * var vs =
     *   'attribute vec4 position; ' +
     *   'uniform mat4 u_mvp; ' +
     *   'void main() { gl_Position = u_mvp * position; }';
     * var fs = // ...
     * var sp = context.createShaderProgram(vs, fs);
     *
     * var mvp = sp.getAllUniforms().u_mvp;
     * console.log(mvp.getName());           // 'u_mvp'
     * console.log(mvp.getDatatype().name);  // 'FLOAT_MATRIX4'
     * mvp.value = Matrix4.IDENTITY;
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Setting values for a GLSL array uniform
     * // GLSL:  uniform float u_float[2];
     * sp.getAllUniforms().u_float.value = new Cartesian2(1.0, 2.0);
     *
     * // GLSL:  uniform vec4 u_vec4[2];
     * sp.getAllUniforms().u_vec4.value = [
     *   Cartesian4.UNIT_X,
     *   Cartesian4.UNIT_Y
     * ];
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Setting values for members of a GLSL struct
     * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
     * sp.getAllUniforms()['u_struct.f'].value = 1.0;
     * sp.getAllUniforms()['u_struct.v'].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
     */
    var Uniform = function(_gl, activeUniform, _uniformName, _location, uniformValue) {
        /**
         * The value of the uniform.  The datatype depends on the datatype used in the
         * GLSL declaration as explained in the {@link Uniform} help and shown
         * in the examples below.
         *
         * @field
         * @alias Uniform#value
         *
         * @see Context#createTexture2D
         *
         * @example
         * // GLSL:  uniform float u_float;
         * sp.getAllUniforms().u_float.value = 1.0;
         *
         * // GLSL:  uniform vec4 u_vec4;
         * sp.getAllUniforms().u_vec4.value = Cartesian4.ZERO;
         *
         * // GLSL:  uniform bvec4 u_bvec4;
         * sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);
         *
         * // GLSL:  uniform mat4 u_mat4;
         * sp.getAllUniforms().u_mat4.value = Matrix4.IDENTITY;
         *
         * // GLSL:  uniform sampler2D u_texture;
         * sp.getAllUniforms().u_texture.value = context.createTexture2D(...);
         *
         * // GLSL:  uniform vec2 u_vec2[2];
         * sp.getAllUniforms().u_vec2.value = [
         *   new Cartesian2(1.0, 2.0),
         *   new Cartesian2(3.0, 4.0)
         * ];
         *
         * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
         * sp.getAllUniforms()['u_struct.f'].value = 1.0;
         * sp.getAllUniforms()['u_struct.v'].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
         */
        this.value = uniformValue;

        /**
         * Returns the case-sensitive name of the GLSL uniform.
         *
         * @returns {String} The name of the uniform.
         * @function
         * @alias Uniform#getName
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getName());  // 'u_mvp'
         */
        this.getName = function() {
            return _uniformName;
        };

        /**
         * Returns the datatype of the uniform.  This is useful when dynamically
         * creating a user interface to tweak shader uniform values.
         *
         * @returns {UniformDatatype} The datatype of the uniform.
         * @function
         * @alias Uniform#getDatatype
         *
         * @see UniformDatatype
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getDatatype().name);  // 'FLOAT_MATRIX4'
         */
        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocation = function() {
            return _location;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    _gl.uniform1f(_location, this.value);
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2f(_location, v.x, v.y);
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3f(_location, v.x, v.y, v.z);
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    var v = this.value;

                    if (typeof v.red !== 'undefined') {
                        _gl.uniform4f(_location, v.red, v.green, v.blue, v.alpha);
                    } else if (typeof v.x !== 'undefined') {
                        _gl.uniform4f(_location, v.x, v.y, v.z, v.w);
                    } else {
                        throw new DeveloperError('Invalid vec4 value for uniform "' + activeUniform.name + '".');
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    _gl.uniform1i(_location, this.value);
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2i(_location, v.x, v.y);
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3i(_location, v.x, v.y, v.z);
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    var v = this.value;
                    _gl.uniform4i(_location, v.x, v.y, v.z, v.w);
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    _gl.uniformMatrix2fv(_location, false, Matrix2.toArray(this.value));
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    _gl.uniformMatrix3fv(_location, false, Matrix3.toArray(this.value));
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    _gl.uniformMatrix4fv(_location, false, Matrix4.toArray(this.value));
                };
            default:
                throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type + ' for uniform "' + activeUniform.name + '".');
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), this.value._getTexture());
                _gl.uniform1i(_location, textureUnitIndex);

                return textureUnitIndex + 1;
            };

            this._clearSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), null);

                return textureUnitIndex + 1;
            };
        }
    };

    /**
     * Uniform and UniformArray have the same documentation.  It is just an implementation
     * detail that they are two different types.
     *
     * @alias UniformArray
     * @constructor
     *
     * @see Uniform
     */
    var UniformArray = function(_gl, activeUniform, _uniformName, locations, value) {
        this.value = value;

        var _locations = locations;

        /**
         * @private
         */
        this.getName = function() {
            return _uniformName;
        };

        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocations = function() {
            return _locations;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1f(_locations[i], this.value[i]);
                    }
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2f(_locations[i], v.x, v.y);
                    }
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3f(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];

                        if (typeof v.red !== 'undefined') {
                            _gl.uniform4f(_locations[i], v.red, v.green, v.blue, v.alpha);
                        } else if (typeof v.x !== 'undefined') {
                            _gl.uniform4f(_locations[i], v.x, v.y, v.z, v.w);
                        } else {
                            throw new DeveloperError('Invalid vec4 value.');
                        }
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1i(_locations[i], this.value[i]);
                    }
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2i(_locations[i], v.x, v.y);
                    }
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3i(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform4i(_locations[i], v.x, v.y, v.z, v.w);
                    }
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix2fv(_locations[i], false, Matrix2.toArray(this.value[i]));
                    }
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix3fv(_locations[i], false, Matrix3.toArray(this.value[i]));
                    }
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix4fv(_locations[i], false, Matrix4.toArray(this.value[i]));
                    }
                };
            default:
                throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type);
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    var value = this.value[i];
                    var index = textureUnitIndex + i;
                    _gl.activeTexture(_gl.TEXTURE0 + index);
                    _gl.bindTexture(value._getTarget(), value._getTexture());
                    _gl.uniform1i(_locations[i], index);
                }

                return textureUnitIndex + _locations.length;
            };

            this._clearSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex + i);
                    _gl.bindTexture(this.value[i]._getTarget(), null);
                }

                return textureUnitIndex + _locations.length;
            };
        }
    };

    /**
     * DOC_TBA
     *
     * @alias ShaderProgram
     * @internalConstructor
     *
     * @see Context#createShaderProgram
     * @see Context#getShaderCache
     */
    var ShaderProgram = function(gl, logShaderCompilation, vertexShaderSource, fragmentShaderSource, attributeLocations) {
        var program = createAndLinkProgram(gl, logShaderCompilation, vertexShaderSource, fragmentShaderSource, attributeLocations);
        var numberOfVertexAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        var uniforms = findUniforms(gl, program);
        var partitionedUniforms = partitionUniforms(uniforms.allUniforms);

        this._gl = gl;
        this._program = program;
        this._numberOfVertexAttributes = numberOfVertexAttributes;
        this._vertexAttributes = findVertexAttributes(gl, program, numberOfVertexAttributes);
        this._allUniforms = uniforms.allUniforms;
        this._uniforms = uniforms.uniforms;
        this._samplerUniforms = uniforms.samplerUniforms;
        this._automaticUniforms = partitionedUniforms.automaticUniforms;
        this._manualUniforms = partitionedUniforms.manualUniforms;
    };

    function extractShaderVersion(source) {
        // This will fail if the first #version is actually in a comment.
        var index = source.indexOf('#version');
        if (index !== -1) {
            var newLineIndex = source.indexOf('\n', index);

            // We could throw an exception if there is not a new line after
            // #version, but the GLSL compiler will catch it.
            if (index !== -1) {
                // Extract #version directive, including the new line.
                var version = source.substring(index, newLineIndex + 1);

                // Comment out original #version directive so the line numbers
                // are not off by one.  There can be only one #version directive
                // and it must appear at the top of the source, only preceded by
                // whitespace and comments.
                var modified = source.substring(0, index) + '//' + source.substring(index);

                return {
                    versionDirective : version,
                    modifiedSource : modified
                };
            }
        }

        return {
            versionDirective : '', // defaults to #version 100
            modifiedSource : source // no modifications required
        };
    }

    function getAutomaticUniformDeclaration(uniforms, uniform) {
        var automaticUniform = uniforms[uniform];
        var declaration = 'uniform ' + automaticUniform.getDatatype().getGLSL() + ' ' + uniform;

        var size = automaticUniform.getSize();
        if (size === 1) {
            declaration += ';';
        } else {
            declaration += '[' + size.toString() + '];';
        }

        return declaration;
    }

    function commentOutAutomaticUniforms(source) {
        // Comment out automatic uniforms that the user may have declared, perhaps
        // because the shader was authored in a third-party tool like RenderMonkey.
        // At runtime, all automatic uniforms are declared by the engine itself.

        // This function has problems if the automatic uniform was declared with the
        // wrong datatype or with extra whitespace or comments in the declaration.

        var modifiedSource = source;
        var uniforms = allAutomaticUniforms;
        for ( var uniform in uniforms) {
            if (uniforms.hasOwnProperty(uniform)) {
                var declaration = getAutomaticUniformDeclaration(uniforms, uniform);
                var index = modifiedSource.indexOf(declaration);
                if (index !== -1) {
                    modifiedSource =
                        modifiedSource.substring(0, index) +
                        '/*' +
                        modifiedSource.substring(index, declaration.length) +
                        '*/' +
                        modifiedSource.substring(index + declaration.length);
                }
            }
        }

        return modifiedSource;
    }

    function getFragmentShaderPrecision() {
        // TODO: Performance?
        return '#ifdef GL_FRAGMENT_PRECISION_HIGH \n' +
               '  precision highp float; \n' +
               '#else \n' +
               '  precision mediump float; \n' +
               '#endif \n\n';
    }

    function getBuiltinConstants() {
        var constants = {
            /**
             * A built-in GLSL floating-point constant for <code>Math.PI</code>.
             *
             * @alias czm_pi
             * @glslConstant
             *
             * @see CesiumMath.PI
             *
             * @example
             * // GLSL declaration
             * const float czm_pi = ...;
             *
             * // Example
             * float twoPi = 2.0 * czm_pi;
             */
            czm_pi : Math.PI.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>1/pi</code>.
             *
             * @alias czm_oneOverPi
             * @glslConstant
             *
             * @see CesiumMath.ONE_OVER_PI
             *
             * @example
             * // GLSL declaration
             * const float czm_oneOverPi = ...;
             *
             * // Example
             * float pi = 1.0 / czm_oneOverPi;
             */
            czm_oneOverPi : CesiumMath.ONE_OVER_PI.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>pi/2</code>.
             *
             * @alias czm_piOverTwo
             * @glslConstant
             *
             * @see CesiumMath.PI_OVER_TWO
             *
             * @example
             * // GLSL declaration
             * const float czm_piOverTwo = ...;
             *
             * // Example
             * float pi = 2.0 * czm_piOverTwo;
             */
            czm_piOverTwo : CesiumMath.PI_OVER_TWO.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>pi/3</code>.
             *
             * @alias czm_piOverThree
             * @glslConstant
             *
             * @see CesiumMath.PI_OVER_THREE
             *
             * @example
             * // GLSL declaration
             * const float czm_piOverThree = ...;
             *
             * // Example
             * float pi = 3.0 * czm_piOverThree;
             */
            czm_piOverThree : CesiumMath.PI_OVER_THREE.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>pi/4</code>.
             *
             * @alias czm_piOverFour
             * @glslConstant
             *
             * @see CesiumMath.PI_OVER_FOUR
             *
             * @example
             * // GLSL declaration
             * const float czm_piOverFour = ...;
             *
             * // Example
             * float pi = 4.0 * czm_piOverFour;
             */
            czm_piOverFour : CesiumMath.PI_OVER_FOUR.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>pi/6</code>.
             *
             * @alias czm_piOverSix
             * @glslConstant
             *
             * @see CesiumMath.PI_OVER_SIX
             *
             * @example
             * // GLSL declaration
             * const float czm_piOverSix = ...;
             *
             * // Example
             * float pi = 6.0 * czm_piOverSix;
             */
            czm_piOverSix : CesiumMath.PI_OVER_SIX.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>3pi/2</code>.
             *
             * @alias czm_threePiOver2
             * @glslConstant
             *
             * @see CesiumMath.THREE_PI_OVER_TWO
             *
             * @example
             * // GLSL declaration
             * const float czm_threePiOver2 = ...;
             *
             * // Example
             * float pi = (2.0 / 3.0) * czm_threePiOver2;
             */
            czm_threePiOver2 : CesiumMath.THREE_PI_OVER_TWO.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>2pi</code>.
             *
             * @alias czm_twoPi
             * @glslConstant
             *
             * @see CesiumMath.TWO_PI
             *
             * @example
             * // GLSL declaration
             * const float czm_twoPi = ...;
             *
             * // Example
             * float pi = czm_twoPi / 2.0;
             */
            czm_twoPi : CesiumMath.TWO_PI.toString(),

            /**
             * A built-in GLSL floating-point constant for <code>1/2pi</code>.
             *
             * @alias czm_oneOverTwoPi
             * @glslConstant
             *
             * @see CesiumMath.ONE_OVER_TWO_PI
             *
             * @example
             * // GLSL declaration
             * const float czm_oneOverTwoPi = ...;
             *
             * // Example
             * float pi = 2.0 * czm_oneOverTwoPi;
             */
            czm_oneOverTwoPi : CesiumMath.ONE_OVER_TWO_PI.toString(),

            /**
             * A built-in GLSL floating-point constant for converting degrees to radians.
             *
             * @alias czm_radiansPerDegree
             * @glslConstant
             *
             * @see CesiumMath.RADIANS_PER_DEGREE
             *
             * @example
             * // GLSL declaration
             * const float czm_radiansPerDegree = ...;
             *
             * // Example
             * float rad = czm_radiansPerDegree * deg;
             */
            czm_radiansPerDegree : CesiumMath.RADIANS_PER_DEGREE.toString(),

            /**
             * A built-in GLSL floating-point constant for converting radians to degrees.
             *
             * @alias czm_degreesPerRadian
             * @glslConstant
             *
             * @see CesiumMath.DEGREES_PER_RADIAN
             *
             * @example
             * // GLSL declaration
             * const float czm_degreesPerRadian = ...;
             *
             * // Example
             * float deg = czm_degreesPerRadian * rad;
             */
            czm_degreesPerRadian : CesiumMath.DEGREES_PER_RADIAN.toString()
        };

        var glslConstants = '';
        for ( var name in constants) {
            if (constants.hasOwnProperty(name)) {
                glslConstants += 'const float ' + name + ' = ' + constants[name] + '; \n';
            }
        }
        glslConstants += ' \n';

        return glslConstants;
    }

    function getAutomaticUniforms() {
        var automatics = '';

        var uniforms = allAutomaticUniforms;
        for ( var uniform in uniforms) {
            if (uniforms.hasOwnProperty(uniform)) {
                automatics += getAutomaticUniformDeclaration(uniforms, uniform) + ' \n';
            }
        }
        automatics += '\n';

        return automatics;
    }

    var getShaderDefinitions = function() {
        // I think this should be #line 1 given what the GL ES spec says:
        //
        //   After processing this directive (including its new-line), the implementation will
        //   behave as if the following line has line number line...
        //
        // But this works, at least on NVIDIA hardware.

        // Functions after constants and uniforms because functions depend on them.
        var definitions = getBuiltinConstants() +
                          getAutomaticUniforms() +
                          ShadersBuiltinFunctions + '\n\n' +
                          '#line 0 \n';

        getShaderDefinitions = function() {
            return definitions;
        };

        return definitions;
    };

    function createAndLinkProgram(gl, logShaderCompilation, vertexShaderSource, fragmentShaderSource, attributeLocations) {
        var vsSourceVersioned = extractShaderVersion(vertexShaderSource);
        var fsSourceVersioned = extractShaderVersion(fragmentShaderSource);

        var vsSource = vsSourceVersioned.versionDirective +
                       getShaderDefinitions() +
                       commentOutAutomaticUniforms(vsSourceVersioned.modifiedSource);
        var fsSource = fsSourceVersioned.versionDirective +
                       getFragmentShaderPrecision() +
                       getShaderDefinitions() +
                       commentOutAutomaticUniforms(fsSourceVersioned.modifiedSource);

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        var vsLog = gl.getShaderInfoLog(vertexShader);

        if (logShaderCompilation && vsLog && vsLog.length) {
            console.log('[GL] Vertex shader compile log: ' + vsLog);
        }

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            gl.deleteShader(vertexShader);
            console.error('[GL] Vertex shader compile log: ' + vsLog);
            throw new RuntimeError('Vertex shader failed to compile.  Compile log: ' + vsLog);
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        var fsLog = gl.getShaderInfoLog(fragmentShader);

        if (logShaderCompilation && fsLog && fsLog.length) {
            console.log('[GL] Fragment shader compile log: ' + fsLog);
        }

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            console.error('[GL] Fragment shader compile log: ' + fsLog);
            throw new RuntimeError('Fragment shader failed to compile.  Compile log: ' + fsLog);
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);

        if (attributeLocations) {
            for ( var attribute in attributeLocations) {
                if (attributeLocations.hasOwnProperty(attribute)) {
                    gl.bindAttribLocation(program, attributeLocations[attribute], attribute);
                }
            }
        }

        gl.linkProgram(program);
        var linkLog = gl.getProgramInfoLog(program);

        if (logShaderCompilation && linkLog && linkLog.length) {
            console.log('[GL] Shader program link log: ' + linkLog);
        }

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.deleteProgram(program);
            console.error('[GL] Shader program link log: ' + linkLog);
            throw new RuntimeError('Program failed to link.  Link log: ' + linkLog);
        }

        return program;
    }

    function findVertexAttributes(gl, program, numberOfAttributes) {
        var attributes = {};
        for ( var i = 0; i < numberOfAttributes; ++i) {
            var attr = gl.getActiveAttrib(program, i);
            var location = gl.getAttribLocation(program, attr.name);

            attributes[attr.name] = {
                name : attr.name,
                type : attr.type,
                index : location
            };
        }

        return attributes;
    }

    function findUniforms(gl ,program) {
        var allUniforms = {};
        var uniforms = [];
        var samplerUniforms = [];

        var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

        for ( var i = 0; i < numberOfUniforms; ++i) {
            var activeUniform = gl.getActiveUniform(program, i);
            var suffix = '[0]';
            var uniformName = activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ?
                    activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;

            // Ignore GLSL built-in uniforms returned in Firefox.
            if (uniformName.indexOf('gl_') !== 0) {
                if (activeUniform.name.indexOf('[') < 0) {
                    // Single uniform
                    var location = gl.getUniformLocation(program, uniformName);
                    var uniformValue = gl.getUniform(program, location);
                    var uniform = new Uniform(gl, activeUniform, uniformName, location, uniformValue);

                    allUniforms[uniformName] = uniform;

                    if (uniform._setSampler) {
                        samplerUniforms.push(uniform);
                    } else {
                        uniforms.push(uniform);
                    }
                } else {
                    // Uniform array
                    var locations = [];
                    var value = [];
                    for ( var j = 0; j < activeUniform.size; ++j) {
                        var loc = gl.getUniformLocation(program, uniformName + '[' + j + ']');
                        locations.push(loc);
                        value.push(gl.getUniform(program, loc));
                    }
                    var uniformArray = new UniformArray(gl, activeUniform, uniformName, locations, value);

                    allUniforms[uniformName] = uniformArray;

                    if (uniformArray._setSampler) {
                        samplerUniforms.push(uniformArray);
                    } else {
                        uniforms.push(uniformArray);
                    }
                }
            }
        }

        return {
            allUniforms : allUniforms,
            uniforms : uniforms,
            samplerUniforms : samplerUniforms
        };
    }

    function partitionUniforms(uniforms) {
        var automaticUniforms = [];
        var manualUniforms = {};

        for (var uniform in uniforms) {
            if (uniforms.hasOwnProperty(uniform)) {
                var automaticUniform = allAutomaticUniforms[uniform];
                if (automaticUniform) {
                    automaticUniforms.push({
                        uniform : uniforms[uniform],
                        automaticUniform : automaticUniform
                    });
                } else {
                    manualUniforms[uniform] = uniforms[uniform];
                }
            }
        }

        return {
            automaticUniforms : automaticUniforms,
            manualUniforms : manualUniforms
        };
    }

    /**
     * DOC_TBA
     * @memberof ShaderProgram
     *
     * @return {Object} DOC_TBA
     * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
     */
    ShaderProgram.prototype.getVertexAttributes = function() {
        return this._vertexAttributes;
    };

    /**
     * DOC_TBA
     * @memberof ShaderProgram
     *
     * @return {Number} DOC_TBA
     * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
     */
    ShaderProgram.prototype.getNumberOfVertexAttributes = function() {
        return this._numberOfVertexAttributes;
    };

    /**
     * DOC_TBA
     * @memberof ShaderProgram
     *
     * @return {Object} DOC_TBA
     *
     * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
     *
     * @see ShaderProgram#getManualUniforms
     */
    ShaderProgram.prototype.getAllUniforms = function() {
        return this._allUniforms;
    };

    /**
     * DOC_TBA
     * @memberof ShaderProgram
     *
     * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
     *
     * @see ShaderProgram#getAllUniforms
     */
    ShaderProgram.prototype.getManualUniforms = function() {
        return this._manualUniforms;
    };

    ShaderProgram.prototype._bind = function() {
        this._gl.useProgram(this._program);
    };

    ShaderProgram.prototype._unBind = function() {
        this._gl.useProgram(null);

        var samplerUniforms = this._samplerUniforms;
        var textureUnitIndex = 0;
        var len = samplerUniforms.length;
        for ( var i = 0; i < len; ++i) {
            textureUnitIndex = samplerUniforms[i]._clearSampler(textureUnitIndex);
        }
    };

    ShaderProgram.prototype._setUniforms = function(uniformMap, uniformState, validate) {
        // TODO: Performance

        var len;
        var i;

        var uniforms = this._uniforms;
        var samplerUniforms = this._samplerUniforms;
        var manualUniforms = this._manualUniforms;
        var automaticUniforms = this._automaticUniforms;

        if (uniformMap) {
            for (var uniform in manualUniforms) {
                if (manualUniforms.hasOwnProperty(uniform)) {
                    manualUniforms[uniform].value = uniformMap[uniform]();
                }
            }
        }

        len = automaticUniforms.length;
        for (i = 0; i < len; ++i) {
            automaticUniforms[i].uniform.value = automaticUniforms[i].automaticUniform.getValue(uniformState);
        }

        ///////////////////////////////////////////////////////////////////

        len = uniforms.length;
        for (i = 0; i < len; ++i) {
            uniforms[i]._set();
        }

        var textureUnitIndex = 0;
        len = samplerUniforms.length;
        for (i = 0; i < len; ++i) {
            textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
        }

        if (validate) {
            var gl = this._gl;
            var program = this._program;

            gl.validateProgram(program);
            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
                throw new DeveloperError('Program validation failed.  Link log: ' + gl.getProgramInfoLog(program));
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @memberof ShaderProgram
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ShaderProgram#destroy
     */
    ShaderProgram.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @memberof ShaderProgram
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
     *
     * @see ShaderProgram#isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteShader.xml'>glDeleteShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteProgram.xml'>glDeleteProgram</a>
     *
     * @example
     * shaderProgram = shaderProgram && shaderProgram.destroy();
     */
    ShaderProgram.prototype.destroy = function() {
        this._gl.deleteProgram(this._program);
        return destroyObject(this);
    };

    /**
     * DOC_TBA
     * @memberof ShaderProgram
     */
    ShaderProgram.prototype.release = function() {
        if (this._cachedShader) {
            return this._cachedShader.cache.releaseShaderProgram(this);
        }

        return this.destroy();
    };

    return ShaderProgram;
});

/*global define*/
define('Renderer/Context',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/IndexDatatype',
        '../Core/RuntimeError',
        '../Core/PrimitiveType',
        '../Core/WindingOrder',
        '../Core/BoundingRectangle',
        '../Core/createGuid',
        '../Core/Matrix4',
        './Buffer',
        './BufferUsage',
        './BlendEquation',
        './BlendFunction',
        './CubeMap',
        './CullFace',
        './DepthFunction',
        './Framebuffer',
        './MipmapHint',
        './PixelDatatype',
        './PixelFormat',
        './PickFramebuffer',
        './Renderbuffer',
        './RenderbufferFormat',
        './ShaderCache',
        './ShaderProgram',
        './StencilFunction',
        './StencilOperation',
        './Texture',
        './TextureAtlas',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap',
        './UniformState',
        './VertexArray',
        './VertexLayout'
    ], function(
        defaultValue,
        DeveloperError,
        destroyObject,
        Color,
        IndexDatatype,
        RuntimeError,
        PrimitiveType,
        WindingOrder,
        BoundingRectangle,
        createGuid,
        Matrix4,
        Buffer,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        CubeMap,
        CullFace,
        DepthFunction,
        Framebuffer,
        MipmapHint,
        PixelDatatype,
        PixelFormat,
        PickFramebuffer,
        Renderbuffer,
        RenderbufferFormat,
        ShaderCache,
        ShaderProgram,
        StencilFunction,
        StencilOperation,
        Texture,
        TextureAtlas,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        UniformState,
        VertexArray,
        VertexLayout) {
    
    /*global Uint8Array*/

    function _errorToString(gl, error) {
        var message = 'OpenGL Error:  ';
        switch (error) {
        case gl.INVALID_ENUM:
            message += 'Invalid enumeration';
            break;
        case gl.INVALID_VALUE:
            message += 'Invalid value';
            break;
        case gl.INVALID_OPERATION:
            message += 'Invalid operation';
            break;
        case gl.OUT_OF_MEMORY:
            message += 'Out of memory';
            break;
        case gl.CONTEXT_LOST_WEBGL:
            message += 'Context lost';
            break;
        default:
            message += 'Unknown';
        }

        return message;
    }

    function _createErrorMessage(gl, glFunc, glFuncArguments, error) {
        var message = _errorToString(gl, error) + ': ' + glFunc.name + '(';

        for ( var i = 0; i < glFuncArguments.length; ++i) {
            if (i !== 0) {
                message += ', ';
            }
            message += glFuncArguments[i];
        }
        message += ');';

        return message;
    }

    function throwOnError(gl, glFunc, glFuncArguments) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new RuntimeError(_createErrorMessage(gl, glFunc, glFuncArguments, error));
        }
    }

    function wrapGL(gl, logFunc) {
        if (!logFunc) {
            return gl;
        }

        function wrapFunction(property) {
            return function() {
                var result = property.apply(gl, arguments);
                logFunc(gl, property, arguments);
                return result;
            };
        }

        var glWrapper = {};

        /*jslint forin: true*/
        /*jshint forin: false*/
        // JSLint normally demands that a for..in loop must directly contain an if,
        // but in our loop below, we actually intend to iterate all properties, including
        // those in the prototype.
        for ( var propertyName in gl) {
            var property = gl[propertyName];

            // wrap any functions we encounter, otherwise just copy the property to the wrapper.
            if (typeof property === 'function') {
                glWrapper[propertyName] = wrapFunction(property);
            } else {
                glWrapper[propertyName] = property;
            }
        }

        return glWrapper;
    }

    /**
     * DOC_TBA
     *
     * @alias Context
     * @constructor
     *
     * @exception {RuntimeError} The browser does not support WebGL.  Visit http://get.webgl.org.
     * @exception {RuntimeError} The browser supports WebGL, but initialization failed.
     * @exception {DeveloperError} canvas is required.
     */
    var Context = function(canvas, options) {
        if (!window.WebGLRenderingContext) {
            throw new RuntimeError('The browser does not support WebGL.  Visit http://get.webgl.org.');
        }

        if (!canvas) {
            throw new DeveloperError('canvas is required.');
        }

        this._canvas = canvas;

        if (typeof options === 'undefined') {
            options = {};
        }
        if (typeof options.stencil === 'undefined') {
            options.stencil = true;
        }
        if (typeof options.alpha === 'undefined') {
            options.alpha = false;
        }

        this._originalGLContext = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);

        if (!this._originalGLContext) {
            throw new RuntimeError('The browser supports WebGL, but initialization failed.');
        }

        this._id = createGuid();

        // Validation and logging disabled by default for speed.
        this._validateFB = false;
        this._validateSP = false;
        this._logShaderCompilation = false;
        this._throwOnWebGLError = false;

        // TODO:  Also need point_size and point_size_enable for ColladaFX
        // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
        this._shaderCache = new ShaderCache(this);

        var gl = this._gl = this._originalGLContext;

        this._version = gl.getParameter(gl.VERSION);
        this._shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        this._vendor = gl.getParameter(gl.VENDOR);
        this._renderer = gl.getParameter(gl.RENDERER);
        this._redBits = gl.getParameter(gl.RED_BITS);
        this._greenBits = gl.getParameter(gl.GREEN_BITS);
        this._blueBits = gl.getParameter(gl.BLUE_BITS);
        this._alphaBits = gl.getParameter(gl.ALPHA_BITS);
        this._depthBits = gl.getParameter(gl.DEPTH_BITS);
        this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
        this._maximumCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE); // min: 16
        this._maximumFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS); // min: 16
        this._maximumTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE); // min: 1
        this._maximumTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE); // min: 64
        this._maximumVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS); // min: 8
        this._maximumVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS); // min: 8
        this._maximumVertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS); // min: 0
        this._maximumVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS); // min: 128
        this._aliasedLineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE); // must include 1
        this._aliasedPointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); // must include 1
        this._maximumViewportDimensions = gl.getParameter(gl.MAX_VIEWPORT_DIMS);

        // Query and initialize extensions
        this._standardDerivatives = gl.getExtension('OES_standard_derivatives');
        this._depthTexture = gl.getExtension('WEBKIT_WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture');
        var textureFilterAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._maximumTextureFilterAnisotropy = textureFilterAnisotropic ? gl.getParameter(textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;

        var cc = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        this._clearColor = new Color(cc[0], cc[1], cc[2], cc[3]);
        this._clearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
        this._clearStencil = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
        this._defaultClearColor = new Color(cc[0], cc[1], cc[2], cc[3]);
        this._defaultClearDepth = this._clearDepth;
        this._defaultClearStencil = this._clearStencil;

        this._us = new UniformState();
        this._currentFramebuffer = undefined;
        this._currentSp = undefined;

        this._defaultTexture = undefined;
        this._defaultCubeMap = undefined;
    };

    Context.prototype._enableOrDisable = function(glEnum, enable) {
        if (enable) {
            this._gl.enable(glEnum);
        } else {
            this._gl.disable(glEnum);
        }
    };

    Context.prototype._applyFrontFace = function(frontFace) {
        this._gl.frontFace(frontFace);
    };

    Context.prototype._applyCull = function(cull) {
        var gl = this._gl;
        var enabled = cull.enabled;

        this._enableOrDisable(gl.CULL_FACE, enabled);

        if (enabled) {
            gl.cullFace(cull.face);
        }
    };

    Context.prototype._applyLineWidth = function(lineWidth) {
        this._gl.lineWidth(lineWidth);
    };

    Context.prototype._applyPolygonOffset = function(polygonOffset) {
        var gl = this._gl;
        var enabled = polygonOffset.enabled;

        this._enableOrDisable(gl.POLYGON_OFFSET_FILL, enabled);

        if (enabled) {
            gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
        }
    };

    Context.prototype._applyScissorTest = function(scissorTest) {
        var gl = this._gl;
        var enabled = scissorTest.enabled;

        this._enableOrDisable(gl.SCISSOR_TEST, enabled);

        if (enabled) {
            var newRectangle = scissorTest.rectangle;
            gl.scissor(newRectangle.x, newRectangle.y, newRectangle.width, newRectangle.height);
        }
    };

    Context.prototype._applyDepthRange = function(depthRange) {
        var near = depthRange.near;
        var far = depthRange.far;
        this._gl.depthRange(near, far);
    };

    Context.prototype._applyDepthTest = function(depthTest) {
        var gl = this._gl;
        var enabled = depthTest.enabled;

        this._enableOrDisable(gl.DEPTH_TEST, enabled);

        if (enabled) {
            gl.depthFunc(depthTest.func);
        }
    };

    Context.prototype._applyColorMask = function(colorMask) {
        this._gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
    };

    Context.prototype._applyDepthMask = function(depthMask) {
        this._gl.depthMask(depthMask);
    };

    Context.prototype._applyStencilMask = function(stencilMask) {
        this._gl.stencilMask(stencilMask);
    };

    Context.prototype._applyBlending = function(blending) {
        var gl = this._gl;
        var enabled = blending.enabled;

        this._enableOrDisable(gl.BLEND, enabled);

        if (enabled) {
            var color = blending.color;
            var equationRgb = blending.equationRgb;
            var equationAlpha = blending.equationAlpha;
            var functionSourceRgb = blending.functionSourceRgb;
            var functionDestinationRgb = blending.functionDestinationRgb;
            var functionSourceAlpha = blending.functionSourceAlpha;
            var functionDestinationAlpha = blending.functionDestinationAlpha;

            gl.blendColor(color.red, color.green, color.blue, color.alpha);
            gl.blendEquationSeparate(equationRgb, equationAlpha);
            gl.blendFuncSeparate(functionSourceRgb, functionDestinationRgb, functionSourceAlpha, functionDestinationAlpha);
        }
    };

    Context.prototype._applyStencilTest = function(stencilTest) {
        var gl = this._gl;
        var enabled = stencilTest.enabled;

        this._enableOrDisable(gl.STENCIL_TEST, enabled);

        if (enabled) {
            var frontFunction = stencilTest.frontFunction;
            var backFunction = stencilTest.backFunction;
            var reference = stencilTest.reference;
            var mask = stencilTest.mask;

            // Section 6.8 of the WebGL spec requires the reference and masks to be the same for
            // front- and back-face tests.  This call prevents invalid operation errors when calling
            // stencilFuncSeparate on Firefox.  Perhaps they should delay validation to avoid requiring this.
            gl.stencilFunc(stencilTest.frontFunction, stencilTest.reference, stencilTest.mask);
            gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
            gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);

            var frontOperation = stencilTest.frontOperation;
            var frontOperationFail = frontOperation.fail;
            var frontOperationZFail = frontOperation.zFail;
            var frontOperationZPass = frontOperation.zPass;

            gl.stencilOpSeparate(gl.FRONT, frontOperationFail, frontOperationZFail, frontOperationZPass);

            var backOperation = stencilTest.backOperation;
            var backOperationFail = backOperation.fail;
            var backOperationZFail = backOperation.zFail;
            var backOperationZPass = backOperation.zPass;

            gl.stencilOpSeparate(gl.BACK, backOperationFail, backOperationZFail, backOperationZPass);
        }
    };

    Context.prototype._applySampleCoverage = function(sampleCoverage) {
        var gl = this._gl;
        var enabled = sampleCoverage.enabled;

        this._enableOrDisable(gl.SAMPLE_COVERAGE, enabled);

        if (enabled) {
            gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
        }
    };

    Context.prototype._applyDither = function(dither) {
        this._enableOrDisable(this._gl.DITHER, dither);
    };

    var scratchViewport = new BoundingRectangle();
    Context.prototype._applyViewport = function(viewport) {
        if (typeof viewport === 'undefined') {
            viewport = scratchViewport;
            viewport.width = this._canvas.clientWidth;
            viewport.height = this._canvas.clientHeight;
        }

        this._us.setViewport(viewport);
        this._gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    };

    Context.prototype._applyRenderState = function(state) {
        this._applyFrontFace(state.frontFace);
        this._applyCull(state.cull);
        this._applyLineWidth(state.lineWidth);
        this._applyPolygonOffset(state.polygonOffset);
        this._applyScissorTest(state.scissorTest);
        this._applyDepthRange(state.depthRange);
        this._applyDepthTest(state.depthTest);
        this._applyColorMask(state.colorMask);
        this._applyDepthMask(state.depthMask);
        this._applyStencilMask(state.stencilMask);
        this._applyBlending(state.blending);
        this._applyStencilTest(state.stencilTest);
        this._applySampleCoverage(state.sampleCoverage);
        this._applyDither(state.dither);
        this._applyViewport(state.viewport);
    };

    /**
     * Returns a unique ID for this context.
     *
     * @memberof Context
     *
     * @returns {String} A unique ID for this context.
     */
    Context.prototype.getId = function() {
        return this._id;
    };

    /**
     * Returns the canvas assoicated with this context.
     *
     * @memberof Context
     *
     * @returns {HTMLCanvasElement} The canvas assoicated with this context.
     */
    Context.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createShaderProgram
     */
    Context.prototype.getShaderCache = function() {
        return this._shaderCache;
    };

    /**
     * DOC_TBA
     * @memberof Context
     */
    Context.prototype.getUniformState = function() {
        return this._us;
    };

    /**
     * Returns the WebGL version or release number of the form &lt;WebGL&gt;&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The WebGL version or release number.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>VERSION</code>.
     */
    Context.prototype.getVersion = function() {
        return this._version;
    };

    /**
     * Returns the version or release number for the shading language of the form WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The version or release number for the shading language.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>SHADING_LANGUAGE_VERSION</code>.
     */
    Context.prototype.getShadingLanguageVersion = function() {
        return this._shadingLanguageVersion;
    };

    /**
     * Returns the company responsible for the WebGL implementation.
     *
     * @memberof Context
     *
     * @returns {String} The company responsible for the WebGL implementation.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>VENDOR</code>.
     */
    Context.prototype.getVendor = function() {
        return this._vendor;
    };

    /**
     * Returns the name of the renderer/configuration/hardware platform. For example, this may be the model of the
     * video card, e.g., 'GeForce 8800 GTS/PCI/SSE2', or the browser-dependent name of the GL implementation, e.g.
     * 'Mozilla' or 'ANGLE.'
     *
     * @memberof Context
     *
     * @returns {String} The name of the renderer.
     *
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>RENDERER</code>.
     * @see <a href='http://code.google.com/p/angleproject/'>ANGLE</a>
     */
    Context.prototype.getRenderer = function() {
        return this._renderer;
    };

    /**
     * Returns the number of red bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of red bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>RED_BITS</code>.
     */
    Context.prototype.getRedBits = function() {
        return this._redBits;
    };

    /**
     * Returns the number of green bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of green bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>GREEN_BITS</code>.
     */
    Context.prototype.getGreenBits = function() {
        return this._greenBits;
    };

    /**
     * Returns the number of blue bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of blue bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>BLUE_BITS</code>.
     */
    Context.prototype.getBlueBits = function() {
        return this._blueBits;
    };

    /**
     * Returns the number of alpha bits per component in the default framebuffer's color buffer.  The minimum is eight.
     * <br /><br />
     * The alpha channel is used for GL destination alpha operations and by the HTML compositor to combine the color buffer
     * with the rest of the page.
     *
     * @memberof Context
     *
     * @returns {Number} The number of alpha bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALPHA_BITS</code>.
     */
    Context.prototype.getAlphaBits = function() {
        return this._alphaBits;
    };

    /**
     * Returns the number of depth bits per pixel in the default bound framebuffer.  The minimum is 16 bits; most
     * implementations will have 24 bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of depth bits per pixel in the default bound framebuffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>DEPTH_BITS</code>.
     */
    Context.prototype.getDepthBits = function() {
        return this._depthBits;
    };

    /**
     * Returns the number of stencil bits per pixel in the default bound framebuffer.  The minimum is eight bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of stencil bits per pixel in the default bound framebuffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>STENCIL_BITS</code>.
     */
    Context.prototype.getStencilBits = function() {
        return this._stencilBits;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex and fragment
     * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
     * same texture unit, this counts as two texture units.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported texture image units.
     *
     * @see Context#getMaximumTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumCombinedTextureImageUnits = function() {
        return this._maximumCombinedTextureImageUnits;
    };

    /**
     * Returns the approximate maximum cube mape width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum cube mape width and height.
     *
     * @see Context#createCubeMap
     * @see Context#getMaximumTextureSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumCubeMapSize = function() {
        return this._maximumCubeMapSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a fragment shader.
     *
     * @see Context#getMaximumVertexUniformVectors
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumFragmentUniformVectors = function() {
        return this._maximumFragmentUniformVectors;
    };

    /**
     * Returns the maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the fragment shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumTextureImageUnits = function() {
        return this._maximumTextureImageUnits;
    };

    /**
     * Returns the maximum renderbuffer width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum renderbuffer width and height.
     *
     * @see Context#createRenderbuffer
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_RENDERBUFFER_SIZE</code>.
     */
    Context.prototype.getMaximumRenderbufferSize = function() {
        return this._maximumRenderbufferSize;
    };

    /**
     * Returns the approximate maximum texture width and height supported by this WebGL implementation.
     * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum texture width and height.
     *
     * @see Context#createTexture2D
     * @see Context#getMaximumCubeMapSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumTextureSize = function() {
        return this._maximumTextureSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
     * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
     *
     * @memberof Context
     *
     * @returns {Number} Returns the maximum number of <code>vec4</code> varying variables.
     *
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VARYING_VECTORS</code>.
     */
    Context.prototype.getMaximumVaryingVectors = function() {
        return this._maximumVaryingVectors;
    };

    /**
     * Returns the maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code> vertex attributes.
     *
     * @see Context#createVertexArray
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_ATTRIBS</code>.
     */
    Context.prototype.getMaximumVertexAttributes = function() {
        return this._maximumVertexAttributes;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
     * The minimum is zero, which means the GL does not support vertex texture fetch.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the vertex shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumVertexTextureImageUnits = function() {
        return this._maximumVertexTextureImageUnits;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a vertex shader.
     *
     * @see Context#getMaximumFragmentUniformVectors
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumVertexUniformVectors = function() {
        return this._maximumVertexUniformVectors;
    };

    /**
     * Returns the minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased line in pixels.
     *
     * @see Context#getMaximumAliasedLineWidth
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[0];
    };

    /**
     * Returns the maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased line in pixels.
     *
     * @see Context#getMinimumAliasedLineWidth
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[1];
    };

    /**
     * Returns the minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased point size in pixels.
     *
     * @see Context#getMaximumAliasedPointSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[0];
    };

    /**
     * Returns the maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased point size in pixels.
     *
     * @see Context#getMinimumAliasedPointSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[1];
    };

    /**
     * Returns the maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported width of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportWidth = function() {
        return this._maximumViewportDimensions[0];
    };

    /**
     * Returns the maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported height of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportHeight = function() {
        return this._maximumViewportDimensions[1];
    };

    /**
     * Returns <code>true</code> if the OES_standard_derivatives extension is supported.  This
     * extension provides access to <code>dFdx<code>, <code>dFdy<code>, and <code>fwidth<code>
     * functions from GLSL.  A shader using these functions still needs to explicitly enable the
     * extension with <code>#extension GL_OES_standard_derivatives : enable</code>.
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if OES_standard_derivatives is supported; otherwise, <code>false</code>.
     *
     * @see <a href='http://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt'>OES_standard_derivatives</a>
     */
    Context.prototype.getStandardDerivatives = function() {
        return !!this._standardDerivatives;
    };

    /**
     * Returns <code>true</code> if WEBGL_depth_texture is supported.  This extension provides
     * access to depth textures that, for example, can be attached to framebuffers for shadow mapping.
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if WEBGL_depth_texture is supported; otherwise, <code>false</code>.
     *
     * @see <a href='http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/'>WEBGL_depth_texture</a>
     */
    Context.prototype.getDepthTexture = function() {
        return !!this._depthTexture;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if EXT_texture_filter_anisotropic is supported; otherwise, <code>false</code>.
     *
     * @see <a href='http://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/'>EXT_texture_filter_anisotropic</a>
     */
    Context.prototype.getTextureFilterAnisotropic = function() {
        return !!this._textureFilterAnisotropic;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getTextureFilterAnisotropic
     */
    Context.prototype.getMaximumTextureFilterAnisotropy = function() {
        return this._maximumTextureFilterAnisotropy;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateFramebuffer
     */
    Context.prototype.getValidateFramebuffer = function() {
        return this._validateFB;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateShaderProgram
     * @see Context#getValidateFramebuffer
     */
    Context.prototype.setValidateFramebuffer = function(value) {
        this._validateFB = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateShaderProgram
     */
    Context.prototype.getValidateShaderProgram = function() {
        return this._validateSP;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#getValidateShaderProgram
     */
    Context.prototype.setValidateShaderProgram = function(value) {
        this._validateSP = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setThrowOnWebGLError
     */
    Context.prototype.getThrowOnWebGLError = function() {
        return this._throwOnWebGLError;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#setValidateShaderProgram
     * @see Context#getThrowOnWebGLError
     */
    Context.prototype.setThrowOnWebGLError = function(value) {
        this._throwOnWebGLError = value;
        this._gl = wrapGL(this._originalGLContext, value ? throwOnError : null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setLogShaderCompilation
     */
    Context.prototype.getLogShaderCompilation = function() {
        return this._logShaderCompilation;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getLogShaderCompilation
     */
    Context.prototype.setLogShaderCompilation = function(value) {
        this._logShaderCompilation = value;
    };

    /**
     * Returns a 1x1 RGBA texture initialized to [255, 255, 255, 255].  This can
     * be used as a placeholder texture while other textures are downloaded.
     *
     * @return {Texture}
     *
     * @memberof Context
     */
    Context.prototype.getDefaultTexture = function() {
        if (this._defaultTexture === undefined) {
            this._defaultTexture = this.createTexture2D({
                source : {
                    width : 1,
                    height : 1,
                    arrayBufferView : new Uint8Array([255, 255, 255, 255])
                }
            });
        }

        return this._defaultTexture;
    };

    /**
     * Returns a cube map, where each face is a 1x1 RGBA texture initialized to
     * [255, 255, 255, 255].  This can be used as a placeholder cube map while
     * other cube maps are downloaded.
     *
     * @return {CubeMap}
     *
     * @memberof Context
     */
    Context.prototype.getDefaultCubeMap = function() {
        if (this._defaultCubeMap === undefined) {
            var face = {
                width : 1,
                height : 1,
                arrayBufferView : new Uint8Array([255, 255, 255, 255])
            };

            this._defaultCubeMap = this.createCubeMap({
                source : {
                    positiveX : face,
                    negativeX : face,
                    positiveY : face,
                    negativeY : face,
                    positiveZ : face,
                    negativeZ : face
                }
            });
        }

        return this._defaultCubeMap;
    };

    /**
     * Creates a shader program given the GLSL source for a vertex and fragment shader.
     * <br /><br />
     * The vertex and fragment shader are individually compiled, and then linked together
     * to create a shader program.  An exception is thrown if any errors are encountered,
     * as described below.
     * <br /><br />
     * The program's active uniforms and attributes are queried and can be accessed using
     * the returned shader program.  The caller can explicitly define the vertex
     * attribute indices using the optional <code>attributeLocations</code> argument as
     * shown in example two below.
     *
     * @memberof Context
     *
     * @param {String} vertexShaderSource The GLSL source for the vertex shader.
     * @param {String} fragmentShaderSource The GLSL source for the fragment shader.
     * @param {Object} [attributeLocations=undefined] An optional object that maps vertex attribute names to indices for use with vertex arrays.
     *
     * @return {ShaderProgram} The compiled and linked shader program, ready for use in a draw call.
     *
     * @exception {RuntimeError} Vertex shader failed to compile.
     * @exception {RuntimeError} Fragment shader failed to compile.
     * @exception {RuntimeError} Program failed to link.
     *
     * @see Context#draw
     * @see Context#createVertexArray
     * @see Context#getShaderCache
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateShader.xml'>glCreateShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glShaderSource.xml'>glShaderSource</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCompileShader.xml'>glCompileShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateProgram.xml'>glCreateProgram</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glAttachShader.xml'>glAttachShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glLinkProgram.xml'>glLinkProgram</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderiv.xml'>glGetShaderiv</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveUniform.xml'>glGetActiveUniform</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniformLocation.xml'>glGetUniformLocation</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniform.xml'>glGetUniform</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindAttribLocation.xml'>glBindAttribLocation</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveAttrib.xml'>glGetActiveAttrib</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetAttribLocation.xml'>glGetAttribLocation</a>
     *
     * @example
     * // Example 1. Create a shader program allowing the GL to determine
     * // attribute indices.
     * var vs = 'attribute vec4 position; void main() { gl_Position = position; }';
     * var fs = 'void main() { gl_FragColor = vec4(1.0); }';
     * var sp = context.createShaderProgram(vs, fs);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a shader program with explicit attribute indices.
     * var vs = 'attribute vec4 position;' +
     *          'attribute vec3 normal;' +
     *          'void main() { ... }';
     * var fs = 'void main() { gl_FragColor = vec4(1.0); }';
     * var attributes = {
     *     position : 0,
     *     normal   : 1
     * };
     * sp = context.createShaderProgram(vs, fs, attributes);            *
     */
    Context.prototype.createShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        return new ShaderProgram(this._gl, this._logShaderCompilation, vertexShaderSource, fragmentShaderSource, attributeLocations);
    };

    function createBuffer(gl, bufferTarget, typedArrayOrSizeInBytes, usage) {
        var sizeInBytes;

        if (typeof typedArrayOrSizeInBytes === 'number') {
            sizeInBytes = typedArrayOrSizeInBytes;
        } else if (typeof typedArrayOrSizeInBytes === 'object' && typeof typedArrayOrSizeInBytes.byteLength !== 'undefined') {
            sizeInBytes = typedArrayOrSizeInBytes.byteLength;
        } else {
            throw new DeveloperError('typedArrayOrSizeInBytes must be either a typed array or a number.');
        }

        if (sizeInBytes <= 0) {
            throw new DeveloperError('typedArrayOrSizeInBytes must be greater than zero.');
        }

        if (!BufferUsage.validate(usage)) {
            throw new DeveloperError('usage is invalid.');
        }

        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferTarget, buffer);
        gl.bufferData(bufferTarget, typedArrayOrSizeInBytes, usage);
        gl.bindBuffer(bufferTarget, null);

        return new Buffer(gl, bufferTarget, sizeInBytes, usage, buffer);
    }

    /**
     * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.
     * <br /><br />
     * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,
     * etc., by interpreting the raw data in one or more vertex buffers.
     *
     * @memberof Context
     *
     * @param {ArrayBufferView|Number} typedArrayOrSizeInBytes A typed array containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     *
     * @return {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createIndexBuffer
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml'>glGenBuffer</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml'>glBindBuffer</a> with <code>ARRAY_BUFFER</code>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml'>glBufferData</a> with <code>ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a dynamic vertex buffer 16 bytes in size.
     * var buffer = context.createVertexBuffer(16, BufferUsage.DYNAMIC_DRAW);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a dynamic vertex buffer from three floating-point values.
     * // The data copied to the vertex buffer is considered raw bytes until it is
     * // interpreted as vertices using a vertex array.
     * var positionBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     */
    Context.prototype.createVertexBuffer = function(typedArrayOrSizeInBytes, usage) {
        return createBuffer(this._gl, this._gl.ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
    };

    /**
     * Creates an index buffer, which contains typed indices in GPU-controlled memory.
     * <br /><br />
     * An index buffer can be attached to a vertex array to select vertices for rendering.
     * <code>Context.draw</code> can render using the entire index buffer or a subset
     * of the index buffer defined by an offset and count.
     *
     * @memberof Context
     *
     * @param {ArrayBufferView|Number} typedArrayOrSizeInBytes A typed array containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     * @param {IndexDatatype} indexDatatype The datatype of indices in the buffer.
     *
     * @return {IndexBuffer} The index buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     * @exception {DeveloperError} Invalid <code>indexDatatype</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#draw
     * @see VertexArray
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml'>glGenBuffer</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml'>glBindBuffer</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml'>glBufferData</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a stream index buffer of unsigned shorts that is
     * // 16 bytes in size.
     * var buffer = context.createIndexBuffer(16, BufferUsage.STREAM_DRAW,
     *     IndexType.unsignedShort);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a static index buffer containing three unsigned shorts.
     * var buffer = context.createIndexBuffer(new Uint16Array([0, 1, 2]),
     *     BufferUsage.STATIC_DRAW, IndexType.unsignedShort)
     */
    Context.prototype.createIndexBuffer = function(typedArrayOrSizeInBytes, usage, indexDatatype) {
        var bytesPerIndex;

        if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {
            bytesPerIndex = Uint8Array.BYTES_PER_ELEMENT;
        } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {
            bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;
        } else {
            throw new DeveloperError('Invalid indexDatatype.');
        }

        var gl = this._gl;
        var buffer = createBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
        var numberOfIndices = buffer.getSizeInBytes() / bytesPerIndex;

        buffer.getIndexDatatype = function() {
            return indexDatatype;
        };

        buffer.getBytesPerIndex = function() {
            return bytesPerIndex;
        };

        buffer.getNumberOfIndices = function() {
            return numberOfIndices;
        };

        return buffer;
    };

    /**
     * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer
     * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.
     *
     * @memberof Context
     *
     * @param {Array} [attributes=undefined] An optional array of attributes.
     * @param {IndexBuffer} [indexBuffer=undefined] An optional index buffer.
     *
     * @return {VertexArray} The vertex array, ready for use with drawing.
     *
     * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.
     * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.
     * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.
     * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArrayFromMesh
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see Context#draw
     *
     * @example
     * // Example 1. Create a vertex array with vertices made up of three floating point
     * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         enabled                : true,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : false,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 0 // tightly packed
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a vertex array with vertices from two different vertex buffers.
     * // Each vertex has a three-component position and three-component normal.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var normalBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     },
     *     {
     *         index                  : 1,
     *         vertexBuffer           : normalBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Creates the same vertex layout as Example 2 using a single
     * // vertex buffer, instead of two.
     * var buffer = context.createVertexBuffer(24, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 24
     *     },
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : true,
     *         offsetInBytes          : 12,
     *         strideInBytes          : 24
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     */
    Context.prototype.createVertexArray = function(attributes, indexBuffer) {
        return new VertexArray(this._gl, attributes, indexBuffer);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {Texture} DOC_TBA.
     *
     * @exception {RuntimeError} When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description requires a source field to create an initialized texture or width and height fields to create a blank texture.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     * @exception {DeveloperError} When description.pixelFormat is DEPTH_COMPONENT, description.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.
     * @exception {DeveloperError} When description.pixelFormat is DEPTH_STENCIL, description.pixelDatatype must be UNSIGNED_INT_24_8_WEBGL.
     * @exception {DeveloperError} When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.
     *
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createCubeMap
     * @see Context#createSampler
     */
    Context.prototype.createTexture2D = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width = typeof source !== 'undefined' ? source.width : description.width;
        var height = typeof source !== 'undefined' ? source.height : description.height;

        if (typeof width === 'undefined' || typeof height === 'undefined') {
            throw new DeveloperError('description requires a source field to create an initialized texture or width and height fields to create a blank texture.');
        }

        if (width <= 0) {
            throw new DeveloperError('Width must be greater than zero.');
        }

        if (width > this._maximumTextureSize) {
            throw new DeveloperError('Width must be less than or equal to the maximum texture size (' + this._maximumTextureSize + ').  Check getMaximumTextureSize().');
        }

        if (height <= 0) {
            throw new DeveloperError('Height must be greater than zero.');
        }

        if (height > this._maximumTextureSize) {
            throw new DeveloperError('Height must be less than or equal to the maximum texture size (' + this._maximumTextureSize + ').  Check getMaximumTextureSize().');
        }

        var pixelFormat = defaultValue(description.pixelFormat, PixelFormat.RGBA);
        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid description.pixelFormat.');
        }

        var pixelDatatype = defaultValue(description.pixelDatatype, PixelDatatype.UNSIGNED_BYTE);
        if (!PixelDatatype.validate(pixelDatatype)) {
            throw new DeveloperError('Invalid description.pixelDatatype.');
        }

        if ((pixelFormat === PixelFormat.DEPTH_COMPONENT) &&
            ((pixelDatatype !== PixelDatatype.UNSIGNED_SHORT) && (pixelDatatype !== PixelDatatype.UNSIGNED_INT))) {
            throw new DeveloperError('When description.pixelFormat is DEPTH_COMPONENT, description.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.');
        }

        if ((pixelFormat === PixelFormat.DEPTH_STENCIL) && (pixelDatatype !== PixelDatatype.UNSIGNED_INT_24_8_WEBGL)) {
            throw new DeveloperError('When description.pixelFormat is DEPTH_STENCIL, description.pixelDatatype must be UNSIGNED_INT_24_8_WEBGL.');
        }

        if (PixelFormat.isDepthFormat(pixelFormat)) {
            if (source) {
                throw new DeveloperError('When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.');
            }

            if (!this.getDepthTexture()) {
                throw new RuntimeError('When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check getDepthTexture().');
            }
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        if (source) {
            // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

            if (source.arrayBufferView) {
                // Source: typed array
                gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, source.arrayBufferView);
            } else {
                // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement
                gl.texImage2D(textureTarget, 0, pixelFormat, pixelFormat, pixelDatatype, source);
            }
        } else {
            gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha);
    };

    /**
     * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,
     * the texture is the same width and height as the framebuffer and contains its contents.
     *
     * @memberof Context
     *
     * @param {PixelFormat} [pixelFormat=PixelFormat.RGB] The texture's internal pixel format.
     * @param {PixelFormat} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
     * @param {PixelFormat} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
     * @param {PixelFormat} [width=canvas.clientWidth] The width of the texture in texels.
     * @param {PixelFormat} [height=canvas.clientHeight] The height of the texture in texels.
     *
     * @return {Texture} A texture with contents from the framebuffer.
     *
     * @exception {DeveloperError} Invalid pixelFormat.
     * @exception {DeveloperError} pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to getCanvas().clientWidth.
     * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createSampler
     *
     * @example
     * // Create a texture with the contents of the framebuffer.
     * var t = context.createTexture2DFromFramebuffer();
     */
    Context.prototype.createTexture2DFromFramebuffer = function(pixelFormat, framebufferXOffset, framebufferYOffset, width, height) {
        pixelFormat = pixelFormat || PixelFormat.RGB;
        framebufferXOffset = defaultValue(framebufferXOffset, 0);
        framebufferYOffset = defaultValue(framebufferYOffset, 0);
        width = defaultValue(width, this._canvas.clientWidth);
        height = defaultValue(height, this._canvas.clientHeight);

        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid pixelFormat.');
        }

        if (PixelFormat.isDepthFormat(pixelFormat)) {
            throw new DeveloperError('pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset + width > this._canvas.clientWidth) {
            throw new DeveloperError('framebufferXOffset + width must be less than or equal to getCanvas().clientWidth');
        }

        if (framebufferYOffset + height > this._canvas.clientHeight) {
            throw new DeveloperError('framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.');
        }

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);
        gl.copyTexImage2D(textureTarget, 0, pixelFormat, framebufferXOffset, framebufferYOffset, width, height, 0);
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, undefined, width, height);
    };

    /**
     * Creates a new texture atlas with this context.
     *
     * @memberof Context
     *
     * @param {PixelFormat} [description.pixelFormat = PixelFormat.RGBA] The pixel format of the texture.
     * @param {Number} [description.borderWidthInPixels = 1] The amount of spacing between adjacent images in pixels.
     * @param {Cartesian2} [description.initialSize = new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.
     * @param {Array} [description.images=undefined] Array of {@link Image} to be added to the atlas. Same as calling addImages(images).
     * @param {Image} [description.image=undefined] Single image to be added to the atlas. Same as calling addImage(image).
     *
     * @returns {TextureAtlas} The new texture atlas.
     *
     * @see TextureAtlas
     */
    Context.prototype.createTextureAtlas = function(description) {
        description = description || {};
        description.context = this;
        return new TextureAtlas(description);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {CubeMap} DOC_TBA.
     *
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.
     * @exception {DeveloperError} Each face in description.sources must have the same width and height.
     * @exception {DeveloperError} description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.
     * @exception {DeveloperError} Width must equal height.
     * @exception {DeveloperError} Width and height must be greater than zero.
     * @exception {DeveloperError} Width and height must be less than or equal to the maximum cube map size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} description.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createSampler
     */
    Context.prototype.createCubeMap = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width;
        var height;

        if (source) {
            var faces = [source.positiveX, source.negativeX, source.positiveY, source.negativeY, source.positiveZ, source.negativeZ];

            if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
                throw new DeveloperError('description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.');
            }

            width = faces[0].width;
            height = faces[0].height;

            for ( var i = 1; i < 6; ++i) {
                if ((Number(faces[i].width) !== width) || (Number(faces[i].height) !== height)) {
                    throw new DeveloperError('Each face in description.source must have the same width and height.');
                }
            }
        } else {
            width = description.width;
            height = description.height;
        }

        if (typeof width === 'undefined' || typeof height === 'undefined') {
            throw new DeveloperError('description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.');
        }

        if (width !== height) {
            throw new DeveloperError('Width must equal height.');
        }

        var size = width;

        if (size <= 0) {
            throw new DeveloperError('Width and height must be greater than zero.');
        }

        if (size > this._maximumCubeMapSize) {
            throw new DeveloperError('Width and height must be less than or equal to the maximum cube map size (' + this._maximumCubeMapSize + ').  Check getMaximumCubeMapSize().');
        }

        var pixelFormat = defaultValue(description.pixelFormat, PixelFormat.RGBA);
        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid description.pixelFormat.');
        }

        if (PixelFormat.isDepthFormat(pixelFormat)) {
            throw new DeveloperError('description.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.');
        }

        var pixelDatatype = defaultValue(description.pixelDatatype, PixelDatatype.UNSIGNED_BYTE);
        if (!PixelDatatype.validate(pixelDatatype)) {
            throw new DeveloperError('Invalid description.pixelDatatype.');
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || ((pixelFormat === PixelFormat.RGB) || (pixelFormat === PixelFormat.LUMINANCE));

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_CUBE_MAP;
        var texture = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        function createFace(target, sourceFace) {
            if (sourceFace.arrayBufferView) {
                gl.texImage2D(target, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, sourceFace.arrayBufferView);
            } else {
                gl.texImage2D(target, 0, pixelFormat, pixelFormat, pixelDatatype, sourceFace);
            }
        }

        if (source) {
            // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X, source.positiveX);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source.negativeX);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source.positiveY);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source.negativeY);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source.positiveZ);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source.negativeZ);
        } else {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new CubeMap(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
    };

    /**
     * Creates a framebuffer with optional initial color, depth, and stencil attachments.
     * Framebuffers are used for render-to-texture effects; they allow us to render to
     * a texture in one pass, and read from it in a later pass.
     *
     * @memberof Context
     *
     * @param {Object} [description] The initial framebuffer attachments as shown in Example 2.  The possible properties are <code>colorTexture</code>, <code>colorRenderbuffer</code>, <code>depthTexture</code>, <code>depthRenderbuffer</code>, <code>stencilRenderbuffer</code>, <code>depthStencilTexture</code>, and <code>depthStencilRenderbuffer</code>.
     *
     * @return {Framebuffer} The created framebuffer.
     *
     * @exception {DeveloperError} Cannot have both a color texture and color renderbuffer attachment.
     * @exception {DeveloperError} Cannot have both a depth texture and depth renderbuffer attachment.
     * @exception {DeveloperError} Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.
     * @exception {DeveloperError} Cannot have both a depth and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a stencil and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a depth and stencil renderbuffer.
     * @exception {DeveloperError} The color-texture pixel-format must be a color format.
     * @exception {DeveloperError} The depth-texture pixel-format must be DEPTH_COMPONENT.
     * @exception {DeveloperError} The depth-stencil-texture pixel-format must be DEPTH_STENCIL.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createRenderbuffer
     *
     * @example
     * // Example 1. Create a framebuffer with no initial attachments,
     * // and then add a color-texture attachment.
     * var framebuffer = context.createFramebuffer();
     * framebuffer.setColorTexture(context.createTexture2D({
     *     width : 256,
     *     height : 256,
     * }));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a framebuffer with color and depth texture attachments.
     * var width = context.getCanvas().clientWidth;
     * var height = context.getCanvas().clientHeight;
     * var framebuffer = context.createFramebuffer({
     *   colorTexture : context.createTexture2D({
     *     width : width,
     *     height : height,
     *     pixelFormat : PixelFormat.RGBA
     *   }),
     *   depthTexture : context.createTexture2D({
     *     width : width,
     *     height : height,
     *     pixelFormat : PixelFormat.DEPTH_COMPONENT,
     *     pixelDatatype : PixelDatatype.UNSIGNED_SHORT
     *   })
     * });
     */
    Context.prototype.createFramebuffer = function(description) {
        return new Framebuffer(this._gl, description);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {Object} [description] DOC_TBA.
     *
     * @return {createRenderbuffer} DOC_TBA.
     *
     * @exception {DeveloperError} Invalid format.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum renderbuffer size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum renderbuffer size.
     *
     * @see Context#createFramebuffer
     */
    Context.prototype.createRenderbuffer = function(description) {
        description = description || {};
        var format = description.format || RenderbufferFormat.RGBA4;
        var width = (typeof description.width === 'undefined') ? this._canvas.clientWidth : description.width;
        var height = (typeof description.height === 'undefined') ? this._canvas.clientHeight : description.height;


        var gl = this._gl;
        if (!RenderbufferFormat.validate(format)) {
            throw new DeveloperError('Invalid format.');
        }

        if (width <= 0) {
            throw new DeveloperError('Width must be greater than zero.');
        }

        if (width > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError('Width must be less than or equal to the maximum renderbuffer size (' + this.getMaximumRenderbufferSize() + ').  Check getMaximumRenderbufferSize().');
        }

        if (height <= 0) {
            throw new DeveloperError('Height must be greater than zero.');
        }

        if (height > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError('Height must be less than or equal to the maximum renderbuffer size (' + this.getMaximumRenderbufferSize() + ').  Check getMaximumRenderbufferSize().');
        }

        return new Renderbuffer(gl, format, width, height);
    };

    /**
     * DOC_TBA.
     *
     * Validates and adds defaults for missing states.
     *
     * @memberof Context
     *
     * @exception {RuntimeError} renderState.lineWidth is out of range.
     * @exception {DeveloperError} Invalid renderState.frontFace.
     * @exception {DeveloperError} Invalid renderState.cull.face.
     * @exception {DeveloperError} scissorTest.rectangle.width and scissorTest.rectangle.height must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.near can't be greater than renderState.depthRange.far.
     * @exception {DeveloperError} renderState.depthRange.near must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.far must be less than or equal to zero.
     * @exception {DeveloperError} Invalid renderState.depthTest.func.
     * @exception {DeveloperError} renderState.blending.color components must be greater than or equal to zero and less than or equal to one
     * @exception {DeveloperError} Invalid renderState.blending.equationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.equationAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationAlpha.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zPass.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zPass.
     * @exception {DeveloperError} renderState.viewport.width must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.viewport.width must be less than or equal to the maximum viewport width.
     * @exception {DeveloperError} renderState.viewport.height must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.viewport.height must be less than or equal to the maximum viewport height.
     */
    Context.prototype.createRenderState = function(renderState) {
        var rs = renderState || {};
        var cull = rs.cull || {};
        var polygonOffset = rs.polygonOffset || {};
        var scissorTest = rs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var depthRange = rs.depthRange || {};
        var depthTest = rs.depthTest || {};
        var colorMask = rs.colorMask || {};
        var blending = rs.blending || {};
        var blendingColor = blending.color || {};
        var stencilTest = rs.stencilTest || {};
        var stencilTestFrontOperation = stencilTest.frontOperation || {};
        var stencilTestBackOperation = stencilTest.backOperation || {};
        var sampleCoverage = rs.sampleCoverage || {};
        var viewport = rs.viewport;

        var r = {
            frontFace : (typeof rs.frontFace === 'undefined') ? WindingOrder.COUNTER_CLOCKWISE : rs.frontFace,
            cull : {
                enabled : (typeof cull.enabled === 'undefined') ? false : cull.enabled,
                face : (typeof cull.face === 'undefined') ? CullFace.BACK : cull.face
            },
            lineWidth : (typeof rs.lineWidth === 'undefined') ? 1 : rs.lineWidth,
            polygonOffset : {
                enabled : (typeof polygonOffset.enabled === 'undefined') ? false : polygonOffset.enabled,
                factor : (typeof polygonOffset.factor === 'undefined') ? 0 : polygonOffset.factor,
                units : (typeof polygonOffset.units === 'undefined') ? 0 : polygonOffset.units
            },
            scissorTest : {
                enabled : (typeof scissorTest.enabled === 'undefined') ? false : scissorTest.enabled,
                rectangle : BoundingRectangle.clone(scissorTestRectangle)
            },
            depthRange : {
                near : (typeof depthRange.near === 'undefined') ? 0 : depthRange.near,
                far : (typeof depthRange.far === 'undefined') ? 1 : depthRange.far
            },
            depthTest : {
                enabled : (typeof depthTest.enabled === 'undefined') ? false : depthTest.enabled,
                func : (typeof depthTest.func === 'undefined') ? DepthFunction.LESS : depthTest.func // func, because function is a JavaScript keyword
            },
            colorMask : {
                red : (typeof colorMask.red === 'undefined') ? true : colorMask.red,
                green : (typeof colorMask.green === 'undefined') ? true : colorMask.green,
                blue : (typeof colorMask.blue === 'undefined') ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === 'undefined') ? true : colorMask.alpha
            },
            depthMask : (typeof rs.depthMask === 'undefined') ? true : rs.depthMask,
            stencilMask : (typeof rs.stencilMask === 'undefined') ? ~0 : rs.stencilMask,
            blending : {
                enabled : (typeof blending.enabled === 'undefined') ? false : blending.enabled,
                color : new Color(
                    (typeof blendingColor.red === 'undefined') ? 0.0 : blendingColor.red,
                    (typeof blendingColor.green === 'undefined') ? 0.0 : blendingColor.green,
                    (typeof blendingColor.blue === 'undefined') ? 0.0 : blendingColor.blue,
                    (typeof blendingColor.alpha === 'undefined') ? 0.0 : blendingColor.alpha
                ),
                equationRgb : (typeof blending.equationRgb === 'undefined') ? BlendEquation.ADD : blending.equationRgb,
                equationAlpha : (typeof blending.equationAlpha === 'undefined') ? BlendEquation.ADD : blending.equationAlpha,
                functionSourceRgb : (typeof blending.functionSourceRgb === 'undefined') ? BlendFunction.ONE : blending.functionSourceRgb,
                functionSourceAlpha : (typeof blending.functionSourceAlpha === 'undefined') ? BlendFunction.ONE : blending.functionSourceAlpha,
                functionDestinationRgb : (typeof blending.functionDestinationRgb === 'undefined') ? BlendFunction.ZERO : blending.functionDestinationRgb,
                functionDestinationAlpha : (typeof blending.functionDestinationAlpha === 'undefined') ? BlendFunction.ZERO : blending.functionDestinationAlpha
            },
            stencilTest : {
                enabled : (typeof stencilTest.enabled === 'undefined') ? false : stencilTest.enabled,
                frontFunction : (typeof stencilTest.frontFunction === 'undefined') ? StencilFunction.ALWAYS : stencilTest.frontFunction,
                backFunction : (typeof stencilTest.backFunction === 'undefined') ? StencilFunction.ALWAYS : stencilTest.backFunction,
                reference : (typeof stencilTest.reference === 'undefined') ? 0 : stencilTest.reference,
                mask : (typeof stencilTest.mask === 'undefined') ? ~0 : stencilTest.mask,
                frontOperation : {
                    fail : (typeof stencilTestFrontOperation.fail === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.fail,
                    zFail : (typeof stencilTestFrontOperation.zFail === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.zFail,
                    zPass : (typeof stencilTestFrontOperation.zPass === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.zPass
                },
                backOperation : {
                    fail : (typeof stencilTestBackOperation.fail === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.fail,
                    zFail : (typeof stencilTestBackOperation.zFail === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.zFail,
                    zPass : (typeof stencilTestBackOperation.zPass === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.zPass
                }
            },
            // TODO:  Also need point_size and point_size_enable for ColladaFX
            // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
            sampleCoverage : {
                enabled : (typeof sampleCoverage.enabled === 'undefined') ? false : sampleCoverage.enabled,
                value : (typeof sampleCoverage.value === 'undefined') ? 1.0 : sampleCoverage.value,
                invert : (typeof sampleCoverage.invert === 'undefined') ? false : sampleCoverage.invert
            },
            dither : (typeof rs.dither === 'undefined') ? true : rs.dither
            // viewport is set below because it is allowed to be undefined - meaning always the canvas size.
        };

        // Validate

        if (!WindingOrder.validate(r.frontFace)) {
            throw new DeveloperError('Invalid renderState.frontFace.');
        }

        if (!CullFace.validate(r.cull.face)) {
            throw new DeveloperError('Invalid renderState.cull.face.');
        }

        if ((r.lineWidth < this._aliasedLineWidthRange[0]) ||
            (r.lineWidth > this._aliasedLineWidthRange[1])) {
            throw new RuntimeError('renderState.lineWidth is out of range.  Check getMinimumAliasedLineWidth() and getMaximumAliasedLineWidth().');
        }

        if ((r.scissorTest.rectangle.width < 0) ||
            (r.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError('renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.');
        }

        if (r.depthRange.near > r.depthRange.far) {
            // WebGL specific - not an error in GL ES
            throw new DeveloperError('renderState.depthRange.near can not be greater than renderState.depthRange.far.');
        }

        if (r.depthRange.near < 0) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.depthRange.near must be greater than or equal to zero.');
        }

        if (r.depthRange.far > 1) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.depthRange.far must be less than or equal to one.');
        }


        if (!DepthFunction.validate(r.depthTest.func)) {
            throw new DeveloperError('Invalid renderState.depthTest.func.');
        }

        if ((r.blending.color.red < 0.0) || (r.blending.color.red > 1.0) ||
            (r.blending.color.green < 0.0) || (r.blending.color.green > 1.0) ||
            (r.blending.color.blue < 0.0) || (r.blending.color.blue > 1.0) ||
            (r.blending.color.alpha < 0.0) || (r.blending.color.alpha > 1.0)) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.blending.color components must be greater than or equal to zero and less than or equal to one.');
        }

        if (!BlendEquation.validate(r.blending.equationRgb)) {
            throw new DeveloperError('Invalid renderState.blending.equationRgb.');
        }

        if (!BlendEquation.validate(r.blending.equationAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.equationAlpha.');
        }

        if (!BlendFunction.validate(r.blending.functionSourceRgb)) {
            throw new DeveloperError('Invalid renderState.blending.functionSourceRgb.');
        }

        if (!BlendFunction.validate(r.blending.functionSourceAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.functionSourceAlpha.');
        }

        if (!BlendFunction.validate(r.blending.functionDestinationRgb)) {
            throw new DeveloperError('Invalid renderState.blending.functionDestinationRgb.');
        }

        if (!BlendFunction.validate(r.blending.functionDestinationAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.functionDestinationAlpha.');
        }

        if (!StencilFunction.validate(r.stencilTest.frontFunction)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontFunction.');
        }

        if (!StencilFunction.validate(r.stencilTest.backFunction)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backFunction.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.fail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.fail.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.zFail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zFail.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.zPass)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zPass.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.fail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.fail.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.zFail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zFail.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.zPass)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zPass.');
        }

        if (typeof vieport !== 'undefined') {
            if (viewport.width < 0) {
                throw new DeveloperError('renderState.viewport.width must be greater than or equal to zero.');
            }

            if (viewport.width > this.getMaximumViewportWidth()) {
                throw new RuntimeError('renderState.viewport.width must be less than or equal to the maximum viewport width (' + this.getMaximumViewportWidth().toString() + ').  Check getMaximumViewportWidth().');
            }

            if (viewport.height < 0) {
                throw new DeveloperError('renderState.viewport.height must be greater than or equal to zero.');
            }

            if (viewport.height > this.getMaximumViewportHeight()) {
                throw new RuntimeError('renderState.viewport.height must be less than or equal to the maximum viewport height (' + this.getMaximumViewportHeight().toString() + ').  Check getMaximumViewportHeight().');
            }

            r.viewport = new BoundingRectangle(viewport.x, viewport.y,
                    (typeof viewport.width === 'undefined') ? this._canvas.clientWidth : viewport.width,
                    (typeof viewport.height === 'undefined') ? this._canvas.clientHeight : viewport.height);
        }

        return r;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} Invalid sampler.wrapS.
     * @exception {DeveloperError} Invalid sampler.wrapT.
     * @exception {DeveloperError} Invalid sampler.minificationFilter.
     * @exception {DeveloperError} Invalid sampler.magnificationFilter.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     */
    Context.prototype.createSampler = function(sampler) {
        var s = {
            wrapS : sampler.wrapS || TextureWrap.CLAMP,
            wrapT : sampler.wrapT || TextureWrap.CLAMP,
            minificationFilter : sampler.minificationFilter || TextureMinificationFilter.LINEAR,
            magnificationFilter : sampler.magnificationFilter || TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : (typeof sampler.maximumAnisotropy !== 'undefined') ? sampler.maximumAnisotropy : 1.0
        };

        if (!TextureWrap.validate(s.wrapS)) {
            throw new DeveloperError('Invalid sampler.wrapS.');
        }

        if (!TextureWrap.validate(s.wrapT)) {
            throw new DeveloperError('Invalid sampler.wrapT.');
        }

        if (!TextureMinificationFilter.validate(s.minificationFilter)) {
            throw new DeveloperError('Invalid sampler.minificationFilter.');
        }

        if (!TextureMagnificationFilter.validate(s.magnificationFilter)) {
            throw new DeveloperError('Invalid sampler.magnificationFilter.');
        }

        if (s.maximumAnisotropy < 1.0) {
            throw new DeveloperError('sampler.maximumAnisotropy must be greater than or equal to one.');
        }

        return s;
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * Validates and adds defaults for missing states.
     *
     * @exception {DeveloperError} clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.
     *
     * @see Context#clear
     */
    Context.prototype.createClearState = function(clearState) {
        var cs = clearState || {};
        var scissorTest = cs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var colorMask = cs.colorMask || {};

        var color = cs.color;
        var depth = cs.depth;
        var stencil = cs.stencil;

        // Clear everything if nothing is specified
        if ((typeof color === 'undefined') && (typeof depth === 'undefined') && (typeof stencil === 'undefined')) {
            color = this._defaultClearColor;
            depth = this._defaultClearDepth;
            stencil = this._defaultClearStencil;
        }

        var c = {
            scissorTest : {
                enabled : (typeof scissorTest.enabled === 'undefined') ? false : scissorTest.enabled,
                rectangle : {
                    x : (typeof scissorTestRectangle.x === 'undefined') ? 0 : scissorTestRectangle.x,
                    y : (typeof scissorTestRectangle.y === 'undefined') ? 0 : scissorTestRectangle.y,
                    width : (typeof scissorTestRectangle.width === 'undefined') ? 0 : scissorTestRectangle.width,
                    height : (typeof scissorTestRectangle.height === 'undefined') ? 0 : scissorTestRectangle.height
                }
            },
            colorMask : {
                red : (typeof colorMask.red === 'undefined') ? true : colorMask.red,
                green : (typeof colorMask.green === 'undefined') ? true : colorMask.green,
                blue : (typeof colorMask.blue === 'undefined') ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === 'undefined') ? true : colorMask.alpha
            },
            depthMask : (typeof cs.depthMask === 'undefined') ? true : cs.depthMask,
            stencilMask : (typeof cs.stencilMask === 'undefined') ? ~0 : cs.stencilMask,
            dither : (typeof cs.dither === 'undefined') ? true : cs.dither,

            framebuffer : cs.framebuffer,

            color : (typeof color !== 'undefined') ? Color.clone(color) : undefined,
            depth : depth,
            stencil : stencil
        };

        if ((c.scissorTest.rectangle.width < 0) || (c.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError('clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.');
        }

        return c;
    };

    Context.prototype._validateFramebuffer = function(framebuffer) {
        if (this._validateFB) {
            var gl = this._gl;
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            if (status !== gl.FRAMEBUFFER_COMPLETE) {
                var message;

                switch (status) {
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    message = 'Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.';
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    message = 'Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.';
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    message = 'Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.';
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    message = 'Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.';
                    break;
                }

                throw new DeveloperError(message);
            }
        }
    };

    /**
     * Executes the specified clear command.
     *
     * @memberof Context
     *
     * @param {ClearCommand} [clearCommand] The command with which to clear.  If this parameter is undefined
     *        or its clearState property is undefined, a default clear state is used.
     * @param {Framebuffer} [framebuffer] The framebuffer to clear if one is not specified by the command.
     *
     * @memberof Context
     *
     * @see Context#createClearState
     */
    Context.prototype.clear = function(clearCommand, framebuffer) {
        var clearState;
        if (typeof clearCommand !== 'undefined' && typeof clearCommand.clearState !== 'undefined') {
            clearState = clearCommand.clearState;
        } else {
            clearState = this.createClearState();
        }

        var gl = this._gl;
        var bitmask = 0;

        clearState = clearState || this.createClearState();
        var c = clearState.color;
        var d = clearState.depth;
        var s = clearState.stencil;

        if (typeof c !== 'undefined') {
            if (!Color.equals(this._clearColor, c)) {
                Color.clone(c, this._clearColor);
                gl.clearColor(c.red, c.green, c.blue, c.alpha);
            }
            bitmask |= gl.COLOR_BUFFER_BIT;
        }

        if (typeof d !== 'undefined') {
            if (d !== this._clearDepth) {
                this._clearDepth = d;
                gl.clearDepth(d);
            }
            bitmask |= gl.DEPTH_BUFFER_BIT;
        }

        if (typeof s !== 'undefined') {
            if (s !== this._clearStencil) {
                this._clearStencil = s;
                gl.clearStencil(s);
            }
            bitmask |= gl.STENCIL_BUFFER_BIT;
        }

        this._applyScissorTest(clearState.scissorTest);
        this._applyColorMask(clearState.colorMask);
        this._applyDepthMask(clearState.depthMask);
        this._applyStencilMask(clearState.stencilMask);
        this._applyDither(clearState.dither);

        framebuffer = defaultValue(clearState.framebuffer, framebuffer);

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        gl.clear(bitmask);

        if (framebuffer) {
            framebuffer._unBind();
        }
    };

    /**
     * Executes the specified draw command.
     *
     * @memberof Context
     *
     * @param {DrawCommand} drawCommand The command with which to draw.
     * @param {Framebuffer} [framebuffer] The framebuffer to which to draw if one is not specified by the command.
     *
     * @memberof Context
     *
     * @exception {DeveloperError} drawCommand is required.
     * @exception {DeveloperError} drawCommand.primitiveType is required and must be valid.
     * @exception {DeveloperError} drawCommand.shaderProgram is required.
     * @exception {DeveloperError} drawCommand.vertexArray is required.
     * @exception {DeveloperError} drawCommand.offset must be omitted or greater than or equal to zero.
     * @exception {DeveloperError} Program validation failed.
     * @exception {DeveloperError} Framebuffer is not complete.
     *
     * @example
     * // Example 1.  Draw a single triangle specifying only required arguments
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2.  Draw a single triangle specifying every argument
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     offset        : 0,
     *     count         : 3,
     *     framebuffer   : fb,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     *     renderState   : rs
     * });
     *
     * @see Context#createShaderProgram
     * @see Context#createVertexArray
     * @see Context#createFramebuffer
     * @see Context#createRenderState
     */
    Context.prototype.draw = function(drawCommand, framebuffer) {
        this.beginDraw(drawCommand, framebuffer);
        this.continueDraw(drawCommand);
        this.endDraw();
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.beginDraw = function(command, framebuffer) {
        if (typeof command === 'undefined') {
            throw new DeveloperError('command is required.');
        }

        if (typeof command.shaderProgram === 'undefined') {
            throw new DeveloperError('command.shaderProgram is required.');
        }

        framebuffer = defaultValue(command.framebuffer, framebuffer);
        var sp = command.shaderProgram;
        var rs = command.renderState || this.createRenderState();

        if (framebuffer && rs.depthTest) {
            if (rs.depthTest.enabled && !framebuffer.hasDepthAttachment()) {
                throw new DeveloperError('The depth test can not be enabled (command.renderState.depthTest.enabled) because the framebuffer (command.framebuffer) does not have a depth or depth-stencil renderbuffer.');
            }
        }

        ///////////////////////////////////////////////////////////////////////

        this._applyRenderState(rs);
        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }
        sp._bind();

        this._currentFramebuffer = framebuffer;
        this._currentSp = sp;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.continueDraw = function(command) {
        var sp = this._currentSp;
        if (typeof sp === 'undefined') {
            throw new DeveloperError('beginDraw must be called before continueDraw.');
        }

        if (typeof command === 'undefined') {
            throw new DeveloperError('command is required.');
        }

        var primitiveType = command.primitiveType;
        if (!PrimitiveType.validate(primitiveType)) {
            throw new DeveloperError('command.primitiveType is required and must be valid.');
        }

        if (typeof command.vertexArray === 'undefined') {
            throw new DeveloperError('command.vertexArray is required.');
        }

        var va = command.vertexArray;
        var indexBuffer = va.getIndexBuffer();

        var offset = command.offset;
        var count = command.count;

        if (indexBuffer) {
            offset = (offset || 0) * indexBuffer.getBytesPerIndex(); // in bytes
            count = count || indexBuffer.getNumberOfIndices();
        } else {
            offset = offset || 0; // in vertices
            count = count || va._getNumberOfVertices();
        }

        if (offset < 0) {
            throw new DeveloperError('command.offset must be omitted or greater than or equal to zero.');
        }

        if (count > 0) {
            this._us.setModel(defaultValue(command.modelMatrix, Matrix4.IDENTITY));
            sp._setUniforms(command.uniformMap, this._us, this._validateSP);

            va._bind();

            if (indexBuffer) {
                this._gl.drawElements(primitiveType, count, indexBuffer.getIndexDatatype().value, offset);
            } else {
                this._gl.drawArrays(primitiveType, offset, count);
            }

            va._unBind();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.endDraw = function() {
        if (this._currentFramebuffer) {
            this._currentFramebuffer._unBind();
            this._currentFramebuffer = undefined;
        }
        this._currentSp._unBind();
        this._currentSp = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} readState.width must be greater than zero.
     * @exception {DeveloperError} readState.height must be greater than zero.
     */
    Context.prototype.readPixels = function(readState) {
        readState = readState || {};
        var x = Math.max(readState.x || 0, 0);
        var y = Math.max(readState.y || 0, 0);
        var width = readState.width || this._canvas.clientWidth;
        var height = readState.height || this._canvas.clientHeight;
        var framebuffer = readState.framebuffer || null;

        if (width <= 0) {
            throw new DeveloperError('readState.width must be greater than zero.');
        }

        if (height <= 0) {
            throw new DeveloperError('readState.height must be greater than zero.');
        }

        var pixels = new Uint8Array(4 * width * height);

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        var gl = this._gl;
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        if (framebuffer) {
            framebuffer._unBind();
        }

        return pixels;
    };

    //////////////////////////////////////////////////////////////////////////////////////////

    Context.prototype._interleaveAttributes = function(attributes) {
        function computeNumberOfVertices(attribute) {
            return attribute.values.length / attribute.componentsPerAttribute;
        }

        function computeAttributeSizeInBytes(attribute) {
            return attribute.componentDatatype.sizeInBytes * attribute.componentsPerAttribute;
        }

        var j;
        var name;
        var attribute;

        // Extract attribute names.
        var names = [];
        for (name in attributes) {
            // Attribute needs to have per-vertex values; not a constant value for all vertices.
            if (attributes.hasOwnProperty(name) && attributes[name].values) {
                names.push(name);
            }
        }

        // Validation.  Compute number of vertices.
        var numberOfVertices;
        var namesLength = names.length;

        if (namesLength > 0) {
            numberOfVertices = computeNumberOfVertices(attributes[names[0]]);

            for (j = 1; j < namesLength; ++j) {
                var currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);

                if (currentNumberOfVertices !== numberOfVertices) {
                    throw new RuntimeError(
                        'Each attribute list must have the same number of vertices.  ' +
                        'Attribute ' + names[j] + ' has a different number of vertices ' +
                        '(' + currentNumberOfVertices.toString() + ')' +
                        ' than attribute ' + names[0] +
                        ' (' + numberOfVertices.toString() + ').');
                }
            }
        }

        // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
        names.sort(function(left, right) {
            return attributes[right].componentDatatype.sizeInBytes - attributes[left].componentDatatype.sizeInBytes;
        });

        // Compute sizes and strides.
        var vertexSizeInBytes = 0;
        var offsetsInBytes = {};

        for (j = 0; j < namesLength; ++j) {
            name = names[j];
            attribute = attributes[name];

            offsetsInBytes[name] = vertexSizeInBytes;
            vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
        }

        if (vertexSizeInBytes > 0) {
            // Pad each vertex to be a multiple of the largest component datatype so each
            // attribute can be addressed using typed arrays.
            var maxComponentSizeInBytes = attributes[names[0]].componentDatatype.sizeInBytes; // Sorted large to small
            var remainder = vertexSizeInBytes % maxComponentSizeInBytes;
            if (remainder !== 0) {
                vertexSizeInBytes += (maxComponentSizeInBytes - remainder);
            }

            // Total vertex buffer size in bytes, including per-vertex padding.
            var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;

            // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.
            var buffer = new ArrayBuffer(vertexBufferSizeInBytes);
            var views = {};

            for (j = 0; j < namesLength; ++j) {
                name = names[j];
                var sizeInBytes = attributes[name].componentDatatype.sizeInBytes;

                views[name] = {
                    pointer : attributes[name].componentDatatype.toTypedArray(buffer),
                    index : offsetsInBytes[name] / sizeInBytes, // Offset in ComponentType
                    strideInComponentType : vertexSizeInBytes / sizeInBytes
                };
            }

            // Copy attributes into one interleaved array.
            // PERFORMANCE_IDEA:  Can we optimize these loops?
            for (j = 0; j < numberOfVertices; ++j) {
                for ( var n = 0; n < namesLength; ++n) {
                    name = names[n];
                    attribute = attributes[name];
                    var values = attribute.values;
                    var view = views[name];
                    var pointer = view.pointer;

                    var numberOfComponents = attribute.componentsPerAttribute;
                    for ( var k = 0; k < numberOfComponents; ++k) {
                        pointer[view.index + k] = values[(j * numberOfComponents) + k];
                    }

                    view.index += view.strideInComponentType;
                }
            }

            return {
                buffer : buffer,
                offsetsInBytes : offsetsInBytes,
                vertexSizeInBytes : vertexSizeInBytes
            };
        }

        // No attributes to interleave.
        return undefined;
    };

    Context.prototype._createVertexArrayAttributes = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var attributeIndices = ca.attributeIndices || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var interleave = ca.vertexLayout && (ca.vertexLayout === VertexLayout.INTERLEAVED);

        var name;
        var attribute;
        var vaAttributes = [];
        var attributes = mesh.attributes;

        if (interleave) {
            // Use a single vertex buffer with interleaved vertices.
            var interleavedAttributes = this._interleaveAttributes(attributes);
            if (interleavedAttributes) {
                var vertexBuffer = this.createVertexBuffer(interleavedAttributes.buffer, bufferUsage);
                var offsetsInBytes = interleavedAttributes.offsetsInBytes;
                var strideInBytes = interleavedAttributes.vertexSizeInBytes;

                for (name in attributes) {
                    if (attributes.hasOwnProperty(name)) {
                        attribute = attributes[name];

                        if (attribute.values) {
                            // Common case: per-vertex attributes
                            vaAttributes.push({
                                index : attributeIndices[name],
                                vertexBuffer : vertexBuffer,
                                componentDatatype : attribute.componentDatatype,
                                componentsPerAttribute : attribute.componentsPerAttribute,
                                normalize : attribute.normalize,
                                offsetInBytes : offsetsInBytes[name],
                                strideInBytes : strideInBytes
                            });
                        } else {
                            // Constant attribute for all vertices
                            vaAttributes.push({
                                index : attributeIndices[name],
                                value : attribute.value,
                                componentDatatype : attribute.componentDatatype,
                                normalize : attribute.normalize
                            });
                        }
                    }
                }
            }
        } else {
            // One vertex buffer per attribute.
            for (name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    attribute = attributes[name];
                    vaAttributes.push({
                        index : attributeIndices[name],
                        vertexBuffer : attribute.values ? this.createVertexBuffer(attribute.componentDatatype.toTypedArray(attribute.values), bufferUsage) : undefined,
                        value : attribute.value ? attribute.value : undefined,
                        componentDatatype : attribute.componentDatatype,
                        componentsPerAttribute : attribute.componentsPerAttribute,
                        normalize : attribute.normalize
                    });
                }
            }
        }

        return this.createVertexArray(vaAttributes);
    };

    /**
     * Creates a vertex array from a mesh.  A mesh contains vertex attributes and optional index data
     * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL
     * memory for use with rendering.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * <code>creationArguments</code> can have four properties:
     * <ul>
     *   <li><code>mesh</code>:  The source mesh containing data used to create the vertex array.</li>
     *   <li><code>attributeIndices</code>:  An object that maps mesh attribute names to vertex shader attribute indices.</li>
     *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>
     *   <li><code>vertexLayout</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>VertexLayout.SEPARATE</code>.</li>
     * </ul>
     * <br />
     * If <code>creationArguments</code> is not specified or the <code>mesh</code> contains no data, the returned vertex array is empty.
     *
     * @memberof Context
     *
     * @param {Object} [creationArguments=undefined] An object defining the mesh, attribute indices, buffer usage, and vertex layout used to create the vertex array.
     *
     * @exception {RuntimeError} Each attribute list must have the same number of vertices.
     * @exception {DeveloperError} The mesh must have zero or one index lists.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see MeshFilters.createAttributeIndices
     * @see ShaderProgram
     * @see BoxTessellator
     *
     * @example
     * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw
     * // usage is used for the created vertex and index buffer.  The attributes are not
     * // interleaved by default.
     * var mesh = BoxTessellator.compute();
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Creates a vertex array with interleaved attributes in a
     * // single vertex buffer.  The vertex and index buffer have static draw usage.
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     *     bufferUsage      : BufferUsage.STATIC_DRAW,
     *     vertexLayout     : VertexLayout.INTERLEAVED
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3.  When the caller destroys the vertex array, it also destroys the
     * // attached vertex buffer(s) and index buffer.
     * va = va.destroy();
     */
    Context.prototype.createVertexArrayFromMesh = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var indexLists;

        if (mesh.indexLists) {
            indexLists = mesh.indexLists;
            if (indexLists.length !== 1) {
                throw new DeveloperError('The mesh must have zero or one index lists.  This mesh has ' + indexLists.length.toString() + ' index lists.');
            }
        }

        var va = this._createVertexArrayAttributes(creationArguments);

        if (indexLists) {
            va.setIndexBuffer(this.createIndexBuffer(new Uint16Array(indexLists[0].values), bufferUsage, IndexDatatype.UNSIGNED_SHORT));
        }

        return va;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#pick
     */
    Context.prototype.createPickFramebuffer = function() {
        return new PickFramebuffer(this);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createPickId
     */
    Context.prototype.getObjectByPickId = function(pickId) {
        return undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getObjectByPickId
     */
    Context.prototype.createPickId = function(object) {
        var objects = {};
        var nextRgb = new Color(0, 0, 0, 0);

        function rgbToObjectIndex(unnormalizedRgb) {
            // TODO:  Use alpha?
            var index = 'r' + unnormalizedRgb.red + 'g' + unnormalizedRgb.green + 'b' + unnormalizedRgb.blue;
            return index;
        }

        function _createPickId(object) {
            // TODO:  Use alpha?
            if (++nextRgb.blue === 256) {
                nextRgb.blue = 0;

                if (++nextRgb.green === 256) {
                    nextRgb.green = 0;

                    if (++nextRgb.red === 256) {
                        throw new RuntimeError('Out of unique Rgb colors.');
                    }
                }
            }

            var pickId = {
                unnormalizedRgb : new Color(nextRgb.red, nextRgb.green, nextRgb.blue, 1.0),
                normalizedRgba : Color.fromBytes(nextRgb.red, nextRgb.green, nextRgb.blue, 255.0),
                destroy : function() {
                    // TODO: Remove from objects
                    return null;
                }
            };

            objects[rgbToObjectIndex(pickId.unnormalizedRgb)] = object;

            return pickId;
        }

        function _getObjectByPickId(unnormalizedRgb) {
            return objects[rgbToObjectIndex(unnormalizedRgb)];
        }

        this.createPickId = _createPickId;
        this.getObjectByPickId = _getObjectByPickId;

        return _createPickId(object);
    };

    Context.prototype.isDestroyed = function() {
        return false;
    };

    Context.prototype.destroy = function() {
        this._shaderCache = this._shaderCache.destroy();
        this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy();
        this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy();

        return destroyObject(this);
    };

    return Context;
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyFS',[],function() {
    
    return "//#define SHOW_TILE_BOUNDARIES\n\
//#define SHOW_TEXTURE_BOUNDARIES\n\
\n\
#if TEXTURE_UNITS > 0\n\
uniform sampler2D u_dayTextures[TEXTURE_UNITS];\n\
uniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\n\
uniform float u_dayTextureAlpha[TEXTURE_UNITS];\n\
uniform float u_dayTextureBrightness[TEXTURE_UNITS];\n\
uniform float u_dayTextureContrast[TEXTURE_UNITS];\n\
uniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\n\
uniform vec4 u_dayTextureTexCoordsExtent[TEXTURE_UNITS];\n\
#endif\n\
\n\
varying vec3 v_positionMC;\n\
varying vec3 v_positionEC;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
vec3 sampleAndBlend(\n\
    vec3 previousColor,\n\
    sampler2D texture,\n\
    vec2 tileTextureCoordinates,\n\
    vec4 textureCoordinateExtent,\n\
    vec4 textureCoordinateTranslationAndScale,\n\
    float textureAlpha,\n\
    float textureBrightness,\n\
    float textureContrast,\n\
    float textureOneOverGamma)\n\
{\n\
    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\n\
    //    tileTextureCoordinates.s < textureCoordinateExtent.s ||\n\
    //    tileTextureCoordinates.s > textureCoordinateExtent.p ||\n\
    //    tileTextureCoordinates.t < textureCoordinateExtent.t ||\n\
    //    tileTextureCoordinates.t > textureCoordinateExtent.q\n\
    // In other words, the alpha is zero if the fragment is outside the extent\n\
    // covered by this texture.  Would an actual 'if' yield better performance?\n\
    vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates); \n\
    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\
    \n\
    alphaMultiplier = step(vec2(0.0), textureCoordinateExtent.pq - tileTextureCoordinates);\n\
    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\
    \n\
    vec2 translation = textureCoordinateTranslationAndScale.xy;\n\
    vec2 scale = textureCoordinateTranslationAndScale.zw;\n\
    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n\
    vec4 sample = texture2D(texture, textureCoordinates);\n\
    vec3 color = sample.rgb;\n\
    float alpha = sample.a;\n\
    \n\
    color = mix(vec3(0.0, 0.0, 0.0), color, textureBrightness);\n\
    color = mix(vec3(0.5, 0.5, 0.5), color, textureContrast);\n\
    \n\
    color = pow(color, vec3(textureOneOverGamma));\n\
\n\
#ifdef SHOW_TEXTURE_BOUNDARIES\n\
    if (textureCoordinates.x < (1.0/256.0) || textureCoordinates.x > (255.0/256.0) ||\n\
        textureCoordinates.y < (1.0/256.0) || textureCoordinates.y > (255.0/256.0))\n\
    {\n\
        color = vec3(1.0, 1.0, 0.0);\n\
        alpha = 1.0;\n\
    }\n\
#endif\n\
\n\
    return mix(previousColor, color, alpha * textureAlpha);\n\
}\n\
\n\
vec3 computeDayColor(vec3 initialColor, vec2 textureCoordinates);\n\
\n\
void main()\n\
{\n\
    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\n\
    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\n\
    // fragments on the edges of tiles even though the vertex shader is outputting\n\
    // coordinates strictly in the 0-1 range.\n\
    vec3 initialColor = vec3(0.0, 0.0, 0.5);\n\
    vec3 startDayColor = computeDayColor(initialColor, clamp(v_textureCoordinates, 0.0, 1.0));\n\
    \n\
#ifdef SHOW_TILE_BOUNDARIES\n\
    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\n\
        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\n\
    {\n\
        startDayColor = vec3(1.0, 0.0, 0.0);\n\
    }\n\
#endif\n\
\n\
    gl_FragColor = vec4(startDayColor, 1.0);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyFSDepth',[],function() {
    
    return "varying vec4 positionEC;\n\
\n\
void main()\n\
{\n\
    // TODO: make arbitrary ellipsoid\n\
    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
    \n\
    vec3 direction = normalize(positionEC.xyz);\n\
    czm_ray ray = czm_ray(vec3(0.0), direction);\n\
    \n\
    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
    if (!czm_isEmpty(intersection))\n\
    {\n\
        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n\
    }\n\
    else\n\
    {\n\
        discard;\n\
    }\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyFSPole',[],function() {
    
    return "uniform vec3 u_color;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main()\n\
{\n\
    // TODO: make arbitrary ellipsoid\n\
    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
    vec3 direction = normalize(czm_windowToEyeCoordinates(gl_FragCoord).xyz);\n\
    czm_ray ray = czm_ray(vec3(0.0), direction);\n\
    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
    \n\
    if (!czm_isEmpty(intersection))\n\
    {\n\
        vec3 positionEC = czm_pointAlongRay(ray, intersection.start);\n\
        vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n\
	    \n\
	    vec3 normalMC = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0)));\n\
	    vec3 normalEC = normalize(czm_normal * normalMC);\n\
	    \n\
        vec3 startDayColor = u_color;\n\
		\n\
        gl_FragColor = vec4(startDayColor, 1.0);\n\
    }\n\
    else\n\
    {\n\
        discard;\n\
    }\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyVS',[],function() {
    
    return "attribute vec3 position3D;\n\
attribute vec2 textureCoordinates;\n\
\n\
uniform float u_morphTime;\n\
\n\
uniform vec3 u_center3D;\n\
uniform mat4 u_modifiedModelView;\n\
uniform vec4 u_tileExtent;\n\
\n\
// Uniforms for 2D Mercator projection\n\
uniform vec2 u_southAndNorthLatitude;\n\
uniform vec3 u_southMercatorYLowAndHighAndOneOverHeight;\n\
\n\
varying vec3 v_positionMC;\n\
varying vec3 v_positionEC;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
// These functions are generated at runtime.\n\
vec4 getPosition(vec3 position3DWC);\n\
float get2DYPositionFraction();\n\
\n\
vec4 getPosition3DMode(vec3 position3DWC)\n\
{\n\
    return czm_projection * (u_modifiedModelView * vec4(position3D, 1.0));\n\
}\n\
\n\
float get2DMercatorYPositionFraction()\n\
{\n\
    // The width of a tile at level 11, in radians and assuming a single root tile, is\n\
    //   2.0 * czm_pi / pow(2.0, 11.0)\n\
    // We want to just linearly interpolate the 2D position from the texture coordinates\n\
    // when we're at this level or higher.  The constant below is the expression\n\
    // above evaluated and then rounded up at the 4th significant digit.\n\
    const float maxTileWidth = 0.003068;\n\
    float positionFraction = textureCoordinates.y;\n\
    float southLatitude = u_southAndNorthLatitude.x;\n\
    float northLatitude = u_southAndNorthLatitude.y;\n\
    if (northLatitude - southLatitude > maxTileWidth)\n\
    {\n\
        float southMercatorYLow = u_southMercatorYLowAndHighAndOneOverHeight.x;\n\
        float southMercatorYHigh = u_southMercatorYLowAndHighAndOneOverHeight.y;\n\
        float oneOverMercatorHeight = u_southMercatorYLowAndHighAndOneOverHeight.z;\n\
\n\
        float currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);\n\
        currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);\n\
        positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorYLow, southMercatorYHigh, oneOverMercatorHeight);\n\
    }    \n\
    return positionFraction;\n\
}\n\
\n\
float get2DGeographicYPositionFraction()\n\
{\n\
    return textureCoordinates.y;\n\
}\n\
\n\
vec4 getPosition2DMode(vec3 position3DWC)\n\
{\n\
    float yPositionFraction = get2DYPositionFraction();\n\
    vec4 rtcPosition2D = vec4(0.0, mix(u_tileExtent.st, u_tileExtent.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);  \n\
    return czm_projection * (u_modifiedModelView * rtcPosition2D);\n\
}\n\
\n\
vec4 getPositionColumbusViewMode(vec3 position3DWC)\n\
{\n\
    return getPosition2DMode(position3DWC);\n\
}\n\
\n\
vec4 getPositionMorphingMode(vec3 position3DWC)\n\
{\n\
    // We do not do RTC while morphing, so there is potential for jitter.\n\
    // This is unlikely to be noticable, though.\n\
    float yPositionFraction = get2DYPositionFraction();\n\
    vec3 position2DWC = vec3(0.0, mix(u_tileExtent.st, u_tileExtent.pq, vec2(textureCoordinates.x, yPositionFraction)));\n\
    vec4 morphPosition = czm_columbusViewMorph(position2DWC, position3DWC, u_morphTime);\n\
    return czm_modelViewProjection * morphPosition;\n\
}\n\
\n\
void main() \n\
{\n\
    vec3 position3DWC = position3D + u_center3D;\n\
\n\
    gl_Position = getPosition(position3DWC);\n\
    \n\
    v_positionEC = (czm_modelView * vec4(position3DWC, 1.0)).xyz;\n\
    v_positionMC = position3DWC;                                 // position in model coordinates\n\
    v_textureCoordinates = textureCoordinates;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyVSDepth',[],function() {
    
    return "attribute vec4 position;\n\
\n\
varying vec4 positionEC;\n\
\n\
void main()\n\
{\n\
    positionEC = czm_modelView * position;\n\
    gl_Position = czm_projection * positionEC;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CentralBodyVSPole',[],function() {
    
    return "attribute vec4 position;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main() \n\
{\n\
    float x = (position.x - czm_viewport.x) / czm_viewport.z;\n\
    float y = (position.y - czm_viewport.y) / czm_viewport.w;\n\
    v_textureCoordinates = vec2(x, y);\n\
    \n\
    gl_Position = czm_viewportOrthographic * position;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ComplexConicSensorVolumeFS',[],function() {
    
    return "#ifdef GL_OES_standard_derivatives\n\
    #extension GL_OES_standard_derivatives : enable\n\
#endif  \n\
\n\
uniform float u_sensorRadius;\n\
uniform float u_outerHalfAngle;\n\
uniform float u_innerHalfAngle;\n\
uniform float u_maximumClockAngle;\n\
uniform float u_minimumClockAngle;\n\
uniform bool u_showIntersection;    \n\
uniform vec4 u_pickColor;\n\
\n\
varying vec3 v_positionEC;\n\
varying vec3 v_sensorVertexWC;\n\
varying vec3 v_sensorVertexEC;\n\
varying vec3 v_sensorAxisEC;\n\
\n\
#ifndef RENDER_FOR_PICK\n\
\n\
czm_materialInput getMaterialInput(float sensorRadius, vec3 pointEC, vec3 normalEC)\n\
{\n\
    czm_materialInput materialInput;\n\
\n\
    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n\
    materialInput.positionToEyeEC = -v_positionEC; \n\
    materialInput.normalEC = normalEC;\n\
    \n\
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n\
    materialInput.str = pointMC / sensorRadius; \n\
    materialInput.positionMC = pointMC;\n\
    \n\
    return materialInput;\n\
}\n\
vec4 getOuterColor(float sensorRadius, vec3 pointEC, vec3 normalEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    \n\
    czm_materialInput materialInput = getMaterialInput(sensorRadius, pointEC, normalEC);\n\
    czm_material material = czm_getOuterMaterial(materialInput);\n\
    \n\
    //Final\n\
    vec3 positionToEyeEC = normalize(-v_positionEC);\n\
    \n\
    return czm_phong(positionToEyeEC, material);\n\
}\n\
\n\
vec4 getInnerColor(float sensorRadius, vec3 pointEC, vec3 normalEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    \n\
    czm_materialInput materialInput = getMaterialInput(sensorRadius, pointEC, normalEC);\n\
    czm_material material = czm_getInnerMaterial(materialInput);\n\
    \n\
    //Final\n\
    vec3 positionToEyeEC = normalize(-v_positionEC);\n\
\n\
    return czm_phong(positionToEyeEC, material);        \n\
}\n\
\n\
vec4 getCapColor(float sensorRadius, vec3 pointEC, vec3 normalEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    \n\
    czm_materialInput materialInput = getMaterialInput(sensorRadius, pointEC, normalEC);\n\
    czm_material material = czm_getCapMaterial(materialInput);\n\
    \n\
    //Final\n\
    vec3 positionToEyeEC = normalize(-v_positionEC);\n\
\n\
    return czm_phong(positionToEyeEC, material);        \n\
}\n\
\n\
vec4 getSilhouetteColor(float sensorRadius, vec3 pointEC, vec3 normalEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    \n\
    czm_materialInput materialInput = getMaterialInput(sensorRadius, pointEC, normalEC);\n\
    czm_material material = czm_getSilhouetteMaterial(materialInput);\n\
    \n\
    //Final\n\
    vec3 positionToEyeEC = normalize(-v_positionEC);\n\
\n\
    return czm_phong(positionToEyeEC, material);        \n\
}\n\
\n\
#endif\n\
\n\
bool czm_isOnOrNear(float d, czm_raySegment interval, float epsilon)\n\
{\n\
    bool answer = (czm_equalsEpsilon(d, interval.start, epsilon) || czm_equalsEpsilon(d, interval.stop, epsilon));\n\
    return answer;\n\
}\n\
\n\
bool czm_isOnOrNear(float d, czm_raySegmentCollection coneIntervals, float epsilon)\n\
{\n\
    // Can have a maximum of two ray segments from cone intersection.\n\
    bool answer = (coneIntervals.count > 0 && (czm_isOnOrNear(d, coneIntervals.intervals[0], epsilon)))\n\
               || (coneIntervals.count > 1 && (czm_isOnOrNear(d, coneIntervals.intervals[1], epsilon)));\n\
    return answer;\n\
}\n\
\n\
bool czm_isOnOrNearSensor(float d, czm_raySegmentCollection outerIntervals, czm_raySegmentCollection innerIntervals, float epsilon)\n\
{\n\
    bool answer = czm_isOnOrNear(d, outerIntervals, epsilon) || czm_isOnOrNear(d, innerIntervals, epsilon);\n\
    return answer;\n\
}\n\
\n\
bool ellipsoidSensorIntersection(czm_raySegment sphereInterval,\n\
    czm_raySegmentCollection outerIntervals, czm_raySegmentCollection innerIntervals,\n\
    czm_raySegmentCollection clockIntervals,\n\
    czm_raySegment ellipsoidInterval, czm_raySegment silhouetteHalfspaceInterval, czm_raySegmentCollection solid)\n\
{\n\
    if (czm_isEmpty(ellipsoidInterval))\n\
    {\n\
        return false;\n\
    }\n\
\n\
    float t = ellipsoidInterval.start;\n\
\n\
#ifdef GL_OES_standard_derivatives\n\
    // TODO: This seems to be too aggressive in some areas, and too conservative in others\n\
    float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n\
#else\n\
    // TODO:  Don't hardcode this.\n\
    float epsilon = t / 500.0;\n\
#endif\n\
\n\
    float width = 2.0;  // TODO: Expose as a uniform\n\
    epsilon *= width;           \n\
\n\
    // TODO: Rework this once the ray segments have associated boundary surfaces with their start/stop values.\n\
    if (solid.count > 0)\n\
    {\n\
        float d = solid.intervals[0].start;\n\
        if (d == ellipsoidInterval.start\n\
         && (czm_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n\
          || czm_isOnOrNear(d, sphereInterval, epsilon) \n\
          || czm_isOnOrNear(d, clockIntervals, epsilon) \n\
          || czm_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n\
        d = solid.intervals[0].stop;\n\
        if (d == ellipsoidInterval.start\n\
         && (czm_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n\
          || czm_isOnOrNear(d, sphereInterval, epsilon) \n\
          || czm_isOnOrNear(d, clockIntervals, epsilon) \n\
          || czm_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n\
\n\
	    if (solid.count > 1)\n\
	    {\n\
	        d = solid.intervals[1].start;\n\
	        if (d == ellipsoidInterval.start\n\
	         && (czm_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n\
	          || czm_isOnOrNear(d, sphereInterval, epsilon) \n\
              || czm_isOnOrNear(d, clockIntervals, epsilon) \n\
	          || czm_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n\
	        d = solid.intervals[1].stop;\n\
            if (d == ellipsoidInterval.start\n\
             && (czm_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n\
              || czm_isOnOrNear(d, sphereInterval, epsilon) \n\
              || czm_isOnOrNear(d, clockIntervals, epsilon) \n\
              || czm_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n\
	    }\n\
	    \n\
	    return false;\n\
    }\n\
    else\n\
    {\n\
        false;\n\
    }\n\
}\n\
\n\
vec4 shade(\n\
    czm_ray ray,\n\
    float nearestRayTime,\n\
    czm_sphere sphere,\n\
    czm_cone outerCone,\n\
    czm_cone innerCone,\n\
    czm_halfspace maxClock,\n\
    czm_halfspace minClock,\n\
	czm_ellipsoidSilhouetteCone silhouetteCone,\n\
	czm_ellipsoidSilhouetteHalfspace silhouetteHalfspace,    \n\
    czm_raySegment sphereInterval,\n\
    czm_raySegmentCollection outerConeInterval,\n\
    czm_raySegmentCollection innerConeInterval,\n\
    czm_raySegment maxClockInterval,\n\
    czm_raySegment minClockInterval,\n\
    czm_raySegmentCollection clockIntervals,\n\
    czm_raySegment silhouetteConeInterval,\n\
    czm_raySegment silhouetteHalfspaceInterval,\n\
    czm_raySegment ellipsoidInterval,\n\
    czm_raySegmentCollection intervals)\n\
{\n\
#ifdef RENDER_FOR_PICK\n\
    return u_pickColor;\n\
#else\n\
    vec3 nearestPoint = czm_pointAlongRay(ray, nearestRayTime);\n\
\n\
    // Visualization TODO:  Segment stop surface can be used to determine which pixels to \"fill\" \n\
    // in order to indicate projection onto the ellipsoid surface.\n\
\n\
    if (u_showIntersection && ellipsoidSensorIntersection(sphereInterval,\n\
        outerConeInterval, innerConeInterval, clockIntervals,\n\
        ellipsoidInterval, silhouetteHalfspaceInterval, intervals))\n\
    {\n\
        return getIntersectionColor(u_sensorRadius, nearestPoint);\n\
    } \n\
\n\
    vec3 positionToEyeEC = -ray.direction;               // normalized position-to-eye vector in eye coordinates\n\
    vec3 czm_sunDirectionEC = czm_sunDirectionEC;           // normalized position-to-sun vector in eye coordinates\n\
\n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
	    if (i < outerConeInterval.count &&\n\
	       ((nearestRayTime == outerConeInterval.intervals[i].start) ||      // Viewer outside sensor CSG volume\n\
	        (nearestRayTime == outerConeInterval.intervals[i].stop)))         // Viewer inside\n\
	    {\n\
	        // Shade outer cone\n\
	        vec3 normal = czm_coneNormal(outerCone, nearestPoint);\n\
	        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
	        return getOuterColor(u_sensorRadius, nearestPoint, normal);\n\
	    }\n\
    }\n\
    \n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
	    if (i < innerConeInterval.count &&\n\
	       ((nearestRayTime == innerConeInterval.intervals[i].start) ||  // Viewer outside sensor CSG volume\n\
	        (nearestRayTime == innerConeInterval.intervals[i].stop)))     // Viewer inside\n\
	    {\n\
	        // Shade inner cone\n\
	        vec3 normal = -czm_coneNormal(innerCone, nearestPoint);\n\
	        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
	        return getInnerColor(u_sensorRadius, nearestPoint, normal);       \n\
	    }\n\
    }\n\
    \n\
    if ((nearestRayTime == sphereInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == sphereInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = czm_sphereNormal(sphere, nearestPoint);\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getCapColor(u_sensorRadius, nearestPoint, normal);     \n\
    }\n\
\n\
    if ((nearestRayTime == maxClockInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == maxClockInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = maxClock.normal;\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getOuterColor(u_sensorRadius, nearestPoint, normal);        \n\
    }\n\
\n\
    if ((nearestRayTime == minClockInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == minClockInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = minClock.normal;\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getOuterColor(u_sensorRadius, nearestPoint, normal);        \n\
    }\n\
\n\
    if ((nearestRayTime == silhouetteConeInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == silhouetteConeInterval.stop))       // Viewer inside\n\
    {\n\
        vec3 normal = czm_ellipsoidSilhouetteConeNormal(silhouetteCone, nearestPoint); // Normal is already inverted.\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getSilhouetteColor(u_sensorRadius, nearestPoint, normal);   \n\
    }\n\
\n\
    // Should never happen\n\
   return vec4(1.0, 0.0, 0.0, 1.0);\n\
#endif\n\
}\n\
\n\
vec4 shade(\n\
    czm_ray ray,\n\
    float nearestRayTime,\n\
    czm_sphere sphere,\n\
    czm_cone outerCone,\n\
    czm_cone innerCone,\n\
    czm_halfspace maxClock,\n\
    czm_halfspace minClock,\n\
    czm_raySegment sphereInterval,\n\
    czm_raySegmentCollection outerConeInterval,\n\
    czm_raySegmentCollection innerConeInterval,\n\
    czm_raySegment maxClockInterval,\n\
    czm_raySegment minClockInterval,\n\
    czm_raySegmentCollection intervals)\n\
{\n\
#ifdef RENDER_FOR_PICK\n\
    return u_pickColor;\n\
#else\n\
    vec3 nearestPoint = czm_pointAlongRay(ray, nearestRayTime);\n\
\n\
    vec3 positionToEyeEC = -ray.direction;               // normalized position-to-eye vector in eye coordinates\n\
\n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
        if (i < outerConeInterval.count &&\n\
           ((nearestRayTime == outerConeInterval.intervals[i].start) ||      // Viewer outside sensor CSG volume\n\
            (nearestRayTime == outerConeInterval.intervals[i].stop)))         // Viewer inside\n\
        {\n\
            // Shade outer cone\n\
            vec3 normal = czm_coneNormal(outerCone, nearestPoint);\n\
            normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
            return getOuterColor(u_sensorRadius, nearestPoint, normal);\n\
        }\n\
    }\n\
    \n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
        if (i < innerConeInterval.count &&\n\
           ((nearestRayTime == innerConeInterval.intervals[i].start) ||  // Viewer outside sensor CSG volume\n\
            (nearestRayTime == innerConeInterval.intervals[i].stop)))     // Viewer inside\n\
        {\n\
            // Shade inner cone\n\
            vec3 normal = -czm_coneNormal(innerCone, nearestPoint);\n\
            normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
            return getInnerColor(u_sensorRadius, nearestPoint, normal);       \n\
        }\n\
    }\n\
    \n\
    if ((nearestRayTime == sphereInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == sphereInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = czm_sphereNormal(sphere, nearestPoint);\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getCapColor(u_sensorRadius, nearestPoint, normal);      \n\
    }\n\
    \n\
    if ((nearestRayTime == maxClockInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == maxClockInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = maxClock.normal;\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getOuterColor(u_sensorRadius, nearestPoint, normal);       \n\
    }\n\
\n\
    if ((nearestRayTime == minClockInterval.start) ||    // Viewer outside sensor CSG volume\n\
        (nearestRayTime == minClockInterval.stop))       // Viewer inside\n\
    {\n\
        // Shade top cap\n\
        vec3 normal = minClock.normal;\n\
        normal = mix(normal, -normal, step(normal.z, 0.0));  // Normal facing viewer\n\
        return getOuterColor(u_sensorRadius, nearestPoint, normal);      \n\
    }\n\
\n\
   // Should never happen\n\
   return vec4(1.0, 0.0, 0.0, 1.0);\n\
#endif\n\
}\n\
\n\
void main()\n\
{\n\
    czm_ray ray = czm_ray(vec3(0.0), normalize(v_positionEC));  // Ray from eye to fragment in eye coordinates\n\
\n\
    // Determine the sensor primitive intervals.\n\
\n\
    czm_sphere sphere = czm_sphere(v_sensorVertexEC, u_sensorRadius);\n\
    czm_raySegment sphereInterval = czm_raySphereIntersectionInterval(ray, sphere);\n\
    if (czm_isEmpty(sphereInterval))\n\
    {\n\
        discard;\n\
    }\n\
\n\
    vec3 coneAxisEC = normalize(v_sensorAxisEC);    \n\
\n\
    czm_cone outerCone = czm_coneNew(v_sensorVertexEC, coneAxisEC, u_outerHalfAngle);\n\
    czm_raySegmentCollection outerConeInterval = czm_rayConeIntersectionInterval(ray, outerCone);\n\
    if (outerConeInterval.count == 0)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    czm_cone innerCone = czm_coneNew(v_sensorVertexEC, coneAxisEC, u_innerHalfAngle);\n\
    czm_raySegmentCollection innerConeInterval = czm_rayConeIntersectionInterval(ray, innerCone);\n\
    \n\
    // Build up the CSG representation of the sensor.    \n\
    czm_raySegmentCollection difference = (innerConeInterval.count == 0) ? outerConeInterval : czm_subtraction(outerConeInterval, innerConeInterval);\n\
    if (difference.count == 0)\n\
    {\n\
        discard;\n\
    }\n\
    czm_raySegmentCollection capped = czm_intersection(difference, sphereInterval);\n\
    if (capped.count == 0)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    vec3 maxNormal = normalize((czm_modelView * vec4(-sin(u_maximumClockAngle), cos(u_maximumClockAngle), 0.0, 0.0)).xyz);\n\
    czm_halfspace maxClock = czm_halfspace(v_sensorVertexEC, maxNormal);\n\
    czm_raySegment maxClockInterval = czm_rayHalfspaceIntersectionInterval(ray, maxClock);\n\
\n\
    vec3 minNormal = normalize((czm_modelView * vec4(sin(u_minimumClockAngle), -cos(u_minimumClockAngle), 0.0, 0.0)).xyz);\n\
    czm_halfspace minClock = czm_halfspace(v_sensorVertexEC, minNormal);\n\
    czm_raySegment minClockInterval = czm_rayHalfspaceIntersectionInterval(ray, minClock);\n\
\n\
    czm_raySegmentCollection clockIntervals = ((u_maximumClockAngle - u_minimumClockAngle) > czm_pi)\n\
        ? (czm_isEmpty(maxClockInterval) \n\
	        ? (czm_isEmpty(minClockInterval) ? czm_raySegmentCollectionNew() : czm_raySegmentCollectionNew(minClockInterval))\n\
	        : (czm_isEmpty(minClockInterval) ? czm_raySegmentCollectionNew(maxClockInterval) : czm_union(maxClockInterval, minClockInterval)))\n\
        : ((czm_isEmpty(maxClockInterval) || czm_isEmpty(minClockInterval)) ? czm_raySegmentCollectionNew() : czm_raySegmentCollectionNew(czm_intersection(maxClockInterval, minClockInterval)));\n\
\n\
    czm_raySegmentCollection sensor = (clockIntervals.count == 0) ? czm_raySegmentCollectionNew() : czm_intersection(capped, clockIntervals);\n\
    if (sensor.count == 0)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    // Determine the obstruction primitive intervals.\n\
\n\
    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
\n\
    czm_ellipsoidSilhouetteCone silhouetteCone = czm_ellipsoidSilhouetteConeNew(ellipsoid, v_sensorVertexEC);\n\
    czm_raySegment silhouetteConeInterval = czm_rayEllipsoidSilhouetteConeIntersectionInterval(ray, silhouetteCone);\n\
\n\
    if (czm_isEmpty(silhouetteConeInterval))\n\
    {\n\
        gl_FragColor = shade(ray, sensor.intervals[0].start,\n\
            sphere, outerCone, innerCone, maxClock, minClock,\n\
            sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval,\n\
            sensor);\n\
    }\n\
    else\n\
    {	\n\
	    czm_ellipsoidSilhouetteHalfspace silhouetteHalfspace = czm_ellipsoidSilhouetteHalfspaceNew(ellipsoid, v_sensorVertexEC);    \n\
	    czm_raySegment silhouetteHalfspaceInterval = czm_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(ray, silhouetteHalfspace);\n\
	    \n\
	    // Build up the CSG representation of the composite.\n\
	    czm_raySegment temp = (czm_isEmpty(silhouetteHalfspaceInterval)) ? czm_emptyRaySegment : czm_intersection(silhouetteConeInterval, silhouetteHalfspaceInterval);\n\
	    czm_raySegmentCollection stuff = (czm_isEmpty(temp)) ? sensor : czm_subtraction(sensor, temp);\n\
	    if (stuff.count == 0)\n\
	    {\n\
	       discard;\n\
	    }\n\
\n\
        czm_raySegment ellipsoidInterval = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
	    czm_raySegmentCollection result = (czm_isEmpty(ellipsoidInterval)) ? stuff : czm_subtraction(stuff, ellipsoidInterval);\n\
	    \n\
	    if ((result.count == 0)\n\
	        || (!czm_isEmpty(ellipsoidInterval) && (result.intervals[0].start > ellipsoidInterval.start))) // Fails depth test with ellipsoid\n\
	    {\n\
	        discard;\n\
	    }\n\
	    \n\
	    gl_FragColor = shade(ray, result.intervals[0].start,\n\
	        sphere, outerCone, innerCone, maxClock, minClock,\n\
	        silhouetteCone, silhouetteHalfspace,\n\
	        sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval, clockIntervals,\n\
	        silhouetteConeInterval, silhouetteHalfspaceInterval, ellipsoidInterval,\n\
	        result);\n\
    }\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ComplexConicSensorVolumeVS',[],function() {
    
    return "attribute vec4 position;\n\
\n\
varying vec3 v_positionEC;\n\
varying vec3 v_sensorVertexWC;\n\
varying vec3 v_sensorVertexEC;\n\
varying vec3 v_sensorAxisEC;\n\
\n\
void main()\n\
{\n\
    gl_Position = czm_modelViewInfiniteProjection * position;\n\
    v_positionEC = (czm_modelView * position).xyz;\n\
    \n\
    // These transforms could be done once on the CPU, but there are only five vertices.\n\
    // We could also hand-optimize the zeros out if the compiler doesn't already.\n\
    vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n\
    v_sensorVertexWC = (czm_model * sensorVertexMC).xyz;\n\
    v_sensorVertexEC = (czm_modelView * sensorVertexMC).xyz;\n\
    v_sensorAxisEC = czm_normal * vec3(0.0, 0.0, 1.0);\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ConstructiveSolidGeometry',[],function() {
    
    return "float _czm_addWithCancellationCheck(float left, float right, float tolerance)\n\
{\n\
    float difference = left + right;\n\
    if ((sign(left) != sign(right)) && abs(difference / max(abs(left), abs(right))) < tolerance)\n\
    {\n\
        return 0.0;\n\
    }\n\
    else\n\
    {\n\
        return difference;\n\
    }\n\
}\n\
        \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_quadraticRoots\n\
 * @glslStruct\n\
 */\n\
struct czm_quadraticRoots\n\
{\n\
    int numberOfRoots;\n\
    float root0;\n\
    float root1;\n\
};\n\
\n\
/**\n\
 * Computes the real-valued roots of the 2nd order polynomial function of one variable with only real coefficients.\n\
 *\n\
 * @name czm_quadraticRealPolynomialRealRoots\n\
 * @glslFunction\n\
 *\n\
 * @param {float} a The coefficient of the 2nd order monomial.\n\
 * @param {float} b The coefficient of the 1st order monomial.\n\
 * @param {float} c The coefficient of the 0th order monomial.\n\
 * \n\
 * @returns {czm_quadraticRoots} Zero, one, or two real-valued roots.\n\
 * \n\
 * @example\n\
 * czm_quadraticRoots r = czm_quadraticRealPolynomialRealRoots(2.0, -4.0, -6.0); // 2(x + 1)(x - 3)\n\
 * // The result is r.numberOfRoots = 2, r.root0 = -1.0, and r.root1 = 3.0.\n\
 */\n\
czm_quadraticRoots czm_quadraticRealPolynomialRealRoots(float a, float b, float c)\n\
{\n\
    // This function's return statements have an ANGLE workaround:  http://code.google.com/p/angleproject/issues/detail?id=185\n\
\n\
    const float tolerance = czm_epsilon7;\n\
\n\
    if (a == 0.0)\n\
    {\n\
        if (b == 0.0)\n\
        {\n\
            // Constant function: c = 0.  No real polynomial roots possible.\n\
            czm_quadraticRoots r = czm_quadraticRoots(0, 0.0, 0.0);\n\
            return r;\n\
        }\n\
        else\n\
        {\n\
            // Linear function: b * x + c = 0.\n\
            czm_quadraticRoots r = czm_quadraticRoots(1, -c / b, 0.0);\n\
            return r;           \n\
        }\n\
    }\n\
    else if (b == 0.0)\n\
    {\n\
        if (c == 0.0)\n\
        {\n\
            // 2nd order monomial: a * x^2 = 0.\n\
            czm_quadraticRoots r = czm_quadraticRoots(2, 0.0, 0.0);\n\
            return r;\n\
        }\n\
        else\n\
        {\n\
            float cMagnitude = abs(c);\n\
            float aMagnitude = abs(a);\n\
    \n\
            if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < tolerance)) // c ~= 0.0.\n\
            {\n\
                // 2nd order monomial: a * x^2 = 0.\n\
                czm_quadraticRoots r = czm_quadraticRoots(2, 0.0, 0.0);\n\
                return r;\n\
            }\n\
            else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < tolerance)) // a ~= 0.0.\n\
            {\n\
                // Constant function: c = 0.\n\
                czm_quadraticRoots r = czm_quadraticRoots(0, 0.0, 0.0);\n\
                return r;\n\
            }\n\
            else\n\
            {\n\
                // a * x^2 + c = 0\n\
                float ratio = -c / a;\n\
    \n\
                if (ratio < 0.0)\n\
                {\n\
                    // Both roots are complex.\n\
                    czm_quadraticRoots r = czm_quadraticRoots(0, 0.0, 0.0);\n\
                    return r;\n\
                }\n\
                else\n\
                {\n\
                    // Both roots are real.\n\
                    float root = sqrt(ratio);\n\
    \n\
                    // Return them in ascending order.\n\
                    czm_quadraticRoots r = czm_quadraticRoots(2, -root, root);\n\
                    return r;\n\
                }\n\
            }\n\
        }\n\
    }\n\
    else if (c == 0.0)\n\
    {\n\
        // a * x^2 + b * x = 0\n\
        float ratio = -b / a;\n\
    \n\
        // Return them in ascending order.\n\
        if (ratio < 0.0)\n\
        {\n\
            czm_quadraticRoots r = czm_quadraticRoots(2, ratio, 0.0);\n\
            return r;           \n\
        }\n\
        else\n\
        {\n\
            czm_quadraticRoots r = czm_quadraticRoots(2, 0.0, ratio);\n\
            return r;\n\
        }\n\
    }\n\
    else\n\
    {\n\
        // a * x^2 + b * x + c = 0\n\
        float b2 = b * b;\n\
        float four_ac = 4.0 * a * c;\n\
        float radicand = _czm_addWithCancellationCheck(b2, -four_ac, tolerance);\n\
    \n\
        if (radicand < 0.0)\n\
        {\n\
            // Both roots are complex.\n\
            czm_quadraticRoots r = czm_quadraticRoots(0, 0.0, 0.0);\n\
            return r;\n\
        }\n\
        else\n\
        {\n\
            // Both roots are real.\n\
            float q = -0.5 * _czm_addWithCancellationCheck(b, sign(b) * sqrt(radicand), tolerance);\n\
    \n\
            // Return them in ascending order.\n\
            if (b > 0.0)\n\
            {\n\
                // q < 0.0\n\
                czm_quadraticRoots r = czm_quadraticRoots(2, q / a, c / q);\n\
                return r;               \n\
            }\n\
            else\n\
            {\n\
                // q > 0.0\n\
                czm_quadraticRoots r = czm_quadraticRoots(2, c / q, q / a);\n\
                return r;               \n\
            }\n\
        }\n\
    }\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_sphere\n\
 * @glslStruct\n\
 */\n\
struct czm_sphere\n\
{\n\
    vec3 center;\n\
    float radius;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_raySphereIntersectionInterval\n\
 * @glslFunction\n\
 *\n\
 * @see czm_sphereNormal\n\
 */\n\
czm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, czm_sphere sphere)\n\
{\n\
    // From Real-Time Rendering, Section 16.6.2, Optimized Ray/Sphere Intersection Solution, Page 741\n\
    \n\
    // This function's return statements have an ANGLE workaround:  http://code.google.com/p/angleproject/issues/detail?id=185\n\
    \n\
    // PERFORMANCE_IDEA:  A more optimized but less friendly function could take radius squared directly, \n\
    // assume a center or origin of zero, etc.\n\
    \n\
    vec3 l = sphere.center - ray.origin;\n\
    float s = dot(l, ray.direction);\n\
    float l2 = dot(l, l);\n\
    float r2 = sphere.radius * sphere.radius;\n\
    \n\
    if ((s < 0.0) // Looking away from sphere.\n\
    && (l2 > r2)) // Outside of sphere.\n\
    {\n\
        return czm_emptyRaySegment;  // ray does not intersect (at least not along the indicated direction).\n\
    }\n\
    \n\
    float s2 = s * s;\n\
    float m2 = l2 - s2;\n\
    \n\
    if (m2 > r2) // Discriminant is negative, yielding only imaginary roots.\n\
    {\n\
        return czm_emptyRaySegment;  // ray does not intersect.\n\
    }\n\
    \n\
    float q = sqrt(r2 - m2);\n\
\n\
    if (czm_equalsEpsilon(q, 0.0)) // Discriminant is zero, yielding a double root.\n\
    {\n\
        return czm_raySegment(s, s);  // ray is tangent.\n\
    }\n\
        \n\
    if (l2 > r2) // Outside of sphere.\n\
    {\n\
	    czm_raySegment i = czm_raySegment(s - q, s + q);\n\
	    return i;\n\
    }\n\
    else if (l2 < r2) // Inside of sphere.\n\
   	{\n\
        czm_raySegment i = czm_raySegment(0.0, s + q);\n\
        return i;\n\
    }\n\
    else if (s > 0.0) // On sphere and looking inward.\n\
    {\n\
        czm_raySegment i = czm_raySegment(0.0, s + q);\n\
        return i;\n\
    }\n\
    else // On sphere and looking outward or tangent.\n\
    {\n\
        return czm_emptyRaySegment;\n\
   	}\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_sphereNormal\n\
 * @glslFunction\n\
 *\n\
 * @see czm_raySphereIntersectionInterval \n\
 * @see czm_pointAlongRay\n\
 */\n\
vec3 czm_sphereNormal(czm_sphere sphere, vec3 pointOnSphere)\n\
{\n\
    return normalize(pointOnSphere - sphere.center);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_cone\n\
 * @glslStruct\n\
 */\n\
struct czm_cone\n\
{\n\
    vec3 vertex;\n\
    vec3 axis;          // Unit-length direction vector\n\
    float halfAperture;    // Measured from the cone axis to the cone wall\n\
	// PERFORMANCE_IDEA: Make sure all of these are used...\n\
    float cosineOfHalfAperture;\n\
    float cosineSquaredOfHalfAperture;\n\
    float sineOfHalfAperture;\n\
    float sineSquaredOfHalfAperture;\n\
    mat3 intersectionMatrix;\n\
};\n\
\n\
czm_cone czm_coneNew(vec3 vertex, vec3 axis, float halfAperture)\n\
{\n\
	float cosineOfHalfAperture = cos(halfAperture);\n\
	float cosineSquaredOfHalfAperture = cosineOfHalfAperture * cosineOfHalfAperture;\n\
	float sineOfHalfAperture = sin(halfAperture);\n\
	float sineSquaredOfHalfAperture = sineOfHalfAperture * sineOfHalfAperture;\n\
	\n\
    float x2 = axis.x * axis.x;\n\
    float y2 = axis.y * axis.y;\n\
    float z2 = axis.z * axis.z;\n\
    float xy = axis.x * axis.y;\n\
    float yz = axis.y * axis.z;\n\
    float zx = axis.z * axis.x;\n\
\n\
    // This is a symmetric matrix.\n\
    mat3 intersectionMatrix = mat3(\n\
    	cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n\
		-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n\
		-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);            \n\
	\n\
    czm_cone temp = czm_cone(vertex, axis, halfAperture,\n\
    	cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n\
    	sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n\
    return temp;\n\
}\n\
\n\
/**\n\
 * Determines if a point is in, or on the boundary, of an infinite cone.\n\
 *\n\
 * @name czm_coneContainsPoint\n\
 * @glslFunction\n\
 *\n\
 * @param {czm_cone} cone The infinite cone.\n\
 * @param {vec3} point The point to test for containment.\n\
 *\n\
 * @returns {bool} <code>true</code> if the point is in the infinite cone; otherwise, <code>false</code>.\n\
 *\n\
 * @see czm_rayConeIntersectionInterval\n\
 *\n\
 * @example\n\
 * czm_cone cone = czm_coneNew(vec3(0.0), vec3(0.0, 0.0, 1.0), radians(45.0)); // vertex, axis, halfAperture\n\
 * vec3 point = vec3(1.0, 0.0, 0.0);\n\
 * bool b = czm_coneContainsPoint(cone, point)); // false\n\
 */\n\
bool czm_coneContainsPoint(czm_cone cone, vec3 point)\n\
{\n\
    vec3 n = normalize(point - cone.vertex);\n\
    return (dot(n, cone.axis) >= cone.cosineOfHalfAperture);\n\
}\n\
\n\
bool _czm_rayIntersectsReflectedCone(czm_ray ray, czm_cone cone, float time, float cosine)\n\
{\n\
    vec3 s = ray.origin + (time * ray.direction) - cone.vertex;  // The vector from the origin is at (vertex + s)\n\
    vec3 sUnit = normalize(s);\n\
    float c = dot(sUnit, cone.axis);\n\
    \n\
    return (sign(c) != sign(cosine));\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_rayConeIntersectionInterval\n\
 * @glslFunction\n\
 *\n\
 * @see czm_coneNormal\n\
 * @see czm_coneContainsPoint\n\
 */\n\
czm_raySegmentCollection czm_rayConeIntersectionInterval(czm_ray ray, czm_cone cone)\n\
{\n\
    vec3 temp = ray.origin - cone.vertex;\n\
\n\
    float t2 = dot(temp, temp);\n\
\n\
    float cosineNu = dot(ray.direction, cone.axis);\n\
\n\
    if (t2 == 0.0) // At vertex.\n\
    {\n\
        if (cosineNu >= cone.cosineOfHalfAperture) // Looking inward or along surface.\n\
        {\n\
            return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
        }\n\
        else // Looking outward.\n\
        {\n\
            return czm_raySegmentCollectionNew();\n\
        }\n\
    }\n\
    else // Not at vertex\n\
    {\n\
        float projection = dot(normalize(temp), cone.axis);\n\
\n\
        if (projection == cone.cosineOfHalfAperture) // On surface.\n\
        {\n\
            vec3 u = ray.direction;\n\
\n\
            mat3 crossProductMatrix = mat3(0.0, -u.z, u.y,\n\
                                            u.z, 0.0, -u.x,\n\
                                           -u.y, u.x, 0.0);\n\
            if (length(crossProductMatrix * temp) == 0.0) // Looking along surface.\n\
            {\n\
                if (dot(temp, u) > 0.0) // Looking away from vertex.\n\
                {\n\
                    return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
                }\n\
                else // Looking toward vertex.\n\
                {\n\
                    czm_raySegment i = czm_raySegment(0.0, length(temp));\n\
                    return czm_raySegmentCollectionNew(i);\n\
                }\n\
            }\n\
            else // Looking tangent at surface.\n\
            {\n\
                return czm_raySegmentCollectionNew();\n\
            }\n\
        }\n\
        else // Not on surface\n\
        {\n\
            vec3 t = normalize(temp);\n\
\n\
            float cosineAlpha2 = cone.cosineOfHalfAperture * cone.cosineOfHalfAperture;\n\
\n\
            float cosineTau = dot(t, cone.axis);\n\
            float cosineDelta = dot(t, ray.direction);\n\
\n\
            float cosineNu2 = cosineNu * cosineNu;\n\
            float cosineTau2 = cosineTau * cosineTau;\n\
\n\
            float stuff = cosineTau * cosineNu;\n\
\n\
            float positiveTerm = cosineNu2 + cosineTau2;\n\
            float negativeTerm = (cosineDelta * cosineDelta - 1.0) * cosineAlpha2;\n\
            float signedTerm = -2.0 * stuff * cosineDelta;\n\
\n\
            if (signedTerm > 0.0)\n\
            {\n\
                positiveTerm = positiveTerm + signedTerm;\n\
            }\n\
            else if (signedTerm < 0.0)\n\
            {\n\
                negativeTerm = negativeTerm + signedTerm;\n\
            }\n\
\n\
            float d = 4.0 * cosineAlpha2 * (positiveTerm + negativeTerm);\n\
\n\
            if (d < 0.0) // Imaginary roots.  No intersections.\n\
            {\n\
                if (cone.cosineOfHalfAperture < 0.0) // Obtuse cone.\n\
                {\n\
                    return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
                }\n\
                else // Acute cone.\n\
                {\n\
                    return czm_raySegmentCollectionNew();\n\
                }\n\
            }\n\
            else if (d > 0.0) // Distinct real roots.  Two intersections.\n\
            {\n\
                float a = cosineNu2 - cosineAlpha2;\n\
                float c = cosineTau2 - cosineAlpha2;\n\
                float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n\
\n\
                float s = (b == 0.0) ? 1.0 : sign(b);\n\
                float q = -(b + s * sqrt(d)) / 2.0;\n\
\n\
                float first = q / a;\n\
                float second = c / q;\n\
                if (second < first)\n\
                {\n\
                    float thing = first;\n\
                    first = second;\n\
                    second = thing;\n\
                }\n\
\n\
                // Check roots to ensure that they are non-negative and intersect the desired nape of the cone.\n\
                bool firstTest = (first >= 0.0) && !(sign(dot(t + first * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n\
                bool secondTest = (second >= 0.0) && !(sign(dot(t + second * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n\
\n\
                float m = sqrt(t2);\n\
\n\
                if (cosineTau > cone.cosineOfHalfAperture) // Inside cone.\n\
                {\n\
                    if (firstTest && secondTest)\n\
                    {\n\
                        // Ray starts inside cone and exits; then enters and never exits.\n\
                        czm_raySegment one = czm_raySegment(0.0, m * first);\n\
                        czm_raySegment two = czm_raySegment(m * second, czm_infinity);\n\
                        return czm_raySegmentCollectionNew(one, two);\n\
                    }\n\
                    else if (firstTest)\n\
                    {\n\
                        // Ray starts inside cone and exits.\n\
                        czm_raySegment i = czm_raySegment(0.0, m * first);\n\
                        return czm_raySegmentCollectionNew(i);\n\
                    }\n\
                    else if (secondTest)\n\
                    {\n\
                        // Ray starts inside cone and exits.\n\
                        czm_raySegment i = czm_raySegment(0.0, m * second);\n\
                        return czm_raySegmentCollectionNew(i);\n\
                    }\n\
                    else\n\
                    {\n\
                        // Ray starts inside cone and never exits.\n\
                        return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
                    }\n\
                }\n\
                else\n\
                {\n\
                    if (firstTest && secondTest)\n\
                    {\n\
                        // Ray enters and exits.\n\
                        czm_raySegment i = czm_raySegment(m * first, m * second);\n\
                        return czm_raySegmentCollectionNew(i);\n\
                    }\n\
                    else if (firstTest)\n\
                    {\n\
                        // Ray enters and never exits.\n\
                        czm_raySegment i = czm_raySegment(m * first, czm_infinity);\n\
                        return czm_raySegmentCollectionNew(i);\n\
                    }\n\
                    else if (secondTest)\n\
                    {\n\
                        // Ray enters and never exits.\n\
                        czm_raySegment i = czm_raySegment(m * second, czm_infinity);\n\
                        return czm_raySegmentCollectionNew(i);\n\
                    }\n\
                    else\n\
                    {\n\
                        // Ray never enters.\n\
                        return czm_raySegmentCollectionNew();\n\
                    }\n\
                }\n\
            }\n\
            else // (d == 0.0)  Repeated real roots.  Two intersections.\n\
            {\n\
                if (cone.cosineOfHalfAperture == 0.0) // Planar cone.\n\
                {\n\
                    if (cosineTau >= 0.0) // Inside or on surface.\n\
                    {\n\
                        if (cosineNu >= 0.0) // Looking inward or tangent.\n\
                        {\n\
                            // Ray starts inside cone and never exits.\n\
                            return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
                        }\n\
                        else\n\
                        {\n\
                            // Ray starts inside cone and intersects.\n\
                            czm_raySegment i = czm_raySegment(0.0, -sqrt(t2) * cosineTau / cosineNu);\n\
                            return czm_raySegmentCollectionNew(i);\n\
                        }\n\
                    }\n\
                    else // Outside.\n\
                    {\n\
                        if (cosineNu <= 0.0) // Looking outward or tangent.\n\
                        {\n\
                            // Ray starts outside cone and never enters.\n\
                            return czm_raySegmentCollectionNew();\n\
                        }\n\
                        else\n\
                        {\n\
                            // Ray starts outside cone and intersects.\n\
                            czm_raySegment i = czm_raySegment(-sqrt(t2) * cosineTau / cosineNu, czm_infinity);\n\
                            return czm_raySegmentCollectionNew(i);\n\
                        }\n\
                    }\n\
                }\n\
                else\n\
                {\n\
                    float a = cosineNu2 - cosineAlpha2;\n\
                    float c = cosineTau2 - cosineAlpha2;\n\
                    float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n\
\n\
                    float root = (a == 0.0) ? -sign(b) * czm_infinity : (-sign(b) / sign(a)) * sqrt(c / a);\n\
\n\
                    // Check roots to ensure that they are non-negative and intersect the desired nape of the cone.\n\
                    bool rootTest = (root >= 0.0) && !(sign(dot(t + root * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n\
\n\
                    float m = sqrt(t2);\n\
\n\
                    if (cosineTau > cone.cosineOfHalfAperture) // Inside cone.\n\
                    {\n\
                        if (rootTest)\n\
                        {\n\
                            // Ray starts inside cone and exits or becomes tangent.\n\
                            czm_raySegment i = czm_raySegment(0.0, m * root);\n\
                            return czm_raySegmentCollectionNew(i);\n\
                        }\n\
                        else\n\
                        {\n\
                            // Ray starts inside cone and never exits.\n\
                            return czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
                        }\n\
                    }\n\
                    else\n\
                    {\n\
                        if (rootTest)\n\
                        {\n\
                            if (c < 0.0) // Outside both napes of the cone.\n\
                            {\n\
                                // Ray starts outside cone and becomes tangent.\n\
                                float thing = m * root;\n\
                                czm_raySegment i = czm_raySegment(thing, thing);\n\
                                return czm_raySegmentCollectionNew(i);\n\
                            }\n\
                            else\n\
                            {\n\
                                // Ray starts outside cone and enters at vertex.\n\
                                float thing = m * root;\n\
                                czm_raySegment i = czm_raySegment(thing, czm_infinity);\n\
                                return czm_raySegmentCollectionNew(i);\n\
                            }\n\
                        }\n\
                        else\n\
                        {\n\
                            // Ray never enters.\n\
                            return czm_raySegmentCollectionNew();\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        }\n\
    }\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_rayConeIntersectNormal\n\
 * @glslFunction \n\
 *\n\
 * @see czm_rayConeIntersectionInterval\n\
 * @see czm_pointAlongRay\n\
 *\n\
 * @example\n\
 * // Compute the outward-facing cone normal where a ray first intersects a cone\n\
 * czm_ray ray = czm_ray(vec3(0.0), vec3(0.0, 0.0, 1.0)); // origin, direction\n\
 * czm_cone cone = czm_coneNew(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0), radians(45.0)); // vertex, axis, halfAperture\n\
 * czm_raySegment i = czm_rayConeIntersectionInterval(ray, cone);\n\
 * vec3 normal = czm_coneNormal(cone, czm_pointAlongRay(ray, i.start));\n\
 */\n\
vec3 czm_coneNormal(czm_cone cone, vec3 pointOnCone)\n\
{\n\
    // PERFORMANCE_IDEA: Remove duplicate computation with _czm_rayIntersectsReflectedCone\n\
    vec3 s = pointOnCone - cone.vertex;     // Vector from the origin is at (vertex + s)\n\
    vec3 sUnit = normalize(s);\n\
    return normalize((cone.cosineOfHalfAperture * sUnit - cone.axis) / cone.sineOfHalfAperture);\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidSilhouetteCone\n\
 * @glslStruct\n\
 */\n\
struct czm_ellipsoidSilhouetteCone\n\
{\n\
    czm_ellipsoid ellipsoid;\n\
    vec3 pointOutsideEllipsoid;\n\
    czm_cone coneInScaledSpace;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidSilhouetteConeNormal\n\
 * @glslFunction\n\
 *\n\
 */\n\
vec3 czm_ellipsoidSilhouetteConeNormal(czm_ellipsoidSilhouetteCone cone, vec3 pointOnCone)\n\
{\n\
    vec3 pointOnScaledCone = cone.ellipsoid.inverseRadii * (czm_inverseView * vec4(pointOnCone, 1.0)).xyz;\n\
\n\
    vec3 scaledNormal = czm_coneNormal(cone.coneInScaledSpace, pointOnScaledCone);\n\
\n\
    vec3 temp = -normalize(czm_viewRotation * (cone.ellipsoid.radii * scaledNormal));\n\
    \n\
    return temp;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidSilhouetteConeNew\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_ellipsoidSilhouetteCone czm_ellipsoidSilhouetteConeNew(czm_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n\
{\n\
	vec3 q = ellipsoid.inverseRadii * (czm_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n\
	vec3 axis = -normalize(q);\n\
	\n\
	float q2 = dot(q, q);\n\
	float sineSquaredOfHalfAperture = 1.0 / q2;\n\
	float sineOfHalfAperture = sqrt(sineSquaredOfHalfAperture);\n\
	float cosineSquaredOfHalfAperture = 1.0 - sineSquaredOfHalfAperture;\n\
	float cosineOfHalfAperture = sqrt(cosineSquaredOfHalfAperture);\n\
	float halfAperture = atan(sineOfHalfAperture / cosineOfHalfAperture);\n\
	\n\
    float x2 = axis.x * axis.x;\n\
    float y2 = axis.y * axis.y;\n\
    float z2 = axis.z * axis.z;\n\
    float xy = axis.x * axis.y;\n\
    float yz = axis.y * axis.z;\n\
    float zx = axis.z * axis.x;\n\
\n\
    // This is a symmetric matrix.\n\
    mat3 intersectionMatrix = mat3(\n\
    	cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n\
		-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n\
		-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);            \n\
	\n\
	czm_cone coneInScaledSpace = czm_cone(q, axis, halfAperture,\n\
		cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n\
		sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n\
\n\
    // ANGLE workaround:  http://code.google.com/p/angleproject/issues/detail?id=185		\n\
	czm_ellipsoidSilhouetteCone temp = czm_ellipsoidSilhouetteCone(ellipsoid, pointOutsideEllipsoid, coneInScaledSpace);\n\
	return temp;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_rayEllipsoidSilhouetteConeIntersectionInterval\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_raySegment czm_rayEllipsoidSilhouetteConeIntersectionInterval(czm_ray ray, czm_ellipsoidSilhouetteCone cone)\n\
{\n\
	// Determine the ray in the scaled space.\n\
	vec3 origin = cone.ellipsoid.inverseRadii * (czm_inverseView * vec4(ray.origin, 1.0)).xyz;\n\
	vec3 direction = normalize(cone.ellipsoid.inverseRadii * (czm_inverseViewRotation * ray.direction));\n\
	czm_ray rayInScaledSpace = czm_ray(origin, direction);\n\
	\n\
	// Perform the intersection in the scaled space.\n\
	czm_raySegmentCollection collection = czm_rayConeIntersectionInterval(rayInScaledSpace, cone.coneInScaledSpace);\n\
\n\
	if (collection.count == 0) // No intersection.\n\
	{\n\
		return czm_emptyRaySegment;\n\
	}\n\
	else // Intersection.\n\
	{\n\
        czm_raySegment interval = collection.intervals[0];\n\
        \n\
		// Honor ray origin case (start == 0.0).\n\
		float start = interval.start;\n\
		if (start != 0.0)\n\
		{\n\
			// Determine start in unscaled space.\n\
			vec3 temp = (czm_view * vec4(cone.ellipsoid.radii * czm_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n\
			start = dot(temp, ray.direction);\n\
		}\n\
		\n\
		// Honor infinite ray (stop == infinity).\n\
		float stop = interval.stop;\n\
		if (stop != czm_infinity)\n\
		{\n\
			// Determine stop in unscaled space.\n\
			vec3 temp = (czm_view * vec4(cone.ellipsoid.radii * czm_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n\
			stop = dot(temp, ray.direction);\n\
		}\n\
		\n\
		return czm_raySegment(start, stop);\n\
	}\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_halfspace\n\
 * @glslStruct\n\
 */\n\
struct czm_halfspace\n\
{\n\
	vec3 center;\n\
	vec3 normal; // Unit vector.\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_rayHalfspaceIntersectionInterval\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_raySegment czm_rayHalfspaceIntersectionInterval(czm_ray ray, czm_halfspace halfspace)\n\
{\n\
	float numerator = dot(halfspace.center - ray.origin, halfspace.normal);\n\
	float denominator = dot(ray.direction, halfspace.normal);\n\
	\n\
	if (numerator > 0.0) // Inside.\n\
	{\n\
		if (denominator > 0.0) // Looking outward.\n\
		{\n\
			return czm_raySegment(0.0, numerator / denominator);\n\
		}\n\
		else // Looking inward or parallel.\n\
		{\n\
			return czm_fullRaySegment;		\n\
		}\n\
	}\n\
	else if (numerator < 0.0) // Outside.\n\
	{\n\
		if (denominator < 0.0 ) // Looking inward.\n\
		{\n\
			return czm_raySegment(numerator / denominator, czm_infinity);		\n\
		}\n\
		else // Looking outward or parallel.\n\
		{\n\
			return czm_emptyRaySegment;\n\
		}\n\
	}\n\
	else // On surface.\n\
	{\n\
		if (denominator < 0.0 ) // Looking inward.\n\
		{\n\
			return czm_fullRaySegment;		\n\
		}\n\
		else // Looking outward or parallel.\n\
		{\n\
			return czm_emptyRaySegment;\n\
		}\n\
	}\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidSilhouetteHalfspace\n\
 * @glslStruct\n\
 */\n\
struct czm_ellipsoidSilhouetteHalfspace\n\
{\n\
    czm_ellipsoid ellipsoid;\n\
    vec3 pointOutsideEllipsoid;\n\
    czm_halfspace halfspaceInScaledSpace;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_ellipsoidSilhouetteHalfspaceNew\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_ellipsoidSilhouetteHalfspace czm_ellipsoidSilhouetteHalfspaceNew(czm_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n\
{\n\
	vec3 q = ellipsoid.inverseRadii * (czm_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n\
	float magnitude = 1.0 / length(q);\n\
	vec3 normal = normalize(q);\n\
	vec3 center = magnitude * normal;      \n\
	\n\
	czm_halfspace halfspaceInScaledSpace = czm_halfspace(center, normal);\n\
\n\
    // ANGLE workaround:  http://code.google.com/p/angleproject/issues/detail?id=185		\n\
	czm_ellipsoidSilhouetteHalfspace temp = czm_ellipsoidSilhouetteHalfspace(ellipsoid, pointOutsideEllipsoid, halfspaceInScaledSpace);\n\
	return temp;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_rayEllipsoidSilhouetteHalfspaceIntersectionInterval\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_raySegment czm_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(czm_ray ray, czm_ellipsoidSilhouetteHalfspace halfspace)\n\
{\n\
	// Determine the ray in the scaled space.\n\
	vec3 origin = halfspace.ellipsoid.inverseRadii * (czm_inverseView * vec4(ray.origin, 1.0)).xyz;\n\
	vec3 direction = halfspace.ellipsoid.inverseRadii * (czm_inverseViewRotation * ray.direction);\n\
	czm_ray rayInScaledSpace = czm_ray(origin, direction);\n\
	\n\
	// Perform the intersection in the scaled space.\n\
	czm_raySegment interval = czm_rayHalfspaceIntersectionInterval(rayInScaledSpace, halfspace.halfspaceInScaledSpace);\n\
\n\
	if (czm_isEmpty(interval)) // No intersection.\n\
	{\n\
		return interval;\n\
	}\n\
	else // Intersection.\n\
	{\n\
		// Honor ray origin case (start == 0.0).\n\
		float start = interval.start;\n\
		if (start != 0.0)\n\
		{\n\
			// Determine start in unscaled space.\n\
			vec3 temp = (czm_view * vec4(halfspace.ellipsoid.radii * czm_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n\
			start = dot(temp, ray.direction);\n\
		}\n\
		\n\
		// Honor infinite ray (stop == infinity).\n\
		float stop = interval.stop;\n\
		if (stop != czm_infinity)\n\
		{\n\
			// Determine stop in unscaled space.\n\
			vec3 temp = (czm_view * vec4(halfspace.ellipsoid.radii * czm_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n\
			stop = dot(temp, ray.direction);\n\
		}\n\
		\n\
		return czm_raySegment(start, stop);\n\
	}\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CustomSensorVolumeFS',[],function() {
    
    return "#ifdef GL_OES_standard_derivatives\n\
    #extension GL_OES_standard_derivatives : enable\n\
#endif  \n\
\n\
uniform bool u_showIntersection;\n\
uniform bool u_showThroughEllipsoid;\n\
\n\
uniform float u_sensorRadius;\n\
uniform vec4 u_pickColor;\n\
\n\
varying vec3 v_positionWC;\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec3 v_sensorVertexWC;\n\
varying vec3 v_sensorVertexEC;\n\
\n\
#ifndef RENDER_FOR_PICK\n\
\n\
vec4 getColor(float sensorRadius, vec3 pointEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    \n\
    czm_materialInput materialInput;\n\
    \n\
    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;                                \n\
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);   \n\
    materialInput.str = pointMC / sensorRadius;\n\
    materialInput.positionMC = pointMC;               \n\
    \n\
    vec3 positionToEyeEC = -v_positionEC;\n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
    \n\
    vec3 normalEC = normalize(v_normalEC);\n\
    normalEC = mix(normalEC, -normalEC, step(normalEC.z, 0.0));  // Normal facing viewer\n\
    materialInput.normalEC = normalEC;\n\
    \n\
    czm_material material = czm_getMaterial(materialInput);\n\
    \n\
    return czm_phong(normalize(positionToEyeEC), material);        \n\
}\n\
\n\
#endif\n\
\n\
bool ellipsoidSensorIntersection(czm_raySegment ellipsoidInterval)\n\
{\n\
	if (czm_isEmpty(ellipsoidInterval))\n\
	{\n\
	    return false;\n\
	}\n\
\n\
    float t = ellipsoidInterval.start;\n\
\n\
#ifdef GL_OES_standard_derivatives\n\
    // TODO: This seems to be too aggressive in some areas, and too conservative in others\n\
    float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n\
    \n\
    if (epsilon >= ellipsoidInterval.start)\n\
    {\n\
        // If the fragment is on the silhouette of the ellipsoid, the adjacent fragment\n\
        // will not hit the ellipsoid (its ellipsoidInterval.start will be zero),\n\
        // so the derivative will be large, and we would get false positives.\n\
        return false;\n\
    }\n\
#else\n\
    // TODO:  Don't hardcode this.\n\
    float epsilon = t / 500.0;\n\
#endif\n\
\n\
    float width = 2.0;  // TODO: Expose as a uniform\n\
    epsilon *= width;           \n\
\n\
    return czm_equalsEpsilon(t, length(v_positionEC), epsilon);\n\
}\n\
\n\
vec4 shade(czm_raySegment ellipsoidInterval)\n\
{\n\
#ifdef RENDER_FOR_PICK\n\
    return u_pickColor;\n\
#else\n\
    if (u_showIntersection && ellipsoidSensorIntersection(ellipsoidInterval))\n\
    {\n\
        return getIntersectionColor(u_sensorRadius, v_positionEC);\n\
    }\n\
    return getColor(u_sensorRadius, v_positionEC);\n\
#endif\n\
}\n\
\n\
bool czm_pointInEllipsoid(czm_ellipsoid ellipsoid, vec3 point)\n\
{\n\
    // TODO: Take into account ellipsoid's center; optimize with radii-squared; and move elsewhere\n\
    return (((point.x * point.x) / (ellipsoid.radii.x * ellipsoid.radii.x)) +\n\
            ((point.y * point.y) / (ellipsoid.radii.y * ellipsoid.radii.y)) +\n\
            ((point.z * point.z) / (ellipsoid.radii.z * ellipsoid.radii.z)) < 1.0);\n\
}\n\
\n\
void main()\n\
{\n\
    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
\n\
    // Occluded by the ellipsoid?\n\
	if (!u_showThroughEllipsoid)\n\
	{\n\
	    // Discard if in the ellipsoid    \n\
	    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\n\
	    if (czm_pointInEllipsoid(ellipsoid, v_positionWC))\n\
	    {\n\
	        discard;\n\
	    }\n\
	\n\
	    // Discard if in the sensor's shadow\n\
	    if (inSensorShadow(v_sensorVertexWC, ellipsoid, v_positionEC))\n\
	    {\n\
	        discard;\n\
	    }\n\
    }\n\
    \n\
    // Discard if not in the sensor's sphere\n\
    // PERFORMANCE_IDEA: We can omit this check if the radius is Number.POSITIVE_INFINITY.\n\
    if (distance(v_positionEC, v_sensorVertexEC) > u_sensorRadius)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    czm_ray ray = czm_ray(vec3(0.0), normalize(v_positionEC));  // Ray from eye to fragment in eye coordinates\n\
    czm_raySegment ellipsoidInterval = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
\n\
    gl_FragColor = shade(ellipsoidInterval);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/CustomSensorVolumeVS',[],function() {
    
    return "attribute vec4 position;\n\
attribute vec3 normal;\n\
\n\
varying vec3 v_positionWC;\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec3 v_sensorVertexWC;\n\
varying vec3 v_sensorVertexEC;\n\
\n\
void main()\n\
{\n\
    gl_Position = czm_modelViewProjection * position;\n\
    v_positionWC = (czm_model * position).xyz;\n\
    v_positionEC = (czm_modelView * position).xyz;\n\
    v_normalEC = czm_normal * normal;\n\
    \n\
    // This transform could be done once on the CPU.\n\
    // We could also hand-optimize the zeros out if the compiler doesn't already.\n\
    vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n\
    v_sensorVertexWC = (czm_model * sensorVertexMC).xyz;\n\
    v_sensorVertexEC = (czm_modelView * sensorVertexMC).xyz;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/EllipsoidFS',[],function() {
    
    return "uniform vec3 u_radii;\n\
uniform vec3 u_oneOverEllipsoidRadiiSquared;\n\
\n\
varying vec3 v_positionEC;\n\
\n\
void main()\n\
{\n\
    czm_ellipsoid ellipsoid = czm_ellipsoidNew(czm_modelView[3].xyz, u_radii);\n\
    vec3 direction = normalize(v_positionEC);\n\
    czm_ray ray = czm_ray(vec3(0.0), direction);\n\
    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
    \n\
    if (czm_isEmpty(intersection))\n\
    {\n\
        discard;\n\
    }\n\
        \n\
    // Pick the intersection point based on if the viewer is outside or inside the ellipsoid\n\
    bool hitFrontFace = (intersection.start != 0.0);\n\
    vec3 positionEC = czm_pointAlongRay(ray, hitFrontFace ? intersection.start : intersection.stop);\n\
    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n\
    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\n\
    vec3 normalMC = hitFrontFace ? geodeticNormal : -geodeticNormal;   // normalized surface normal (always facing the viewer) in model coordinates\n\
    vec3 normalEC = normalize(czm_normal * normalMC);                    // normalized surface normal in eye coordiantes\n\
    \n\
    vec2 st = czm_ellipsoidWgs84TextureCoordinates(geodeticNormal);\n\
    vec3 positionToEyeEC = -positionEC; \n\
                \n\
    czm_materialInput materialInput;\n\
    materialInput.s = st.s;\n\
    materialInput.st = st;\n\
    materialInput.str = (positionMC + u_radii) / u_radii;\n\
    materialInput.normalEC = normalEC;\n\
    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
    materialInput.positionMC = positionMC;\n\
    czm_material material = czm_getMaterial(materialInput);\n\
\n\
	gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/EllipsoidVS',[],function() {
    
    return "attribute vec3 position;\n\
\n\
uniform vec3 u_radii;\n\
\n\
varying vec3 v_positionEC;\n\
\n\
void main() \n\
{\n\
   // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.\n\
   // Scale to consider the radii.  We could also do this once on the CPU when using the BoxTessellator,\n\
   // but doing it here allows us to change the radii without rewriting the vertex data, and\n\
   // allows all ellipsoids to reuse the same vertex data.\n\
    vec4 p = vec4(u_radii * position, 1.0);\n\
    \n\
    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates\n\
    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/AsphaltMaterial',[],function() {
    
    return "uniform vec4 asphaltColor;\n\
uniform float bumpSize;\n\
uniform float roughness;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n\
    //Main cellular pattern\n\
    vec4 color = asphaltColor;\n\
    vec2 st = materialInput.st;\n\
    vec2 F = czm_cellular(st / bumpSize);\n\
    color.rgb -= (F.x / F.y) * 0.1;\n\
    \n\
    //Extra bumps for roughness\n\
    float noise = czm_snoise(st / bumpSize);\n\
    noise = pow(noise, 5.0) * roughness;\n\
    color.rgb += noise;\n\
\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/BlobMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform float frequency;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n\
    vec2 F = czm_cellular(materialInput.st * frequency);\n\
    float t = 1.0 - F.x * F.x;\n\
    \n\
    vec4 color = mix(lightColor, darkColor, t);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/BrickMaterial',[],function() {
    
    return "uniform vec4 brickColor;\n\
uniform vec4 mortarColor;\n\
uniform vec2 brickSize;\n\
uniform vec2 brickPct;\n\
uniform float brickRoughness;\n\
uniform float mortarRoughness;\n\
\n\
#define Integral(x, p) ((floor(x) * p) + max(fract(x) - (1.0 - p), 0.0))\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    // From OpenGL Shading Language (3rd edition) pg. 194, 501\n\
    vec2 st = materialInput.st;\n\
    vec2 position = st / brickSize;\n\
    if(fract(position.y * 0.5) > 0.5) {\n\
        position.x += 0.5;    \n\
    }\n\
        \n\
    //calculate whether to use brick or mortar (does AA)\n\
    vec2 filterWidth = vec2(0.02);\n\
    vec2 useBrick = (Integral(position + filterWidth, brickPct) - \n\
                       Integral(position, brickPct)) / filterWidth;\n\
    float useBrickFinal = useBrick.x * useBrick.y;\n\
    vec4 color = mix(mortarColor, brickColor, useBrickFinal);\n\
    \n\
    //Apply noise to brick\n\
    vec2 brickScaled = vec2(st.x / 0.1, st.y / 0.006);\n\
    float brickNoise = abs(czm_snoise(brickScaled) * brickRoughness / 5.0);\n\
    color.rg += brickNoise * useBrickFinal;\n\
    \n\
    //Apply noise to mortar\n\
    vec2 mortarScaled = st / 0.005;\n\
    float mortarNoise = max(czm_snoise(mortarScaled) * mortarRoughness, 0.0);\n\
    color.rgb += mortarNoise * (1.0 - useBrickFinal); \n\
\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/BumpMapMaterial',[],function() {
    
    return "uniform sampler2D image;\n\
uniform float strength;\n\
uniform vec2 repeat;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    vec2 st = materialInput.st;\n\
    \n\
    vec2 centerPixel = fract(repeat * st);\n\
    float centerBump = texture2D(image, centerPixel).channel;\n\
    \n\
    float imageWidth = float(imageDimensions.x);\n\
    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n\
    float rightBump = texture2D(image, rightPixel).channel;\n\
    \n\
    float imageHeight = float(imageDimensions.y);\n\
    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n\
    float topBump = texture2D(image, leftPixel).channel;\n\
    \n\
    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n\
    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\
 \n\
    material.normal = normalEC;\n\
    material.diffuse = vec3(0.01);\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/CementMaterial',[],function() {
    
    return "uniform vec4 cementColor;\n\
uniform float grainScale;\n\
uniform float roughness;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    float noise = czm_snoise(materialInput.st / grainScale);\n\
    noise = pow(noise, 5.0) * roughness;\n\
   \n\
    vec4 color = cementColor;\n\
    color.rgb += noise;\n\
    \n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/CheckerboardMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform vec2 repeat;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    // Fuzz Factor - Controls blurriness between light and dark colors\n\
    vec2 st = materialInput.st;\n\
    const float fuzz = 0.03;\n\
    \n\
    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n\
    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n\
    \n\
    // Find the distance from the closest separator (region between two colors)\n\
    float scaledWidth = fract(repeat.s * st.s);\n\
    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n\
    float scaledHeight = fract(repeat.t * st.t);\n\
    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\
    float value = min(scaledWidth, scaledHeight);\n\
    \n\
    //anti-aliasing\n\
    float val1 = clamp(value / fuzz, 0.0, 1.0);\n\
    float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n\
    val1 = val1 * (1.0 - val2);\n\
    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n\
    val1 = pow(val1, 0.5); //makes the transition nicer\n\
    \n\
    vec4 midColor = (lightColor + darkColor) / 2.0;\n\
    vec4 currentColor = mix(lightColor, darkColor, b);\n\
    \n\
    vec4 color = mix(midColor, currentColor, val1);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/DotMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform vec2 repeat;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n\
    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\
\n\
    vec4 color = mix(lightColor, darkColor, b);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/FacetMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform float frequency;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n\
    vec2 F = czm_cellular(materialInput.st * frequency);\n\
    float t = 0.1 + (F.y - F.x);\n\
        \n\
    vec4 color = mix(lightColor, darkColor, t);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/FresnelMaterial',[],function() {
    
    return "czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\n\
    vec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\n\
    float cosAngIncidence = max(dot(normalWC, positionWC), 0.0);\n\
    \n\
    material.diffuse = mix(reflection.diffuse, refraction.diffuse, cosAngIncidence);\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/GrassMaterial',[],function() {
    
    return "uniform vec4 grassColor;\n\
uniform vec4 dirtColor;\n\
uniform float patchiness;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec2 st = materialInput.st;\n\
    float noise1 = (czm_snoise(st * patchiness * 1.0)) * 1.0;\n\
    float noise2 = (czm_snoise(st * patchiness * 2.0)) * 0.5;\n\
    float noise3 = (czm_snoise(st * patchiness * 4.0)) * 0.25;\n\
    float noise = sin(noise1 + noise2 + noise3) * 0.1;\n\
    \n\
    vec4 color = mix(grassColor, dirtColor, noise);\n\
    \n\
    //Make thatch patterns\n\
    float verticalNoise = czm_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\n\
    float horizontalNoise = czm_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\n\
    float stripeNoise = min(verticalNoise, horizontalNoise);\n\
 \n\
    color.rgb += stripeNoise;\n\
    \n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/NormalMapMaterial',[],function() {
    
    return "uniform sampler2D image;\n\
uniform float strength;\n\
uniform vec2 repeat;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\n\
    vec3 normalTangentSpace = textureValue.channels;\n\
    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n\
    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n\
    normalTangentSpace = normalize(normalTangentSpace);\n\
    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\
    \n\
    material.normal = normalEC;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/ReflectionMaterial',[],function() {
    
    return "uniform samplerCube cubeMap;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\n\
    vec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\n\
    vec3 reflectedWC = reflect(positionWC, normalWC);\n\
    material.diffuse = textureCube(cubeMap, reflectedWC).channels;\n\
\n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/RefractionMaterial',[],function() {
    
    return "uniform samplerCube cubeMap;\n\
uniform float indexOfRefractionRatio;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\n\
    vec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\n\
    vec3 refractedWC = refract(positionWC, -normalWC, indexOfRefractionRatio);\n\
    material.diffuse = textureCube(cubeMap, refractedWC).channels;\n\
\n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/StripeMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform float offset;\n\
uniform float repeat;\n\
uniform bool horizontal;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n\
    // Fuzz Factor - Controls blurriness between light and dark colors\n\
    const float fuzz = 0.1;\n\
\n\
    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n\
    float value = fract((coord - offset) * (repeat * 0.5));\n\
    \n\
    //anti-aliasing\n\
    float val1 = clamp(value / fuzz, 0.0, 1.0);\n\
    float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n\
    val1 = val1 * (1.0 - val2);\n\
    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n\
\n\
    vec4 color = mix(lightColor, darkColor, val1);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/TieDyeMaterial',[],function() {
    
    return "uniform vec4 lightColor;\n\
uniform vec4 darkColor;\n\
uniform float frequency;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    vec3 scaled = materialInput.str * frequency;\n\
    float t = abs(czm_snoise(scaled));\n\
    \n\
    vec4 color = mix(lightColor, darkColor, t);\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/Water',[],function() {
    
    return "// Thanks for the contribution Jonas\n\
// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\
\n\
uniform sampler2D specularMap;\n\
uniform sampler2D normalMap;\n\
uniform vec4 baseWaterColor;\n\
uniform vec4 blendColor;\n\
uniform float frequency;\n\
uniform float animationSpeed;\n\
uniform float amplitude;\n\
uniform float specularIntensity;\n\
uniform float fadeFactor;\n\
\n\
vec4 getNoise(vec2 uv, float time, float angleInRadians) {\n\
\n\
    float cosAngle = cos(angleInRadians);\n\
    float sinAngle = sin(angleInRadians);\n\
    \n\
    // time dependent sampling directions\n\
    vec2 s0 = vec2(1.0/17.0, 0.0);\n\
    vec2 s1 = vec2(-1.0/29.0, 0.0);\n\
    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n\
    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\
    \n\
    // rotate sampling direction by specified angle\n\
    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n\
    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n\
    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n\
    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\
    \n\
    vec2 uv0 = (uv/103.0) + (time * s0);\n\
    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n\
    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n\
    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\
    \n\
    uv0 = fract(uv0);\n\
    uv1 = fract(uv1);\n\
    uv2 = fract(uv2);\n\
    uv3 = fract(uv3);\n\
    vec4 noise = (texture2D(normalMap, uv0)) +\n\
                 (texture2D(normalMap, uv1)) +\n\
                 (texture2D(normalMap, uv2)) +\n\
                 (texture2D(normalMap, uv3));\n\
                 \n\
    // average and scale to between -1 and 1\n\
    return ((noise / 4.0) - 0.5) * 2.0;\n\
}\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
\n\
    float time = czm_frameNumber * animationSpeed;\n\
    \n\
    // fade is a function of the distance from the fragment and the frequency of the waves\n\
    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\
            \n\
    float specularMapValue = texture2D(specularMap, materialInput.st).r;\n\
    \n\
    // note: not using directional motion at this time, just set the angle to 0.0;\n\
    vec4 noise = getNoise(materialInput.st * frequency, time, 0.0);\n\
    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\
    \n\
    // fade out the normal perturbation as we move further from the water surface\n\
    normalTangentSpace.xy /= fade;\n\
        \n\
    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n\
    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\
    \n\
    normalTangentSpace = normalize(normalTangentSpace);\n\
    \n\
    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n\
    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\
    \n\
    // fade out water effect as specular map value decreases\n\
    material.alpha = specularMapValue;\n\
    \n\
    // base color is a blend of the water and non-water color based on the value from the specular map\n\
    // may need a uniform blend factor to better control this\n\
    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n\
    \n\
    // diffuse highlights are based on how perturbed the normal is\n\
    material.diffuse += (0.1 * tsPerturbationRatio);\n\
    \n\
    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\
    \n\
    material.specular = specularIntensity;\n\
    material.shininess = 10.0;\n\
    \n\
    return material;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Materials/WoodMaterial',[],function() {
    
    return "uniform vec4 lightWoodColor;\n\
uniform vec4 darkWoodColor;\n\
uniform float ringFrequency;\n\
uniform vec2 noiseScale;\n\
uniform float grainFrequency;\n\
\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    \n\
    //Based on wood shader from OpenGL Shading Language (3rd edition) pg. 455\n\
    vec2 st = materialInput.st;\n\
    \n\
    vec2 noisevec;\n\
    noisevec.x = czm_snoise(st * noiseScale.x);\n\
    noisevec.y = czm_snoise(st * noiseScale.y);\n\
    \n\
    vec2 location = st + noisevec;\n\
    float dist = sqrt(location.x * location.x + location.y * location.y);\n\
    dist *= ringFrequency;\n\
    \n\
    float r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\n\
    if(r > 1.0)\n\
        r = 2.0 - r;\n\
        \n\
    vec4 color = mix(lightWoodColor, darkWoodColor, r);\n\
    \n\
    //streaks\n\
    r = abs(czm_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\n\
    color.rgb += lightWoodColor.rgb * r;\n\
    \n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a;\n\
    \n\
    return material;\n\
}";
});
/*!
 * Description : Array and textureless GLSL 2D/3D/4D simplex 
 *               noise functions.
 *      Author : Ian McEwan, Ashima Arts.
 *  Maintainer : ijm
 *     Lastmod : 20110822 (ijm)
 *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
 *               Distributed under the MIT License. See LICENSE file.
 *               https://github.com/ashima/webgl-noise
 */
/*!
 * Cellular noise ("Worley noise") in 2D in GLSL.
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
 * This code is released under the conditions of the MIT license.
 * See LICENSE file for details.
 */
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Noise',[],function() {
    
    return "#ifndef czm_NOISE\n\
#define czm_NOISE 1\n\
\n\
/*!\n\
 * Description : Array and textureless GLSL 2D/3D/4D simplex \n\
 *               noise functions.\n\
 *      Author : Ian McEwan, Ashima Arts.\n\
 *  Maintainer : ijm\n\
 *     Lastmod : 20110822 (ijm)\n\
 *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\
 *               Distributed under the MIT License. See LICENSE file.\n\
 *               https://github.com/ashima/webgl-noise\n\
 */ \n\
\n\
vec4 _czm_mod289(vec4 x)\n\
{\n\
  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\
}\n\
\n\
vec3 _czm_mod289(vec3 x)\n\
{\n\
    return x - floor(x * (1.0 / 289.0)) * 289.0;\n\
}\n\
\n\
vec2 _czm_mod289(vec2 x) \n\
{\n\
    return x - floor(x * (1.0 / 289.0)) * 289.0;\n\
}\n\
\n\
float _czm_mod289(float x)\n\
{\n\
    return x - floor(x * (1.0 / 289.0)) * 289.0;\n\
}\n\
  \n\
vec4 _czm_permute(vec4 x)\n\
{\n\
    return _czm_mod289(((x*34.0)+1.0)*x);\n\
}\n\
\n\
vec3 _czm_permute(vec3 x)\n\
{\n\
    return _czm_mod289(((x*34.0)+1.0)*x);\n\
}\n\
\n\
float _czm_permute(float x) \n\
{\n\
    return _czm_mod289(((x*34.0)+1.0)*x);\n\
}\n\
\n\
vec4 _czm_taylorInvSqrt(vec4 r)\n\
{\n\
    return 1.79284291400159 - 0.85373472095314 * r;\n\
}\n\
\n\
float _czm_taylorInvSqrt(float r)\n\
{\n\
    return 1.79284291400159 - 0.85373472095314 * r;\n\
}\n\
\n\
vec4 _czm_grad4(float j, vec4 ip)\n\
{\n\
    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\
    vec4 p,s;\n\
\n\
    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\
    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\
    s = vec4(lessThan(p, vec4(0.0)));\n\
    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\
\n\
    return p;\n\
}\n\
  \n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n\
 *\n\
 * @name czm_snoise\n\
 * @glslFunction\n\
 *\n\
 * @see <a href=\"https://github.com/ashima/webgl-noise\">https://github.com/ashima/webgl-noise</a>\n\
 * @see Stefan Gustavson's paper <a href=\"http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\">Simplex noise demystified</a>\n\
 */  \n\
float czm_snoise(vec2 v)\n\
{\n\
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\
                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n\
                        0.024390243902439); // 1.0 / 41.0\n\
    // First corner\n\
    vec2 i  = floor(v + dot(v, C.yy) );\n\
    vec2 x0 = v -   i + dot(i, C.xx);\n\
\n\
    // Other corners\n\
    vec2 i1;\n\
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n\
    //i1.y = 1.0 - i1.x;\n\
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\
    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n\
    // x1 = x0 - i1 + 1.0 * C.xx ;\n\
    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n\
    vec4 x12 = x0.xyxy + C.xxzz;\n\
    x12.xy -= i1;\n\
\n\
    // Permutations\n\
    i = _czm_mod289(i); // Avoid truncation effects in permutation\n\
    vec3 p = _czm_permute( _czm_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\
\n\
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\
    m = m*m ;\n\
    m = m*m ;\n\
\n\
    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\
    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n\
    vec3 h = abs(x) - 0.5;\n\
    vec3 ox = floor(x + 0.5);\n\
    vec3 a0 = x - ox;\n\
\n\
    // Normalise gradients implicitly by scaling m\n\
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n\
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\
\n\
    // Compute final noise value at P\n\
    vec3 g;\n\
    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n\
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\
    return 130.0 * dot(m, g);\n\
}\n\
\n\
float czm_snoise(vec3 v)\n\
{ \n\
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\
\n\
    // First corner\n\
    vec3 i  = floor(v + dot(v, C.yyy) );\n\
    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\
\n\
    // Other corners\n\
    vec3 g = step(x0.yzx, x0.xyz);\n\
    vec3 l = 1.0 - g;\n\
    vec3 i1 = min( g.xyz, l.zxy );\n\
    vec3 i2 = max( g.xyz, l.zxy );\n\
\n\
    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\
    //   x1 = x0 - i1  + 1.0 * C.xxx;\n\
    //   x2 = x0 - i2  + 2.0 * C.xxx;\n\
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\
    vec3 x1 = x0 - i1 + C.xxx;\n\
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\
\n\
    // Permutations\n\
    i = _czm_mod289(i); \n\
    vec4 p = _czm_permute( _czm_permute( _czm_permute( \n\
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\
\n\
    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n\
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\
    float n_ = 0.142857142857; // 1.0/7.0\n\
    vec3  ns = n_ * D.wyz - D.xzx;\n\
\n\
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\
\n\
    vec4 x_ = floor(j * ns.z);\n\
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\
\n\
    vec4 x = x_ *ns.x + ns.yyyy;\n\
    vec4 y = y_ *ns.x + ns.yyyy;\n\
    vec4 h = 1.0 - abs(x) - abs(y);\n\
\n\
    vec4 b0 = vec4( x.xy, y.xy );\n\
    vec4 b1 = vec4( x.zw, y.zw );\n\
\n\
    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\
    vec4 s0 = floor(b0)*2.0 + 1.0;\n\
    vec4 s1 = floor(b1)*2.0 + 1.0;\n\
    vec4 sh = -step(h, vec4(0.0));\n\
\n\
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\
\n\
    vec3 p0 = vec3(a0.xy,h.x);\n\
    vec3 p1 = vec3(a0.zw,h.y);\n\
    vec3 p2 = vec3(a1.xy,h.z);\n\
    vec3 p3 = vec3(a1.zw,h.w);\n\
\n\
    //Normalise gradients\n\
    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\
    p0 *= norm.x;\n\
    p1 *= norm.y;\n\
    p2 *= norm.z;\n\
    p3 *= norm.w;\n\
\n\
    // Mix final noise value\n\
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\
    m = m * m;\n\
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\
                                dot(p2,x2), dot(p3,x3) ) );\n\
}\n\
\n\
float czm_snoise(vec4 v)\n\
{\n\
    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n\
                          0.276393202250021,  // 2 * G4\n\
                          0.414589803375032,  // 3 * G4\n\
                         -0.447213595499958); // -1 + 4 * G4\n\
\n\
    // (sqrt(5) - 1)/4 = F4, used once below\n\
    #define F4 0.309016994374947451\n\
\n\
    // First corner\n\
    vec4 i  = floor(v + dot(v, vec4(F4)) );\n\
    vec4 x0 = v -   i + dot(i, C.xxxx);\n\
\n\
    // Other corners\n\
\n\
    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\
    vec4 i0;\n\
    vec3 isX = step( x0.yzw, x0.xxx );\n\
    vec3 isYZ = step( x0.zww, x0.yyz );\n\
    //  i0.x = dot( isX, vec3( 1.0 ) );\n\
    i0.x = isX.x + isX.y + isX.z;\n\
    i0.yzw = 1.0 - isX;\n\
    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\
    i0.y += isYZ.x + isYZ.y;\n\
    i0.zw += 1.0 - isYZ.xy;\n\
    i0.z += isYZ.z;\n\
    i0.w += 1.0 - isYZ.z;\n\
\n\
    // i0 now contains the unique values 0,1,2,3 in each channel\n\
    vec4 i3 = clamp( i0, 0.0, 1.0 );\n\
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n\
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\
\n\
    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n\
    //  x1 = x0 - i1  + 1.0 * C.xxxx\n\
    //  x2 = x0 - i2  + 2.0 * C.xxxx\n\
    //  x3 = x0 - i3  + 3.0 * C.xxxx\n\
    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n\
    vec4 x1 = x0 - i1 + C.xxxx;\n\
    vec4 x2 = x0 - i2 + C.yyyy;\n\
    vec4 x3 = x0 - i3 + C.zzzz;\n\
    vec4 x4 = x0 + C.wwww;\n\
\n\
    // Permutations\n\
    i = _czm_mod289(i); \n\
    float j0 = _czm_permute( _czm_permute( _czm_permute( _czm_permute(i.w) + i.z) + i.y) + i.x);\n\
    vec4 j1 = _czm_permute( _czm_permute( _czm_permute( _czm_permute (\n\
               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n\
             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n\
             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n\
             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\
\n\
    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\
    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\
\n\
    vec4 p0 = _czm_grad4(j0,   ip);\n\
    vec4 p1 = _czm_grad4(j1.x, ip);\n\
    vec4 p2 = _czm_grad4(j1.y, ip);\n\
    vec4 p3 = _czm_grad4(j1.z, ip);\n\
    vec4 p4 = _czm_grad4(j1.w, ip);\n\
\n\
    // Normalise gradients\n\
    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\
    p0 *= norm.x;\n\
    p1 *= norm.y;\n\
    p2 *= norm.z;\n\
    p3 *= norm.w;\n\
    p4 *= _czm_taylorInvSqrt(dot(p4,p4));\n\
\n\
    // Mix contributions from the five corners\n\
    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\
    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n\
    m0 = m0 * m0;\n\
    m1 = m1 * m1;\n\
    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n\
                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/*!\n\
 * Cellular noise (\"Worley noise\") in 2D in GLSL.\n\
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n\
 * This code is released under the conditions of the MIT license.\n\
 * See LICENSE file for details.\n\
 */\n\
 \n\
//#ifdef GL_OES_standard_derivatives\n\
//    #extension GL_OES_standard_derivatives : enable\n\
//#endif  \n\
//\n\
//float aastep (float threshold , float value)\n\
//{\n\
//    float afwidth = 0.7 * length ( vec2 ( dFdx ( value ), dFdy ( value )));\n\
//    return smoothstep ( threshold - afwidth , threshold + afwidth , value );\n\
//}\n\
\n\
// Permutation polynomial: (34x^2 + x) mod 289\n\
vec3 _czm_permute289(vec3 x)\n\
{\n\
    return mod((34.0 * x + 1.0) * x, 289.0);\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * Implemented by Stefan Gustavson, and distributed under the MIT License.  {@link http://openglinsights.git.sourceforge.net/git/gitweb.cgi?p=openglinsights/openglinsights;a=tree;f=proceduraltextures}\n\
 *\n\
 * @name czm_cellular\n\
 * @glslFunction\n\
 *\n\
 * @see Stefan Gustavson's chapter, <i>Procedural Textures in GLSL</i>, in <a href=\"http://www.openglinsights.com/\">OpenGL Insights</a>.\n\
 */  \n\
vec2 czm_cellular(vec2 P)\n\
// Cellular noise, returning F1 and F2 in a vec2.\n\
// Standard 3x3 search window for good F1 and F2 values\n\
{\n\
#define K 0.142857142857 // 1/7\n\
#define Ko 0.428571428571 // 3/7\n\
#define jitter 1.0 // Less gives more regular pattern\n\
    vec2 Pi = mod(floor(P), 289.0);\n\
    vec2 Pf = fract(P);\n\
    vec3 oi = vec3(-1.0, 0.0, 1.0);\n\
    vec3 of = vec3(-0.5, 0.5, 1.5);\n\
    vec3 px = _czm_permute289(Pi.x + oi);\n\
    vec3 p = _czm_permute289(px.x + Pi.y + oi); // p11, p12, p13\n\
    vec3 ox = fract(p*K) - Ko;\n\
    vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\
    vec3 dx = Pf.x + 0.5 + jitter*ox;\n\
    vec3 dy = Pf.y - of + jitter*oy;\n\
    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\
    p = _czm_permute289(px.y + Pi.y + oi); // p21, p22, p23\n\
    ox = fract(p*K) - Ko;\n\
    oy = mod(floor(p*K),7.0)*K - Ko;\n\
    dx = Pf.x - 0.5 + jitter*ox;\n\
    dy = Pf.y - of + jitter*oy;\n\
    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\
    p = _czm_permute289(px.z + Pi.y + oi); // p31, p32, p33\n\
    ox = fract(p*K) - Ko;\n\
    oy = mod(floor(p*K),7.0)*K - Ko;\n\
    dx = Pf.x - 1.5 + jitter*ox;\n\
    dy = Pf.y - of + jitter*oy;\n\
    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\
    // Sort out the two smallest distances (F1, F2)\n\
    vec3 d1a = min(d1, d2);\n\
    d2 = max(d1, d2); // Swap to keep candidates for F2\n\
    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\
    d1 = min(d1a, d2); // F1 is now in d1\n\
    d2 = max(d1a, d2); // Swap to keep candidates for F2\n\
    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\
    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\
    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\
    d1.y = min(d1.y, d1.z); // nor in  d1.z\n\
    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\
    return sqrt(d1.xy);\n\
}\n\
\n\
/*\n\
\n\
// Cellular noise, returning F1 and F2 in a vec2 and the\n\
// 2D vectors to each of the two closest points in a vec4.\n\
// Standard 3x3 search window for good F1 and F2 values.\n\
void czm_cellular(in vec2 P, out vec2 F, out vec4 d1d2)\n\
{\n\
#define K 0.142857142857 // 1/7\n\
#define Ko 0.428571428571 // 3/7\n\
#define jitter 1.0 // Less gives more regular pattern\n\
    vec2 Pi = mod(floor(P), 289.0);\n\
    vec2 Pf = fract(P);\n\
    vec3 oi = vec3(-1.0, 0.0, 1.0);\n\
    vec3 of = vec3(-0.5, 0.5, 1.5);\n\
    vec3 px = _czm_permute289(Pi.x + oi);\n\
    vec3 p = _czm_permute289(px.x + Pi.y + oi); // p11, p12, p13\n\
    vec3 ox = fract(p*K) - Ko;\n\
    vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\
    vec3 d1x = Pf.x + 0.5 + jitter*ox;\n\
    vec3 d1y = Pf.y - of + jitter*oy;\n\
    vec3 d1 = d1x * d1x + d1y * d1y; // d11, d12 and d13, squared\n\
    p = _czm_permute289(px.y + Pi.y + oi); // p21, p22, p23\n\
    ox = fract(p*K) - Ko;\n\
    oy = mod(floor(p*K),7.0)*K - Ko;\n\
    vec3 d2x = Pf.x - 0.5 + jitter*ox;\n\
    vec3 d2y = Pf.y - of + jitter*oy;\n\
    vec3 d2 = d2x * d2x + d2y * d2y; // d21, d22 and d23, squared\n\
    p = _czm_permute289(px.z + Pi.y + oi); // p31, p32, p33\n\
    ox = fract(p*K) - Ko;\n\
    oy = mod(floor(p*K),7.0)*K - Ko;\n\
    vec3 d3x = Pf.x - 1.5 + jitter*ox;\n\
    vec3 d3y = Pf.y - of + jitter*oy;\n\
    vec3 d3 = d3x * d3x + d3y * d3y; // d31, d32 and d33, squared\n\
    // Sort out the two smallest distances (F1, F2)\n\
    // While also swapping dx and dy accordingly\n\
    vec3 comp3 = step(d2, d1);\n\
    vec3 d1a = mix(d1, d2, comp3);\n\
    vec3 d1xa = mix(d1x, d2x, comp3);\n\
    vec3 d1ya = mix(d1y, d2y, comp3);\n\
    d2 = mix(d2, d1, comp3); // Swap to keep candidates for F2\n\
    d2x = mix(d2x, d1x, comp3);\n\
    d2y = mix(d2y, d1y, comp3);\n\
  \n\
    comp3 = step(d3, d2);\n\
    d2 = mix(d2, d3, comp3); // neither F1 nor F2 are now in d3\n\
    d2x = mix(d2x, d3x, comp3);\n\
    d2y = mix(d2y, d3y, comp3);\n\
  \n\
    comp3 = step(d2, d1a);\n\
    d1 = mix(d1a, d2, comp3); // F1 is now in d1\n\
    d1x = mix(d1xa, d2x, comp3);\n\
    d1y = mix(d1ya, d2y, comp3);\n\
    d2 = mix(d2, d1a, comp3); // Swap to keep candidates for F2\n\
    d2x = mix(d2x, d1xa, comp3);\n\
    d2y = mix(d2y, d1ya, comp3);\n\
  \n\
    float comp1 = step(d1.y, d1.x);\n\
    d1.xy = mix(d1.xy, d1.yx, comp1); // Swap if smaller\n\
    d1x.xy = mix(d1x.xy, d1x.yx, comp1);\n\
    d1y.xy = mix(d1y.xy, d1y.yx, comp1);\n\
  \n\
    comp1 = step(d1.z, d1.x);\n\
    d1.xz = mix(d1.xz, d1.zx, comp1); // F1 is in d1.x\n\
    d1x.xz = mix(d1x.xz, d1x.zx, comp1);\n\
    d1y.xz = mix(d1y.xz, d1y.zx, comp1);\n\
 \n\
    vec2 comp2 = step(d2.yz, d1.yz);\n\
    d1.yz = mix(d1.yz, d2.yz, comp2); // F2 is now not in d2.yz\n\
    d1x.yz = mix(d1x.yz, d2x.yz, comp2);\n\
    d1y.yz = mix(d1y.yz, d2y.yz, comp2);\n\
  \n\
    comp1 = step(d1.z, d1.y);\n\
    d1.y = mix(d1.y, d1.z, comp1); // nor in  d1.z\n\
    d1x.y = mix(d1x.y, d1x.z, comp1);\n\
    d1y.y = mix(d1y.y, d1y.z, comp1);\n\
 \n\
    comp1 = step(d2.x, d1.y);\n\
    d1.y = mix(d1.y, d2.x, comp1); // F2 is in d1.y, we're done.\n\
    d1x.y = mix(d1x.y, d2x.x, comp1);\n\
    d1y.y = mix(d1y.y, d2y.x, comp1);\n\
    F = sqrt(d1.xy);\n\
    d1d2 = vec4(d1x.x, d1y.x, d1x.y, d1y.y);\n\
}\n\
\n\
*/\n\
\n\
#endif\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolygonFS',[],function() {
    
    return "uniform float u_erosion;\n\
uniform float u_morphTime;\n\
\n\
varying vec3 v_positionMC;\n\
varying vec3 v_positionEC;\n\
varying vec2 v_textureCoordinates;\n\
\n\
#ifndef RENDER_FOR_PICK\n\
\n\
void erode(vec3 str)\n\
{\n\
    if (u_erosion != 1.0)\n\
    {\n\
        float t = 0.5 + (0.5 * czm_snoise(str / (1.0 / 10.0)));   // Scale [-1, 1] to [0, 1]\n\
    \n\
        if (t > u_erosion)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
}\n\
\n\
#endif\n\
\n\
void main()\n\
{\n\
    czm_materialInput materialInput;\n\
    \n\
    // TODO: Real 1D distance, and better 3D coordinate\n\
    materialInput.st = v_textureCoordinates;\n\
    materialInput.str = vec3(v_textureCoordinates, 0.0);\n\
    materialInput.positionMC = v_positionMC;\n\
    \n\
    //Convert tangent space material normal to eye space\n\
    materialInput.normalEC = mix(czm_normal[0], normalize(czm_normal * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0))), u_morphTime); // +x is up in Columbus view   \n\
    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\
    \n\
    //Convert view vector to world space\n\
    vec3 positionToEyeEC = -v_positionEC; \n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
\n\
    erode(materialInput.str);\n\
    czm_material material = czm_getMaterial(materialInput);\n\
    \n\
    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolygonFSPick',[],function() {
    
    return "uniform vec4 u_pickColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = u_pickColor;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolygonVS',[],function() {
    
    return "attribute vec2 position2D;\n\
attribute vec3 position3D;\n\
attribute vec2 textureCoordinates;\n\
\n\
uniform float u_morphTime;\n\
uniform float u_height;     // in meters\n\
\n\
varying vec3 v_positionMC;\n\
varying vec3 v_positionEC;\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main() \n\
{\n\
    vec4 p = czm_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n\
\n\
    v_positionMC = position3D;                      // position in model coordinates\n\
    v_positionEC = (czm_modelView * p).xyz;         // position in eye coordinates\n\
    v_textureCoordinates = textureCoordinates;\n\
    gl_Position = czm_modelViewProjection * p;      // position in clip coordinates\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolygonVSPick',[],function() {
    
    return "attribute vec2 position2D;\n\
attribute vec3 position3D;\n\
\n\
uniform float u_morphTime;\n\
uniform float u_height;     // in meters\n\
\n\
void main() \n\
{\n\
    vec4 p = czm_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n\
\n\
    gl_Position = czm_modelViewProjection * p;                      // position in clip coordinates\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolylineFS',[],function() {
    
    return "varying vec4 v_color;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = v_color; \n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/PolylineVS',[],function() {
    
    return "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 position2DHigh;\n\
attribute vec3 position2DLow;\n\
attribute vec4 color;\n\
attribute float show;\n\
\n\
varying vec4 v_color;\n\
\n\
uniform float u_morphTime;\n\
\n\
void main() \n\
{\n\
    vec4 p;\n\
\n\
    if (u_morphTime == 1.0)\n\
    {\n\
        p = vec4(czm_translateRelativeToEye(position3DHigh, position3DLow), 1.0);\n\
    }\n\
    else if (u_morphTime == 0.0)\n\
    {\n\
        p = vec4(czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy), 1.0);\n\
    }\n\
    else\n\
    {\n\
        p = czm_columbusViewMorph(\n\
        	czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\n\
            czm_translateRelativeToEye(position3DHigh, position3DLow), \n\
            u_morphTime);\n\
    }\n\
\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p * show;  // position in clip coordinates\n\
    v_color = color;\n\
}\n\
";
});
/*global define*/
define('Scene/PolylineCollection',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/EncodedCartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Core/Color',
        '../Core/BoundingSphere',
        '../Core/Intersect',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CommandLists',
        '../Renderer/DrawCommand',
        './SceneMode',
        './Polyline',
        '../Shaders/PolylineVS',
        '../Shaders/PolylineFS',
        '../Renderer/StencilFunction',
        '../Renderer/StencilOperation'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        Cartesian3,
        Cartesian4,
        EncodedCartesian3,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        Color,
        BoundingSphere,
        Intersect,
        BlendingState,
        BufferUsage,
        CommandLists,
        DrawCommand,
        SceneMode,
        Polyline,
        PolylineVS,
        PolylineFS,
        StencilFunction,
        StencilOperation) {
    

    var SHOW_INDEX = Polyline.SHOW_INDEX;
    var POSITION_INDEX = Polyline.POSITION_INDEX;
    var COLOR_INDEX = Polyline.COLOR_INDEX;
    var OUTLINE_COLOR_INDEX = Polyline.OUTLINE_COLOR_INDEX;
    var WIDTH_INDEX = Polyline.WIDTH_INDEX;
    var OUTLINE_WIDTH_INDEX = Polyline.OUTLINE_WIDTH_INDEX;
    //POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.
    //When it does, we need to recreate the indicesBuffer.
    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;
    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;
    var SIXTYFOURK = 64 * 1024;

    var attributeIndices = {
        position3DHigh : 0,
        position3DLow : 1,
        position2DHigh : 2,
        position2DLow : 3,
        color : 4,
        pickColor : 5,
        show : 6
    };

    /**
     * A renderable collection of polylines.
     * <br /><br />
     * <div align="center">
     * <img src="images/Polyline.png" width="400" height="300" /><br />
     * Example polylines
     * </div>
     * <br /><br />
     * Polylines are added and removed from the collection using {@link PolylineCollection#add}
     * and {@link PolylineCollection#remove}.
     *
     * @alias PolylineCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many polylines, to
     * many collections with only a few polylines each.  Organize collections so that polylines
     * with the same update frequency are in the same collection, i.e., polylines that do not
     * change should be in one collection; polylines that change every frame should be in another
     * collection; and so on.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#remove
     * @see Polyline
     * @see LabelCollection
     *
     * @example
     * // Create a polyline collection with two polylines
     * var polylines = new PolylineCollection(undefined);
     * polylines.add({positions:ellipsoid.cartographicDegreesToCartesians([
     *     new Cartographic2(-75.10, 39.57),
     *     new Cartographic2(-77.02, 38.53),
     *     new Cartographic2(-80.50, 35.14),
     *     new Cartographic2(-80.12, 25.46)]),
           width:2
           });

     * polylines.add({positions:ellipsoid.cartographicDegreesToCartesians([
     *     new Cartographic2(-73.10, 37.57),
     *     new Cartographic2(-75.02, 36.53),
     *     new Cartographic2(-78.50, 33.14),
     *     new Cartographic2(-78.12, 23.46)]),
     *     width:4
     * });
     */
    var PolylineCollection = function() {
        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;

        /**
         * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.
         * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link czm_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see czm_model
         */
        this.modelMatrix = Matrix4.IDENTITY.clone();
        this._modelMatrix = Matrix4.IDENTITY.clone();
        this._sp = undefined;

        this._boundingVolume = undefined;
        this._boundingVolume2D = undefined;

        this._commandLists = new CommandLists();

        this._polylinesUpdated = false;
        this._polylinesRemoved = false;
        this._createVertexArray = false;
        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
        this._polylines = [];
        this._polylineBuckets = {};

        // The buffer usage for each attribute is determined based on the usage of the attribute over time.
        this._buffersUsage = [
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0},// SHOW_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // POSITION_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // COLOR_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // OUTLINE_COLOR_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // WIDTH_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0} // OUTLINE_WIDTH_INDEX
        ];

        this._mode = undefined;
        var that = this;

        this._uniforms = {
            u_morphTime : function() {
                return that.morphTime;
            }
        };

        this._polylinesToUpdate = [];
        this._colorVertexArrays = [];
        this._outlineColorVertexArrays = [];
        this._pickColorVertexArrays = [];
        this._positionBuffer = undefined;
        this._outlineColorBuffer = undefined;
        this._colorBuffer = undefined;
        this._pickColorBuffer = undefined;
        this._showBuffer = undefined;
    };

    /**
     * Creates and adds a polyline with the specified initial properties to the collection.
     * The added polyline is returned so it can be modified or removed from the collection later.
     *
     * @memberof PolylineCollection
     *
     * @param {Object}[polyline=undefined] A template describing the polyline's properties as shown in Example 1.
     *
     * @return {Polyline} The polyline that was added to the collection.
     *
     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and
     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
     * For best performance, add as many polylines as possible before calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#remove
     * @see PolylineCollection#removeAll
     * @see PolylineCollection#update
     *
     * @example
     * // Example 1:  Add a polyline, specifying all the default values.
     * var p = polylines.add({
     *   show : true,
     *   positions : ellipsoid.cartographicDegreesToCartesians([
     *     new Cartographic2(-75.10, 39.57),
     *     new Cartographic2(-77.02, 38.53)]),
     *     color : { red : 1.0, green : 1.0, blue : 1.0, alpha : 1.0 },
     *     width : 1,
     *     outlineWidth : 2
     * });
     *
     */
    PolylineCollection.prototype.add = function(polyline) {
        var p = new Polyline(polyline, this);
        p._index = this._polylines.length;
        this._polylines.push(p);
        this._createVertexArray = true;
        return p;
    };

    /**
     * Removes a polyline from the collection.
     *
     * @memberof PolylineCollection
     *
     * @param {Polyline} polyline The polyline to remove.
     *
     * @return {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.
     *
     * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and
     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
     * For best performance, remove as many polylines as possible before calling <code>update</code>.
     * If you intend to temporarily hide a polyline, it is usually more efficient to call
     * {@link Polyline#setShow} instead of removing and re-adding the polyline.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#removeAll
     * @see PolylineCollection#update
     * @see Polyline#setShow
     *
     * @example
     * var p = polylines.add(...);
     * polylines.remove(p);  // Returns true
     */
    PolylineCollection.prototype.remove = function(polyline) {
        if (this.contains(polyline)) {
            this._polylines[polyline._index] = null; // Removed later
            this._polylinesRemoved = true;
            this._createVertexArray = true;
            polyline._destroy();
            return true;
        }

        return false;
    };

    /**
     * Removes all polylines from the collection.
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @memberof PolylineCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#remove
     * @see PolylineCollection#update
     *
     * @example
     * polylines.add(...);
     * polylines.add(...);
     * polylines.removeAll();
     */
    PolylineCollection.prototype.removeAll = function() {
        this._destroyPolylines();
        this._polylineBuckets = {};
        this._polylinesRemoved = false;
        this._polylines.length = 0;
        this._polylinesToUpdate.length = 0;
        this._createVertexArray = true;
    };

    /**
     * Determines if this collection contains the specified polyline.
     *
     * @memberof PolylineCollection
     *
     * @param {Polyline} polyline The polyline to check for.
     *
     * @return {Boolean} true if this collection contains the billboard, false otherwise.
     *
     * @see PolylineCollection#get
     */
    PolylineCollection.prototype.contains = function(polyline) {
        return typeof polyline !== 'undefined' && polyline._polylineCollection === this;
    };

    /**
     * Returns the polyline in the collection at the specified index.  Indices are zero-based
     * and increase as polylines are added.  Removing a polyline shifts all polylines after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link PolylineCollection#getLength} to iterate over all the polylines
     * in the collection.
     *
     * @memberof PolylineCollection
     *
     * @param {Number} index The zero-based index of the polyline.
     *
     * @return {Polyline} The polyline at the specified index.
     *
     * @performance If polylines were removed from the collection and
     * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#getLength
     *
     * @example
     * // Toggle the show property of every polyline in the collection
     * var len = polylines.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = polylines.get(i);
     *   p.setShow(!p.getShow());
     * }
     */
    PolylineCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        this._removePolylines();
        return this._polylines[index];
    };

    /**
     * Returns the number of polylines in this collection.  This is commonly used with
     * {@link PolylineCollection#get} to iterate over all the polylines
     * in the collection.
     *
     * @memberof PolylineCollection
     *
     * @return {Number} The number of polylines in this collection.
     *
     * @performance If polylines were removed from the collection and
     * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#get
     *
     * @example
     * // Toggle the show property of every polyline in the collection
     * var len = polylines.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = polylines.get(i);
     *   p.setShow(!p.getShow());
     * }
     */
    PolylineCollection.prototype.getLength = function() {
        this._removePolylines();
        return this._polylines.length;
    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     *
     * @memberof PolylineCollection
     */
    PolylineCollection.prototype.update = function(context, frameState, commandList) {
        if (typeof this._sp === 'undefined') {
            this._sp = context.getShaderCache().getShaderProgram(PolylineVS, PolylineFS, attributeIndices);
        }
        this._removePolylines();
        this._updateMode(frameState);

        var bucket;
        var polyline;
        var length;
        var buckets;
        var polylineBuckets;
        var bucketLength;
        var bucketLocator;

        var properties = this._propertiesChanged;
        if (this._createVertexArray || this._computeNewBuffersUsage()) {
            this._createVertexArrays(context);
        } else if (this._polylinesUpdated) {
            // Polylines were modified, but no polylines were added or removed.
            var polylinesToUpdate = this._polylinesToUpdate;
            var createVertexArrays = false;
            if (this._mode !== SceneMode.SCENE3D) {
                var updateLength = polylinesToUpdate.length;
                for ( var i = 0; i < updateLength; ++i) {
                    polyline = polylinesToUpdate[i];
                    var changedProperties = polyline._propertiesChanged;
                    if (changedProperties[POSITION_INDEX]) {
                        if(intersectsIDL(polyline)){
                            var newSegments = polyline._createSegments(this._projection._ellipsoid);
                            if(polyline._segmentsLengthChanged(newSegments)){
                                createVertexArrays = true;
                                break;
                            }
                            polyline._setSegments(newSegments);
                        }
                    }
                }
            }
            //if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.
            if (properties[POSITION_SIZE_INDEX] || properties[WIDTH_INDEX] || properties[OUTLINE_WIDTH_INDEX] || createVertexArrays) {
                this._createVertexArrays(context);
            } else {
                length = polylinesToUpdate.length;
                polylineBuckets = this._polylineBuckets;
                for ( var ii = 0; ii < length; ++ii) {
                    polyline = polylinesToUpdate[ii];
                    properties = polyline._propertiesChanged;
                    bucket = polyline._bucket;
                    var index = 0;
                    for ( var x in polylineBuckets) {
                        if (polylineBuckets.hasOwnProperty(x)) {
                            if (polylineBuckets[x] === bucket) {
                                if (properties[POSITION_INDEX]) {
                                    bucket.writePositionsUpdate(index, polyline, this._positionBuffer);
                                }
                                if (properties[COLOR_INDEX]) {
                                    bucket.writeColorUpdate(index, polyline, this._colorBuffer);
                                }
                                if (properties[OUTLINE_COLOR_INDEX]) {
                                    bucket.writeColorUpdate(index, polyline, this._outlineColorBuffer);
                                }
                                if (properties[SHOW_INDEX]) {
                                    bucket.writeShowUpdate(index, polyline, this._showBuffer);
                                }
                                break;
                            }
                            index += polylineBuckets[x].lengthOfPositions;
                        }
                    }
                    polyline._clean();
                }
            }
            polylinesToUpdate.length = 0;
            this._polylinesUpdated = false;
        }
        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }

        var boundingVolume;
        var modelMatrix = Matrix4.IDENTITY;

        if (frameState.mode === SceneMode.SCENE3D) {
            boundingVolume = this._boundingVolume;
            modelMatrix = this.modelMatrix;
        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW || frameState.mode === SceneMode.SCENE2D) {
            boundingVolume = this._boundingVolume2D;
        } else {
            boundingVolume = this._boundingVolume && this._boundingVolume2D && this._boundingVolume.union(this._boundingVolume2D);
        }

        var pass = frameState.passes;
        var commands;
        var command;
        polylineBuckets = this._polylineBuckets;
        var sp = this._sp;
        this._commandLists.removeAll();
        if (typeof polylineBuckets !== 'undefined') {
            if (pass.color) {
                length = this._colorVertexArrays.length;
                commands = this._commandLists.colorList;
                for (var m = 0; m < length; ++m) {
                    var vaColor = this._colorVertexArrays[m];
                    var vaOutlineColor = this._outlineColorVertexArrays[m];
                    buckets = this._colorVertexArrays[m].buckets;
                    bucketLength = buckets.length;
                    var p = commands.length;
                    commands.length += bucketLength * 3;
                    for ( var n = 0; n < bucketLength; ++n, p += 3) {
                        bucketLocator = buckets[n];

                        command = commands[p];
                        if (typeof command === 'undefined') {
                            command = commands[p] = new DrawCommand();
                        }

                        command.boundingVolume = boundingVolume;
                        command.modelMatrix = modelMatrix;
                        command.primitiveType = PrimitiveType.LINES;
                        command.count = bucketLocator.count;
                        command.offset = bucketLocator.offset;
                        command.shaderProgram = sp;
                        command.uniformMap = this._uniforms;
                        command.vertexArray = vaOutlineColor.va;
                        command.renderState = bucketLocator.rsOne;

                        command = commands[p + 1];
                        if (typeof command === 'undefined') {
                            command = commands[p + 1] = new DrawCommand();
                        }

                        command.boundingVolume = boundingVolume;
                        command.modelMatrix = modelMatrix;
                        command.primitiveType = PrimitiveType.LINES;
                        command.count = bucketLocator.count;
                        command.offset = bucketLocator.offset;
                        command.shaderProgram = sp;
                        command.uniformMap = this._uniforms;
                        command.vertexArray = vaColor.va;
                        command.renderState = bucketLocator.rsTwo;

                        command = commands[p + 2];
                        if (typeof command === 'undefined') {
                            command = commands[p + 2] = new DrawCommand();
                        }

                        command.boundingVolume = boundingVolume;
                        command.modelMatrix = modelMatrix;
                        command.primitiveType = PrimitiveType.LINES;
                        command.count = bucketLocator.count;
                        command.offset = bucketLocator.offset;
                        command.shaderProgram = sp;
                        command.uniformMap = this._uniforms;
                        command.vertexArray = vaOutlineColor.va;
                        command.renderState = bucketLocator.rsThree;
                    }
                }
            }
            if (pass.pick) {
                length = this._pickColorVertexArrays.length;
                commands = this._commandLists.pickList;
                for ( var a = 0; a < length; ++a) {
                    var vaPickColor = this._pickColorVertexArrays[a];
                    buckets = vaPickColor.buckets;
                    bucketLength = buckets.length;
                    commands.length += bucketLength;
                    for ( var b = 0; b < bucketLength; ++b) {
                        bucketLocator = buckets[b];

                        command = commands[b];
                        if (typeof command === 'undefined') {
                            command = commands[b] = new DrawCommand();
                        }

                        command.boundingVolume = boundingVolume;
                        command.modelMatrix = modelMatrix;
                        command.primitiveType = PrimitiveType.LINES;
                        command.count = bucketLocator.count;
                        command.offset = bucketLocator.offset;
                        command.shaderProgram = sp;
                        command.uniformMap = this._uniforms;
                        command.vertexArray = vaPickColor.va;
                        command.renderState = bucketLocator.rsPick;
                    }
                }
            }
        }

        if (!this._commandLists.empty()) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PolylineCollection
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see PolylineCollection#destroy
     */
    PolylineCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof PolylineCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#isDestroyed
     *
     * @example
     * polylines = polylines && polylines.destroy();
     */
    PolylineCollection.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._destroyVertexArrays();
        this._destroyPolylines();
        return destroyObject(this);
    };

    PolylineCollection.prototype._computeNewBuffersUsage = function() {
        var buffersUsage = this._buffersUsage;
        var usageChanged = false;

        var properties = this._propertiesChanged;
        //subtract 1 from NUMBER_OF_PROPERTIES because we don't care about POSITION_SIZE_INDEX property change.
        for ( var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {
            var bufferUsage = buffersUsage[k];
            if(properties[k]){
                if(bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW){
                    usageChanged = true;
                    bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;
                    bufferUsage.frameCount = 100;
                }
                else{
                    bufferUsage.frameCount = 100;
                }
            } else {
                if(bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW){
                    if(bufferUsage.frameCount === 0){
                        usageChanged = true;
                        bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;
                    }
                    else{
                        bufferUsage.frameCount--;
                    }
                }
            }
        }
        return usageChanged;
    };

    PolylineCollection.prototype._createVertexArrays = function(context) {
        this._createVertexArray = false;
        this._destroyVertexArrays();
        this._sortPolylinesIntoBuckets();
        //stores all of the individual indices arrays.
        var totalIndices = [];
        var indices = [];

        //used to determine the vertexBuffer offset if the indicesArray goes over 64k.
        //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes
        //so that the polyline looks contiguous.
        //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype
        var vertexBufferOffset = [0];
        totalIndices.push(indices);
        var offset = 0;
        var useDepthTest = (this.morphTime !== 0.0);
        var vertexArrayBuckets = [[]];
        var totalLength = 0;
        var polylineBuckets = this._polylineBuckets;
        var x;
        var bucket;
        for (x in polylineBuckets) {
            if (polylineBuckets.hasOwnProperty(x)) {
                bucket = polylineBuckets[x];
                bucket.updateRenderState(context, useDepthTest);
                totalLength += bucket.lengthOfPositions;
            }
        }
        if (totalLength > 0) {
            var positionArray = new Float32Array(2 * totalLength * 3);
            var outlineColorArray = new Uint8Array(totalLength * 4);
            var colorArray = new Uint8Array(totalLength * 4);
            var pickColorArray = new Uint8Array(totalLength * 4);
            var showArray = new Uint8Array(totalLength);
            var position3DArray;

            var positionIndex = 0;
            var colorIndex = 0;
            var showIndex = 0;
            for (x in polylineBuckets) {
                if (polylineBuckets.hasOwnProperty(x)) {
                    bucket = polylineBuckets[x];
                    bucket.write(positionArray, colorArray, outlineColorArray, pickColorArray, showArray, positionIndex, showIndex, colorIndex, context);
                    if (this._mode === SceneMode.MORPHING) {
                        if (typeof position3DArray === 'undefined') {
                            position3DArray = new Float32Array(2 * totalLength * 3);
                        }
                        bucket.writeForMorph(position3DArray, positionIndex);
                    }
                    var bucketLength = bucket.lengthOfPositions;
                    positionIndex += 2 * bucketLength * 3;
                    showIndex += bucketLength;
                    colorIndex += bucketLength * 4;
                    offset = bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
                }
            }
            this._positionBuffer = context.createVertexBuffer(positionArray, this._buffersUsage[POSITION_INDEX].bufferUsage);
            var position3DBuffer;
            if (typeof position3DArray !== 'undefined') {
                position3DBuffer = context.createVertexBuffer(position3DArray, this._buffersUsage[POSITION_INDEX].bufferUsage);
            }
            this._outlineColorBuffer = context.createVertexBuffer(outlineColorArray, this._buffersUsage[OUTLINE_COLOR_INDEX].bufferUsage);
            this._colorBuffer = context.createVertexBuffer(colorArray, this._buffersUsage[COLOR_INDEX].bufferUsage);
            this._pickColorBuffer = context.createVertexBuffer(pickColorArray, BufferUsage.STATIC_DRAW);
            this._showBuffer = context.createVertexBuffer(showArray, this._buffersUsage[SHOW_INDEX].bufferUsage);
            var colorSizeInBytes = 4 * Uint8Array.BYTES_PER_ELEMENT;
            var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;
            var vbo = 0;
            var numberOfIndicesArrays = totalIndices.length;
            for ( var k = 0; k < numberOfIndicesArrays; ++k) {
                indices = totalIndices[k];
                if (indices.length > 0) {
                    var indicesArray = new Uint16Array(indices);
                    var indexBuffer = context.createIndexBuffer(indicesArray, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
                    indexBuffer.setVertexArrayDestroyable(false);
                    vbo += vertexBufferOffset[k];
                    var positionHighOffset = 2 * (k * (positionSizeInBytes * SIXTYFOURK) - vbo * positionSizeInBytes);//componentsPerAttribute(3) * componentDatatype(4)
                    var positionLowOffset = positionSizeInBytes + positionHighOffset;
                    var vertexColorBufferOffset = k * (colorSizeInBytes * SIXTYFOURK) - vbo * colorSizeInBytes;
                    var vertexShowBufferOffset = k * SIXTYFOURK - vbo;
                    var attributes = [{
                        index : attributeIndices.position3DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position3DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._colorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    var attributesOutlineColor = [{
                        index : attributeIndices.position3DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position3DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._outlineColorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    var attributesPickColor = [{
                        index : attributeIndices.position3DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position3DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DHigh,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionHighOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.position2DLow,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : positionLowOffset,
                        strideInBytes : 2 * positionSizeInBytes
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._pickColorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    if (this._mode === SceneMode.SCENE3D) {
                        attributes[0].vertexBuffer = this._positionBuffer;
                        attributes[1].vertexBuffer = this._positionBuffer;
                        attributes[2].value = [0.0, 0.0, 0.0];
                        attributes[3].value = [0.0, 0.0, 0.0];
                        attributesOutlineColor[0].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[1].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[2].value = [0.0, 0.0, 0.0];
                        attributesOutlineColor[3].value = [0.0, 0.0, 0.0];
                        attributesPickColor[0].vertexBuffer = this._positionBuffer;
                        attributesPickColor[1].vertexBuffer = this._positionBuffer;
                        attributesPickColor[2].value = [0.0, 0.0, 0.0];
                        attributesPickColor[3].value = [0.0, 0.0, 0.0];
                    } else if (this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW) {
                        attributes[0].value = [0.0, 0.0, 0.0];
                        attributes[1].value = [0.0, 0.0, 0.0];
                        attributes[2].vertexBuffer = this._positionBuffer;
                        attributes[3].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[0].value = [0.0, 0.0, 0.0];
                        attributesOutlineColor[1].value = [0.0, 0.0, 0.0];
                        attributesOutlineColor[2].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[3].vertexBuffer = this._positionBuffer;
                        attributesPickColor[0].value = [0.0, 0.0, 0.0];
                        attributesPickColor[1].value = [0.0, 0.0, 0.0];
                        attributesPickColor[2].vertexBuffer = this._positionBuffer;
                        attributesPickColor[3].vertexBuffer = this._positionBuffer;
                    } else {
                        attributes[0].vertexBuffer = position3DBuffer;
                        attributes[1].vertexBuffer = position3DBuffer;
                        attributes[2].vertexBuffer = this._positionBuffer;
                        attributes[3].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[0].vertexBuffer = position3DBuffer;
                        attributesOutlineColor[1].vertexBuffer = position3DBuffer;
                        attributesOutlineColor[2].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[3].vertexBuffer = this._positionBuffer;
                        attributesPickColor[0].vertexBuffer = position3DBuffer;
                        attributesPickColor[1].vertexBuffer = position3DBuffer;
                        attributesPickColor[2].vertexBuffer = this._positionBuffer;
                        attributesPickColor[3].vertexBuffer = this._positionBuffer;
                    }
                    var va = context.createVertexArray(attributes, indexBuffer);
                    var vaOutlineColor = context.createVertexArray(attributesOutlineColor, indexBuffer);
                    var vaPickColor = context.createVertexArray(attributesPickColor, indexBuffer);

                    this._colorVertexArrays.push({
                        va : va,
                        buckets : vertexArrayBuckets[k]
                    });
                    this._outlineColorVertexArrays.push({
                        va : vaOutlineColor,
                        buckets : vertexArrayBuckets[k]
                    });
                    this._pickColorVertexArrays.push({
                        va : vaPickColor,
                        buckets : vertexArrayBuckets[k]
                    });
                }
            }
        }
    };

    PolylineCollection.prototype._sortPolylinesIntoBuckets = function() {
        var polylineBuckets = this._polylineBuckets = {};
        var polylines = this._polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var p = polylines[i];
            var outlineWidth = p.getOutlineWidth();
            var width = p.getWidth();
            var hash = 'OL' + outlineWidth + 'W' + width;
            var value = polylineBuckets[hash];
            if (typeof value === 'undefined') {
                value = polylineBuckets[hash] = new PolylineBucket(outlineWidth, width, this._mode, this._projection, this._modelMatrix);
            }
            value.addPolyline(p);
        }
    };

    PolylineCollection.prototype._updateMode = function(frameState) {
        var mode = frameState.mode;
        var projection = frameState.scene2D.projection;
        if (this._mode !== mode && typeof mode.morphTime !== 'undefined') {
            this.morphTime = mode.morphTime;
        }
        if (this._mode !== mode || (this._projection !== projection) || (!this._modelMatrix.equals(this.modelMatrix))) {
            this._mode = mode;
            this._projection = projection;
            this._modelMatrix = this.modelMatrix.clone();
            this._createVertexArray = true;
        }
    };

    PolylineCollection.prototype._removePolylines = function() {
        if (this._polylinesRemoved) {
            this._polylinesRemoved = false;

            var polylines = [];

            var length = this._polylines.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var polyline = this._polylines[i];
                if (polyline) {
                    polyline._index = j++;
                    polylines.push(polyline);
                }
            }

            this._polylines = polylines;
        }
    };

    PolylineCollection.prototype._destroyVertexArrays = function() {
        var length = this._colorVertexArrays.length;
        for ( var t = 0; t < length; ++t) {
            this._colorVertexArrays[t].va.destroy();
            this._pickColorVertexArrays[t].va.destroy();
            this._outlineColorVertexArrays[t].va.destroy();
        }
        this._colorVertexArrays.length = 0;
        this._pickColorVertexArrays.length = 0;
        this._outlineColorVertexArrays.length = 0;
    };

    PolylineCollection.prototype._updatePolyline = function(polyline, propertyChanged) {
        this._polylinesUpdated = true;
        this._polylinesToUpdate.push(polyline);
        ++this._propertiesChanged[propertyChanged];
    };

    PolylineCollection.prototype._destroyPolylines = function() {
        var polylines = this._polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            if (polylines[i]) {
                polylines[i]._destroy();
            }
        }
    };

    /**
     * @private
     */
    function VertexArrayBucketLocator(count, offset, bucket) {
        this.count = count;
        this.offset = offset;
        this.rsOne = bucket.rsOne;
        this.rsTwo = bucket.rsTwo;
        this.rsThree = bucket.rsThree;
        this.rsPick = bucket.rsPick;
    }

    /**
     * @private
     */
    var PolylineBucket = function(outlineWidth, width, mode, projection, modelMatrix) {
        this.width = width;
        this.outlineWidth = outlineWidth;
        this.polylines = [];
        this.lengthOfPositions = 0;
        this.rsOne = undefined;
        this.rsTwo = undefined;
        this.rsThree = undefined;
        this.rsPick = undefined;
        this.mode = mode;
        this.projection = projection;
        this.ellipsoid = projection.getEllipsoid();
        this.modelMatrix = modelMatrix;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.addPolyline = function(p) {
        var polylines = this.polylines;
        polylines.push(p);
        p._actualLength = this.getPolylinePositionsLength(p);
        this.lengthOfPositions += p._actualLength;
        p._bucket = this;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.updateRenderState = function(context, useDepthTest) {
        var width = this._clampWidth(context, this.width);
        var outlineWidth = this._clampWidth(context, this.outlineWidth);
        var rsOne = this.rsOne || context.createRenderState({
            colorMask : {
                red : false,
                green : false,
                blue : false,
                alpha : false
            },
            lineWidth : 1,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.ALWAYS,
                backFunction : StencilFunction.ALWAYS,
                reference : 0,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.REPLACE,
                    zFail : StencilOperation.REPLACE,
                    zPass : StencilOperation.REPLACE
                },
                backOperation : {
                    fail : StencilOperation.REPLACE,
                    zFail : StencilOperation.REPLACE,
                    zPass : StencilOperation.REPLACE
                }
            }
        });
        rsOne.depthMask = !useDepthTest;
        rsOne.depthTest.enabled = useDepthTest;
        rsOne.lineWidth = outlineWidth;
        this.rsOne = rsOne;
        var rsTwo = this.rsTwo || context.createRenderState({
            lineWidth : 1,
            depthMask : false,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.ALWAYS,
                backFunction : StencilFunction.ALWAYS,
                reference : 1,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.REPLACE
                },
                backOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.REPLACE
                }
            }
        });
        rsTwo.depthTest.enabled = useDepthTest;
        rsTwo.lineWidth = width;
        this.rsTwo = rsTwo;
        var rsThree = this.rsThree || context.createRenderState({
            lineWidth : 1,
            depthMask : false,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.NOT_EQUAL,
                backFunction : StencilFunction.NOT_EQUAL,
                reference : 1,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.KEEP
                },
                backOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.KEEP
                }
            }
        });
        rsThree.lineWidth = this.outlineWidth;
        rsThree.depthTest.enabled = useDepthTest;
        this.rsThree = rsThree;

        var rsPick = this.rsPick || context.createRenderState();
        rsPick.depthTest.enabled = useDepthTest;
        rsPick.lineWidth = outlineWidth;
        rsPick.depthMask = !useDepthTest;
        this.rsPick = rsPick;
    };

    function intersectsIDL(polyline) {
        return Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 ||
            polyline._boundingVolume.intersect(Cartesian4.UNIT_Y) === Intersect.INTERSECTING;
    }

    /**
     * @private
     */
    PolylineBucket.prototype.getPolylinePositionsLength = function(polyline) {
        if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {
            return polyline.getPositions().length;
        }
        var segments = polyline._createSegments(this.ellipsoid);
        return polyline._setSegments(segments);
    };

    var scratchWritePosition = new Cartesian3();

    /**
     * @private
     */
    PolylineBucket.prototype.write = function(positionArray, colorArray, outlineColorArray, pickColorArray, showArray, positionIndex, showIndex, colorIndex, context) {
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var color = polyline.getColor();
            var show = polyline.getShow();
            var outlineColor = polyline.getOutlineColor();
            var pickColor = polyline.getPickId(context).unnormalizedRgb;
            var positions = this._getPositions(polyline);
            var positionsLength = positions.length;
            for ( var j = 0; j < positionsLength; ++j) {
                var position = positions[j];
                scratchWritePosition.x = position.x;
                scratchWritePosition.y = position.y;
                scratchWritePosition.z = (this.mode !== SceneMode.SCENE2D) ? position.z : 0.0;
                EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);
                outlineColorArray[colorIndex] = Color.floatToByte(outlineColor.red);
                outlineColorArray[colorIndex + 1] = Color.floatToByte(outlineColor.green);
                outlineColorArray[colorIndex + 2] = Color.floatToByte(outlineColor.blue);
                outlineColorArray[colorIndex + 3] = Color.floatToByte(outlineColor.alpha);
                colorArray[colorIndex] = Color.floatToByte(color.red);
                colorArray[colorIndex + 1] = Color.floatToByte(color.green);
                colorArray[colorIndex + 2] = Color.floatToByte(color.blue);
                colorArray[colorIndex + 3] = Color.floatToByte(color.alpha);
                pickColorArray[colorIndex] = pickColor.red;
                pickColorArray[colorIndex + 1] = pickColor.green;
                pickColorArray[colorIndex + 2] = pickColor.blue;
                pickColorArray[colorIndex + 3] = 255;
                showArray[showIndex++] = show;
                positionIndex += 6;
                colorIndex += 4;
            }
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeForMorph = function(positionArray, positionIndex) {
        var modelMatrix = this.modelMatrix;
        var position;
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var positions = polyline.getPositions();

            var numberOfSegments;
            var j;
            if (intersectsIDL(polyline)) {
                var segments = polyline._getSegments();
                numberOfSegments = segments.length;
                for ( j = 0; j < numberOfSegments; ++j) {
                    var segment = segments[j];
                    var segmentLength = segment.length;
                    for ( var n = 0; n < segmentLength; ++n) {
                        position = positions[segment[n].index];
                        position = modelMatrix.multiplyByPoint(position);
                        EncodedCartesian3.writeElements(position, positionArray, positionIndex);
                        positionIndex += 6;
                    }
                }
            } else {
                numberOfSegments = positions.length;
                for ( j = 0; j < numberOfSegments; ++j) {
                    position = positions[j];
                    position = modelMatrix.multiplyByPoint(position);
                    EncodedCartesian3.writeElements(position, positionArray, positionIndex);
                    positionIndex += 6;
                }
            }
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype._clampWidth = function(context, value) {
        var min = context.getMinimumAliasedLineWidth();
        var max = context.getMaximumAliasedLineWidth();

        return Math.min(Math.max(value, min), max);
    };

    /**
     * @private
     */
    PolylineBucket.prototype._updateIndices3D = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        var vaCount = vertexArrayBuckets.length - 1;
        var bucketLocator = new VertexArrayBucketLocator(0, offset, this);
        vertexArrayBuckets[vaCount].push(bucketLocator);
        var count = 0;
        var indices = totalIndices[totalIndices.length - 1];
        var indicesCount = 0;
        if (indices.length > 0) {
            indicesCount = indices[indices.length - 1] + 1;
        }
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var positions = polyline.getPositions();
            var positionsLength = positions.length;
            if(positions.length > 0){
                for ( var j = 0; j < positionsLength; ++j) {
                    if (j !== positionsLength - 1) {
                        if (indicesCount === SIXTYFOURK - 1) {
                            vertexBufferOffset.push(1);
                            indices = [];
                            totalIndices.push(indices);
                            indicesCount = 0;
                            bucketLocator.count = count;
                            count = 0;
                            offset = 0;
                            bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                            vertexArrayBuckets[++vaCount] = [bucketLocator];
                        }
                        count += 2;
                        offset += 2;
                        indices.push(indicesCount++);
                        indices.push(indicesCount);
                    }
                }
                if (indicesCount < SIXTYFOURK - 1) {
                    indicesCount++;
                } else {
                    vertexBufferOffset.push(0);
                    indices = [];
                    totalIndices.push(indices);
                    indicesCount = 0;
                    bucketLocator.count = count;
                    offset = 0;
                    count = 0;
                    bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                    vertexArrayBuckets[++vaCount] = [bucketLocator];
                }
            }
            polyline._clean();
        }
        bucketLocator.count = count;
        return offset;
    };

    /**
     * @private
     */
    PolylineBucket.prototype._updateIndices2D = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        var vaCount = vertexArrayBuckets.length - 1;
        var bucketLocator = new VertexArrayBucketLocator(0, offset, this);
        vertexArrayBuckets[vaCount].push(bucketLocator);
        var count = 0;
        var indices = totalIndices[totalIndices.length - 1];
        var indicesCount = 0;
        if (indices.length > 0) {
            indicesCount = indices[indices.length - 1] + 1;
        }
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            if(intersectsIDL(polyline)){
                var segments = polyline._segments;
                var numberOfSegments = segments.length;
                if(numberOfSegments > 0){
                    for ( var k = 0; k < numberOfSegments; ++k) {
                        var segment = segments[k];
                        var segmentLength = segment.length;
                        for ( var n = 0; n < segmentLength; ++n) {
                            if (n !== segmentLength - 1) {
                                if (indicesCount === SIXTYFOURK - 1) {
                                    vertexBufferOffset.push(1);
                                    indices = [];
                                    totalIndices.push(indices);
                                    indicesCount = 0;
                                    bucketLocator.count = count;
                                    count = 0;
                                    offset = 0;
                                    bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                                    vertexArrayBuckets[++vaCount] = [bucketLocator];
                                }
                                count += 2;
                                offset += 2;
                                indices.push(indicesCount++);
                                indices.push(indicesCount);
                            }
                        }
                        if (k !== numberOfSegments - 1) {
                            indicesCount++;
                        }
                    }

                    if (indicesCount < SIXTYFOURK - 1) {
                        indicesCount++;
                    } else {
                        vertexBufferOffset.push(0);
                        indices = [];
                        totalIndices.push(indices);
                        indicesCount = 0;
                        bucketLocator.count = count;
                        offset = 0;
                        count = 0;
                        bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                        vertexArrayBuckets[++vaCount] = [bucketLocator];
                    }
                }
            } else {
                var positions = polyline.getPositions();
                var positionsLength = positions.length;
                for ( var j = 0; j < positionsLength; ++j) {
                    if (j !== positionsLength - 1) {
                        if (indicesCount === SIXTYFOURK - 1) {
                            vertexBufferOffset.push(1);
                            indices = [];
                            totalIndices.push(indices);
                            indicesCount = 0;
                            bucketLocator.count = count;
                            count = 0;
                            offset = 0;
                            bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                            vertexArrayBuckets[++vaCount] = [bucketLocator];
                        }
                        count += 2;
                        offset += 2;
                        indices.push(indicesCount++);
                        indices.push(indicesCount);
                    }
                }

                if (indicesCount < SIXTYFOURK - 1) {
                    indicesCount++;
                } else {
                    vertexBufferOffset.push(0);
                    indices = [];
                    totalIndices.push(indices);
                    indicesCount = 0;
                    bucketLocator.count = count;
                    offset = 0;
                    count = 0;
                    bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                    vertexArrayBuckets[++vaCount] = [bucketLocator];
                }
            }
            polyline._clean();
        }
        bucketLocator.count = count;
        return offset;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.updateIndices = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        if (this.mode === SceneMode.SCENE3D) {
            return this._updateIndices3D(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
        }
        return this._updateIndices2D(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
    };

    /**
     * @private
     */
    PolylineBucket.prototype._getPolylineStartIndex = function(polyline) {
        var polylines = this.polylines;
        var positionIndex = 0;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var p = polylines[i];
            if (p === polyline) {
                break;
            }
            positionIndex += p._actualLength;
        }
        return positionIndex;
    };

    /**
     * @private
     */
    PolylineBucket.prototype._getPositions = function(polyline) {
        var positions = polyline.getPositions();

        if (positions.length > 0) {
            if (typeof polyline._polylineCollection._boundingVolume === 'undefined') {
                polyline._polylineCollection._boundingVolume = BoundingSphere.clone(polyline._boundingVolume);
            } else {
                polyline._polylineCollection._boundingVolume = polyline._polylineCollection._boundingVolume.union(polyline._boundingVolume, polyline._polylineCollection._boundingVolume);
            }
        }


        if (this.mode === SceneMode.SCENE3D) {
            return positions;
        }
        if(intersectsIDL(polyline)){
            positions = polyline._getPositions2D();
        }

        var ellipsoid = this.ellipsoid;
        var projection = this.projection;
        var newPositions = [];
        var modelMatrix = this.modelMatrix;
        var length = positions.length;
        var position;
        var p;

        for (var n = 0; n < length; ++n) {
            position = positions[n];
            p = modelMatrix.multiplyByPoint(position);
            newPositions.push(projection.project(ellipsoid.cartesianToCartographic(Cartesian3.fromCartesian4(p))));
        }

        if (newPositions.length > 0) {
            polyline._boundingVolume2D = BoundingSphere.fromPoints(newPositions, polyline._boundingVolume2D);
            var center2D = polyline._boundingVolume2D.center;
            polyline._boundingVolume2D.center = new Cartesian3(center2D.z,  center2D.x, center2D.y);
            if (typeof polyline._polylineCollection._boundingVolume2D === 'undefined') {
                polyline._polylineCollection._boundingVolume2D = BoundingSphere.clone(polyline._boundingVolume2D);
            } else {
                polyline._polylineCollection._boundingVolume2D = polyline._polylineCollection._boundingVolume2D.union(polyline._boundingVolume2D, polyline._polylineCollection._boundingVolume2D);
            }
        }

        return newPositions;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writePositionsUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);
            var positionArray = new Float32Array(2 * positionsLength * 3);
            var index = 0;
            var positions = this._getPositions(polyline);
            for ( var i = 0; i < positionsLength; ++i) {
                var position = positions[i];
                scratchWritePosition.x = position.x;
                scratchWritePosition.y = position.y;
                scratchWritePosition.z = (this.mode !== SceneMode.SCENE2D) ? position.z : 0.0;
                EncodedCartesian3.writeElements(scratchWritePosition, positionArray, index);
                index += 6;
            }

            buffer.copyFromArrayView(positionArray, 2 * 12 * positionIndex);
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeColorUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);

            var index = 0;
            var color = polyline.getColor();
            var red = Color.floatToByte(color.red);
            var green = Color.floatToByte(color.green);
            var blue = Color.floatToByte(color.blue);
            var alpha = Color.floatToByte(color.alpha);
            var colorsArray = new Uint8Array(positionsLength * 4);
            for ( var j = 0; j < positionsLength; ++j) {
                colorsArray[index] = red;
                colorsArray[index + 1] = green;
                colorsArray[index + 2] = blue;
                colorsArray[index + 3] = alpha;
                index += 4;
            }
            buffer.copyFromArrayView(colorsArray, 4 * positionIndex);
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeShowUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);
            var show = polyline.getShow();
            var showArray = new Uint8Array(positionsLength);
            for ( var j = 0; j < positionsLength; ++j) {
                showArray[j] = show;
            }
            buffer.copyFromArrayView(showArray, positionIndex);
        }
    };

    return PolylineCollection;
});
/*global define*/
define('DynamicScene/DynamicPathVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Scene/PolylineCollection'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         PolylineCollection) {
    

    function samplePositions(currentTime, positionProperty, availability, leadTime, trailTime, result) {
        var hasAvailability = typeof availability !== 'undefined';
        var hasLeadTime = typeof leadTime !== 'undefined';
        var hasTrailTime = typeof trailTime !== 'undefined';

        if (!hasAvailability && (!hasLeadTime || !hasTrailTime)) {
            return [];
        }

        var sampleStart;
        var sampleStop;
        if (hasTrailTime) {
            sampleStart = currentTime.addSeconds(-trailTime);
        }
        if (hasAvailability && (!hasTrailTime || availability.start.greaterThan(sampleStart))) {
            sampleStart = availability.start;
        }

        if (hasLeadTime) {
            sampleStop = currentTime.addSeconds(leadTime);
        }
        if (hasAvailability && (!hasLeadTime || availability.stop.lessThan(sampleStop))) {
            sampleStop = availability.stop;
        }

        return positionProperty.getValueRangeCartesian(sampleStart, sampleStop, currentTime, result);
    }

    /**
     * A DynamicObject visualizer which maps the DynamicPath instance
     * in DynamicObject.path to a Polyline primitive.
     * @alias DynamicPathVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPath
     * @see Polyline
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPathVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        var polylineCollection = this._polylineCollection = new PolylineCollection();
        scene.getPrimitives().add(polylineCollection);
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPathVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPathVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPathVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPathVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPathVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPathVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPathVisualizer.prototype.removeAllPrimitives = function() {
        var i;
        this._polylineCollection.removeAll();

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._pathVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPathVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPathVisualizer#destroy
     */
    DynamicPathVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPathVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPathVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPathVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._polylineCollection);
        return destroyObject(this);
    };

    DynamicPathVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPath = dynamicObject.path;
        if (typeof dynamicPath === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var polyline;
        var showProperty = dynamicPath.show;
        var pathVisualizerIndex = dynamicObject._pathVisualizerIndex;
        var show = (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof pathVisualizerIndex !== 'undefined') {
                polyline = this._polylineCollection.get(pathVisualizerIndex);
                polyline.setShow(false);
                dynamicObject._pathVisualizerIndex = undefined;
                this._unusedIndexes.push(pathVisualizerIndex);
            }
            return;
        }

        if (typeof pathVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                pathVisualizerIndex = unusedIndexes.pop();
                polyline = this._polylineCollection.get(pathVisualizerIndex);
            } else {
                pathVisualizerIndex = this._polylineCollection.getLength();
                polyline = this._polylineCollection.add();
            }
            dynamicObject._pathVisualizerIndex = pathVisualizerIndex;
            polyline.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            polyline.setColor(Color.WHITE);
            polyline.setOutlineColor(Color.BLACK);
            polyline.setOutlineWidth(1);
            polyline.setWidth(1);
        } else {
            polyline = this._polylineCollection.get(pathVisualizerIndex);
        }

        polyline.setShow(true);

        var property = dynamicPath.leadTime;
        var leadTime;
        if (typeof property !== 'undefined') {
            leadTime = property.getValue(time);
        }

        property = dynamicPath.trailTime;
        var trailTime;
        if (typeof property !== 'undefined') {
            trailTime = property.getValue(time);
        }

        polyline.setPositions(samplePositions(time, positionProperty, dynamicObject.availability, leadTime, trailTime, polyline.getPositions()));

        property = dynamicPath.color;
        if (typeof property !== 'undefined') {
            polyline.setColor(property.getValue(time, polyline.getColor()));
        }

        property = dynamicPath.outlineColor;
        if (typeof property !== 'undefined') {
            polyline.setOutlineColor(property.getValue(time, polyline.getOutlineColor()));
        }

        property = dynamicPath.outlineWidth;
        if (typeof property !== 'undefined') {
            var outlineWidth = property.getValue(time);
            if (typeof outlineWidth !== 'undefined') {
                polyline.setOutlineWidth(outlineWidth);
            }
        }

        property = dynamicPath.width;
        if (typeof property !== 'undefined') {
            var width = property.getValue(time);
            if (typeof width !== 'undefined') {
                polyline.setWidth(width);
            }
        }
    };

    DynamicPathVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPolylineCollection = this._polylineCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var pathVisualizerIndex = dynamicObject._pathVisualizerIndex;
            if (typeof pathVisualizerIndex !== 'undefined') {
                var polyline = thisPolylineCollection.get(pathVisualizerIndex);
                polyline.setShow(false);
                thisUnusedIndexes.push(pathVisualizerIndex);
                dynamicObject._pathVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPathVisualizer;
});
/*global define*/
define('DynamicScene/DynamicPolylineVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Scene/PolylineCollection'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         PolylineCollection) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPolyline instance
     * in DynamicObject.polyline to a Polyline primitive.
     * @alias DynamicPolylineVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPolyline
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPolylineVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        var polylineCollection = this._polylineCollection = new PolylineCollection();
        scene.getPrimitives().add(polylineCollection);
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPolylineVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPolylineVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPolylineVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPolylineVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPolylineVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPolylineVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPolylineVisualizer.prototype.removeAllPrimitives = function() {
        var i;
        this._polylineCollection.removeAll();

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._polylineVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPolylineVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPolylineVisualizer#destroy
     */
    DynamicPolylineVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPolylineVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPolylineVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPolylineVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._polylineCollection);
        return destroyObject(this);
    };

    DynamicPolylineVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPolyline = dynamicObject.polyline;
        if (typeof dynamicPolyline === 'undefined') {
            return;
        }

        var vertexPositionsProperty = dynamicObject.vertexPositions;
        if (typeof vertexPositionsProperty === 'undefined') {
            return;
        }

        var polyline;
        var showProperty = dynamicPolyline.show;
        var polylineVisualizerIndex = dynamicObject._polylineVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof polylineVisualizerIndex !== 'undefined') {
                polyline = this._polylineCollection.get(polylineVisualizerIndex);
                polyline.setShow(false);
                dynamicObject._polylineVisualizerIndex = undefined;
                this._unusedIndexes.push(polylineVisualizerIndex);
            }
            return;
        }

        if (typeof polylineVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                polylineVisualizerIndex = unusedIndexes.pop();
                polyline = this._polylineCollection.get(polylineVisualizerIndex);
            } else {
                polylineVisualizerIndex = this._polylineCollection.getLength();
                polyline = this._polylineCollection.add();
            }
            dynamicObject._polylineVisualizerIndex = polylineVisualizerIndex;
            polyline.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            polyline.setColor(Color.WHITE);
            polyline.setOutlineColor(Color.BLACK);
            polyline.setOutlineWidth(1);
            polyline.setWidth(1);
        } else {
            polyline = this._polylineCollection.get(polylineVisualizerIndex);
        }

        polyline.setShow(true);

        var vertexPositions = vertexPositionsProperty.getValueCartesian(time);
        if (typeof vertexPositions !== 'undefined' && polyline._visualizerPositions !== vertexPositions) {
            polyline.setPositions(vertexPositions);
            polyline._visualizerPositions = vertexPositions;
        }

        var property = dynamicPolyline.color;
        if (typeof property !== 'undefined') {
            polyline.setColor(property.getValue(time, polyline.getColor()));
        }

        property = dynamicPolyline.outlineColor;
        if (typeof property !== 'undefined') {
            polyline.setOutlineColor(property.getValue(time, polyline.getOutlineColor()));
        }

        property = dynamicPolyline.outlineWidth;
        if (typeof property !== 'undefined') {
            var outlineWidth = property.getValue(time);
            if (typeof outlineWidth !== 'undefined') {
                polyline.setOutlineWidth(outlineWidth);
            }
        }

        property = dynamicPolyline.width;
        if (typeof property !== 'undefined') {
            var width = property.getValue(time);
            if (typeof width !== 'undefined') {
                polyline.setWidth(width);
            }
        }
    };

    DynamicPolylineVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPolylineCollection = this._polylineCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var polylineVisualizerIndex = dynamicObject._polylineVisualizerIndex;
            if (typeof polylineVisualizerIndex !== 'undefined') {
                var polyline = thisPolylineCollection.get(polylineVisualizerIndex);
                polyline.setShow(false);
                thisUnusedIndexes.push(polylineVisualizerIndex);
                dynamicObject._polylineVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPolylineVisualizer;
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/Ray',[],function() {
    
    return "/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_raySegmentCollectionCapacity\n\
 * @glslConstant \n\
 *\n\
 * @see czm_raySegmentCollection\n\
 */\n\
const int czm_raySegmentCollectionCapacity = 4;\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_raySegmentCollection\n\
 * @glslStruct\n\
 *\n\
 * @see czm_raySegmentCollectionCapacity\n\
 * @see czm_raySegment\n\
 */\n\
struct czm_raySegmentCollection\n\
{\n\
    czm_raySegment intervals[czm_raySegmentCollectionCapacity];\n\
    int count;\n\
};\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_raySegmentCollectionNew\n\
 * @glslFunction\n\
 *\n\
 */\n\
czm_raySegmentCollection czm_raySegmentCollectionNew()\n\
{\n\
    czm_raySegment intervals[czm_raySegmentCollectionCapacity];\n\
    czm_raySegmentCollection i = czm_raySegmentCollection(intervals, 0);\n\
    return i;\n\
}\n\
\n\
czm_raySegmentCollection czm_raySegmentCollectionNew(czm_raySegment segment)\n\
{\n\
    czm_raySegment intervals[czm_raySegmentCollectionCapacity];\n\
    intervals[0] = segment;\n\
    czm_raySegmentCollection i = czm_raySegmentCollection(intervals, 1);\n\
    return i;\n\
}\n\
\n\
czm_raySegmentCollection czm_raySegmentCollectionNew(czm_raySegment first, czm_raySegment second)\n\
{\n\
    czm_raySegment intervals[czm_raySegmentCollectionCapacity];\n\
    intervals[0] = first;\n\
    intervals[1] = second;\n\
    czm_raySegmentCollection i = czm_raySegmentCollection(intervals, 2);\n\
    return i;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_removeAt\n\
 * @glslFunction\n\
 *\n\
 */\n\
void czm_removeAt(inout czm_raySegmentCollection collection, int index)\n\
{\n\
    --collection.count;\n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
        if (i >= index && i < collection.count)\n\
        {\n\
            collection.intervals[i] = collection.intervals[i + 1];\n\
        }\n\
        else if (i == collection.count)\n\
        {\n\
            break;\n\
        }\n\
    }\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_insertAt\n\
 * @glslFunction\n\
 *\n\
 */\n\
void czm_insertAt(inout czm_raySegmentCollection collection, czm_raySegment segment, int index)\n\
{\n\
    for (int i = czm_raySegmentCollectionCapacity - 1; i >= 0; --i)\n\
    {\n\
        if (i <= collection.count && i > index)\n\
        {\n\
            collection.intervals[i] = collection.intervals[i - 1];\n\
        }\n\
        else if (i == index)\n\
        {\n\
            collection.intervals[i] = segment;\n\
        }\n\
        else if (i < index)\n\
        {\n\
            break;\n\
        }\n\
    }\n\
    ++collection.count;\n\
}\n\
\n\
void czm_insertAt(inout czm_raySegmentCollection collection, czm_raySegmentCollection segments, int index)\n\
{\n\
    if (segments.count == 1)\n\
    {\n\
        czm_insertAt(collection, segments.intervals[0], index);\n\
    }\n\
    else\n\
    {\n\
        for (int i = czm_raySegmentCollectionCapacity - 1; i >= 0; --i)\n\
        {\n\
            if (i < segments.count)\n\
            {\n\
                czm_insertAt(collection, segments.intervals[i], index);\n\
            }\n\
        }\n\
    }\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_complement\n\
 * @glslFunction\n\
 *\n\
 */\n\
void czm_complement(czm_raySegment segment, out czm_raySegmentCollection collection)\n\
{\n\
    if (czm_isEmpty(segment))\n\
    {\n\
        collection = czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
    }\n\
    else if (segment.stop == czm_infinity)\n\
    {\n\
        if (segment.start == 0.0)\n\
        {\n\
	        collection = czm_raySegmentCollectionNew();\n\
        }\n\
        else\n\
        {\n\
	        collection = czm_raySegmentCollectionNew(czm_raySegment(0.0, segment.start));\n\
        }\n\
    }\n\
    else if (segment.start == 0.0)\n\
    {\n\
        collection = czm_raySegmentCollectionNew(czm_raySegment(segment.stop, czm_infinity));\n\
    }\n\
    else\n\
    {\n\
	    czm_raySegment head = czm_raySegment(0.0, segment.start);\n\
	    czm_raySegment tail = czm_raySegment(segment.stop, czm_infinity);\n\
	    collection = czm_raySegmentCollectionNew(head, tail);\n\
    }        \n\
}\n\
\n\
czm_raySegmentCollection czm_complement(czm_raySegmentCollection collection)\n\
{\n\
    if (collection.count == 0)\n\
    {\n\
        czm_raySegmentCollection result = czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
        return result;\n\
    }\n\
    else if (collection.count == 1)\n\
    {\n\
        czm_raySegmentCollection result;\n\
        czm_complement(collection.intervals[0], result);\n\
        return result;\n\
    }\n\
\n\
    czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
\n\
    for (int i = 0; i < czm_raySegmentCollectionCapacity; ++i)\n\
    {\n\
        if (i < collection.count)\n\
        {\n\
            float start = collection.intervals[i].stop;\n\
            if (i < collection.count - 1)\n\
            {\n\
                float stop = collection.intervals[i + 1].start;\n\
                result.intervals[i] = czm_raySegment(start, stop);\n\
                ++result.count;\n\
            }\n\
            else if (start != czm_infinity)\n\
            {\n\
                result.intervals[i] = czm_raySegment(start, czm_infinity);\n\
                ++result.count;\n\
            }\n\
        }\n\
        else\n\
        {\n\
            break;\n\
        }\n\
    }\n\
    \n\
    if (collection.count > 0)\n\
    {\n\
        float stop = collection.intervals[0].start;\n\
        if (stop != 0.0)\n\
        {\n\
            // PERFORMANCE TODO: See if the additional loop iteration from the insert can be eliminated.\n\
            czm_insertAt(result, czm_raySegment(0.0, stop), 0);\n\
        }\n\
    }\n\
    \n\
    return result;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_union\n\
 */\n\
czm_raySegmentCollection czm_union(czm_raySegment left, czm_raySegment right)\n\
{\n\
    if (czm_isFull(left) || czm_isFull(right))\n\
    {\n\
        czm_raySegmentCollection result = czm_raySegmentCollectionNew(czm_fullRaySegment);\n\
        return result;\n\
    }\n\
\n\
    float stop = min(left.stop, right.stop);\n\
    float start = max(left.start, right.start);\n\
    \n\
    if (stop < start) // No intersection.\n\
    {\n\
        czm_raySegmentCollection result = (left.start < right.start) ? czm_raySegmentCollectionNew(left, right) : czm_raySegmentCollectionNew(right, left);\n\
        return result;\n\
    }\n\
\n\
    czm_raySegmentCollection result = czm_raySegmentCollectionNew(czm_raySegment(min(left.start, right.start), max(left.stop, right.stop)));\n\
    return result;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * Determines the intersection of two time intervals.  If they do not intersect, an\n\
 * empty time interval, <code>czm_emptyRaySegment</code>, is returned.\n\
 *\n\
 * @name czm_intersection\n\
 * @glslFunction \n\
 *\n\
 * @param {czm_raySegment} left One interval.\n\
 * @param {czm_raySegment} right The other interval.\n\
 *\n\
 * @returns {czm_raySegment} The intersection of <code>left</code> and <code>right</code>.\n\
 * \n\
 * @see czm_unionRaySegments\n\
 * @see czm_subtraction  \n\
 * @see czm_isEmpty\n\
 *\n\
 * @example\n\
 * czm_raySegment i0 = czm_intersection(czm_raySegment(1.0, 2.0), czm_raySegment(3.0, 4.0));    // Empty\n\
 * czm_raySegment i1 = czm_intersection(czm_raySegment(1.0, 3.0), czm_raySegment(2.0, 4.0));    // (2.0, 3.0)\n\
 */\n\
czm_raySegment czm_intersection(czm_raySegment left, czm_raySegment right)\n\
{\n\
    float stop = min(left.stop, right.stop);\n\
    \n\
    if (stop < 0.0)\n\
    {\n\
        return czm_emptyRaySegment;\n\
    }\n\
\n\
    float start = max(left.start, right.start);\n\
    \n\
    if (stop < start)\n\
    {\n\
        return czm_emptyRaySegment;\n\
    }\n\
\n\
    czm_raySegment s = czm_raySegment(start, stop);\n\
    return s;\n\
}\n\
\n\
czm_raySegmentCollection czm_intersection(czm_raySegmentCollection left, czm_raySegment right)\n\
{\n\
    if (left.count == 1)\n\
    {\n\
        czm_raySegment intersection = czm_intersection(left.intervals[0], right);\n\
        \n\
        if (czm_isEmpty(intersection))\n\
        {\n\
            czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
            \n\
            return result;\n\
        }\n\
        else\n\
        {\n\
            czm_raySegmentCollection result = czm_raySegmentCollectionNew(intersection);\n\
            \n\
            return result;\n\
        }\n\
    }\n\
\n\
    czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
    \n\
    for (int leftIndex = 0; leftIndex < czm_raySegmentCollectionCapacity; ++leftIndex)\n\
    {\n\
        if (leftIndex < left.count)\n\
        {\n\
            czm_raySegment intersection = czm_intersection(left.intervals[leftIndex], right);\n\
            if (!czm_isEmpty(intersection))\n\
            {\n\
                czm_insertAt(result, intersection, result.count);\n\
            }\n\
        }\n\
        else\n\
        {\n\
            break;\n\
        }\n\
    }\n\
\n\
    return result;\n\
}\n\
\n\
czm_raySegmentCollection czm_intersection(czm_raySegmentCollection left, czm_raySegmentCollection right)\n\
{\n\
    if (right.count == 1)\n\
    {\n\
        if (left.count == 1)\n\
        {\n\
            czm_raySegment intersection = czm_intersection(left.intervals[0], right.intervals[0]);\n\
            \n\
	        if (czm_isEmpty(intersection))\n\
	        {\n\
	            czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
	            \n\
	            return result;\n\
	        }\n\
	        else\n\
	        {\n\
	            czm_raySegmentCollection result = czm_raySegmentCollectionNew(intersection);\n\
	            \n\
	            return result;\n\
	        }\n\
        }\n\
        else\n\
        {\n\
            czm_raySegmentCollection result = czm_intersection(left, right.intervals[0]);\n\
            \n\
            return result;\n\
        }\n\
    }\n\
\n\
    czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
    \n\
    if (left.count > 0 && right.count > 0)\n\
    {\n\
        for (int leftIndex = 0; leftIndex < czm_raySegmentCollectionCapacity; ++leftIndex)\n\
        {\n\
            if (leftIndex < left.count)\n\
            {\n\
                for (int rightIndex = 0; rightIndex < czm_raySegmentCollectionCapacity; ++rightIndex)\n\
                {\n\
                    // TODO:  Figure out why this isn't \"rightIndex < right.count\".\n\
                    if (rightIndex <= right.count && left.intervals[leftIndex].stop >= right.intervals[rightIndex].start)\n\
                    {\n\
	                    czm_raySegment intersection = czm_intersection(left.intervals[leftIndex], right.intervals[rightIndex]);\n\
	                    if (!czm_isEmpty(intersection))\n\
	                    {\n\
                            czm_insertAt(result, intersection, result.count);\n\
                        }\n\
                    }\n\
                    else\n\
                    {\n\
                        break;\n\
	                }\n\
                }\n\
            }\n\
            else\n\
            {\n\
                break;\n\
            }\n\
        }\n\
    }\n\
\n\
    return result;\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
/**\n\
 * Subtracts one time interval from another, resulting in zero, one, or two non-empty time intervals.\n\
 * \n\
 * @name czm_subtraction\n\
 * @glslFunction\n\
 *\n\
 * @param {czm_raySegment} outer The outer interval.\n\
 * @param {czm_raySegment} inner The inner interval that is subtracted from <code>outer</code>.\n\
 * \n\
 * @returns {czm_raySegmentCollection} The time intervals resulting from <code>outer - inner</code>.\n\
 *\n\
 * @see czm_intersection\n\
 * @see czm_unionRaySegments\n\
 *\n\
 * @example\n\
 * czm_raySegmentCollection i0 = czm_subtraction(\n\
 *   czm_raySegment(1.0, 4.0), czm_raySegment(2.0, 3.0)); \n\
 * // i0 is [(1.0, 2.0), (3.0, 4.0)]\n\
 * \n\
 * czm_raySegmentCollection i1 = czm_subtraction(\n\
 *   czm_raySegment(1.0, 4.0), czm_raySegment(1.0, 2.0));\n\
 * // i1 is [(2.0, 4.0)]\n\
 * \n\
 * czm_raySegmentCollection i2 = czm_subtraction(\n\
 *   czm_raySegment(1.0, 4.0), czm_raySegment(5.0, 6.0));\n\
 * // i2 is []\n\
 */\n\
czm_raySegmentCollection czm_subtraction(czm_raySegment outer, czm_raySegment inner)\n\
{\n\
    // This function has ANGLE workarounds:  http://code.google.com/p/angleproject/issues/detail?id=185\n\
\n\
    czm_raySegmentCollection i = czm_raySegmentCollectionNew();\n\
\n\
    czm_raySegment intersection = czm_intersection(outer, inner);\n\
    \n\
    if (czm_isEmpty(intersection) || (intersection.start == intersection.stop))\n\
    {\n\
        // No intersection, or intersection at an end point; subtraction doesn't change outer.\n\
        i.count = 1;\n\
        i.intervals[0] = outer;\n\
    }\n\
    else\n\
    {\n\
        if ((intersection.start == outer.start) && (intersection.stop == outer.stop))\n\
        {\n\
            // outer and inner are the same interval; subtracting them yields empty intervals.\n\
            i.count = 0;\n\
        }\n\
        else if (intersection.start == outer.start)\n\
        {\n\
            // inner is completely inside outer, and touching the left boundary; subtraction yields one interval\n\
            i.count = 1;\n\
            i.intervals[0] = czm_raySegment(inner.stop, outer.stop);\n\
        }\n\
        else if (intersection.stop == outer.stop)\n\
        {\n\
            // inner is completely inside outer, and touching the right boundary; subtraction yields one interval\n\
            i.count = 1;\n\
            i.intervals[0] = czm_raySegment(outer.start, inner.start);\n\
        }\n\
        else\n\
        {\n\
            // inner is completely inside outer, but not on a boundary; break outer into two intervals\n\
            i.count = 2;\n\
            i.intervals[0] = czm_raySegment(outer.start, inner.start);\n\
            i.intervals[1] = czm_raySegment(inner.stop, outer.stop);\n\
        }\n\
    }\n\
    \n\
    return i;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_subtraction\n\
 */\n\
czm_raySegmentCollection czm_subtraction(czm_raySegmentCollection left, czm_raySegment right)\n\
{\n\
    if (left.count == 1)\n\
    {\n\
        czm_raySegmentCollection result = czm_subtraction(left.intervals[0], right);\n\
        \n\
        return result;\n\
    }\n\
\n\
    czm_raySegmentCollection result = czm_raySegmentCollectionNew();\n\
    \n\
    for (int leftIndex = 0; leftIndex < czm_raySegmentCollectionCapacity; ++leftIndex)\n\
    {\n\
        if (leftIndex < left.count)\n\
        {\n\
            czm_raySegmentCollection segments = czm_subtraction(left.intervals[leftIndex], right);\n\
            if (segments.count != 0)\n\
            {\n\
                czm_insertAt(result, segments, result.count);\n\
            }\n\
        }\n\
        else\n\
        {\n\
            break;\n\
        }\n\
    }\n\
\n\
    return result;\n\
}\n\
\n\
/**\n\
 * DOC_TBA\n\
 *\n\
 * @name czm_subtraction\n\
 */\n\
czm_raySegmentCollection czm_subtraction(czm_raySegmentCollection left, czm_raySegmentCollection right)\n\
{\n\
    if (right.count == 1)\n\
    {\n\
        if (left.count == 1)\n\
        {\n\
            czm_raySegmentCollection result = czm_subtraction(left.intervals[0], right.intervals[0]);\n\
            \n\
            return result;\n\
        }\n\
        else\n\
        {\n\
	        czm_raySegmentCollection result = czm_subtraction(left, right.intervals[0]);\n\
	        \n\
	        return result;\n\
        }\n\
    }\n\
\n\
    // PERFORMANCE TODO: See if these two calls (with separate loop iterations) can be combined into one loop.\n\
    czm_raySegmentCollection complement = czm_complement(right);\n\
\n\
    czm_raySegmentCollection result = czm_intersection(left, complement);\n\
    \n\
    return result;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ReprojectWebMercatorFS',[],function() {
    
    return "uniform sampler2D u_texture;\n\
\n\
uniform float u_northLatitude;\n\
uniform float u_southLatitude;\n\
uniform float u_southMercatorYHigh;\n\
uniform float u_southMercatorYLow;\n\
uniform float u_oneOverMercatorHeight;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main()\n\
{\n\
    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\n\
    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\n\
    // fragments on the edges of tiles even though the vertex shader is outputting\n\
    // coordinates strictly in the 0-1 range.\n\
    vec2 geographicUV = clamp(v_textureCoordinates, 0.0, 1.0);\n\
    vec2 webMercatorUV = geographicUV;\n\
    \n\
    float currentLatitude = mix(u_southLatitude, u_northLatitude, geographicUV.y);\n\
    float fraction = czm_latitudeToWebMercatorFraction(currentLatitude, u_southMercatorYLow, u_southMercatorYHigh, u_oneOverMercatorHeight);\n\
    \n\
    webMercatorUV = vec2(geographicUV.x, fraction);\n\
    \n\
    gl_FragColor = texture2D(u_texture, webMercatorUV);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ReprojectWebMercatorVS',[],function() {
    
    return "attribute vec4 position;\n\
\n\
uniform vec2 u_textureDimensions;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main()\n\
{\n\
    v_textureCoordinates = position.xy;\n\
    gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/SensorVolume',[],function() {
    
    return "uniform float u_erosion;\n\
uniform vec4 u_intersectionColor;\n\
\n\
bool inSensorShadow(vec3 coneVertexWC, czm_ellipsoid ellipsoidEC, vec3 pointEC)\n\
{\n\
    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n\
    vec3 D = ellipsoidEC.inverseRadii;\n\
\n\
    // Sensor vertex in the scaled ellipsoid space\n\
    vec3 q = D * coneVertexWC;\n\
    float qMagnitudeSquared = dot(q, q);\n\
    float test = qMagnitudeSquared - 1.0;\n\
    \n\
    // Fragment in the ellipsoid frame\n\
    vec3 t = (czm_inverseView * vec4(pointEC, 1.0)).xyz;\n\
\n\
    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n\
    vec3 temp = D * t - q;\n\
    float d = dot(temp, q);\n\
    \n\
    // Behind silhouette plane and inside silhouette cone\n\
    return (d < -test) && (d / length(temp) < -sqrt(test));\n\
}\n\
\n\
///////////////////////////////////////////////////////////////////////////////\n\
\n\
#ifndef RENDER_FOR_PICK\n\
\n\
void sensorErode(float sensorRadius, vec3 pointEC)\n\
{\n\
    if (u_erosion != 1.0)\n\
    {\n\
        vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n\
        pointMC /= sensorRadius;\n\
        pointMC /= (1.0 / 10.0);\n\
    \n\
        float t = 0.5 + (0.5 * czm_snoise(pointMC));   // Scale [-1, 1] to [0, 1]\n\
    \n\
        if (t > u_erosion)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
}\n\
\n\
vec4 getIntersectionColor(float sensorRadius, vec3 pointEC)\n\
{\n\
    sensorErode(sensorRadius, pointEC);\n\
    return u_intersectionColor;\n\
}\n\
\n\
vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n\
{\n\
    // (s, t) both in the range [0, 1]\n\
    float t = pointMC.z / sensorRadius;\n\
    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n\
    s = s - floor(s);\n\
    \n\
    return vec2(s, t);\n\
}\n\
\n\
#endif";
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/SkyAtmosphereFS',[],function() {
    
    return "/*!\n\
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\n\
 * All rights reserved.\n\
 * \n\
 * Redistribution and use in source and binary forms, with or without\n\
 * modification, are permitted provided that the following conditions\n\
 * are met:\n\
 * \n\
 * * Redistributions of source code must retain the above copyright notice,\n\
 *   this list of conditions and the following disclaimer.\n\
 * * Redistributions in binary form must reproduce the above copyright notice,\n\
 *   this list of conditions and the following disclaimer in the documentation\n\
 *   and/or other materials provided with the distribution.\n\
 * * Neither the name of the project nor the names of its contributors may be\n\
 *   used to endorse or promote products derived from this software without\n\
 *   specific prior written permission.\n\
 * \n\
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n\
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n\
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\
 *\n\
 * Modifications made by Analytical Graphics, Inc.\n\
 */\n\
 \n\
 // Code:  http://sponeil.net/\n\
 // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n\
 \n\
uniform float u_morphTime;\n\
 \n\
const float g = -0.95;\n\
const float g2 = g * g;\n\
\n\
varying vec3 v_rayleighColor;\n\
varying vec3 v_mieColor;\n\
varying vec3 v_toCamera;\n\
varying vec3 v_positionEC;\n\
\n\
void main (void)\n\
{\n\
    // TODO: make arbitrary ellipsoid\n\
    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n\
    \n\
    vec3 direction = normalize(v_positionEC);\n\
    czm_ray ray = czm_ray(vec3(0.0), direction);\n\
    \n\
    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n\
    if (!czm_isEmpty(intersection)) {\n\
        discard;\n\
    }\n\
    \n\
    // Extra normalize added for Android\n\
    float fCos = dot(czm_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n\
    float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\n\
    float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n\
    \n\
    const float fExposure = 2.0;\n\
    \n\
    vec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n\
    rgb = vec3(1.0) - exp(-fExposure * rgb);\n\
    float l = czm_luminance(rgb);\n\
    gl_FragColor = vec4(rgb, min(smoothstep(0.0, 0.1, l), 1.0) * smoothstep(0.0, 1.0, u_morphTime));\n\
}\n\
";
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/SkyAtmosphereVS',[],function() {
    
    return "/*!\n\
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\n\
 * All rights reserved.\n\
 * \n\
 * Redistribution and use in source and binary forms, with or without\n\
 * modification, are permitted provided that the following conditions\n\
 * are met:\n\
 * \n\
 * * Redistributions of source code must retain the above copyright notice,\n\
 *   this list of conditions and the following disclaimer.\n\
 * * Redistributions in binary form must reproduce the above copyright notice,\n\
 *   this list of conditions and the following disclaimer in the documentation\n\
 *   and/or other materials provided with the distribution.\n\
 * * Neither the name of the project nor the names of its contributors may be\n\
 *   used to endorse or promote products derived from this software without\n\
 *   specific prior written permission.\n\
 * \n\
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n\
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n\
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\
 *\n\
 * Modifications made by Analytical Graphics, Inc.\n\
 */\n\
 \n\
 // Code:  http://sponeil.net/\n\
 // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n\
  \n\
attribute vec4 position;\n\
\n\
uniform float fCameraHeight;\n\
uniform float fCameraHeight2;\n\
uniform float fOuterRadius;     // The outer (atmosphere) radius\n\
uniform float fOuterRadius2;    // fOuterRadius^2\n\
uniform float fInnerRadius;     // The inner (planetary) radius\n\
uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\n\
uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n\
uniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\
\n\
const float Kr = 0.0025;\n\
const float fKr4PI = Kr * 4.0 * czm_pi;\n\
const float Km = 0.0015;\n\
const float fKm4PI = Km * 4.0 * czm_pi;\n\
const float ESun = 15.0;\n\
const float fKmESun = Km * ESun;\n\
const float fKrESun = Kr * ESun;\n\
const vec3 v3InvWavelength = vec3(\n\
    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n\
    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n\
    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n\
const float rayleighScaleDepth = 0.25;\n\
          \n\
const int nSamples = 2;\n\
const float fSamples = 2.0;\n\
\n\
varying vec3 v_rayleighColor;\n\
varying vec3 v_mieColor;\n\
varying vec3 v_toCamera;\n\
varying vec3 v_positionEC;\n\
\n\
float scale(float fCos)\n\
{\n\
    float x = 1.0 - fCos;\n\
    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n\
}\n\
\n\
void main(void)\n\
{\n\
    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n\
    vec3 v3Pos = position.xyz;\n\
    vec3 v3Ray = v3Pos - czm_viewerPositionWC;\n\
    float fFar = length(v3Ray);\n\
    v3Ray /= fFar;\n\
\n\
#ifdef SKY_FROM_SPACE\n\
    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n\
    float B = 2.0 * dot(czm_viewerPositionWC, v3Ray);\n\
    float C = fCameraHeight2 - fOuterRadius2;\n\
    float fDet = max(0.0, B*B - 4.0 * C);\n\
    float fNear = 0.5 * (-B - sqrt(fDet));\n\
\n\
    // Calculate the ray's starting position, then calculate its scattering offset\n\
    vec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;\n\
    fFar -= fNear;\n\
    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n\
    float fStartDepth = exp(-1.0 / fScaleDepth);\n\
    float fStartOffset = fStartDepth*scale(fStartAngle);\n\
#else // SKY_FROM_ATMOSPHERE\n\
    // Calculate the ray's starting position, then calculate its scattering offset\n\
    vec3 v3Start = czm_viewerPositionWC;\n\
    float fHeight = length(v3Start);\n\
    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n\
    float fStartAngle = dot(v3Ray, v3Start) / fHeight;\n\
    float fStartOffset = fDepth*scale(fStartAngle);\n\
#endif\n\
\n\
    // Initialize the scattering loop variables\n\
    float fSampleLength = fFar / fSamples;\n\
    float fScaledLength = fSampleLength * fScale;\n\
    vec3 v3SampleRay = v3Ray * fSampleLength;\n\
    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\
\n\
    // Now loop through the sample rays\n\
    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n\
    for(int i=0; i<nSamples; i++)\n\
    {\n\
        float fHeight = length(v3SamplePoint);\n\
        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n\
        vec3 lightPosition = normalize(czm_viewerPositionWC); // czm_sunDirectionWC\n\
        float fLightAngle = dot(lightPosition, v3SamplePoint) / fHeight;\n\
        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n\
        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\n\
        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\
        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n\
        v3SamplePoint += v3SampleRay;\n\
    }\n\
\n\
    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n\
    v_mieColor = v3FrontColor * fKmESun;\n\
    v_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\n\
    v_toCamera = czm_viewerPositionWC - v3Pos;\n\
    v_positionEC = (czm_modelView * position).xyz;\n\
    gl_Position = czm_modelViewProjection * position;\n\
}\n\
";
});
/*global define*/
define('Scene/SkyAtmosphere',[
        '../Core/defaultValue',
        '../Core/CubeMapEllipsoidTessellator',
        '../Core/destroyObject',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/Ellipsoid',
        '../Renderer/BufferUsage',
        '../Renderer/DrawCommand',
        '../Renderer/CullFace',
        '../Renderer/BlendingState',
        '../Scene/SceneMode',
        '../Shaders/SkyAtmosphereVS',
        '../Shaders/SkyAtmosphereFS'
    ], function(
        defaultValue,
        CubeMapEllipsoidTessellator,
        destroyObject,
        MeshFilters,
        PrimitiveType,
        Ellipsoid,
        BufferUsage,
        DrawCommand,
        CullFace,
        BlendingState,
        SceneMode,
        SkyAtmosphereVS,
        SkyAtmosphereFS) {
    

    /**
     * An atmosphere drawn around the limb of the provided ellipsoid.  Based on
     * <a href="http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html" target="_blank">Accurate Atmospheric Scattering</a>
     * in GPU Gems 2.
     * <p>
     * This is only supported in 3D.  atmosphere is faded out when morphing to 2D or Columbus view.
     * </p>
     *
     * @alias SkyAtmosphere
     * @constructor
     *
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.
     *
     * @example
     * scene.skyAtmosphere = new SkyAtmosphere();
     *
     * @see Scene.skyAtmosphere
     */
    var SkyAtmosphere = function(ellipsoid) {
        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

        /**
         * Determines if the atmosphere is shown.
         * <p>
         * The default is <code>true</code>.
         * </p>
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;

        this._ellipsoid = ellipsoid;
        this._command = new DrawCommand();
        this._spSkyFromSpace = undefined;
        this._spSkyFromAtmosphere = undefined;

        this._fCameraHeight = undefined;
        this._fCameraHeight2 = undefined;
        this._outerRadius = ellipsoid.getRadii().multiplyByScalar(1.025).getMaximumComponent();
        var innerRadius = ellipsoid.getMaximumRadius();
        var rayleighScaleDepth = 0.25;

        var that = this;

        this._command.uniformMap = {
            fCameraHeight : function() {
                return that._fCameraHeight;
            },
            fCameraHeight2 : function() {
                return that._fCameraHeight2;
            },
            fOuterRadius : function() {
                return that._outerRadius;
            },
            fOuterRadius2 : function() {
                return that._outerRadius * that._outerRadius;
            },
            fInnerRadius : function() {
                return innerRadius;
            },
            fScale : function() {
                return 1.0 / (that._outerRadius - innerRadius);
            },
            fScaleDepth : function() {
                return rayleighScaleDepth;
            },
            fScaleOverScaleDepth : function() {
                return (1.0 / (that._outerRadius - innerRadius)) / rayleighScaleDepth;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
    };

    /**
     * Gets the ellipsoid the atmosphere is drawn around.
     *
     * @memberof SkyAtmosphere
     *
     * @return {Ellipsoid}
     */
    SkyAtmosphere.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * @private
     */
    SkyAtmosphere.prototype.update = function(context, frameState) {
        if (!this.show) {
            return undefined;
        }

        if ((frameState.mode !== SceneMode.SCENE3D) &&
            (frameState.mode !== SceneMode.MORPHING)) {
            return undefined;
        }

        // The atmosphere is only rendered during the color pass; it is not pickable, it doesn't cast shadows, etc.
        if (!frameState.passes.color) {
            return undefined;
        }

        var command = this._command;

        if (typeof command.vertexArray === 'undefined') {
            var mesh = CubeMapEllipsoidTessellator.compute(Ellipsoid.fromCartesian3(this._ellipsoid.getRadii().multiplyByScalar(1.025)), 60);
            command.vertexArray = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : MeshFilters.createAttributeIndices(mesh),
                bufferUsage : BufferUsage.STATIC_DRAW
            });
            command.primitiveType = PrimitiveType.TRIANGLES;
            command.renderState = context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                },
                blending : BlendingState.ALPHA_BLEND
            });

            var vs;
            var fs;
            var shaderCache = context.getShaderCache();

            vs = '#define SKY_FROM_SPACE\n' +
                 '#line 0\n' +
                 SkyAtmosphereVS;
            fs = '#line 0\n' +
                 SkyAtmosphereFS;
            this._spSkyFromSpace = shaderCache.getShaderProgram(vs, fs);

            vs = '#define SKY_FROM_ATMOSPHERE\n' +
                 '#line 0\n' +
                 SkyAtmosphereVS;
            this._spSkyFromAtmosphere = shaderCache.getShaderProgram(vs, fs);
        }

        var cameraPosition = frameState.camera.getPositionWC();

        this._fCameraHeight2 = cameraPosition.magnitudeSquared();
        this._fCameraHeight = Math.sqrt(this._fCameraHeight2);

        if (this._fCameraHeight > this._outerRadius) {
            // Camera in space
            command.shaderProgram = this._spSkyFromSpace;
        } else {
            // Camera in atmosphere
            command.shaderProgram = this._spSkyFromAtmosphere;
        }

        return command;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof SkyAtmosphere
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see SkyAtmosphere#destroy
     */
    SkyAtmosphere.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof SkyAtmosphere
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see SkyAtmosphere#isDestroyed
     *
     * @example
     * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();
     */
    SkyAtmosphere.prototype.destroy = function() {
        var command = this._command;
        command.vertexArray = command.vertexArray && command.vertexArray.destroy();
        this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.release();
        this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.release();
        return destroyObject(this);
    };

    return SkyAtmosphere;
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/SkyBoxFS',[],function() {
    
    return "uniform samplerCube u_cubeMap;\n\
uniform float u_morphTime;\n\
\n\
varying vec3 v_texCoord;\n\
\n\
void main()\n\
{\n\
    vec3 rgb = textureCube(u_cubeMap, normalize(v_texCoord)).rgb;\n\
    gl_FragColor = vec4(rgb, u_morphTime);\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/SkyBoxVS',[],function() {
    
    return "attribute vec3 position;\n\
\n\
varying vec3 v_texCoord;\n\
\n\
void main()\n\
{\n\
    vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n\
    gl_Position = czm_projection * vec4(p, 1.0);\n\
    v_texCoord = position.xyz;\n\
}\n\
";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ViewportQuadFS',[],function() {
    
    return "uniform sampler2D u_texture;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main()\n\
{\n\
    vec4 c = texture2D(u_texture, v_textureCoordinates);\n\
    \n\
    if (c.a == 0.0)\n\
    {\n\
        discard;\n\
    }\n\
    \n\
    gl_FragColor = c;\n\
}";
});
// This file is automatically rebuilt by the Cesium build process.
/*global define*/
define('Shaders/ViewportQuadVS',[],function() {
    
    return "attribute vec4 position;\n\
attribute vec2 textureCoordinates;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main() \n\
{\n\
    gl_Position = position;\n\
    v_textureCoordinates = textureCoordinates;\n\
}";
});
/*global define*/
define('Scene/ViewportQuad',[
        '../Core/destroyObject',
        '../Core/defaultValue',
        '../Core/BoundingRectangle',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Renderer/BlendEquation',
        '../Renderer/BlendFunction',
        '../Renderer/CommandLists',
        '../Renderer/DrawCommand',
        '../Shaders/ViewportQuadVS',
        '../Shaders/ViewportQuadFS'
    ], function(
        destroyObject,
        defaultValue,
        BoundingRectangle,
        ComponentDatatype,
        PrimitiveType,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        CommandLists,
        DrawCommand,
        ViewportQuadVS,
        ViewportQuadFS) {
    

    /**
     * DOC_TBA
     *
     * @alias ViewportQuad
     * @constructor
     */
    var ViewportQuad = function(rectangle, vertexShaderSource, fragmentShaderSource) {
        /**
         * DOC_TBA
         */
        this.renderState = undefined;

        /**
         * DOC_TBA
         */
        this.enableBlending = false;

        this._va = undefined;
        this._overlayCommand = new DrawCommand();
        this._overlayCommand.primitiveType = PrimitiveType.TRIANGLE_FAN;
        this._commandLists = new CommandLists();
        this._commandLists.overlayList.push(this._overlayCommand);

        this._vertexShaderSource = defaultValue(vertexShaderSource, ViewportQuadVS);
        this._fragmentShaderSource = defaultValue(fragmentShaderSource, ViewportQuadFS);

        this._texture = undefined;
        this._destroyTexture = true;

        this._framebuffer = undefined;
        this._destroyFramebuffer = false;

        this._rectangle = BoundingRectangle.clone(rectangle);

        var that = this;
        this._overlayCommand.uniformMap = this.uniforms = {
            u_texture : function() {
                return that._texture;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getRectangle = function() {
        return this._rectangle;
    };

    /**
     * DOC_TBA
     *
     * @memberof ViewportQuad
     *
     * @param {BoundingRectangle} value DOC_TBA
     */
    ViewportQuad.prototype.setRectangle = function(value) {
        BoundingRectangle.clone(value, this._rectangle);
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setTexture = function(value) {
        if (this._texture !== value) {
            this._texture = this._destroyTexture && this._texture && this._texture.destroy();
            this._texture = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyTexture = function() {
        return this._destroyTexture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyTexture = function(value) {
        this._destroyTexture = value;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getFramebuffer = function() {
        return this._framebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setFramebuffer = function(value) {
        if (this._framebuffer !== value) {
            this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();
            this._framebuffer = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyFramebuffer = function() {
        return this._destroyFramebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyFramebuffer = function(value) {
        this._destroyFramebuffer = value;
    };

    var attributeIndices = {
        position : 0,
        textureCoordinates : 1
    };

    var vertexArrayCache = {};

    function getVertexArray(context) {
        // Per-context cache for viewport quads
        var c = vertexArrayCache[context.getId()];

        if (typeof c !== 'undefined' &&
            typeof c.vertexArray !== 'undefined') {

            ++c.referenceCount;
            return c;
        }

        var mesh = {
            attributes : {
                position : {
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 2,
                    values : [
                       -1.0, -1.0,
                        1.0, -1.0,
                        1.0,  1.0,
                       -1.0,  1.0
                    ]
                },

                textureCoordinates : {
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 2,
                    values : [
                        0.0, 0.0,
                        1.0, 0.0,
                        1.0, 1.0,
                        0.0, 1.0
                    ]
                }
            }
        };

        var va = context.createVertexArrayFromMesh({
            mesh : mesh,
            attributeIndices : attributeIndices,
            bufferUsage : BufferUsage.STATIC_DRAW
        });

        var cachedVA = {
            vertexArray : va,
            referenceCount : 1,

            release : function() {
                if (typeof this.vertexArray !== 'undefined' &&
                    --this.referenceCount === 0) {

                    // TODO: Schedule this for a few hundred frames later so we don't thrash the cache
                    this.vertexArray = this.vertexArray.destroy();
                }

                return undefined;
            }
        };

        vertexArrayCache[context.getId()] = cachedVA;
        return cachedVA;
    }

    /**
     * @private
     */
    ViewportQuad.prototype.update = function(context, frameState, commandList) {
        if (typeof this._texture === 'undefined') {
            return;
        }

        if (typeof this._overlayCommand.shaderProgram === 'undefined') {
            this._overlayCommand.shaderProgram = context.getShaderCache().getShaderProgram(this._vertexShaderSource, this._fragmentShaderSource, attributeIndices);
            this._va = getVertexArray(context);
            this._overlayCommand.vertexArray = this._va.vertexArray;
            this.renderState = context.createRenderState({
                blending : {
                    enabled : true,
                    equationRgb : BlendEquation.ADD,
                    equationAlpha : BlendEquation.ADD,
                    functionSourceRgb : BlendFunction.SOURCE_ALPHA,
                    functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
                    functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
                    functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
                }
            });
        }

        this.renderState.blending.enabled = this.enableBlending;
        this.renderState.viewport = this._rectangle;
        this._overlayCommand.renderState = this.renderState;
        this._overlayCommand.framebuffer = this._framebuffer;

        if (frameState.passes.overlay) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof ViewportQuad
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ViewportQuad#destroy
     */
    ViewportQuad.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof ViewportQuad
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see ViewportQuad#isDestroyed
     *
     * @example
     * quad = quad && quad.destroy();
     */
    ViewportQuad.prototype.destroy = function() {
        this._va = this._va && this._va.release();
        this._overlayCommand.shaderProgram = this._overlayCommand.shaderProgram && this._overlayCommand.shaderProgram.release();
        this._texture = this._destroyTexture && this._texture && this._texture.destroy();
        this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();

        return destroyObject(this);
    };

    return ViewportQuad;
});

/*global define*/
define('Scene/PerformanceDisplay',[
        '../Core/destroyObject',
        '../Core/BoundingRectangle',
        '../Renderer/PixelFormat',
        './ViewportQuad'
    ], function(
        destroyObject,
        BoundingRectangle,
        PixelFormat,
        ViewportQuad) {
    

    /**
     * Draws a display in the top left corner of the scene displaying FPS (frames per second),
     * averaged over 1 second intervals, as well as unaveraged frame time.
     *
     * @alias PerformanceDisplay
     * @constructor
     *
     * @param {Color} [description.fpsColor] The color of the FPS graph.
     * @param {Color} [description.frameTimeColor] The color of the frame time graph.
     * @param {Color} [description.backgroundColor] The color of the background of the display.
     * @param {String} [description.font] The CSS font of the text in the display.
     * @param {BoundingRectangle} [description.rectangle] The position and size of the display, relative to the top left corner.
     *
     * @example
     * scene.getPrimitives().add(new PerformanceDisplay());
     */
    var PerformanceDisplay = function(description) {
        if (typeof description === 'undefined') {
            description = {};
        }

        this._fpsColor = typeof description.fpsColor !== 'undefined' ? description.fpsColor.toCSSColor() : '#e52';
        this._frameTimeColor = typeof description.frameTimeColor !== 'undefined' ? description.frameTimeColor.toCSSColor() : '#de3';
        this._backgroundColor = typeof description.backgroundColor !== 'undefined' ? description.backgroundColor.toCSSColor() : 'rgba(0, 0, 30, 0.9)';
        this._font = typeof description.font !== 'undefined' ? description.font : 'bold 10px Helvetica,Arial,sans-serif';
        this._rectangle = typeof description.rectangle !== 'undefined' ? description.rectangle : new BoundingRectangle(0, 0, 80, 40);

        this._canvas = document.createElement('canvas');
        this._canvas.width = this._rectangle.width;
        this._canvas.height = this._rectangle.height;

        this._canvasContext = this._canvas.getContext('2d');
        this._canvasContext.font = this._font;
        this._canvasContext.lineWidth = 1;

        this._bufferLength = this._rectangle.width;
        this._frameTimeSamples = new Array(this._bufferLength);
        this._fpsSamples = new Array(this._bufferLength);

        for ( var i = 0; i < this._bufferLength; i++) {
            this._frameTimeSamples[i] = this._fpsSamples[i] = 0;
        }

        this._frameTimeIndex = 0;
        this._fpsIndex = 0;
        this._lastFpsSampleTime = undefined;
        this._frameCount = 0;

        this._quad = new ViewportQuad(new BoundingRectangle(0, 0, 0, 0));
        this._quad.enableBlending = true;

        this._time = undefined;
        this._texture = undefined;
        this._viewportHeight = 0;
    };

    /**
     * Update the display.  This function should only be called once per frame, because
     * each call records a frame in the internal buffer and redraws the display.
     */
    PerformanceDisplay.prototype.update = function(context, frameState, commandList) {
        if (typeof this._time === 'undefined') {
            //first update
            this._lastFpsSampleTime = this._time = Date.now();
            return;
        }

        var previousTime = this._time;
        var time = this._time = Date.now();

        var frameTime = time - previousTime;
        this._frameTimeSamples[this._frameTimeIndex++] = frameTime;

        if (this._frameTimeIndex >= this._bufferLength) {
            this._frameTimeIndex = 0;
        }

        this._frameCount++;
        var fps = this._fps;
        var fpsElapsedTime = time - this._lastFpsSampleTime;
        if (fpsElapsedTime > 1000) {
            fps = this._fps = this._frameCount * 1000 / fpsElapsedTime | 0;
            this._fpsSamples[this._fpsIndex++] = fps;

            if (this._fpsIndex >= this._bufferLength) {
                this._fpsIndex = 0;
            }

            this._lastFpsSampleTime = time;
            this._frameCount = 0;
        }

        var ctx = this._canvasContext;
        var canvasWidth = this._rectangle.width;
        var canvasHeight = this._rectangle.height;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = this._backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        if (typeof fps !== 'undefined') {
            ctx.fillStyle = this._fpsColor;
            ctx.textAlign = 'left';
            ctx.fillText(fps + ' FPS', 1, 10);
        }

        ctx.fillStyle = this._frameTimeColor;
        ctx.textAlign = 'right';
        ctx.fillText(frameTime + ' MS', canvasWidth - 1, 10);

        for ( var i = 0; i < this._bufferLength; i++) {
            fps = this._fpsSamples[(i + this._fpsIndex) % this._bufferLength];
            if (fps > 0) {
                this._drawLine(this._fpsColor, i, fps / 100);
            }

            frameTime = this._frameTimeSamples[(i + this._frameTimeIndex) % this._bufferLength];
            if (frameTime > 0) {
                this._drawLine(this._frameTimeColor, i, frameTime / 200);
            }
        }

        if (typeof this._texture === 'undefined') {
            this._texture = context.createTexture2D({
                source : this._canvas,
                pixelFormat : PixelFormat.RGBA
            });
            this._quad.setTexture(this._texture);
        } else {
            this._texture.copyFrom(this._canvas);
        }

        var viewportHeight = context.getCanvas().clientHeight;
        if (viewportHeight !== this._viewportHeight) {
            this._viewportHeight = viewportHeight;
            this._quad.setRectangle(new BoundingRectangle(this._rectangle.x, viewportHeight - canvasHeight - this._rectangle.y, canvasWidth, canvasHeight));
        }

        this._quad.update(context, frameState, commandList);
    };

    PerformanceDisplay.prototype._drawLine = function(style, x, valuePercent) {
        var ctx = this._canvasContext;
        var canvasHeight = this._rectangle.height;
        var maxGraphHeight = canvasHeight - 10;

        x = 0.5 + x;
        ctx.beginPath();
        ctx.strokeStyle = style;
        ctx.moveTo(x, canvasHeight);

        var lineHeight = valuePercent * maxGraphHeight;
        if (lineHeight > maxGraphHeight) {
            lineHeight = maxGraphHeight;
        }

        var y = canvasHeight - lineHeight;
        ctx.lineTo(x, y);
        ctx.stroke();
    };

    /**
     * Destroys the WebGL resources held by this object.
     */
    PerformanceDisplay.prototype.destroy = function() {
        this._quad = this._quad.destroy();
        return destroyObject(this);
    };

    return PerformanceDisplay;
});

/**
 * @author sole / http://soledadpenades.com
 * @author mr.doob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 */

/*global define*/
define('ThirdParty/Tween',[],function() {

var TWEEN = TWEEN || ( function () {

	var _interval = null, _fps = 60, _autostart = false, _tweens = [];

	return {

		setFPS: function ( fps ) {

			_fps = fps || 60;

		},

		start: function ( fps ) {

			if ( fps ) {

				this.setFPS( fps );

			}

			if ( _interval === null ) {

				_interval = setInterval( this.update, 1000 / _fps );

			}

		},

		stop: function () {

			clearInterval( _interval );

			_interval = null;

		},

		setAutostart: function ( value ) {

			_autostart = value;

			if ( _autostart && _tweens.length ) {

				this.start();

			}

		},

		add: function ( tween ) {

			_tweens.push( tween );

			if ( _autostart ) {

				this.start();

			}

		},

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			var i = 0, num_tweens = _tweens.length, time = time || Date.now();

			while ( i < num_tweens ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );
					num_tweens--;

				}

			}

			if ( num_tweens === 0 && _autostart ) {

				TWEEN.stop();

			}

		}

	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object,
	_valuesStart = {},
	_valuesDelta = {},
	_valuesEnd = {},
	_duration = 1000,
	_delayTime = 0,
	_startTime = null,
	_easingFunction = TWEEN.Easing.Linear.EaseNone,
	_chainedTween = null,
	_onUpdateCallback = null,
	_onCompleteCallback = null;

	this.to = function ( properties, duration ) {

		if( duration !== null ) {

			_duration = duration;

		}

		for ( var property in properties ) {

			// This prevents the engine from interpolating null values
			if ( _object[ property ] === null ) {

				continue;

			}

			// The current values are read when the tween starts;
			// here we only store the final desired values
			_valuesEnd[ property ] = properties[ property ];

		}

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_startTime = time ? time + _delayTime : Date.now() + _delayTime;

		for ( var property in _valuesEnd ) {

			// Again, prevent dealing with null values
			if ( _object[ property ] === null ) {

				continue;

			}

			_valuesStart[ property ] = _object[ property ];
			_valuesDelta[ property ] = _valuesEnd[ property ] - _object[ property ];

		}

		return this;
	};

	this.stop = function () {

		TWEEN.remove( this );
		return this;

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.chain = function ( chainedTween ) {

		_chainedTween = chainedTween;
		return this;

	};

	this.onUpdate = function ( onUpdateCallback ) {

		_onUpdateCallback = onUpdateCallback;
		return this;

	};

	this.onComplete = function ( onCompleteCallback ) {

		_onCompleteCallback = onCompleteCallback;
		return this;

	};

	this.update = function ( time ) {

		var property, elapsed, value;

		if ( time < _startTime ) {

			return true;

		}

		elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction( elapsed );

		for ( property in _valuesDelta ) {

			_object[ property ] = _valuesStart[ property ] + _valuesDelta[ property ] * value;

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _onCompleteCallback !== null ) {

				_onCompleteCallback.call( _object );

			}

			if ( _chainedTween !== null ) {

				_chainedTween.start();

			}

			return false;

		}

		return true;

	};

	/*
	this.destroy = function () {

		TWEEN.remove( this );

	};
	*/
};

TWEEN.Easing = { Linear: {}, Quadratic: {}, Cubic: {}, Quartic: {}, Quintic: {}, Sinusoidal: {}, Exponential: {}, Circular: {}, Elastic: {}, Back: {}, Bounce: {} };


TWEEN.Easing.Linear.EaseNone = function ( k ) {

	return k;

};

//

TWEEN.Easing.Quadratic.EaseIn = function ( k ) {

	return k * k;

};

TWEEN.Easing.Quadratic.EaseOut = function ( k ) {

	return k * ( 2 - k );

};

TWEEN.Easing.Quadratic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
	return - 0.5 * ( --k * ( k - 2 ) - 1 );

};

//

TWEEN.Easing.Cubic.EaseIn = function ( k ) {

	return k * k * k;

};

TWEEN.Easing.Cubic.EaseOut = function ( k ) {

	return --k * k * k + 1;

};

TWEEN.Easing.Cubic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k + 2 );

};

//

TWEEN.Easing.Quartic.EaseIn = function ( k ) {

	return k * k * k * k;

};

TWEEN.Easing.Quartic.EaseOut = function ( k ) {

	return 1 - --k * k * k * k;

};

TWEEN.Easing.Quartic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
	return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

};

//

TWEEN.Easing.Quintic.EaseIn = function ( k ) {

	return k * k * k * k * k;

};

TWEEN.Easing.Quintic.EaseOut = function ( k ) {

	return --k * k * k * k * k + 1;

};

TWEEN.Easing.Quintic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

};

//

TWEEN.Easing.Sinusoidal.EaseIn = function ( k ) {

	return 1 - Math.cos( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseOut = function ( k ) {

	return Math.sin( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseInOut = function ( k ) {

	return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

};

//

TWEEN.Easing.Exponential.EaseIn = function ( k ) {

	return k === 0 ? 0 : Math.pow( 1024, k - 1 );

};

TWEEN.Easing.Exponential.EaseOut = function ( k ) {

	return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

};

TWEEN.Easing.Exponential.EaseInOut = function ( k ) {

	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
	return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

};

//

TWEEN.Easing.Circular.EaseIn = function ( k ) {

	return 1 - Math.sqrt( 1 - k * k );

};

TWEEN.Easing.Circular.EaseOut = function ( k ) {

	return Math.sqrt( 1 - --k * k );

};

TWEEN.Easing.Circular.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
	return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

};

//

TWEEN.Easing.Elastic.EaseIn = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

};

TWEEN.Easing.Elastic.EaseOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

};

TWEEN.Easing.Elastic.EaseInOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
	return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

};

//

TWEEN.Easing.Back.EaseIn = function ( k ) {

	var s = 1.70158;
	return k * k * ( ( s + 1 ) * k - s );

};

TWEEN.Easing.Back.EaseOut = function ( k ) {

	var s = 1.70158;
	return --k * k * ( ( s + 1 ) * k + s ) + 1;

};

TWEEN.Easing.Back.EaseInOut = function ( k ) {

	var s = 1.70158 * 1.525;
	if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
	return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

};

//

TWEEN.Easing.Bounce.EaseIn = function ( k ) {

	return 1 - TWEEN.Easing.Bounce.EaseOut( 1 - k );

};

TWEEN.Easing.Bounce.EaseOut = function ( k ) {

	if ( k < ( 1 / 2.75 ) ) {

		return 7.5625 * k * k;

	} else if ( k < ( 2 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

	} else if ( k < ( 2.5 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

	} else {

		return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

	}

};

TWEEN.Easing.Bounce.EaseInOut = function ( k ) {

	if ( k < 0.5 ) return TWEEN.Easing.Bounce.EaseIn( k * 2 ) * 0.5;
	return TWEEN.Easing.Bounce.EaseOut( k * 2 - 1 ) * 0.5 + 0.5;

};

return TWEEN;
});

/*global define*/
define('Scene/AnimationCollection',[
        '../Core/DeveloperError',
        '../Core/clone',
        '../ThirdParty/Tween'
    ], function(
        DeveloperError,
        clone,
        Tween) {
    

    /**
     * DOC_TBA
     *
     * @alias AnimationCollection
     * @constructor
     */
    var AnimationCollection = function() {
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.add = function(template) {
        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = clone(t.startValue);
        var tween = new Tween.Tween(value);
        tween.to(t.stopValue, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        if (t.onUpdate) {
            tween.onUpdate(function() {
                t.onUpdate(value);
            });
        }
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material has no properties with alpha components.
     */
    AnimationCollection.prototype.addAlpha = function(material, start, stop, template) {
        if (typeof material === 'undefined') {
            throw new DeveloperError('material is required.');
        }

        var properties = [];

        for ( var property in material.uniforms) {
            if (material.uniforms.hasOwnProperty(property) &&
                typeof material.uniforms[property] !== 'undefined' &&
                typeof material.uniforms[property].alpha !== 'undefined') {
                properties.push(property);
            }
        }

        if (properties.length === 0) {
            throw new DeveloperError('material has no properties with alpha components.');
        }

        // Default to fade in
        start = (typeof start === 'undefined') ? 0.0 : start;
        stop = (typeof stop === 'undefined') ? 1.0 : stop;

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            alpha : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            alpha : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            var length = properties.length;
            for ( var i = 0; i < length; ++i) {
                material.uniforms[properties[i]].alpha = value.alpha;
            }
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.addProperty = function(object, property, start, stop, template) {
        if (typeof object === 'undefined') {
            throw new DeveloperError('object is required.');
        }

        if (typeof property === 'undefined') {
            throw new DeveloperError('property is required.');
        }

        if (typeof object[property] === 'undefined') {
            throw new DeveloperError('object must have the specified property.');
        }

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            value : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            value : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            object[property] = value.value;
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material must have an offset property.
     */
    AnimationCollection.prototype.addOffsetIncrement = function(material, template) {
        if (typeof material === 'undefined') {
            throw new DeveloperError('material is required.');
        }

        if (typeof material.uniforms.offset === 'undefined') {
            throw new DeveloperError('material must have an offset property.');
        }

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            offset : material.uniforms.offset
        };
        var tween = new Tween.Tween(value);
        tween.to({
            offset : material.uniforms.offset + 1.0
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            material.uniforms.offset = value.offset;
        });
        // t.onComplete is ignored.
        tween.onComplete(function() {
            tween.to({
                offset : material.uniforms.offset + 1.0
            }, t.duration);
            tween.start();
        });
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.remove = function(animation) {
        if (typeof animation !== 'undefined') {
            var count = Tween.getAll().length;
            Tween.remove(animation._tween);

            return Tween.getAll().length === (count - 1);
        }

        return false;
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.removeAll = function() {
        Tween.removeAll();
    };

    /**
     * DOC_TBA
     * @memberof Animationcollection
     */
    AnimationCollection.prototype.contains = function(animation) {
        if (typeof animation !== 'undefined') {
            return Tween.getAll().indexOf(animation) !== -1;
        }
        return false;
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.update = function() {
        Tween.update();
    };

    return AnimationCollection;
});
/*global define*/
define('Scene/Camera2DController',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Cartesian2',
        '../Core/Cartographic',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers',
        './AnimationCollection',
        '../ThirdParty/Tween'
    ], function(
        DeveloperError,
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Matrix3,
        Cartesian2,
        Cartographic,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers,
        AnimationCollection,
        Tween) {
    

    var move = CameraHelpers.move;
    var maintainInertia = CameraHelpers.maintainInertia;
    var handleZoom = CameraHelpers.handleZoom;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and manipulating a camera's orthographic frustum for a zooming effect.
     *
     * @alias Camera2DController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {DOC_TBA} projection The projection of the map the camera is moving around..
     *
     * @exception {DeveloperError} canvas is required.
     * @exception {DeveloperError} camera is required.
     * @exception {DeveloperError} projection is required.
     *
     * @internalConstructor
     */
    var Camera2DController = function(canvas, camera, projection) {
        if (typeof canvas === 'undefined') {
            throw new DeveloperError('canvas is required.');
        }

        if (typeof camera === 'undefined') {
            throw new DeveloperError('camera is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        /**
         * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.
         * @type Boolean
         */
        this.enableTranslate = true;

        /**
         * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.
         * @type Boolean
         */
        this.enableZoom = true;

        /**
         * If true, allows the user to rotate the camera.  If false, the camera is locked to the current heading.
         * @type Boolean
         */
        this.enableRotate = true;

        this._canvas = canvas;
        this._camera = camera;
        this._projection = projection;
        this._zoomRate = 100000.0;
        this._moveRate = 100000.0;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        this._zoomFactor = 1.5;
        this._translateFactor = 1.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);
        this._twistHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);

        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaTranslateMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;

        this._frustum = this._camera.frustum.clone();
        this._animationCollection = new AnimationCollection();
        this._zoomAnimation = undefined;
        this._translateAnimation = undefined;

        this._frustum = this._camera.frustum.clone();
        this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO, 0.0));

        var maxZoomOut = 2.0;
        var ratio = this._frustum.top / this._frustum.right;
        this._frustum.right = this._maxCoord.x * maxZoomOut;
        this._frustum.left = -this._frustum.right;
        this._frustum.top = ratio * this._frustum.right;
        this._frustum.bottom = -this._frustum.top;

        this._maxZoomFactor = 2.5;
        this._maxTranslateFactor = 1.5;
    };

    /**
     * Returns the projection of the map that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @returns {DOC_TBA} The projection of the map that the camera is moving around.
     *
     * @see Camera2DController#setProjection
     */
    Camera2DController.prototype.getProjection = function() {
        return this._projection;
    };

    /**
     * Sets the projection of the map that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @param {DOC_TBA} projection The projection of the map that the camera is moving around.
     *
     * @exception {DeveloperError} projection is required.
     *
     * @see Camera2DController#getProjection
     */
    Camera2DController.prototype.setProjection = function(projection) {
        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        this._projection = projection;
        this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.toRadians(85.05112878)));
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveDown
     */
    Camera2DController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveUp
     */
    Camera2DController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveLeft
     */
    Camera2DController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveRight
     */
    Camera2DController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomOut
     */
    Camera2DController.prototype.zoomIn = function(rate) {
        var moveRate = rate || this._zoomRate;
        var frustum = this._camera.frustum;

        if (typeof frustum.left === 'undefined' || typeof frustum.right === 'undefined' ||
            typeof frustum.top === 'undefined' || typeof frustum.bottom === 'undefined') {
            throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
        }

        var newRight = frustum.right - moveRate;
        var newLeft = frustum.left + moveRate;

        var maxRight = this._maxCoord.x * this._maxZoomFactor;
        if (newRight > maxRight) {
            newRight = maxRight;
            newLeft = -newRight;
        }

        if (newRight > newLeft) {
            var ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }
    };

    /**
     * Moves the camera to the provided cartographic position.
     * @memberof Camera2DController
     *
     * @param {Cartographic} cartographic The new camera position.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Camera2DController.prototype.setPositionCartographic = function(cartographic) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required.');
        }

        var newLeft = -cartographic.height * 0.5;
        var newRight = -newLeft;

        var frustum = this._camera.frustum;
        if (newRight > newLeft) {
            var ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }

        //We use Cartesian2 instead of 3 here because Z must be constant in 2D mode.
        Cartesian2.clone(this._projection.project(cartographic), this._camera.position);
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomIn
     */
    Camera2DController.prototype.zoomOut = function(rate) {
        this.zoomIn(-rate || -this._zoomRate);
    };

    Camera2DController.prototype._addCorrectZoomAnimation = function() {
        var camera = this._camera;
        var frustum = camera.frustum;
        var top = frustum.top;
        var bottom = frustum.bottom;
        var right = frustum.right;
        var left = frustum.left;

        var startFrustum = this._frustum;

        var update2D = function(value) {
            camera.frustum.top = CesiumMath.lerp(top, startFrustum.top, value.time);
            camera.frustum.bottom = CesiumMath.lerp(bottom, startFrustum.bottom, value.time);
            camera.frustum.right = CesiumMath.lerp(right, startFrustum.right, value.time);
            camera.frustum.left = CesiumMath.lerp(left, startFrustum.left, value.time);
        };

        this._zoomAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update2D
        });
    };

    Camera2DController.prototype._addCorrectTranslateAnimation = function() {
        var camera = this._camera;
        var currentPosition = camera.position;
        var translatedPosition = currentPosition.clone();

        if (translatedPosition.x > this._maxCoord.x) {
            translatedPosition.x = this._maxCoord.x;
        } else if (translatedPosition.x < -this._maxCoord.x) {
            translatedPosition.x = -this._maxCoord.x;
        }

        if (translatedPosition.y > this._maxCoord.y) {
            translatedPosition.y = this._maxCoord.y;
        } else if (translatedPosition.y < -this._maxCoord.y) {
            translatedPosition.y = -this._maxCoord.y;
        }

        var update2D = function(value) {
            camera.position = currentPosition.lerp(translatedPosition, value.time);
        };

        this._translateAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update2D
        });
    };

    /**
     * @private
     */
    Camera2DController.prototype.update = function() {
        var translate = this._translateHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var translating = translate.isMoving() && translate.getMovement();
        var rightZooming = rightZoom.isMoving();
        var wheelZooming = wheelZoom.isMoving();

        if (translate.isButtonDown() || rightZoom.isButtonDown() || wheelZooming) {
            this._animationCollection.removeAll();
        }

        if (this.enableTranslate) {
            if (translating) {
                this._translate(translate.getMovement());
            }

            if (!translating && this.inertiaTranslate < 1.0) {
                maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
            }
        }

        if (this.enableZoom) {
            if (rightZooming) {
                this._zoom(rightZoom.getMovement());
            } else if (wheelZooming) {
                this._zoom(wheelZoom.getMovement());
            }

            if (!rightZooming && this.inertiaZoom < 1.0) {
                maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
            }

            if (!wheelZooming && this.inertiaZoom < 1.0) {
                maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
            }
        }

        if (this.enableRotate) {
            if (this._twistHandler.isMoving()) {
                this._twist(this._twistHandler.getMovement());
            }
        }

        if (!translate.isButtonDown() && !rightZoom.isButtonDown()) {
            if (this._camera.frustum.right > this._frustum.right &&
                !this._lastInertiaZoomMovement && !this._animationCollection.contains(this._zoomAnimation)) {
                this._addCorrectZoomAnimation();
            }

            var position = this._camera.position;
            var translateX = position.x < -this._maxCoord.x || position.x > this._maxCoord.x;
            var translateY = position.y < -this._maxCoord.y || position.y > this._maxCoord.y;
            if ((translateX || translateY) && !this._lastInertiaTranslateMovement &&
                 !this._animationCollection.contains(this._translateAnimation)) {
                this._addCorrectTranslateAnimation();
            }
        }

        this._animationCollection.update();

        return true;
    };

    Camera2DController.prototype._translate = function(movement) {
        var frustum = this._camera.frustum;

        if (frustum.left === null || frustum.right === null ||
           frustum.top === null || frustum.bottom === null) {
            throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
        }

        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var start = new Cartesian2();
        start.x = (movement.startPosition.x / width) * (frustum.right - frustum.left) + frustum.left;
        start.y = ((height - movement.startPosition.y) / height) * (frustum.top - frustum.bottom) + frustum.bottom;

        var end = new Cartesian2();
        end.x = (movement.endPosition.x / width) * (frustum.right - frustum.left) + frustum.left;
        end.y = ((height - movement.endPosition.y) / height) * (frustum.top - frustum.bottom) + frustum.bottom;

        var camera = this._camera;
        var right = camera.right;
        var up = camera.up;
        var position;
        var newPosition;

        var distance = start.subtract(end);
        if (distance.x !== 0) {
            position = camera.position;
            newPosition = position.add(right.multiplyByScalar(distance.x));

            var maxX = this._maxCoord.x * this._maxTranslateFactor;
            if (newPosition.x > maxX) {
                newPosition.x = maxX;
            }
            if (newPosition.x < -maxX) {
                newPosition.x = -maxX;
            }

            camera.position = newPosition;
        }
        if (distance.y !== 0) {
            position = camera.position;
            newPosition = position.add(up.multiplyByScalar(distance.y));

            var maxY = this._maxCoord.y * this._maxTranslateFactor;
            if (newPosition.y > maxY) {
                newPosition.y = maxY;
            }
            if (newPosition.y < -maxY) {
                newPosition.y = -maxY;
            }

            camera.position = newPosition;
        }
    };

    Camera2DController.prototype._zoom = function(movement) {
        var camera = this._camera;
        var mag = Math.max(camera.frustum.right - camera.frustum.left, camera.frustum.top - camera.frustum.bottom);
        handleZoom(this, movement, mag);
    };

    Camera2DController.prototype._twist = function(movement) {
        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var start = new Cartesian2();
        start.x = (2.0 / width) * movement.startPosition.x - 1.0;
        start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;
        start = start.normalize();

        var end = new Cartesian2();
        end.x = (2.0 / width) * movement.endPosition.x - 1.0;
        end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;
        end = end.normalize();

        var startTheta = Math.acos(start.x);
        if (start.y < 0) {
            startTheta = CesiumMath.TWO_PI - startTheta;
        }
        var endTheta = Math.acos(end.x);
        if (end.y < 0) {
            endTheta = CesiumMath.TWO_PI - endTheta;
        }
        var theta = startTheta - endTheta;

        var camera = this._camera;
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(camera.direction, theta));
        camera.up = rotation.multiplyByVector(camera.up);
        camera.right = camera.direction.cross(camera.up);
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof Camera2DController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see Camera2DController#destroy
      */
    Camera2DController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Camera2DController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera2DController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    Camera2DController.prototype.destroy = function() {
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        this._zoomWheel = this._zoomWheel && this._zoomWheel.destroy();
        this._twistHandler = this._twistHandler && this._twistHandler.destroy();
        return destroyObject(this);
    };

    return Camera2DController;
});
/*global define*/
define('Scene/CameraColumbusViewController',[
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Math',
        '../Core/Matrix4',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraHelpers',
        './AnimationCollection',
        '../ThirdParty/Tween'
    ], function(
        destroyObject,
        Ellipsoid,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        CesiumMath,
        Matrix4,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleController,
        CameraFreeLookController,
        CameraHelpers,
        AnimationCollection,
        Tween) {
    

    var maintainInertia = CameraHelpers.maintainInertia;
    var handleZoom = CameraHelpers.handleZoom;

    /**
     * DOC_TBD
     * @alias CameraColumbusViewController
     * @constructor
     */
    var CameraColumbusViewController = function(canvas, camera, ellipsoid) {
        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid || Ellipsoid.WGS84;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With a value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._rotateHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);

        // TODO: Separate mouse behaviour from mouse handling.
        this._spindleController = new CameraSpindleController(canvas, camera, Ellipsoid.UNIT_SPHERE);
        this._spindleController.constrainedAxis = Cartesian3.UNIT_Z;

        this._freeLookController = new CameraFreeLookController(canvas, camera);
        this._freeLookController.horizontalRotationAxis = Cartesian3.UNIT_Z;

        this._transform = this._camera.transform.clone();
        this._lastInertiaTranslateMovement = undefined;

        this._animationCollection = new AnimationCollection();
        this._translateAnimation = undefined;

        this._mapWidth = this._ellipsoid.getRadii().x * Math.PI;
        this._mapHeight = this._ellipsoid.getRadii().y * CesiumMath.PI_OVER_TWO;
    };

    /**
     * @private
     */
    CameraColumbusViewController.prototype.update = function() {
        var translate = this._translateHandler;
        var translating = translate.isMoving() && translate.getMovement();
        var rotate = this._rotateHandler;
        var rotating = rotate.isMoving() && rotate.getMovement();
        var zoom = this._zoomHandler;
        var zoomimg = zoom && zoom.isMoving();

        if (rotating) {
            this._rotate(rotate.getMovement());
        }

        var buttonDown = translate.isButtonDown() || rotate.isButtonDown() ||
            rotate.isButtonDown() || this._freeLookController._handler.isButtonDown();
        if (buttonDown) {
            this._animationCollection.removeAll();
        }

        if (translating) {
            this._translate(translate.getMovement());
        }

        if (!translating && this.inertiaTranslate < 1.0) {
            maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
        }

        if (zoomimg) {
            this._zoom(zoom.getMovement());
        }

        if (zoom && !zoomimg && this.inertiaZoom < 1.0) {
            maintainInertia(zoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        this._freeLookController.update();

        if (!buttonDown) {
            this._correctPosition();
        }

        this._animationCollection.update();

        return true;
    };

    CameraColumbusViewController.prototype._addCorrectTranslateAnimation = function(position, center, maxX, maxY) {
        var newPosition = position.clone();

        if (center.y > maxX) {
            newPosition.y -= center.y - maxX;
        } else if (center.y < -maxX) {
            newPosition.y += -maxX - center.y;
        }

        if (center.z > maxY) {
            newPosition.z -= center.z - maxY;
        } else if (center.z < -maxY) {
            newPosition.z += -maxY - center.z;
        }

        var camera = this._camera;
        var updateCV = function(value) {
            var interp = position.lerp(newPosition, value.time);
            var pos = new Cartesian4(interp.x, interp.y, interp.z, 1.0);
            camera.position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(pos));
        };

        this._translateAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : updateCV
        });
    };

    CameraColumbusViewController.prototype._translate = function(movement) {
        var camera = this._camera;
        var sign = (camera.direction.dot(Cartesian3.UNIT_Z) >= 0) ? 1.0 : -1.0;

        var startRay = camera.getPickRay(movement.startPosition);
        var endRay = camera.getPickRay(movement.endPosition);

        var normal = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(Cartesian4.UNIT_X));

        var position = new Cartesian4(startRay.origin.x, startRay.origin.y, startRay.origin.z, 1.0);
        position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(position));
        var direction = new Cartesian4(startRay.direction.x, startRay.direction.y, startRay.direction.z, 0.0);
        direction = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(direction));
        var scalar = sign * normal.dot(position) / normal.dot(direction);
        var startPlanePos = position.add(direction.multiplyByScalar(scalar));

        position = new Cartesian4(endRay.origin.x, endRay.origin.y, endRay.origin.z, 1.0);
        position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(position));
        direction = new Cartesian4(endRay.direction.x, endRay.direction.y, endRay.direction.z, 0.0);
        direction = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(direction));
        scalar = sign * normal.dot(position) / normal.dot(direction);
        var endPlanePos = position.add(direction.multiplyByScalar(scalar));

        var diff = startPlanePos.subtract(endPlanePos);
        camera.position = camera.position.add(diff);
    };

    CameraColumbusViewController.prototype._correctPosition = function()
    {
        var camera = this._camera;
        var position = camera.position;
        var direction = camera.direction;

        var normal = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(Cartesian4.UNIT_X));
        var scalar = -normal.dot(position) / normal.dot(direction);
        var center = position.add(direction.multiplyByScalar(scalar));
        center = new Cartesian4(center.x, center.y, center.z, 1.0);
        var centerWC = camera.transform.multiplyByVector(center);
        this._transform.setColumn(3, centerWC, this._transform);

        var cameraPosition = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        var positionWC = camera.transform.multiplyByVector(cameraPosition);

        var tanPhi = Math.tan(this._camera.frustum.fovy * 0.5);
        var tanTheta = this._camera.frustum.aspectRatio * tanPhi;
        var distToC = positionWC.subtract(centerWC).magnitude();
        var dWidth = tanTheta * distToC;
        var dHeight = tanPhi * distToC;

        var maxX = Math.max(dWidth - this._mapWidth, this._mapWidth);
        var maxY = Math.max(dHeight - this._mapHeight, this._mapHeight);

        if (positionWC.x < -maxX || positionWC.x > maxX || positionWC.y < -maxY || positionWC.y > maxY) {
            if (!this._translateHandler.isButtonDown()) {
                var translateX = centerWC.y < -maxX || centerWC.y > maxX;
                var translateY = centerWC.z < -maxY || centerWC.z > maxY;
                if ((translateX || translateY) && !this._lastInertiaTranslateMovement &&
                        !this._animationCollection.contains(this._translateAnimation)) {
                    this._addCorrectTranslateAnimation(Cartesian3.fromCartesian4(positionWC), Cartesian3.fromCartesian4(centerWC), maxX, maxY);
                }
            }

            maxX = maxX + this._mapWidth * 0.5;
            if (centerWC.y > maxX) {
                positionWC.y -= centerWC.y - maxX;
            } else if (centerWC.y < -maxX) {
                positionWC.y += -maxX - centerWC.y;
            }

            maxY = maxY + this._mapHeight * 0.5;
            if (centerWC.z > maxY) {
                positionWC.z -= centerWC.z - maxY;
            } else if (centerWC.z < -maxY) {
                positionWC.z += -maxY - centerWC.z;
            }
        }

        camera.position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(positionWC));
    };

    CameraColumbusViewController.prototype._rotate = function(movement) {
        var camera = this._camera;

        var position = camera.getPositionWC();
        var up = camera.getUpWC();
        var right = camera.getRightWC();
        var direction = camera.getDirectionWC();

        var oldTransform = camera.transform;
        camera.transform = this._transform;

        var invTransform = camera.getInverseTransform();
        camera.position = Cartesian3.fromCartesian4(invTransform.multiplyByPoint(position));
        camera.up = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));

        this._spindleController._rotate(movement);

        position = camera.getPositionWC();
        up = camera.getUpWC();
        right = camera.getRightWC();
        direction = camera.getDirectionWC();

        camera.transform = oldTransform;
        var transform = camera.getInverseTransform();

        camera.position = Cartesian3.fromCartesian4(transform.multiplyByPoint(position));
        camera.up = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));
    };

    CameraColumbusViewController.prototype._zoom = function(movement) {
        handleZoom(this._spindleController, movement, this._camera.position.z);
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraColumbusViewController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraSpindleController#destroy
      */
    CameraColumbusViewController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraColumbusViewController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraColumbusViewController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraColumbusViewController.prototype.destroy = function() {
        this._rotateHandler = this._rotateHandler && this._rotateHandler.destroy();
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._zoomHandler = this._zoomHandle && this._zoomHandler.destroy();
        this._spindleController = this._spindleController && this._spindleController.destroy();
        this._freeLookController = this._freeLookController && this._freeLookController.destroy();
        return destroyObject(this);
    };

    return CameraColumbusViewController;
});
/*global define*/
define('Scene/CameraControllerCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartographic',
        './Camera2DController',
        './CameraFlightController',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraColumbusViewController',
        './CameraCentralBodyController'
    ], function(
        DeveloperError,
        destroyObject,
        Ellipsoid,
        Cartographic,
        Camera2DController,
        CameraFlightController,
        CameraSpindleController,
        CameraFreeLookController,
        CameraColumbusViewController,
        CameraCentralBodyController) {
    

    /**
     * DOC_TBA
     *
     * @alias CameraControllerCollection
     * @internalConstructor
     *
     * @see Camera#getControllers
     */
    var CameraControllerCollection = function(camera, canvas) {
        this._controllers = [];
        this._canvas = canvas;
        this._camera = camera;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.add2D = function(projection) {
        var twoD = new Camera2DController(this._canvas, this._camera, projection);
        this._controllers.push(twoD);
        return twoD;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addSpindle = function(ellipsoid) {
        var spindle = new CameraSpindleController(this._canvas, this._camera, ellipsoid);
        this._controllers.push(spindle);
        return spindle;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFreeLook = function(ellipsoid) {
        var freeLook = new CameraFreeLookController(this._canvas, this._camera);
        this._controllers.push(freeLook);
        return freeLook;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addFreeLook
     */
    CameraControllerCollection.prototype.addColumbusView = function() {
        var cv = new CameraColumbusViewController(this._canvas, this._camera);
        this._controllers.push(cv);
        return cv;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFlight = function(template) {
        var t = template || {};
        var ellipsoid = t.ellipsoid || Ellipsoid.WGS84;
        var destination = t.destination || ellipsoid.cartographicToCartesian(new Cartographic(0.0, 0.0, 0.0));
        var duration = t.duration || 4.0;
        var complete = template.complete;
		var flightController = new CameraFlightController(this._canvas, this._camera, ellipsoid, destination, duration, complete);
		this._controllers.push(flightController);
		return flightController;
    };

    CameraControllerCollection.prototype.addCentralBody = function() {
        var cb = new CameraCentralBodyController(this._canvas, this._camera);
        this._controllers.push(cb);
        return cb;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#removeAll
     */
    CameraControllerCollection.prototype.remove = function(controller) {
        if (controller) {
            var controllers = this._controllers;
            var i = controllers.indexOf(controller);
            if (i !== -1) {
                controllers[i].destroy();
                controllers.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#remove
     */
    CameraControllerCollection.prototype.removeAll = function() {
        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            controllers[i].destroy();
        }

        this._controllers = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.contains = function(controller) {
        if (controller) {
            return (this._controllers.indexOf(controller) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#getLength
     */
    CameraControllerCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._controllers[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#get
     */
    CameraControllerCollection.prototype.getLength = function() {
        return this._controllers.length;
    };

    /**
     * @private
     */
    CameraControllerCollection.prototype.update = function() {
        var toRemove = [];

        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            if (!controllers[i].update()) {
                toRemove.push(i);
            }
        }

        // Automatically remove expired controllers
        for ( var j = 0; j < toRemove.length; ++j) {
            var index = toRemove[j];
            controllers[index].destroy();
            controllers.splice(index, 1);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return CameraControllerCollection;
});

/*global define*/
define('Scene/Camera',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/IntersectionTests',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Matrix4',
        '../Core/Ray',
        './CameraControllerCollection',
        './PerspectiveFrustum'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        Ellipsoid,
        IntersectionTests,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Matrix4,
        Ray,
        CameraControllerCollection,
        PerspectiveFrustum) {
    

    /**
     * The camera is defined by a position, orientation, and view frustum.
     * <br /><br />
     * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
     * <br /><br />
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias Camera
     *
     * @exception {DeveloperError} canvas is required.
     *
     * @constructor
     *
     * @example
     * // Create a camera looking down the negative z-axis, positioned at the origin,
     * // with a field of view of 60 degrees, and 1:1 aspect ratio.
     * var camera = new Camera(canvas);
     * camera.position = new Cartesian3();
     * camera.direction = Cartesian3.UNIT_Z.negate();
     * camera.up = Cartesian3.UNIT_Y;
     * camera.frustum.fovy = CesiumMath.PI_OVER_THREE;
     * camera.frustum.near = 1.0;
     * camera.frustum.far = 2.0;
     */
    var Camera = function(canvas) {
        if (typeof canvas === 'undefined') {
            throw new DeveloperError('canvas is required.');
        }

        /**
         * DOC_TBA
         *
         * @type {Matrix4}
         */
        this.transform = Matrix4.IDENTITY.clone();
        this._transform = this.transform.clone();
        this._invTransform = Matrix4.IDENTITY.clone();

        var maxRadii = Ellipsoid.WGS84.getMaximumRadius();
        var position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyByScalar(2.0 * maxRadii);

        /**
         * The position of the camera.
         *
         * @type {Cartesian3}
         */
        this.position = position.clone();
        this._position = position;
        this._positionWC = position;

        var direction = Cartesian3.ZERO.subtract(position).normalize();

        /**
         * The view direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.direction = direction.clone();
        this._direction = direction;
        this._directionWC = direction;

        var right = direction.cross(Cartesian3.UNIT_Z).normalize();

        /**
         * The right direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.right = right.clone();
        this._right = right;
        this._rightWC = right;

        var up = right.cross(direction);

        /**
         * The up direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.up = up.clone();
        this._up = up;
        this._upWC = up;

        /**
         * DOC_TBA
         *
         * @type {Frustum}
         */
        this.frustum = new PerspectiveFrustum();
        this.frustum.fovy = CesiumMath.toRadians(60.0);
        this.frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;

        this._viewMatrix = undefined;
        this._invViewMatrix = undefined;
        updateViewMatrix(this);

        this._canvas = canvas;
        this._controllers = new CameraControllerCollection(this, canvas);
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getControllers = function() {
        return this._controllers;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.update = function() {
        this._controllers.update();
    };

    /**
     * Sets the camera position and orientation with an eye position, target, and up vector.
     *
     * @memberof Camera
     *
     * @param {Cartesian3} eye The position of the camera.
     * @param {Cartesian3} target The position to look at.
     * @param {Cartesian3} up The up vector.
     *
     * @exception {DeveloperError} eye is required.
     * @exception {DeveloperError} target is required.
     * @exception {DeveloperError} up is required.
     */
    Camera.prototype.lookAt = function(eye, target, up) {
        if (typeof eye === 'undefined') {
            throw new DeveloperError('eye is required');
        }
        if (typeof target === 'undefined') {
            throw new DeveloperError('target is required');
        }
        if (typeof up === 'undefined') {
            throw new DeveloperError('up is required');
        }

        this.position = Cartesian3.clone(eye, this.position);
        this.direction = Cartesian3.subtract(target, eye, this.direction).normalize(this.direction);
        this.right = Cartesian3.cross(this.direction, up, this.right).normalize(this.right);
        this.up = Cartesian3.cross(this.right, this.direction, this.up);
    };

    /**
     * Zooms to a cartographic extent on the central body. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     */
    Camera.prototype.viewExtent = function(extent, ellipsoid) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        ellipsoid = (typeof ellipsoid === 'undefined') ? Ellipsoid.WGS84 : ellipsoid;

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;

        // If we go across the International Date Line
        if (west > east) {
            east += CesiumMath.TWO_PI;
        }

        var northEast = ellipsoid.cartographicToCartesian(new Cartographic(east, north));
        var southWest = ellipsoid.cartographicToCartesian(new Cartographic(west, south));
        var diagonal = northEast.subtract(southWest);
        var center = southWest.add(diagonal.normalize().multiplyByScalar(diagonal.magnitude() * 0.5));

        var northWest = ellipsoid.cartographicToCartesian(new Cartographic(west, north)).subtract(center);
        var southEast = ellipsoid.cartographicToCartesian(new Cartographic(east, south)).subtract(center);
        northEast = northEast.subtract(center);
        southWest = southWest.subtract(center);

        this.direction = center.negate().normalize();
        this.right = this.direction.cross(Cartesian3.UNIT_Z).normalize();
        this.up = this.right.cross(this.direction);

        var height = Math.max(Math.abs(this.up.dot(northWest)), Math.abs(this.up.dot(southEast)), Math.abs(this.up.dot(northEast)), Math.abs(this.up.dot(southWest)));
        var width = Math.max(Math.abs(this.right.dot(northWest)), Math.abs(this.right.dot(southEast)), Math.abs(this.right.dot(northEast)), Math.abs(this.right.dot(southWest)));

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var d = Math.max(width / tanTheta, height / tanPhi);

        this.position = center.normalize().multiplyByScalar(center.magnitude() + d);
    };

    /**
     * Zooms to a cartographic extent on the Columbus view map. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     * @exception {DeveloperError} projection is required.
     */
    Camera.prototype.viewExtentColumbusView = function(extent, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;

        var transform = this.transform.setColumn(3, Cartesian4.UNIT_W);

        var northEast = projection.project(new Cartographic(east, north));
        northEast = transform.multiplyByPoint(northEast);
        northEast = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(northEast));

        var southWest = projection.project(new Cartographic(west, south));
        southWest = transform.multiplyByPoint(southWest);
        southWest = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(southWest));

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var d = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;

        var position = projection.project(new Cartographic(0.5 * (west + east), 0.5 * (north + south), d));
        position = transform.multiplyByPoint(position);
        this.position = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(position));

        // Not exactly -z direction because that would lock the camera in place with a constrained z axis.
        this.direction = new Cartesian3(0.0, 0.0001, -0.999);
        Cartesian3.UNIT_X.clone(this.right);
        this.up = this.right.cross(this.direction);
    };

    /**
     * Zooms to a cartographic extent on the 2D map. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     * @exception {DeveloperError} projection is required.
     */
    Camera.prototype.viewExtent2D = function(extent, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;
        var lla = new Cartographic(0.5 * (west + east), 0.5 * (north + south));

        var northEast = projection.project(new Cartographic(east, north));
        var southWest = projection.project(new Cartographic(west, south));

        var width = Math.abs(northEast.x - southWest.x) * 0.5;
        var height = Math.abs(northEast.y - southWest.y) * 0.5;

        var position = projection.project(lla);
        this.position.x = position.x;
        this.position.y = position.y;

        var right, top;
        var ratio = this.frustum.right / this.frustum.top;
        var heightRatio = height * ratio;
        if (width > heightRatio) {
            right = width;
            top = right / ratio;
        } else {
            top = height;
            right = heightRatio;
        }

        this.frustum.right = right;
        this.frustum.left = -right;
        this.frustum.top = top;
        this.frustum.bottom = -top;

        //Orient the camera north.
        Cartesian3.UNIT_X.clone(this.right);
        this.up = this.right.cross(this.direction);
    };

    function updateViewMatrix(camera) {
        var r = camera._right;
        var u = camera._up;
        var d = camera._direction;
        var e = camera._position;

        var viewMatrix = new Matrix4( r.x,  r.y,  r.z, -r.dot(e),
                                      u.x,  u.y,  u.z, -u.dot(e),
                                     -d.x, -d.y, -d.z,  d.dot(e),
                                      0.0,  0.0,  0.0,      1.0);
        camera._viewMatrix = viewMatrix.multiply(camera._invTransform);

        camera._invViewMatrix = camera._viewMatrix.inverseTransformation();
    }

    function update(camera) {
        var position = camera._position;
        var positionChanged = !position.equals(camera.position);
        if (positionChanged) {
            position = camera._position = camera.position.clone();
        }

        var direction = camera._direction;
        var directionChanged = !direction.equals(camera.direction);
        if (directionChanged) {
            direction = camera._direction = camera.direction.clone();
        }

        var up = camera._up;
        var upChanged = !up.equals(camera.up);
        if (upChanged) {
            up = camera._up = camera.up.clone();
        }

        var right = camera._right;
        var rightChanged = !right.equals(camera.right);
        if (rightChanged) {
            right = camera._right = camera.right.clone();
        }

        var transform = camera._transform;
        var transformChanged = !transform.equals(camera.transform);
        if (transformChanged) {
            transform = camera._transform = camera.transform.clone();

            camera._invTransform = camera._transform.inverseTransformation();
        }

        if (positionChanged || transformChanged) {
            camera._positionWC = Cartesian3.fromCartesian4(transform.multiplyByPoint(position));
        }

        if (directionChanged || transformChanged) {
            camera._directionWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));
        }

        if (upChanged || transformChanged) {
            camera._upWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        }

        if (rightChanged || transformChanged) {
            camera._rightWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        }

        if (directionChanged || upChanged || rightChanged) {
            var det = direction.dot(up.cross(right));
            if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {
                //orthonormalize axes
                direction = camera._direction = direction.normalize();
                camera.direction = direction.clone();

                var invUpMag = 1.0 / up.magnitudeSquared();
                var scalar = up.dot(direction) * invUpMag;
                var w0 = direction.multiplyByScalar(scalar);
                up = camera._up = up.subtract(w0).normalize();
                camera.up = up.clone();

                right = camera._right = direction.cross(up);
                camera.right = right.clone();
            }
        }

        if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {
            updateViewMatrix(camera);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof Camera
     *
     * @return {Matrix4} DOC_TBA
     */
    Camera.prototype.getInverseTransform = function() {
        update(this);
        return this._invTransform;
    };

    /**
     * Returns the view matrix.
     *
     * @memberof Camera
     *
     * @return {Matrix4} The view matrix.
     *
     * @see UniformState#getView
     * @see UniformState#setView
     * @see czm_view
     */
    Camera.prototype.getViewMatrix = function() {
        update(this);
        return this._viewMatrix;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getInverseViewMatrix = function() {
        update(this);
        return this._invViewMatrix;
    };

    /**
     * The position of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getPositionWC = function() {
        update(this);
        return this._positionWC;
    };

    /**
     * The view direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getDirectionWC = function() {
        update(this);
        return this._directionWC;
    };

    /**
     * The up direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getUpWC = function() {
        update(this);
        return this._upWC;
    };

    /**
     * The right direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getRightWC = function() {
        update(this);
        return this._rightWC;
    };

    function getPickRayPerspective(camera, windowPosition) {
        var width = camera._canvas.clientWidth;
        var height = camera._canvas.clientHeight;

        var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        var tanTheta = camera.frustum.aspectRatio * tanPhi;
        var near = camera.frustum.near;

        var x = (2.0 / width) * windowPosition.x - 1.0;
        var y = (2.0 / height) * (height - windowPosition.y) - 1.0;

        var position = camera.getPositionWC();
        var nearCenter = position.add(camera.getDirectionWC().multiplyByScalar(near));
        var xDir = camera.getRightWC().multiplyByScalar(x * near * tanTheta);
        var yDir = camera.getUpWC().multiplyByScalar(y * near * tanPhi);
        var direction = nearCenter.add(xDir).add(yDir).subtract(position).normalize();

        return new Ray(position, direction);
    }

    function getPickRayOrthographic(camera, windowPosition) {
        var width = camera._canvas.clientWidth;
        var height = camera._canvas.clientHeight;

        var x = (2.0 / width) * windowPosition.x - 1.0;
        x *= (camera.frustum.right - camera.frustum.left) * 0.5;
        var y = (2.0 / height) * (height - windowPosition.y) - 1.0;
        y *= (camera.frustum.top - camera.frustum.bottom) * 0.5;

        var position = camera.position.clone();
        position.x += x;
        position.y += y;

        return new Ray(position, camera.getDirectionWC());
    }

    /**
     * Create a ray from the camera position through the pixel at <code>windowPosition</code>
     * in world coordinates.
     *
     * @memberof Camera
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Object} Returns the {@link Cartesian3} position and direction of the ray.
     */
    Camera.prototype.getPickRay = function(windowPosition) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        var frustum = this.frustum;
        if (typeof frustum.aspectRatio !== 'undefined' && typeof frustum.fovy !== 'undefined' && typeof frustum.near !== 'undefined') {
            return getPickRayPerspective(this, windowPosition);
        }

        return getPickRayOrthographic(this, windowPosition);
    };

    /**
     * Pick an ellipsoid in 3D mode.
     *
     * @memberof Camera
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Cartesian3} If the ellipsoid was picked, returns the point on the surface of the ellipsoid.
     * If the ellipsoid was not picked, returns undefined.
     */
    Camera.prototype.pickEllipsoid = function(windowPosition, ellipsoid) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;
        var ray = getPickRayPerspective(this, windowPosition);
        var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
        if (!intersection) {
            return undefined;
        }

        var iPt = ray.getPoint(intersection.start);
        return iPt;
    };

    /**
     * Pick the map in 2D mode.
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {DOC_TBA} projection DOC_TBA
     *
     * @exception {DeveloperError} windowPosition is required.
     * @exception {DeveloperError} projection is required.
     *
     * @return {Cartesian3} If the map was picked, returns the point on the surface of the map.
     * If the map was not picked, returns undefined.
     */
    Camera.prototype.pickMap2D = function(windowPosition, projection) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var ray = getPickRayOrthographic(this, windowPosition);
        var position = ray.origin;
        position.z = 0.0;
        var cart = projection.unproject(position);

        if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO ||
                cart.longitude < - Math.PI || cart.longitude > Math.PI) {
            return undefined;
        }

        return projection.getEllipsoid().cartographicToCartesian(cart);
    };

    /**
     * Pick the map in Columbus View mode.
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {DOC_TBA} projection DOC_TBA
     *
     * @exception {DeveloperError} windowPosition is required.
     * @exception {DeveloperError} projection is required.
     *
     * @return {Cartesian3} If the map was picked, returns the point on the surface of the map.
     * If the map was not picked, returns undefined.
     */
    Camera.prototype.pickMapColumbusView = function(windowPosition, projection) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var ray = getPickRayPerspective(this, windowPosition);
        var scalar = -ray.origin.x / ray.direction.x;
        var position = ray.getPoint(scalar);

        var cart = projection.unproject(new Cartesian3(position.y, position.z, 0.0));

        if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO ||
                cart.longitude < - Math.PI || cart.longitude > Math.PI) {
            return undefined;
        }

        position = projection.getEllipsoid().cartographicToCartesian(cart);
        return position;
    };

    /**
     * Returns a duplicate of a Camera instance.
     *
     * @memberof Camera
     *
     * @return {Camera} A new copy of the Camera instance.
     */
    Camera.prototype.clone = function() {
        var camera = new Camera(this._canvas);
        camera.position = this.position.clone();
        camera.direction = this.direction.clone();
        camera.up = this.up.clone();
        camera.right = this.right.clone();
        camera.transform = this.transform.clone();
        camera.frustum = this.frustum.clone();
        return camera;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Camera
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Camera#destroy
     */
    Camera.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Camera
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera#isDestroyed
     *
     * @example
     * camera = camera && camera.destroy();
     */
    Camera.prototype.destroy = function() {
        this._controllers.destroy();
        return destroyObject(this);
    };

    return Camera;
});

/*global define*/
define('Scene/Scene',[
        '../Core/Math',
        '../Core/Color',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/GeographicProjection',
        '../Core/Ellipsoid',
        '../Core/DeveloperError',
        '../Core/Occluder',
        '../Core/BoundingRectangle',
        '../Core/BoundingSphere',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Intersect',
        '../Core/IntersectionTests',
        '../Core/Interval',
        '../Core/Matrix4',
        '../Core/JulianDate',
        '../Renderer/Context',
        '../Renderer/ClearCommand',
        './Camera',
        './CompositePrimitive',
        './CullingVolume',
        './AnimationCollection',
        './SceneMode',
        './FrameState',
        './OrthographicFrustum',
        './PerspectiveOffCenterFrustum',
        './FrustumCommands'
    ], function(
        CesiumMath,
        Color,
        defaultValue,
        destroyObject,
        GeographicProjection,
        Ellipsoid,
        DeveloperError,
        Occluder,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Intersect,
        IntersectionTests,
        Interval,
        Matrix4,
        JulianDate,
        Context,
        ClearCommand,
        Camera,
        CompositePrimitive,
        CullingVolume,
        AnimationCollection,
        SceneMode,
        FrameState,
        OrthographicFrustum,
        PerspectiveOffCenterFrustum,
        FrustumCommands) {
    

    /**
     * DOC_TBA
     *
     * @alias Scene
     * @constructor
     */
    var Scene = function(canvas) {
        var context = new Context(canvas);

        this._frameState = new FrameState();
        this._canvas = canvas;
        this._context = context;
        this._primitives = new CompositePrimitive();
        this._pickFramebuffer = undefined;
        this._camera = new Camera(canvas);

        this._animate = undefined; // Animation callback
        this._animations = new AnimationCollection();

        this._shaderFrameCount = 0;

        this._commandList = [];
        this._frustumCommandsList = [];

        this._clearColorCommand = new ClearCommand();
        this._clearColorCommand.clearState = context.createClearState({
            color : Color.BLACK
        });
        this._clearDepthStencilCommand = new ClearCommand();
        this._clearDepthStencilCommand.clearState = context.createClearState({
            depth : 1.0,
            stencil : 0.0
        });

        /**
         * The {@link SkyBox} used to draw the stars.
         *
         * @type SkyBox
         *
         * @default undefined
         */
        this.skyBox = undefined;

        /**
         * The sky atmosphere drawn around the globe.
         *
         * @type SkyAtmosphere
         *
         * @default undefined
         */
        this.skyAtmosphere = undefined;

        /**
         * The current mode of the scene.
         *
         * @type SceneMode
         */
        this.mode = SceneMode.SCENE3D;
        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * The projection to use in 2D mode.
             */
            projection : new GeographicProjection(Ellipsoid.WGS84)
        };
        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;
        /**
         * The far-to-near ratio of the multi-frustum. The default is 1,000.0.
         *
         * @type Number
         */
        this.farToNearRatio = 1000.0;

        // initial guess at frustums.
        var near = this._camera.frustum.near;
        var far = this._camera.frustum.far;
        var numFrustums = Math.ceil(Math.log(far / near) / Math.log(this.farToNearRatio));
        updateFrustums(near, far, this.farToNearRatio, numFrustums, this._frustumCommandsList);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getContext = function() {
        return this._context;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getPrimitives = function() {
        return this._primitives;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCamera = function() {
        return this._camera;
    };
    // TODO: setCamera

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getUniformState = function() {
        return this._context.getUniformState();
    };

    /**
     * Gets state information about the current scene.
     *
     * @memberof Scene
     */
    Scene.prototype.getFrameState = function() {
        return this._frameState;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimations = function() {
        return this._animations;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.setAnimation = function(animationCallback) {
        this._animate = animationCallback;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimation = function() {
        return this._animate;
    };

    function clearPasses(passes) {
        passes.color = false;
        passes.pick = false;
        passes.overlay = false;
    }

    function updateFrameState(scene, frameNumber, time) {
        var camera = scene._camera;

        var frameState = scene._frameState;
        frameState.mode = scene.mode;
        frameState.morphTime = scene.morphTime;
        frameState.scene2D = scene.scene2D;
        frameState.frameNumber = frameNumber;
        frameState.time = time;
        frameState.camera = camera;
        frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.getPositionWC(), camera.getDirectionWC(), camera.getUpWC());
        frameState.occluder = undefined;

        // TODO: The occluder is the top-level central body. When we add
        //       support for multiple central bodies, this should be the closest one.
        var cb = scene._primitives.getCentralBody();
        if (scene.mode === SceneMode.SCENE3D && typeof cb !== 'undefined') {
            var ellipsoid = cb.getEllipsoid();
            var occluder = new Occluder(new BoundingSphere(Cartesian3.ZERO, ellipsoid.getMinimumRadius()), camera.getPositionWC());
            frameState.occluder = occluder;
        }

        clearPasses(frameState.passes);
    }

    function update(scene, time) {
        var us = scene.getUniformState();
        var camera = scene._camera;

        // Destroy released shaders once every 120 frames to avoid thrashing the cache
        if (scene._shaderFrameCount++ === 120) {
            scene._shaderFrameCount = 0;
            scene._context.getShaderCache().destroyReleasedShaderPrograms();
        }

        scene._animations.update();
        camera.update();

        var frameNumber = CesiumMath.incrementWrap(us.getFrameNumber(), 15000000.0, 1.0);
        updateFrameState(scene, frameNumber, time);
        scene._frameState.passes.color = true;
        scene._frameState.passes.overlay = true;

        us.update(scene._frameState);

        if (scene._animate) {
            scene._animate();
        }

        scene._commandList.length = 0;
        scene._primitives.update(scene._context, scene._frameState, scene._commandList);
    }

    function updateFrustums(near, far, farToNearRatio, numFrustums, frustumCommandsList) {
        frustumCommandsList.length = numFrustums;
        for (var m = 0; m < numFrustums; ++m) {
            var curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);
            var curFar = Math.min(far, farToNearRatio * curNear);
            curNear *= 0.99;

            var frustumCommands = frustumCommandsList[m];
            if (typeof frustumCommands === 'undefined') {
                frustumCommands = frustumCommandsList[m] = new FrustumCommands(curNear, curFar);
            } else {
                frustumCommands.near = curNear;
                frustumCommands.far = curFar;
            }
        }
    }

    function insertIntoBin(scene, command, distance) {
        var frustumCommandsList = scene._frustumCommandsList;
        var length = frustumCommandsList.length;
        for (var i = 0; i < length; ++i) {
            var frustumCommands = frustumCommandsList[i];
            var curNear = frustumCommands.near;
            var curFar = frustumCommands.far;

            if (typeof distance !== 'undefined') {
                if (distance.start > curFar) {
                    continue;
                }

                if (distance.stop < curNear) {
                    break;
                }
            }

            // PERFORMANCE_IDEA: sort bins
            frustumCommands.commands.push(command);
        }
    }

    var scratchCullingVolume = new CullingVolume();
    var distances = new Interval();
    function createPotentiallyVisibleSet(scene, listName) {
        var commandLists = scene._commandList;
        var cullingVolume = scene._frameState.cullingVolume;
        var camera = scene._camera;

        var direction = camera.getDirectionWC();
        var position = camera.getPositionWC();

        var frustumCommandsList = scene._frustumCommandsList;
        var frustumsLength = frustumCommandsList.length;
        for (var n = 0; n < frustumsLength; ++n) {
            frustumCommandsList[n].commands.length = 0;
        }

        var near = Number.MAX_VALUE;
        var far = Number.MIN_VALUE;
        var undefBV = false;

        var occluder;
        if (scene._frameState.mode === SceneMode.SCENE3D) {
            occluder = scene._frameState.occluder;
        }

        // get user culling volume minus the far plane.
        var planes = scratchCullingVolume.planes;
        for (var k = 0; k < 5; ++k) {
            planes[k] = cullingVolume.planes[k];
        }
        cullingVolume = scratchCullingVolume;

        var length = commandLists.length;
        for (var i = 0; i < length; ++i) {
            var commandList = commandLists[i][listName];
            var commandListLength = commandList.length;
            for (var j = 0; j < commandListLength; ++j) {
                var command = commandList[j];
                var boundingVolume = command.boundingVolume;
                if (typeof boundingVolume !== 'undefined') {
                    var modelMatrix = defaultValue(command.modelMatrix, Matrix4.IDENTITY);
                    var transformedBV = boundingVolume.transform(modelMatrix);               //TODO: Remove this allocation.
                    if (cullingVolume.getVisibility(transformedBV) === Intersect.OUTSIDE ||
                            (typeof occluder !== 'undefined' && !occluder.isBoundingSphereVisible(transformedBV))) {
                        continue;
                    }

                    distances = transformedBV.getPlaneDistances(position, direction, distances);
                    near = Math.min(near, distances.start);
                    far = Math.max(far, distances.stop);

                    insertIntoBin(scene, command, distances);
                } else {
                    // Clear commands don't need a bounding volume - just add the clear to all frustums.
                    // If another command has no bounding volume, though, we need to use the camera's
                    // worst-case near and far planes to avoid clipping something important.
                    undefBV = !(command instanceof ClearCommand);
                    insertIntoBin(scene, command);
                }
            }
        }

        if (undefBV) {
            near = camera.frustum.near;
            far = camera.frustum.far;
        } else {
            near = Math.max(near, camera.frustum.near);
            far = Math.min(far, camera.frustum.far);
        }

        // Exploit temporal coherence. If the frustums haven't changed much, use the frustums computed
        // last frame, else compute the new frustums and sort them by frustum again.
        var farToNearRatio = scene.farToNearRatio;
        var numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));
        if (near !== Number.MAX_VALUE &&
            (numFrustums !== frustumsLength ||
             (frustumCommandsList.length !== 0 &&
              (near < frustumCommandsList[0].near || far > frustumCommandsList[frustumsLength - 1].far)))) {
            updateFrustums(near, far, farToNearRatio, numFrustums, frustumCommandsList);
            createPotentiallyVisibleSet(scene, listName);
        }
    }

    function executeCommands(scene, framebuffer) {
        var camera = scene._camera;
        var frustum = camera.frustum.clone();
        var context = scene._context;
        var us = context.getUniformState();
        var skyBoxCommand = (typeof scene.skyBox !== 'undefined') ? scene.skyBox.update(context, scene._frameState) : undefined;
        var skyAtmosphereCommand = (typeof scene.skyAtmosphere !== 'undefined') ? scene.skyAtmosphere.update(context, scene._frameState) : undefined;

        scene._clearColorCommand.execute(context, framebuffer);

        // Ideally, we would render the sky box and atmosphere last for
        // early-z, but we would have to draw it in each frustum
        frustum.near = camera.frustum.near;
        frustum.far = camera.frustum.far;
        us.updateFrustum(frustum);

        if (typeof skyBoxCommand !== 'undefined') {
            skyBoxCommand.execute(context, framebuffer);
        }

        if (typeof skyAtmosphereCommand !== 'undefined') {
            skyAtmosphereCommand.execute(context, framebuffer);
        }

        var clearDepthStencil = scene._clearDepthStencilCommand;

        var frustumCommandsList = scene._frustumCommandsList;
        var numFrustums = frustumCommandsList.length;
        for (var i = 0; i < numFrustums; ++i) {
            clearDepthStencil.execute(context, framebuffer);

            var index = numFrustums - i - 1.0;
            var frustumCommands = frustumCommandsList[index];
            frustum.near = frustumCommands.near;
            frustum.far = frustumCommands.far;

            us.updateFrustum(frustum);

            var commands = frustumCommands.commands;
            var length = commands.length;
            for (var j = 0; j < length; ++j) {
                commands[j].execute(context, framebuffer);
            }
        }
    }

    function executeOverlayCommands(scene) {
        var context = scene._context;
        var commandLists = scene._commandList;
        var length = commandLists.length;
        for (var i = 0; i < length; ++i) {
            var commandList = commandLists[i].overlayList;
            var commandListLength = commandList.length;
            for (var j = 0; j < commandListLength; ++j) {
                commandList[j].execute(context);
            }
        }
    }

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.render = function(time) {
        if (typeof time === 'undefined') {
            time = new JulianDate();
        }

        update(this, time);
        createPotentiallyVisibleSet(this, 'colorList');
        executeCommands(this);
        executeOverlayCommands(this);
    };

    var orthoPickingFrustum = new OrthographicFrustum();
    function getPickOrthographicCullingVolume(scene, windowPosition, width, height) {
        var canvas = scene._canvas;
        var camera = scene._camera;
        var frustum = camera.frustum;

        var canvasWidth = canvas.clientWidth;
        var canvasHeight = canvas.clientHeight;

        var x = (2.0 / canvasWidth) * windowPosition.x - 1.0;
        x *= (frustum.right - frustum.left) * 0.5;
        var y = (2.0 / canvasHeight) * (canvasHeight - windowPosition.y) - 1.0;
        y *= (frustum.top - frustum.bottom) * 0.5;

        var position = camera.position;
        position = new Cartesian3(position.z, position.x, position.y);
        position.y += x;
        position.z += y;

        var pixelSize = frustum.getPixelSize(new Cartesian2(canvasWidth, canvasHeight));

        var ortho = orthoPickingFrustum;
        ortho.right = pixelSize.x * 0.5;
        ortho.left = -ortho.right;
        ortho.top = pixelSize.y * 0.5;
        ortho.bottom = -ortho.top;
        ortho.near = frustum.near;
        ortho.far = frustum.far;

        return ortho.computeCullingVolume(position, camera.getDirectionWC(), camera.getUpWC());
    }

    var perspPickingFrustum = new PerspectiveOffCenterFrustum();
    function getPickPerspectiveCullingVolume(scene, windowPosition, width, height) {
        var canvas = scene._canvas;
        var camera = scene._camera;
        var frustum = camera.frustum;
        var near = frustum.near;

        var canvasWidth = canvas.clientWidth;
        var canvasHeight = canvas.clientHeight;

        var tanPhi = Math.tan(frustum.fovy * 0.5);
        var tanTheta = frustum.aspectRatio * tanPhi;

        var x = (2.0 / canvasWidth) * windowPosition.x - 1.0;
        var y = (2.0 / canvasHeight) * (canvasHeight - windowPosition.y) - 1.0;

        var xDir = x * near * tanTheta;
        var yDir = y * near * tanPhi;

        var pixelSize = frustum.getPixelSize(new Cartesian2(canvasWidth, canvasHeight));
        var pickWidth = pixelSize.x * width * 0.5;
        var pickHeight = pixelSize.y * height * 0.5;

        var offCenter = perspPickingFrustum;
        offCenter.top = yDir + pickHeight;
        offCenter.bottom = yDir - pickHeight;
        offCenter.right = xDir + pickWidth;
        offCenter.left = xDir - pickWidth;
        offCenter.near = near;
        offCenter.far = frustum.far;

        return offCenter.computeCullingVolume(camera.getPositionWC(), camera.getDirectionWC(), camera.getUpWC());
    }

    function getPickCullingVolume(scene, windowPosition, width, height) {
        if (scene.mode === SceneMode.SCENE2D) {
            return getPickOrthographicCullingVolume(scene, windowPosition, width, height);
        }

        return getPickPerspectiveCullingVolume(scene, windowPosition, width, height);
    }

    // pick rectangle width and height, assumed odd
    var rectangleWidth = 3.0;
    var rectangleHeight = 3.0;
    var scratchRectangle = new BoundingRectangle(0.0, 0.0, rectangleWidth, rectangleHeight);

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.pick = function(windowPosition) {
        var context = this._context;
        var primitives = this._primitives;
        var frameState = this._frameState;

        this._pickFramebuffer = this._pickFramebuffer || context.createPickFramebuffer();
        var fb = this._pickFramebuffer.begin();

        updateFrameState(this);
        frameState.cullingVolume = getPickCullingVolume(this, windowPosition, rectangleWidth, rectangleHeight);
        frameState.passes.pick = true;

        var commandLists = this._commandList;
        commandLists.length = 0;
        primitives.update(context, frameState, commandLists);

        createPotentiallyVisibleSet(this, 'pickList');
        executeCommands(this, fb);

        scratchRectangle.x = windowPosition.x - ((rectangleWidth - 1.0) * 0.5);
        scratchRectangle.y = (this._canvas.clientHeight - windowPosition.y) - ((rectangleHeight - 1.0) * 0.5);
        return this._pickFramebuffer.end(scratchRectangle);
    };

    /**
     * Pick an ellipsoid or map.
     *
     * @memberof Scene
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Cartesian3} If the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map
     * in world coordinates. If the ellipsoid or map was not picked, returns undefined.
     */
    Scene.prototype.pickEllipsoid = function(windowPosition, ellipsoid) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var p;
        if (this.mode === SceneMode.SCENE3D) {
            p = this._camera.pickEllipsoid(windowPosition, ellipsoid);
        } else if (this.mode === SceneMode.SCENE2D) {
            p = this._camera.pickMap2D(windowPosition, this.scene2D.projection);
        } else if (this.mode === SceneMode.COLUMBUS_VIEW) {
            p = this._camera.pickMapColumbusView(windowPosition, this.scene2D.projection);
        }

        return p;
    };

    /**
     * View an extent on an ellipsoid or map.
     *
     * @memberof Scene
     *
     * @param {Extent} extent The extent to view.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to view.
     *
     * @exception {DeveloperError} extent is required.
     */
    Scene.prototype.viewExtent = function(extent, ellipsoid) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        if (this.mode === SceneMode.SCENE3D) {
            this._camera.viewExtent(extent, ellipsoid);
        } else if (this.mode === SceneMode.SCENE2D) {
            this._camera.viewExtent2D(extent, this.scene2D.projection);
        } else if (this.mode === SceneMode.COLUMBUS_VIEW) {
            this._camera.viewExtentColumbusView(extent, this.scene2D.projection);
        }
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.destroy = function() {
        this._camera = this._camera && this._camera.destroy();
        this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy();
        this._primitives = this._primitives && this._primitives.destroy();
        this.skyBox = this.skyBox && this.skyBox.destroy();
        this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy();
        this._context = this._context && this._context.destroy();
        return destroyObject(this);
    };

    return Scene;
});

/*global define*/
define('Scene/SceneTransitioner',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Ellipsoid',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Matrix4',
        '../ThirdParty/Tween',
        './OrthographicFrustum',
        './PerspectiveFrustum',
        './SceneMode'
    ], function(
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Ellipsoid,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Matrix4,
        Tween,
        OrthographicFrustum,
        PerspectiveFrustum,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @alias SceneTransitioner
     * @constructor
     */
    var SceneTransitioner = function(scene, ellipsoid) {
        this._scene = scene;
        this._ellipsoid = ellipsoid || Ellipsoid.WGS84;
        var canvas = scene.getCanvas();

        // Position camera and size frustum so the entire 2D map is visible
        var maxRadii = this._ellipsoid.getMaximumRadius();
        var position = new Cartesian3(0.0, 0.0, 2.0 * maxRadii);
        var direction = position.negate().normalize();
        var up = Cartesian3.UNIT_Y;

        var frustum = new OrthographicFrustum();
        frustum.right = maxRadii * Math.PI;
        frustum.left = -frustum.right;
        frustum.top = frustum.right * (canvas.clientHeight / canvas.clientWidth);
        frustum.bottom = -frustum.top;

        var transform = new Matrix4(0.0, 0.0, 1.0, 0.0,
                                    1.0, 0.0, 0.0, 0.0,
                                    0.0, 1.0, 0.0, 0.0,
                                    0.0, 0.0, 0.0, 1.0);

        this._camera2D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -1.0, 1.0).normalize().multiplyByScalar(5.0 * maxRadii);
        direction = Cartesian3.ZERO.subtract(position).normalize();
        var right = direction.cross(Cartesian3.UNIT_Z).normalize();
        up = right.cross(direction);

        frustum = new PerspectiveFrustum();
        frustum.fovy = CesiumMath.toRadians(60.0);
        frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;

        this._cameraCV = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyByScalar(2.0 * maxRadii);
        direction = Cartesian3.ZERO.subtract(position).normalize();
        right = direction.cross(Cartesian3.UNIT_Z).normalize();
        up = right.cross(direction);

        this._camera3D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum
        };

        this._currentAnimations = [];
        this._morphHandler = undefined;
        this._morphCancelled = false;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration2D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration3D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDurationColumbusView = 3000;

        /**
         * DOC_TBA
         * @type {Boolean}
         */
        this.endMorphOnMouseInput = true;
    };

    //immediately set the morph time of all objects in the scene
    function setMorphTime(scene, morphTime) {
        scene.morphTime = morphTime;

        var primitives = scene.getPrimitives();
        for ( var i = 0, len = primitives.getLength(); i < len; i++) {
            var primitive = primitives.get(i);
            if (typeof primitive.morphTime !== 'undefined') {
                primitive.morphTime = morphTime;
            }
        }

        var centralBody = primitives.getCentralBody();
        centralBody.morphTime = morphTime;

        if (typeof scene.skyBox !== 'undefined') {
            scene.skyBox.morphTime = morphTime;
        }

        if (typeof scene.skyAtmosphere !== 'undefined') {
            scene.skyAtmosphere.morphTime = morphTime;
        }
    }

    //in the future the animations will be more complicated
    function addMorphTimeAnimations(transitioner, scene, start, stop, duration, onComplete) {
        //for now, all objects morph at the same rate
        var template = {
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut
        };

        var primitives = scene.getPrimitives();
        var sceneAnimations = scene.getAnimations();
        var animation;
        for ( var i = 0, len = primitives.getLength(); i < len; i++) {
            var primitive = primitives.get(i);
            if (typeof primitive.morphTime !== 'undefined') {
                animation = sceneAnimations.addProperty(primitive, 'morphTime', start, stop, template);
                transitioner._currentAnimations.push(animation);
            }
        }

        var centralBody = primitives.getCentralBody();
        animation = sceneAnimations.addProperty(centralBody, 'morphTime', start, stop, template);
        transitioner._currentAnimations.push(animation);

        if (typeof scene.skyBox !== 'undefined') {
            animation = sceneAnimations.addProperty(scene.skyBox, 'morphTime', start, stop, template);
            transitioner._currentAnimations.push(animation);
        }

        if (typeof scene.skyAtmosphere !== 'undefined') {
            animation = sceneAnimations.addProperty(scene.skyAtmosphere, 'morphTime', start, stop, template);
            transitioner._currentAnimations.push(animation);
        }

        if (typeof onComplete !== 'undefined') {
            template.onComplete = function() {
                onComplete.call(transitioner);
            };
        }

        animation = sceneAnimations.addProperty(scene, 'morphTime', start, stop, template);
        transitioner._currentAnimations.push(animation);
    }

    function updateFrustums(transitioner) {
        var scene = transitioner._scene;

        var canvas = scene.getCanvas();
        var ratio = canvas.clientHeight / canvas.clientWidth;

        var frustum = transitioner._camera2D.frustum;
        frustum.top = frustum.right * ratio;
        frustum.bottom = -frustum.top;

        ratio = 1.0 / ratio;

        frustum = transitioner._cameraCV.frustum;
        frustum.aspectRatio = ratio;

        frustum = transitioner._camera3D.frustum;
        frustum.aspectRatio = ratio;

        var camera = scene.getCamera();
        switch (scene.mode) {
        case SceneMode.SCENE3D:
            camera.frustum = transitioner._camera3D.frustum.clone();
            break;
        case SceneMode.COLUMBUS_VIEW:
            camera.frustum = transitioner._cameraCV.frustum.clone();
            break;
        case SceneMode.SCENE2D:
            camera.frustum = transitioner._camera2D.frustum.clone();
            break;
        }
    }

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to2D = function() {
        var scene = this._scene;

        if (scene.mode !== SceneMode.SCENE2D) {
            scene.mode = SceneMode.SCENE2D;
            setMorphTime(scene, 0.0);

            this._destroyMorphHandler();

            updateFrustums(this);
            var camera = scene.getCamera();
            camera.transform = this._camera2D.transform.clone();

            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.add2D(scene.scene2D.projection);

            // TODO: Match incoming columbus-view or 3D position
            camera.position = this._camera2D.position.clone();
            camera.direction = this._camera2D.direction.clone();
            camera.up = this._camera2D.up.clone();
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.toColumbusView = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.COLUMBUS_VIEW) {
            scene.mode = SceneMode.COLUMBUS_VIEW;
            setMorphTime(scene, 0.0);

            this._destroyMorphHandler();

            updateFrustums(this);
            var camera = scene.getCamera();
            camera.transform = this._cameraCV.transform.clone();

            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.addColumbusView();

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming 2D or 3D position
                camera.position = this._cameraCV.position.clone();
                camera.direction = this._cameraCV.direction.clone();
                camera.up = this._cameraCV.up.clone();
                camera.right = camera.direction.cross(camera.up);
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.SCENE3D) {
            scene.mode = SceneMode.SCENE3D;
            setMorphTime(scene, 1.0);

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.addCentralBody();

            updateFrustums(this);
            camera.transform = Matrix4.IDENTITY.clone();

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming columbus-view or 2D position
                camera.position = this._camera3D.position.clone();
                camera.direction = this._camera3D.direction.clone();
                camera.up = this._camera3D.up.clone();
            }
        }
    };

    SceneTransitioner.prototype._createMorphHandler = function(endMorphFunction) {
        var that = this;

        var controllers = this._scene.getCamera().getControllers();
        controllers.removeAll();

        if (this.endMorphOnMouseInput) {
            this._morphHandler = new EventHandler(this._scene.getCanvas());

            var cancelMorph = function() {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            };
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.LEFT_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.MIDDLE_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.RIGHT_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.WHEEL);
        }
    };

    SceneTransitioner.prototype._destroyMorphHandler = function() {
        var animations = this._scene.getAnimations();
        for ( var i = 0; i < this._currentAnimations.length; ++i) {
            animations.remove(this._currentAnimations[i]);
        }
        this._currentAnimations.length = 0;
        this._morphHandler = this._morphHandler && this._morphHandler.destroy();
    };

    SceneTransitioner.prototype._changeCameraTransform = function(camera, transform) {
        var pos = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        var dir = new Cartesian4(camera.direction.x, camera.direction.y, camera.direction.z, 0.0);
        var up = new Cartesian4(camera.up.x, camera.up.y, camera.up.z, 0.0);

        var frame = transform.inverseTransformation().multiply(camera.transform);
        camera.transform = transform.clone();

        camera.position = Cartesian3.fromCartesian4(frame.multiplyByVector(pos));
        camera.direction = Cartesian3.fromCartesian4(frame.multiplyByVector(dir));
        camera.up = Cartesian3.fromCartesian4(frame.multiplyByVector(up));
        camera.right = camera.direction.cross(camera.up);
    };

    SceneTransitioner.prototype._columbusViewMorph = function(startPosition, endPosition, time) {
        // Just linear for now.
        return startPosition.lerp(endPosition, time);
    };

    SceneTransitioner.prototype._scenePerspectiveToOrthographic = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        var startPos = camera.position;
        var startFOVy = camera.frustum.fovy;
        var endFOVy = CesiumMath.RADIANS_PER_DEGREE * 0.5;
        var d = startPos.magnitude() * Math.tan(startFOVy * 0.5);
        camera.frustum.far = d / Math.tan(endFOVy * 0.5) + 10000000.0;

        var update = function(value) {
            camera.frustum.fovy = CesiumMath.lerp(startFOVy, endFOVy, value.time);

            var distance = d / Math.tan(camera.frustum.fovy * 0.5);
            camera.position = camera.position.normalize().multiplyByScalar(distance);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.frustum = that._camera2D.frustum.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._sceneCVTo2D = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var endPos = this._camera2D.position.normalize().multiplyByScalar(d);
        var endDir = that._camera2D.direction.clone();
        var endUp = that._camera2D.up.clone();

        var updateCV = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        duration = duration * 0.5;
        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : updateCV,
            onComplete : function() {
                that._scenePerspectiveToOrthographic(duration, onComplete);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene3DTo2D = function(duration, onComplete) {
        duration = duration * 0.5;

        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._camera3D.frustum.fovy * 0.5);
        var tanTheta = this._camera3D.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var camera3DTo2D = {};
        camera3DTo2D.position = this._camera2D.position.normalize().multiplyByScalar(d);
        camera3DTo2D.direction = this._camera2D.direction.clone();
        camera3DTo2D.up = this._camera2D.up.clone();

        var complete = function() {
            this._scenePerspectiveToOrthographic(duration, onComplete);
        };
        this._scene3DToCV(duration, camera3DTo2D, complete);
    };

    SceneTransitioner.prototype._sceneOrthographicToPerspective = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;
        var endPos2D = this._camera2D.position.normalize().multiplyByScalar(d);

        var top = camera.frustum.top;
        var bottom = camera.frustum.bottom;
        var right = camera.frustum.right;
        var left = camera.frustum.left;

        var frustum2D = this._camera2D.frustum;
        var frustumCV = this._cameraCV.frustum;

        var startPos = camera.position.clone();

        var update2D = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos2D, value.time);
            camera.frustum.top = CesiumMath.lerp(top, frustum2D.top, value.time);
            camera.frustum.bottom = CesiumMath.lerp(bottom, frustum2D.bottom, value.time);
            camera.frustum.right = CesiumMath.lerp(right, frustum2D.right, value.time);
            camera.frustum.left = CesiumMath.lerp(left, frustum2D.left, value.time);
        };

        var startTime = (right - left) / (2.0 * maxRadii * Math.PI);
        var endTime = 1.0;
        if (startTime > endTime) {
            startTime = 0.0;
        }

        var partialDuration = (endTime - startTime) * duration;
        if (partialDuration === 0 && Cartesian2.magnitude(Cartesian2.subtract(startPos, endPos2D, startPos)) !== 0) {
            partialDuration = duration;
            startTime = 0.0;
            endTime = 1.0;
        }

        var animation = scene.getAnimations().add({
            easingFunction : Tween.Easing.Quartic.EaseOut,
            duration : partialDuration,
            startValue : {
                time : startTime
            },
            stopValue : {
                time : endTime
            },
            onUpdate : update2D,
            onComplete : function() {
                camera.frustum = frustumCV.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene2DToCV = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        duration = duration * 0.5;

        var completeFrustumChange = function() {
            var startPos = camera.position.clone();
            var startDir = camera.direction.clone();
            var startUp = camera.up.clone();

            var endPos = that._cameraCV.position.clone();
            var endDir = that._cameraCV.direction.clone();
            var endUp = that._cameraCV.up.clone();

            var updateCV = function(value) {
                camera.position = that._columbusViewMorph(startPos, endPos, value.time);
                camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
                camera.up = that._columbusViewMorph(startUp, endUp, value.time);
                camera.right = camera.direction.cross(camera.up);
            };

            var animation = scene.getAnimations().add({
                duration : duration,
                easingFunction : Tween.Easing.Quartic.EaseOut,
                startValue : {
                    time : 0.0
                },
                stopValue : {
                    time : 1.0
                },
                onUpdate : updateCV,
                onComplete : function() {
                    onComplete.call(that);
                }
            });

            that._currentAnimations.push(animation);
        };

        this._sceneOrthographicToPerspective(duration, completeFrustumChange);
    };

    SceneTransitioner.prototype._scene3DToCV = function(duration, endCamera, onComplete) {
        var that = this;

        var scene = this._scene;

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var endPos = endCamera.position.clone();
        var endDir = endCamera.direction.clone();
        var endUp = endCamera.up.clone();

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.position = endPos;
                camera.direction = endDir;
                camera.up = endUp;
            }
        });
        this._currentAnimations.push(animation);

        addMorphTimeAnimations(this, scene, 1.0, 0.0, duration, onComplete);
    };

    SceneTransitioner.prototype._scene2DTo3D = function(duration, onComplete) {
        duration = duration * 0.5;

        var camera = this._scene.getCamera();

        this._sceneOrthographicToPerspective(duration, function() {
            camera.frustum = this._cameraCV.frustum.clone();
            camera.transform = this._cameraCV.transform.clone();
            this._sceneCVTo3D(duration, onComplete);
        });
    };

    SceneTransitioner.prototype._sceneCVTo3D = function(duration, onComplete) {
        var scene = this._scene;

        var that = this;

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, Matrix4.IDENTITY);

        var startPos = camera.position;
        var startDir = camera.direction;
        var startUp = camera.up;

        var maxRadii = this._ellipsoid.getMaximumRadius();
        var endPos = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, 0.0, 10.0));
        endPos = endPos.normalize().multiplyByScalar(2.0 * maxRadii);
        var endDir = Cartesian3.ZERO.subtract(endPos).normalize();
        var endRight = endDir.cross(Cartesian3.UNIT_Z).normalize();
        var endUp = endRight.cross(endDir);

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update
        });
        this._currentAnimations.push(animation);

        addMorphTimeAnimations(this, scene, 0.0, 1.0, duration, onComplete);
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo2D = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.SCENE2D || previousMode === SceneMode.MORPHING) {
            return;
        }

        updateFrustums(this);
        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to2D);

        if (previousMode === SceneMode.COLUMBUS_VIEW) {
            this._sceneCVTo2D(this.morphDuration2D, this.to2D);
        } else {
            this._scene3DTo2D(this.morphDuration2D, this.to2D);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphToColumbusView = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.COLUMBUS_VIEW || previousMode === SceneMode.MORPHING) {
            return;
        }

        updateFrustums(this);
        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.toColumbusView);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DToCV(this.morphDurationColumbusView, this.toColumbusView);
        } else {
            this._scene3DToCV(this.morphDurationColumbusView, this._cameraCV, this.toColumbusView);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (previousMode === SceneMode.SCENE3D || previousMode === SceneMode.MORPHING) {
            return;
        }

        updateFrustums(this);
        scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to3D);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DTo3D(this.morphDuration3D, this.to3D);
        } else {
            this._sceneCVTo3D(this.morphDuration3D, this.to3D);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof SceneTransitioner
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see SceneTransitioner#destroy
     */
    SceneTransitioner.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof SceneTransitioner
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see SceneTransitioner#isDestroyed
     *
     * @example
     * transitioner = transitioner && transitioner.destroy();
     */
    SceneTransitioner.prototype.destroy = function() {
        this._destroyMorphHandler();
        return destroyObject(this);
    };

    return SceneTransitioner;
});
/**
 * @fileOverview
 *
 * Grauw Uri utilities
 *
 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
 *
 * @author Laurens Holst (http://www.grauw.nl/)
 *
 *   Copyright 2012 Laurens Holst
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *   Modifications made by Cesium to fit into our build system as well as fix warnings.
 */
/*global define*/
define('ThirdParty/Uri',[],function() {
    
    /*global unescape*/

    // Regular expression from RFC 3986 appendix B
    var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');

    var caseRegex = /%[0-9a-z]{2}/gi;
    var percentRegex = /[a-zA-Z0-9\-\._~]/;
    var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;

    /**
     * Constructs a Uri object.
     * @constructor
     * @class Implementation of Uri parsing and base Uri resolving algorithm in RFC 3986.
     * @param {string|Uri} uri A string or Uri object to create the object from.
     */
    function Uri(uri) {
        if (uri instanceof Uri) { // copy constructor
            this.scheme = uri.scheme;
            this.authority = uri.authority;
            this.path = uri.path;
            this.query = uri.query;
            this.fragment = uri.fragment;
        } else if (uri) { // uri is Uri string or cast to string
            var c = parseRegex.exec(uri);
            this.scheme = c[1];
            this.authority = c[2];
            this.path = c[3];
            this.query = c[4];
            this.fragment = c[5];
        }
    }

    // Initial values on the prototype
    Uri.prototype.scheme = null;
    Uri.prototype.authority = null;
    Uri.prototype.path = '';
    Uri.prototype.query = null;
    Uri.prototype.fragment = null;

    /**
     * Returns the scheme part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "http".
     */
    Uri.prototype.getScheme = function() {
        return this.scheme;
    };

    /**
     * Returns the authority part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "example.com:80".
     */
    Uri.prototype.getAuthority = function() {
        return this.authority;
    };

    /**
     * Returns the path part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "/a/b".
     * In "mailto:mike@example.com" this is "mike@example.com".
     */
    Uri.prototype.getPath = function() {
        return this.path;
    };

    /**
     * Returns the query part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "x".
     */
    Uri.prototype.getQuery = function() {
        return this.query;
    };

    /**
     * Returns the fragment part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "y".
     */
    Uri.prototype.getFragment = function() {
        return this.fragment;
    };

    /**
     * Tests whether the Uri is an absolute Uri.
     * See RFC 3986 section 4.3.
     */
    Uri.prototype.isAbsolute = function() {
        return !!this.scheme && !this.fragment;
    };

    /**
     * Tests whether the Uri is a same-document reference.
     * See RFC 3986 section 4.4.
     *
     * To perform more thorough comparison, you can normalise the Uri objects.
     */
    Uri.prototype.isSameDocumentAs = function(uri) {
        return uri.scheme === this.scheme && uri.authority === this.authority && uri.path === this.path && uri.query === this.query;
    };

    /**
     * Simple String Comparison of two Uris.
     * See RFC 3986 section 6.2.1.
     *
     * To perform more thorough comparison, you can normalise the Uri objects.
     */
    Uri.prototype.equals = function(uri) {
        return this.isSameDocumentAs(uri) && uri.fragment === this.fragment;
    };

    /**
     * Normalizes the Uri using syntax-based normalization.
     * This includes case normalization, percent-encoding normalization and path segment normalization.
     * XXX: Percent-encoding normalization does not escape characters that need to be escaped.
     *      (Although that would not be a valid Uri in the first place.)
     * See RFC 3986 section 6.2.2.
     */
    Uri.prototype.normalize = function() {
        this.removeDotSegments();
        if (this.scheme) {
            this.scheme = this.scheme.toLowerCase();
        }
        if (this.authority) {
            this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
        }
        if (this.path) {
            this.path = this.path.replace(caseRegex, replaceCase);
        }
        if (this.query) {
            this.query = this.query.replace(caseRegex, replaceCase);
        }
        if (this.fragment) {
            this.fragment = this.fragment.replace(caseRegex, replaceCase);
        }
    };

    function replaceCase(str) {
        var dec = unescape(str);
        return percentRegex.test(dec) ? dec : str.toUpperCase();
    }

    function replaceAuthority(str, p1, p2, p3) {
        return (p1 || '') + p2.toLowerCase() + (p3 || '');
    }

    /**
     * Resolve a relative Uri (this) against a base Uri.
     * The base Uri must be an absolute Uri.
     * See RFC 3986 section 5.2
     */
    Uri.prototype.resolve = function(baseUri) {
        var uri = new Uri();
        if (this.scheme) {
            uri.scheme = this.scheme;
            uri.authority = this.authority;
            uri.path = this.path;
            uri.query = this.query;
        } else {
            uri.scheme = baseUri.scheme;
            if (this.authority) {
                uri.authority = this.authority;
                uri.path = this.path;
                uri.query = this.query;
            } else {
                uri.authority = baseUri.authority;
                if (this.path === '') {
                    uri.path = baseUri.path;
                    uri.query = this.query || baseUri.query;
                } else {
                    if (this.path.charAt(0) === '/') {
                        uri.path = this.path;
                        uri.removeDotSegments();
                    } else {
                        if (baseUri.authority && baseUri.path === '') {
                            uri.path = '/' + this.path;
                        } else {
                            uri.path = baseUri.path.substring(0, baseUri.path.lastIndexOf('/') + 1) + this.path;
                        }
                        uri.removeDotSegments();
                    }
                    uri.query = this.query;
                }
            }
        }
        uri.fragment = this.fragment;
        return uri;
    };

    /**
     * Remove dot segments from path.
     * See RFC 3986 section 5.2.4
     * @private
     */
    Uri.prototype.removeDotSegments = function() {
        var input = this.path.split('/'), output = [], segment, absPath = input[0] === '';
        if (absPath) {
            input.shift();
        }
        if (input[0] === '') {
            input.shift();
        }
        while (input.length) {
            segment = input.shift();
            if (segment === '..') {
                output.pop();
            } else if (segment !== '.') {
                output.push(segment);
            }
        }
        if (segment === '.' || segment === '..') {
            output.push('');
        }
        if (absPath) {
            output.unshift('');
        }
        this.path = output.join('/');
    };

    var cache = {};

    /**
     * Resolves a relative Uri against an absolute base Uri.
     * Convenience method.
     * @param {String} uri the relative Uri to resolve
     * @param {String} baseUri the base Uri (must be absolute) to resolve against
     */
    Uri.resolve = function(sUri, sBaseUri) {
        var uri = cache[sUri];
        if (typeof uri === 'undefined') {
            cache[sUri] = new Uri(sUri);
        }
        var baseUri = cache[sBaseUri] || (cache[sBaseUri] = new Uri(sBaseUri));
        return uri.resolve(baseUri).toString();
    };

    /**
     * Serializes the Uri to a string.
     */
    Uri.prototype.toString = function() {
        var result = '';
        if (this.scheme) {
            result += this.scheme + ':';
        }
        if (this.authority) {
            result += '//' + this.authority;
        }
        result += this.path;
        if (this.query) {
            result += '?' + this.query;
        }
        if (this.fragment) {
            result += '#' + this.fragment;
        }
        return result;
    };

    return Uri;
});

/*global define*/
define('DynamicScene/CzmlImage',['../ThirdParty/Uri'], function(Uri) {
    

    /**
     * Provides methods for working with a image defined in CZML.
     *
     * @exports CzmlImage
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlImage
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlImage = {
        /**
         * Returns the packed image representation contained within the provided CZML interval
         * or undefined if the interval does not contain image data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval, sourceUri) {
            var result = typeof czmlInterval.image === 'undefined' ? czmlInterval : czmlInterval.image;
            if (typeof sourceUri !== 'undefined') {
                var baseUri = new Uri(document.location.href);
                sourceUri = new Uri(sourceUri);
                result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
            }
            return result;
        },

        /**
         * Since CZML images can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the image value contained within the unwrappedInterval.  For images
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlImage.unwrapInterval.
         * @returns The image value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlImage;
});
/*global define*/
define('DynamicScene/DynamicBillboard',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlCartesian2',
        './CzmlCartesian3',
        './CzmlNumber',
        './CzmlImage',
        './CzmlHorizontalOrigin',
        './CzmlVerticalOrigin',
        './CzmlColor',
        './DynamicProperty'
    ], function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlCartesian2,
        CzmlCartesian3,
        CzmlNumber,
        CzmlImage,
        CzmlHorizontalOrigin,
        CzmlVerticalOrigin,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic billboard, typically used in conjunction with DynamicBillboardVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicBillboard
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicBillboardVisualizer
     * @see VisualizerCollection
     * @see Billboard
     * @see BillboardCollection
     * @see CzmlDefaults
     */
    var DynamicBillboard = function() {
        /**
         * A DynamicProperty of type CzmlImage which determines the billboard's texture.
         * @type DynamicProperty
         */
        this.image = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the billboard's scale.
         * @type DynamicProperty
         */
        this.scale = undefined;
        /**
         * A DynamicProperty of type CzmlHorizontalOrigin which determines the billboard's horizontal origin.
         * @type DynamicProperty
         */
        this.horizontalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlVerticalHorigin which determines the billboard's vertical origin.
         * @type DynamicProperty
         */
        this.verticalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the billboard's color.
         * @type DynamicProperty
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian3 which determines the billboard's eye offset.
         * @type DynamicProperty
         */
        this.eyeOffset = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian2 which determines the billboard's pixel offset.
         * @type DynamicProperty
         */
        this.pixelOffset = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the billboard's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's billboard.
     * If the DynamicObject does not have a billboard, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the billboard data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The collection into which objects are being loaded.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicBillboard.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var billboardData = packet.billboard;
        if (typeof billboardData === 'undefined') {
            return false;
        }

        var billboardUpdated = false;
        var billboard = dynamicObject.billboard;
        billboardUpdated = typeof billboard === 'undefined';
        if (billboardUpdated) {
            dynamicObject.billboard = billboard = new DynamicBillboard();
        }

        var interval = billboardData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof billboardData.color !== 'undefined') {
            var color = billboard.color;
            if (typeof color === 'undefined') {
                billboard.color = color = new DynamicProperty(CzmlColor);
                billboardUpdated = true;
            }
            color.processCzmlIntervals(billboardData.color, interval);
        }

        if (typeof billboardData.eyeOffset !== 'undefined') {
            var eyeOffset = billboard.eyeOffset;
            if (typeof eyeOffset === 'undefined') {
                billboard.eyeOffset = eyeOffset = new DynamicProperty(CzmlCartesian3);
                billboardUpdated = true;
            }
            eyeOffset.processCzmlIntervals(billboardData.eyeOffset, interval);
        }

        if (typeof billboardData.horizontalOrigin !== 'undefined') {
            var horizontalOrigin = billboard.horizontalOrigin;
            if (typeof horizontalOrigin === 'undefined') {
                billboard.horizontalOrigin = horizontalOrigin = new DynamicProperty(CzmlHorizontalOrigin);
                billboardUpdated = true;
            }
            horizontalOrigin.processCzmlIntervals(billboardData.horizontalOrigin, interval);
        }

        if (typeof billboardData.image !== 'undefined') {
            var image = billboard.image;
            if (typeof image === 'undefined') {
                billboard.image = image = new DynamicProperty(CzmlImage);
                billboardUpdated = true;
            }
            image.processCzmlIntervals(billboardData.image, interval, sourceUri);
        }

        if (typeof billboardData.pixelOffset !== 'undefined') {
            var pixelOffset = billboard.pixelOffset;
            if (typeof pixelOffset === 'undefined') {
                billboard.pixelOffset = pixelOffset = new DynamicProperty(CzmlCartesian2);
                billboardUpdated = true;
            }
            pixelOffset.processCzmlIntervals(billboardData.pixelOffset, interval);
        }

        if (typeof billboardData.scale !== 'undefined') {
            var scale = billboard.scale;
            if (typeof scale === 'undefined') {
                billboard.scale = scale = new DynamicProperty(CzmlNumber);
                billboardUpdated = true;
            }
            scale.processCzmlIntervals(billboardData.scale, interval);
        }

        if (typeof billboardData.show !== 'undefined') {
            var show = billboard.show;
            if (typeof show === 'undefined') {
                billboard.show = show = new DynamicProperty(CzmlBoolean);
                billboardUpdated = true;
            }
            show.processCzmlIntervals(billboardData.show, interval);
        }

        if (typeof billboardData.verticalOrigin !== 'undefined') {
            var verticalOrigin = billboard.verticalOrigin;
            if (typeof verticalOrigin === 'undefined') {
                billboard.verticalOrigin = verticalOrigin = new DynamicProperty(CzmlVerticalOrigin);
                billboardUpdated = true;
            }
            verticalOrigin.processCzmlIntervals(billboardData.verticalOrigin, interval);
        }

        return billboardUpdated;
    };

    /**
     * Given two DynamicObjects, takes the billboard properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicBillboard.mergeProperties = function(targetObject, objectToMerge) {
        var billboardToMerge = objectToMerge.billboard;
        if (typeof billboardToMerge !== 'undefined') {

            var targetBillboard = targetObject.billboard;
            if (typeof targetBillboard === 'undefined') {
                targetObject.billboard = targetBillboard = new DynamicBillboard();
            }

            targetBillboard.color = defaultValue(targetBillboard.color, billboardToMerge.color);
            targetBillboard.eyeOffset = defaultValue(targetBillboard.eyeOffset, billboardToMerge.eyeOffset);
            targetBillboard.horizontalOrigin = defaultValue(targetBillboard.horizontalOrigin, billboardToMerge.horizontalOrigin);
            targetBillboard.image = defaultValue(targetBillboard.image, billboardToMerge.image);
            targetBillboard.pixelOffset = defaultValue(targetBillboard.pixelOffset, billboardToMerge.pixelOffset);
            targetBillboard.scale = defaultValue(targetBillboard.scale, billboardToMerge.scale);
            targetBillboard.show = defaultValue(targetBillboard.show, billboardToMerge.show);
            targetBillboard.verticalOrigin = defaultValue(targetBillboard.verticalOrigin, billboardToMerge.verticalOrigin);
        }
    };

    /**
     * Given a DynamicObject, undefines the billboard associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the billboard from.
     *
     * @see CzmlDefaults
     */
    DynamicBillboard.undefineProperties = function(dynamicObject) {
        dynamicObject.billboard = undefined;
    };

    return DynamicBillboard;
});
/*!
  This library rewrites the Canvas2D "measureText" function
  so that it returns a more complete metrics object.
  This library is licensed under the MIT (Expat) license,
  the text for which is included below.

   -----------------------------------------------------------------------------

  CHANGELOG:

    2012-01-21 - Whitespace handling added by Joe Turner
                 (https://github.com/oampo)

   -----------------------------------------------------------------------------

  Copyright (C) 2011 by Mike "Pomax" Kamermans

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
/*global define*/
define('ThirdParty/measureText',[],function() {
    
//  var NAME = "FontMetrics Library";
//  var VERSION = "1-2012.0121.1300";

  // if there is no getComputedStyle, this library won't work.
//  if(!document.defaultView.getComputedStyle) {
//    throw("ERROR: 'document.defaultView.getComputedStyle' not found. This library only works in browsers that can report computed CSS values.");
//  }

  // store the old text metrics function on the Canvas2D prototype
  //CanvasRenderingContext2D.prototype.measureTextWidth = CanvasRenderingContext2D.prototype.measureText;

  /**
   *  shortcut function for getting computed CSS values
   */
  var getCSSValue = function(element, property) {
    return document.defaultView.getComputedStyle(element,null).getPropertyValue(property);
  };

  // debug function
//  var show = function(canvas, ctx, xstart, w, h, metrics)
//  {
//    document.body.appendChild(canvas);
//    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
//
//    ctx.beginPath();
//    ctx.moveTo(xstart,0);
//    ctx.lineTo(xstart,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(xstart+metrics.bounds.maxx,0);
//    ctx.lineTo(xstart+metrics.bounds.maxx,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2-metrics.ascent);
//    ctx.lineTo(w,h/2-metrics.ascent);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2+metrics.descent);
//    ctx.lineTo(w,h/2+metrics.descent);
//    ctx.closePath();
//    ctx.stroke();
//  }

  /**
   * The new text metrics function
   */
  return function(context2D, textstring) {
    var metrics = context2D.measureText(textstring),
        fontFamily = getCSSValue(context2D.canvas,"font-family"),
        fontSize = getCSSValue(context2D.canvas,"font-size").replace("px",""),
        isSpace = !(/\S/.test(textstring));
        metrics.fontsize = fontSize;

    // for text lead values, we meaure a multiline text container.
    var leadDiv = document.createElement("div");
    leadDiv.style.position = "absolute";
    leadDiv.style.opacity = 0;
    leadDiv.style.font = fontSize + "px " + fontFamily;
    leadDiv.innerHTML = textstring + "<br/>" + textstring;
    document.body.appendChild(leadDiv);

    // make some initial guess at the text leading (using the standard TeX ratio)
    metrics.leading = 1.2 * fontSize;

    // then we try to get the real value from the browser
    var leadDivHeight = getCSSValue(leadDiv,"height");
    leadDivHeight = leadDivHeight.replace("px","");
    if (leadDivHeight >= fontSize * 2) { metrics.leading = (leadDivHeight/2) | 0; }
    document.body.removeChild(leadDiv);

    // if we're not dealing with white space, we can compute metrics
    if (!isSpace) {
        // Have characters, so measure the text
        var canvas = document.createElement("canvas");
        var padding = 100;
        canvas.width = metrics.width + padding;
        canvas.height = 3*fontSize;
        canvas.style.opacity = 1;
        canvas.style.fontFamily = fontFamily;
        canvas.style.fontSize = fontSize;
        var ctx = canvas.getContext("2d");
        ctx.font = fontSize + "px " + fontFamily;

        var w = canvas.width,
            h = canvas.height,
            baseline = h/2;

        // Set all canvas pixeldata values to 255, with all the content
        // data being 0. This lets us scan for data[i] != 255.
        ctx.fillStyle = "white";
        ctx.fillRect(-1, -1, w+2, h+2);
        ctx.fillStyle = "black";
        ctx.fillText(textstring, padding/2, baseline);
        var pixelData = ctx.getImageData(0, 0, w, h).data;

        // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,
        // consecutive values in the array, rather than stored as 32 bit ints.
        var i = 0,
            w4 = w * 4,
            len = pixelData.length;

        // Finding the ascent uses a normal, forward scanline
        while (++i < len && pixelData[i] === 255) {}
        var ascent = (i/w4)|0;

        // Finding the descent uses a reverse scanline
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255) {}
        var descent = (i/w4)|0;

        // find the min-x coordinate
        for(i = 0; i<len && pixelData[i] === 255; ) {
          i += w4;
          if(i>=len) { i = (i-len) + 4; }}
        var minx = ((i%w4)/4) | 0;

        // find the max-x coordinate
        var step = 1;
        for(i = len-3; i>=0 && pixelData[i] === 255; ) {
          i -= w4;
          if(i<0) { i = (len - 3) - (step++)*4; }}
        var maxx = ((i%w4)/4) + 1 | 0;

        // set font metrics
        metrics.ascent = (baseline - ascent);
        metrics.descent = (descent - baseline);
        metrics.bounds = { minx: minx - (padding/2),
                           maxx: maxx - (padding/2),
                           miny: 0,
                           maxy: descent-ascent };
        metrics.height = 1+(descent - ascent);
    }

    // if we ARE dealing with whitespace, most values will just be zero.
    else {
        // Only whitespace, so we can't measure the text
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = { minx: 0,
                           maxx: metrics.width, // Best guess
                           miny: 0,
                           maxy: 0 };
        metrics.height = 0;
    }
    return metrics;
  };
});
/*global define*/
define('Core/writeTextToCanvas',[
        './defaultValue',
        './DeveloperError',
        './Color',
        '../ThirdParty/measureText'
    ], function(
        defaultValue,
        DeveloperError,
        Color,
        measureText) {
    

    var EMPTY_OBJECT = {};

    /**
     * Writes the given text into a new canvas.  The canvas will be sized to fit the text.
     * If text is blank, returns undefined.
     *
     * @param {String} text The text to write.
     * @param {String} [description.font='10px sans-serif'] The CSS font to use.
     * @param {String} [description.textBaseline='bottom'] The baseline of the text.
     * @param {Boolean} [description.fill=true] Whether to fill the text.
     * @param {Boolean} [description.stroke=false] Whether to stroke the text.
     * @param {Color} [description.fillColor=Color.WHITE] The fill color.
     * @param {Color} [description.strokeColor=Color.BLACK] The stroke color.
     *
     * @returns {Canvas} A new canvas with the given text drawn into it.  The dimensions object
     *                   from measureText will also be added to the returned canvas. If text is
     *                   blank, returns undefined.
     */
    var writeTextToCanvas = function(text, description) {
        if (typeof text === 'undefined') {
            throw new DeveloperError('text is required.');
        }

        if (text === '') {
            return undefined;
        }

        description = defaultValue(description, EMPTY_OBJECT);
        var font = defaultValue(description.font, '10px sans-serif');

        var canvas = document.createElement('canvas');
        canvas.width = canvas.height = 1;
        canvas.style.font = font;

        var context2D = canvas.getContext('2d');
        context2D.font = font;

        // textBaseline needs to be set before the measureText call. It won't work otherwise.
        // It's magic.
        context2D.textBaseline = defaultValue(description.textBaseline, 'bottom');

        // in order for measureText to calculate style, the canvas has to be
        // (temporarily) added to the DOM.
        canvas.style.visibility = 'hidden';
        document.body.appendChild(canvas);

        var dimensions = measureText(context2D, text);
        canvas.dimensions = dimensions;

        document.body.removeChild(canvas);
        canvas.style.visibility = undefined;

        var baseline = dimensions.height - dimensions.ascent;
        canvas.width = dimensions.width;
        canvas.height = dimensions.height;
        var y = canvas.height - baseline;

        // font must be explicitly set again after changing width and height
        context2D.font = font;

        var fill = defaultValue(description.fill, true);
        if (fill) {
            var fillColor = defaultValue(description.fillColor, Color.WHITE);
            context2D.fillStyle = fillColor.toCSSColor();
            context2D.fillText(text, 0, y);
        }

        var stroke = defaultValue(description.stroke, false);
        if (stroke) {
            var strokeColor = defaultValue(description.strokeColor, Color.BLACK);
            context2D.strokeStyle = strokeColor.toCSSColor();
            context2D.strokeText(text, 0, y);
        }

        return canvas;
    };

    return writeTextToCanvas;
});
/*global define*/
define('Scene/LabelCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Matrix4',
        '../Core/writeTextToCanvas',
        '../Renderer/BufferUsage',
        './BillboardCollection',
        './Label',
        './LabelStyle',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        Matrix4,
        writeTextToCanvas,
        BufferUsage,
        BillboardCollection,
        Label,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    

    // A glyph represents a single character in a particular label.  It may or may
    // not have a billboard, depending on whether the texture info has an index into
    // the the label collection's texture atlas.  Invisible characters have no texture, and
    // no billboard.  However, it always has a valid dimensions object.
    function Glyph() {
        this.textureInfo = undefined;
        this.dimensions = undefined;
        this.billboard = undefined;
    }

    // GlyphTextureInfo represents a single character, drawn in a particular style,
    // shared and reference counted across all labels.  It may or may not have an
    // index into the label collection's texture atlas, depending on whether the character
    // has both width and height, but it always has a valid dimensions object.
    function GlyphTextureInfo(labelCollection, index, dimensions) {
        this.labelCollection = labelCollection;
        this.index = index;
        this.dimensions = dimensions;
        this.referenceCount = 1;

        ++labelCollection._textureCount;
    }

    GlyphTextureInfo.prototype.addReference = function() {
        if (this.referenceCount === 0) {
            // was fully released, now has references, so no longer unused
            --this.labelCollection._unusedTextureCount;
        }

        ++this.referenceCount;
    };

    GlyphTextureInfo.prototype.releaseReference = function() {
        --this.referenceCount;

        if (this.referenceCount === 0) {
            ++this.labelCollection._unusedTextureCount;
        }
    };

    // reusable object for calling writeTextToCanvas
    var writeTextToCanvasParameters = {};
    function createGlyphCanvas(character, font, fillColor, outlineColor, style, verticalOrigin) {
        writeTextToCanvasParameters.font = font;
        writeTextToCanvasParameters.fillColor = fillColor;
        writeTextToCanvasParameters.strokeColor = outlineColor;

        if (verticalOrigin === VerticalOrigin.BOTTOM) {
            writeTextToCanvasParameters.textBaseline = 'bottom';
        } else if (verticalOrigin === VerticalOrigin.TOP) {
            writeTextToCanvasParameters.textBaseline = 'top';
        } else {
            // VerticalOrigin.CENTER
            writeTextToCanvasParameters.textBaseline = 'middle';
        }

        writeTextToCanvasParameters.fill = style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;
        writeTextToCanvasParameters.stroke = style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;

        return writeTextToCanvas(character, writeTextToCanvasParameters);
    }

    function unbindGlyph(labelCollection, glyph) {
        if (typeof glyph.textureInfo !== 'undefined') {
            glyph.textureInfo.releaseReference();
        }

        glyph.textureInfo = undefined;
        glyph.dimensions = undefined;

        var billboard = glyph.billboard;
        if (typeof billboard !== 'undefined') {
            billboard.setShow(false);
            billboard.setImageIndex(-1);
            labelCollection._spareBillboards.push(billboard);
            glyph.billboard = undefined;
        }
    }

    function rebindAllGlyphs(labelCollection, label) {
        var text = label._text;
        var textLength = text.length;
        var glyphs = label._glyphs;
        var glyphsLength = glyphs.length;

        var glyph, glyphIndex, textIndex;

        // if we have more glyphs than needed, unbind the extras.
        if (textLength < glyphsLength) {
            for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {
                unbindGlyph(labelCollection, glyphs[glyphIndex]);
            }
        }

        // presize glyphs to match the new text length
        glyphs.length = textLength;

        var glyphTextureCache = labelCollection._glyphTextureCache;
        var textureAtlas = labelCollection._textureAtlas;

        // walk the text looking for new characters (creating new glyphs for each)
        // or changed characters (rebinding existing glyphs)
        for (textIndex = 0; textIndex < textLength; ++textIndex) {
            var character = text.charAt(textIndex);
            var font = label._font;
            var fillColor = label._fillColor;
            var outlineColor = label._outlineColor;
            var style = label._style;
            var verticalOrigin = label._verticalOrigin;

            // retrieve glyph dimensions and texture index (if the canvas has area)
            // from the glyph texture cache, or create and add if not present.
            var id = JSON.stringify([
                                     character,
                                     font,
                                     fillColor.toString(),
                                     outlineColor.toString(),
                                     style.toString(),
                                     verticalOrigin.toString()
                                    ]);

            var glyphTextureInfo = glyphTextureCache[id];
            if (typeof glyphTextureInfo === 'undefined') {
                var canvas = createGlyphCanvas(character, font, fillColor, outlineColor, style, verticalOrigin);
                var index = -1;
                if (canvas.width > 0 && canvas.height > 0) {
                    index = textureAtlas.addImage(canvas);
                }

                glyphTextureInfo = new GlyphTextureInfo(labelCollection, index, canvas.dimensions);
                glyphTextureCache[id] = glyphTextureInfo;
            } else {
                glyphTextureInfo.addReference();
            }

            glyph = glyphs[textIndex];

            if (typeof glyph !== 'undefined') {
                // clean up leftover information from the previous glyph
                if (glyphTextureInfo.index === -1) {
                    // no texture, and therefore no billboard, for this glyph.
                    // so, completely unbind glyph.
                    unbindGlyph(labelCollection, glyph);
                } else {
                    // we have a texture and billboard.  If we had one before, release
                    // our reference to that texture info, but reuse the billboard.
                    if (typeof glyph.textureInfo !== 'undefined') {
                        glyph.textureInfo.releaseReference();
                        glyph.textureInfo = undefined;
                    }
                }
            } else {
                // create a glyph object
                glyph = new Glyph();
                glyphs[textIndex] = glyph;
            }

            glyph.textureInfo = glyphTextureInfo;
            glyph.dimensions = glyphTextureInfo.dimensions;

            // if we have a texture, configure the existing billboard, or obtain one
            if (glyphTextureInfo.index !== -1) {
                var billboard = glyph.billboard;
                if (typeof billboard === 'undefined') {
                    if (labelCollection._spareBillboards.length > 0) {
                        glyph.billboard = billboard = labelCollection._spareBillboards.pop();
                    } else {
                        glyph.billboard = billboard = labelCollection._billboardCollection.add();
                    }

                    billboard.setShow(label._show);
                    billboard.setPosition(label._position);
                    billboard.setEyeOffset(label._eyeOffset);
                    billboard.setHorizontalOrigin(HorizontalOrigin.LEFT);
                    billboard.setVerticalOrigin(label._verticalOrigin);
                    billboard.setScale(label._scale);
                    billboard._pickIdThis = label;
                }

                glyph.billboard.setImageIndex(glyphTextureInfo.index);
            }
        }

        // changing glyphs will cause the position of the
        // glyphs to change, since different characters have different widths
        label._repositionAllGlyphs = true;
    }

    // reusable Cartesian2 instance
    var glyphPixelOffset = new Cartesian2();

    function repositionAllGlyphs(label) {
        var glyphs = label._glyphs;
        var glyph;
        var dimensions;
        var totalWidth = 0;
        var maxHeight = 0;

        var glyphIndex = 0;
        var glyphLength = glyphs.length;
        for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
            glyph = glyphs[glyphIndex];
            dimensions = glyph.dimensions;
            totalWidth += dimensions.width;
            maxHeight = Math.max(maxHeight, dimensions.height);
        }

        var scale = label._scale;
        var horizontalOrigin = label._horizontalOrigin;
        var widthOffset = 0;
        if (horizontalOrigin === HorizontalOrigin.CENTER) {
            widthOffset -= totalWidth / 2 * scale;
        } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {
            widthOffset -= totalWidth * scale;
        }

        var pixelOffset = label._pixelOffset;

        glyphPixelOffset.x = pixelOffset.x + widthOffset;
        glyphPixelOffset.y = 0;

        var verticalOrigin = label._verticalOrigin;
        for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
            glyph = glyphs[glyphIndex];
            dimensions = glyph.dimensions;

            if (verticalOrigin === VerticalOrigin.BOTTOM || dimensions.height === maxHeight) {
                glyphPixelOffset.y = pixelOffset.y - dimensions.descent * scale;
            } else if (verticalOrigin === VerticalOrigin.TOP) {
                glyphPixelOffset.y = pixelOffset.y - (maxHeight - dimensions.height) * scale - dimensions.descent * scale;
            } else if (verticalOrigin === VerticalOrigin.CENTER) {
                glyphPixelOffset.y = pixelOffset.y - (maxHeight - dimensions.height) / 2 * scale - dimensions.descent * scale;
            }

            if (typeof glyph.billboard !== 'undefined') {
                glyph.billboard.setPixelOffset(glyphPixelOffset);
            }

            glyphPixelOffset.x += dimensions.width * scale;
        }
    }

    function destroyLabel(labelCollection, label) {
        var glyphs = label._glyphs;
        for ( var i = 0, len = glyphs.length; i < len; ++i) {
            unbindGlyph(labelCollection, glyphs[i]);
        }
        destroyObject(label);
    }

    /**
     * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
     * Each label can have a different font, color, scale, etc.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Label.png' width='400' height='300' /><br />
     * Example labels
     * </div>
     * <br /><br />
     * Labels are added and removed from the collection using {@link LabelCollection#add}
     * and {@link LabelCollection#remove}.
     *
     * @alias LabelCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many labels, to
     * many collections with only a few labels each.  Avoid having collections where some
     * labels change every frame and others do not; instead, create one or more collections
     * for static labels, and one or more collections for dynamic labels.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see Label
     * @see BillboardCollection
     *
     * @example
     * // Create a label collection with two labels
     * var labels = new LabelCollection();
     * labels.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 },
     *   text : 'A label'
     * });
     * labels.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 },
     *   text : 'Another label'
     * });
     */
    var LabelCollection = function() {
        this._textureAtlas = undefined;

        this._billboardCollection = new BillboardCollection();
        this._billboardCollection.setDestroyTextureAtlas(false);

        this._spareBillboards = [];
        this._glyphTextureCache = {};
        this._textureCount = 0;
        this._unusedTextureCount = 0;
        this._labels = [];
        this._labelsToUpdate = [];
        this._frameCount = 0;
        this._totalGlyphCount = 0;

        /**
         * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
         * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link czm_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see czm_model
         *
         * @example
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * labels.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 0.0),
         *   text     : 'Center'
         * });
         * labels.add({
         *   position : new Cartesian3(1000000.0, 0.0, 0.0),
         *   text     : 'East'
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 1000000.0, 0.0),
         *   text     : 'North'
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 1000000.0),
         *   text     : 'Up'
         * });
         */
        this.modelMatrix = Matrix4.IDENTITY.clone();

        /**
         * If true, aligns all text to a pixel in screen space,
         * providing crisper text at the cost of jumpier motion.
         * Defaults to true.
         *
         * @type Boolean
         */
        this.clampToPixel = true;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;
    };

    /**
     * Creates and adds a label with the specified initial properties to the collection.
     * The added label is returned so it can be modified or removed from the collection later.
     *
     * @memberof LabelCollection
     *
     * @param {Object}[description] A template describing the label's properties as shown in Example 1.
     *
     * @return {Label} The label that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * is rewritten; this operations is <code>O(n)</code> and also incurs
     * CPU to GPU overhead.  For best performance, add as many billboards as possible before
     * calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#remove
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     *
     * @example
     * // Example 1:  Add a label, specifying all the default values.
     * var l = labels.add({
     *   show : true,
     *   position : Cartesian3.ZERO,
     *   text : '',
     *   font : '30px sans-serif',
     *   fillColor : 'white',
     *   outlineColor : 'white',
     *   style : LabelStyle.FILL,
     *   pixelOffset : Cartesian2.ZERO,
     *   eyeOffset : Cartesian3.ZERO,
     *   horizontalOrigin : HorizontalOrigin.LEFT,
     *   verticalOrigin : VerticalOrigin.BOTTOM,
     *   scale : 1.0,
     * });
     *
     * // Example 2:  Specify only the label's cartographic position,
     * // text, and font.
     * var l = labels.add({
     *   position : ellipsoid.cartographicToCartesian(new Cartographic(longitude, latitude, height)),
     *   text : 'Hello World',
     *   font : '24px Helvetica',
     * });
     */
    LabelCollection.prototype.add = function(description) {
        var label = new Label(description, this, this._labels.length);

        this._labels.push(label);
        this._labelsToUpdate.push(label);

        return label;
    };

    /**
     * Removes a label from the collection.  Once removed, a label is no longer usable.
     *
     * @memberof LabelCollection
     *
     * @param {Label} label The label to remove.
     *
     * @return {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many labels as possible before calling <code>update</code>.
     * If you intend to temporarily hide a label, it is usually more efficient to call
     * {@link Label#setShow} instead of removing and re-adding the label.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     * @see Label#setShow
     *
     * @example
     * var l = labels.add(...);
     * labels.remove(l);  // Returns true
     */
    LabelCollection.prototype.remove = function(label) {
        if (typeof label === 'undefined') {
            return false;
        }

        if (label._labelCollection === this) {
            this._labels.splice(label._index, 1);
            destroyLabel(this, label);

            return true;
        }

        return false;
    };

    /**
     * Removes all labels from the collection.
     *
     * @memberof LabelCollection
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the labels
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see LabelCollection#update
     *
     * @example
     * labels.add(...);
     * labels.add(...);
     * labels.removeAll();
     */
    LabelCollection.prototype.removeAll = function() {
        var labels = this._labels;

        for ( var i = 0, len = labels.length; i < len; ++i) {
            destroyLabel(this, labels[i]);
        }

        labels.length = 0;
    };

    /**
     * Check whether this collection contains a given label.
     *
     * @memberof LabelCollection
     *
     * @param {Label} label The label to check for.
     *
     * @return {Boolean} true if this collection contains the label, false otherwise.
     *
     * @see LabelCollection#get
     */
    LabelCollection.prototype.contains = function(label) {
        return typeof label !== 'undefined' && label._labelCollection === this;
    };

    /**
     * Returns the label in the collection at the specified index.  Indices are zero-based
     * and increase as labels are added.  Removing a label shifts all labels after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link LabelCollection#getLength} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Label} The label at the specified index.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#getLength
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._labels[index];
    };

    /**
     * Returns the number of labels in this collection.  This is commonly used with
     * {@link LabelCollection#get} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @return {Number} The number of labels in this collection.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#get
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.getLength = function() {
        return this._labels.length;
    };

    /**
     * @private
     */
    LabelCollection.prototype.update = function(context, frameState, commandList) {
        var billboardCollection = this._billboardCollection;

        billboardCollection.modelMatrix = this.modelMatrix;
        billboardCollection.morphTime = this.morphTime;
        billboardCollection.clampToPixel = this.clampToPixel;

        var rebindAllGlyphsInAllLabels = false;
        if (++this._frameCount % 100 === 0) {
            this._frameCount = 0;
            // clear and rebuild texture atlas to compact it when we have more than 25% unused textures
            if (this._unusedTextureCount > 0.25 * this._textureCount) {
                this._textureAtlas = this._textureAtlas.destroy();
                this._glyphTextureCache = {};
                this._textureCount = 0;
                this._unusedTextureCount = 0;

                // rebind and update all labels to repopulate the textures
                rebindAllGlyphsInAllLabels = true;
                this._labelsToUpdate = this._labels.slice(0);
            }

            // prune spare billboards to 10% of total glyph count
            while (this._spareBillboards.length > this._totalGlyphCount * 0.1) {
                billboardCollection.remove(this._spareBillboards.pop());
            }
        }

        if (typeof this._textureAtlas === 'undefined') {
            this._textureAtlas = context.createTextureAtlas();
            billboardCollection.setTextureAtlas(this._textureAtlas);
        }

        var labelsToUpdate = this._labelsToUpdate;
        for ( var i = 0, len = labelsToUpdate.length; i < len; ++i) {
            var label = labelsToUpdate[i];
            if (label.isDestroyed()) {
                continue;
            }

            var preUpdateGlyphCount = label._glyphs.length;

            if (rebindAllGlyphsInAllLabels || label._rebindAllGlyphs) {
                rebindAllGlyphs(this, label);
                label._rebindAllGlyphs = false;
            }

            if (label._repositionAllGlyphs) {
                repositionAllGlyphs(label);
                label._repositionAllGlyphs = false;
            }

            var glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;
            this._totalGlyphCount += glyphCountDifference;
        }
        labelsToUpdate.length = 0;

        this._billboardCollection.update(context, frameState, commandList);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof LabelCollection
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see LabelCollection#destroy
     */
    LabelCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof LabelCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#isDestroyed
     *
     * @example
     * labels = labels && labels.destroy();
     */
    LabelCollection.prototype.destroy = function() {
        // removeAll destroys the texture atlas
        this.removeAll();
        this._billboardCollection.destroy();
        return destroyObject(this);
    };

    return LabelCollection;
});
/*global define*/
define('DynamicScene/DynamicLabelVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Scene/LabelCollection',
        '../Scene/LabelStyle',
        '../Scene/HorizontalOrigin',
        '../Scene/VerticalOrigin'
    ], function(
        DeveloperError,
        destroyObject,
        Color,
        Cartesian2,
        Cartesian3,
        LabelCollection,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicLabel instance
     * in DynamicObject.label to a Label primitive.
     * @alias DynamicLabelVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicLabel
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicLabelVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;

        var labelCollection = this._labelCollection = new LabelCollection();
        scene.getPrimitives().add(labelCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicLabelVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicLabelVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicLabelVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicLabelVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicLabelVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicLabelVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicLabelVisualizer.prototype.removeAllPrimitives = function() {
        this._unusedIndexes = [];
        this._labelCollection.removeAll();
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._labelVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicLabelVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicLabelVisualizer#destroy
     */
    DynamicLabelVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicLabelVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicLabelVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicLabelVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._labelCollection);
        return destroyObject(this);
    };

    var position;
    var fillColor;
    var outlineColor;
    var eyeOffset;
    var pixelOffset;
    DynamicLabelVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicLabel = dynamicObject.label;
        if (typeof dynamicLabel === 'undefined') {
            return;
        }

        var textProperty = dynamicLabel.text;
        if (typeof textProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var label;
        var showProperty = dynamicLabel.show;
        var labelVisualizerIndex = dynamicObject._labelVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof labelVisualizerIndex !== 'undefined') {
                label = this._labelCollection.get(labelVisualizerIndex);
                label.setShow(false);
                this._unusedIndexes.push(labelVisualizerIndex);
                dynamicObject._labelVisualizerIndex = undefined;
            }
            return;
        }

        if (typeof labelVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                labelVisualizerIndex = unusedIndexes.pop();
                label = this._labelCollection.get(labelVisualizerIndex);
            } else {
                labelVisualizerIndex = this._labelCollection.getLength();
                label = this._labelCollection.add();
            }
            dynamicObject._labelVisualizerIndex = labelVisualizerIndex;
            label.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            label.setText('');
            label.setScale(1.0);
            label.setFont('30px sans-serif');
            label.setFillColor(Color.WHITE);
            label.setOutlineColor(Color.BLACK);
            label.setStyle(LabelStyle.FILL);
            label.setPixelOffset(Cartesian2.ZERO);
            label.setEyeOffset(Cartesian3.ZERO);
            label.setHorizontalOrigin(HorizontalOrigin.CENTER);
            label.setVerticalOrigin(VerticalOrigin.CENTER);
        } else {
            label = this._labelCollection.get(labelVisualizerIndex);
        }

        label.setShow(show);

        var text = textProperty.getValue(time);
        if (typeof text !== 'undefined') {
            label.setText(text);
        }

        position = positionProperty.getValueCartesian(time, position);
        if (typeof position !== 'undefined') {
            label.setPosition(position);
        }

        var property = dynamicLabel.scale;
        if (typeof property !== 'undefined') {
            var scale = property.getValue(time);
            if (typeof scale !== 'undefined') {
                label.setScale(scale);
            }
        }

        property = dynamicLabel.font;
        if (typeof property !== 'undefined') {
            var font = property.getValue(time);
            if (typeof font !== 'undefined') {
                label.setFont(font);
            }
        }

        property = dynamicLabel.fillColor;
        if (typeof property !== 'undefined') {
            fillColor = property.getValue(time, fillColor);
            if (typeof fillColor !== 'undefined') {
                label.setFillColor(fillColor);
            }
        }

        property = dynamicLabel.outlineColor;
        if (typeof property !== 'undefined') {
            outlineColor = property.getValue(time, outlineColor);
            if (typeof outlineColor !== 'undefined') {
                label.setOutlineColor(outlineColor);
            }
        }

        property = dynamicLabel.style;
        if (typeof property !== 'undefined') {
            var style = property.getValue(time);
            if (typeof style !== 'undefined') {
                label.setStyle(style);
            }
        }

        property = dynamicLabel.pixelOffset;
        if (typeof property !== 'undefined') {
            pixelOffset = property.getValue(time, pixelOffset);
            if (typeof pixelOffset !== 'undefined') {
                label.setPixelOffset(pixelOffset);
            }
        }

        property = dynamicLabel.eyeOffset;
        if (typeof property !== 'undefined') {
            eyeOffset = property.getValue(time, eyeOffset);
            if (typeof eyeOffset !== 'undefined') {
                label.setEyeOffset(eyeOffset);
            }
        }

        property = dynamicLabel.horizontalOrigin;
        if (typeof property !== 'undefined') {
            var horizontalOrigin = property.getValue(time);
            if (typeof horizontalOrigin !== 'undefined') {
                label.setHorizontalOrigin(horizontalOrigin);
            }
        }

        property = dynamicLabel.verticalOrigin;
        if (typeof property !== 'undefined') {
            var verticalOrigin = property.getValue(time);
            if (typeof verticalOrigin !== 'undefined') {
                label.setVerticalOrigin(verticalOrigin);
            }
        }
    };

    DynamicLabelVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisLabelCollection = this._labelCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var labelVisualizerIndex = dynamicObject._labelVisualizerIndex;
            if (typeof labelVisualizerIndex !== 'undefined') {
                var label = thisLabelCollection.get(labelVisualizerIndex);
                label.setShow(false);
                thisUnusedIndexes.push(labelVisualizerIndex);
                dynamicObject._labelVisualizerIndex = undefined;
            }
        }
    };

    return DynamicLabelVisualizer;
});
/** @license MIT License (c) copyright B Cavalier & J Hann */

/**
 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.5.0
 */

(function(define, global) {
define('ThirdParty/when',['module'], function(module) { 
    var freeze, reduceArray, slice, envFreeze, falseRx, undef;

//    falseRx = /^false$/i;
//    envFreeze = 'WHEN_PARANOID';
//
//    // Do we need to be extra-secure? i.e. freeze promise, etc.
//    if(module && typeof module.config === 'function') {
//        freeze = module.config().paranoid !== false;
//    } else if(typeof process == 'object') {
//        freeze = !falseRx.test(process.env[envFreeze]);
//    } else if(typeof system == 'object') {
//        freeze = !falseRx.test(system.env[envFreeze]);
//    } else {
//        freeze = !(global && global.when_config && global.when_config.paranoid === false);
//    }

    // If secure and Object.freeze is available, use it.
    freeze = (freeze && Object.freeze) || identity;

    //
    // Public API
    //

    when.defer     = defer;     // Create a deferred
    when.resolve   = resolve;   // Create a resolved promise
    when.reject    = reject;    // Create a rejected promise

    when.all       = all;       // Resolve a list of promises
    when.some      = some;      // Resolve a sub-set of promises
    when.any       = any;       // Resolve one promise in a list

    when.map       = map;       // Array.map() for promises
    when.reduce    = reduce;    // Array.reduce() for promises

    when.chain     = chain;     // Make a promise trigger another resolver

    when.isPromise = isPromise; // Determine if a thing is a promise

    /**
     * Register an observer for a promise or immediate value.
     * @function
     * @name when
     * @namespace
     *
     * @param promiseOrValue {*}
     * @param {Function} [callback] callback to be called when promiseOrValue is
     *   successfully resolved.  If promiseOrValue is an immediate value, callback
     *   will be invoked immediately.
     * @param {Function} [errback] callback to be called when promiseOrValue is
     *   rejected.
     * @param {Function} [progressHandler] callback to be called when progress updates
     *   are issued for promiseOrValue.
     * @returns {Promise} a new {@link Promise} that will complete with the return
     *   value of callback or errback or the completion value of promiseOrValue if
     *   callback and/or errback is not supplied.
     */
    function when(promiseOrValue, callback, errback, progressHandler) {
        // Get a trusted promise for the input promiseOrValue, and then
        // register promise handlers
        return resolve(promiseOrValue).then(callback, errback, progressHandler);
    }

    /**
     * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
     * promiseOrValue is a foreign promise, or a new, already-resolved {@link Promise}
     * whose resolution value is promiseOrValue if promiseOrValue is an immediate value.
     * @memberOf when
     *
     * @param promiseOrValue {*}
     * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
     *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
     *   whose resolution value is:
     *   * the resolution value of promiseOrValue if it's a foreign promise, or
     *   * promiseOrValue if it's a value
     */
    function resolve(promiseOrValue) {
        var promise, deferred;

        if(promiseOrValue instanceof Promise) {
            // It's a when.js promise, so we trust it
            promise = promiseOrValue;

        } else {
            // It's not a when.js promise.
            // Check to see if it's a foreign promise or a value.

            // Some promises, particularly Q promises, provide a valueOf method that
            // attempts to synchronously return the fulfilled value of the promise, or
            // returns the unresolved promise itself.  Attempting to break a fulfillment
            // value out of a promise appears to be necessary to break cycles between
            // Q and When attempting to coerce each-other's promises in an infinite loop.
            // For promises that do not implement "valueOf", the Object#valueOf is harmless.
            // See: https://github.com/kriskowal/q/issues/106
            if (promiseOrValue != null && typeof promiseOrValue.valueOf === "function") {
                promiseOrValue = promiseOrValue.valueOf();
            }

            if(isPromise(promiseOrValue)) {
                // It looks like a thenable, but we don't know where it came from,
                // so we don't trust its implementation entirely.  Introduce a trusted
                // middleman when.js promise
                deferred = defer();

                // IMPORTANT: This is the only place when.js should ever call .then() on
                // an untrusted promise.
                promiseOrValue.then(deferred.resolve, deferred.reject, deferred.progress);
                promise = deferred.promise;

            } else {
                // It's a value, not a promise.  Create a resolved promise for it.
                promise = resolved(promiseOrValue);
            }
        }

        return promise;
    }

    /**
     * Returns a rejected promise for the supplied promiseOrValue. If
     * promiseOrValue is a value, it will be the rejection value of the
     * returned promise.  If promiseOrValue is a promise, its
     * completion value will be the rejected value of the returned promise
     * @memberOf when
     *
     * @param promiseOrValue {*} the rejected value of the returned {@link Promise}
     * @return {Promise} rejected {@link Promise}
     */
    function reject(promiseOrValue) {
        return when(promiseOrValue, function(value) {
            return rejected(value);
        });
    }

    /**
     * Trusted Promise constructor.  A Promise created from this constructor is
     * a trusted when.js promise.  Any other duck-typed promise is considered
     * untrusted.
     * @constructor
     * @name Promise
     */
    function Promise() {}

    Promise.prototype = freeze({
        /**
         * Register a callback that will be called when a promise is
         * resolved or rejected.  Optionally also register a progress handler.
         * Shortcut for .then(alwaysback, alwaysback, progback)
         * @memberOf Promise
         * @param alwaysback {Function}
         * @param progback {Function}
         * @return {Promise}
         */
        always: function(alwaysback, progback) {
            return this.then(alwaysback, alwaysback, progback);
        },

        /**
         * Register a rejection handler.  Shortcut for .then(null, errback)
         * @memberOf Promise
         * @param errback {Function}
         * @return {Promise}
         */
        otherwise: function(errback) {
            return this.then(undef, errback);
        }
    });

    /**
     * Create an already-resolved promise for the supplied value
     * @private
     *
     * @param value anything
     * @return {Promise}
     */
    function resolved(value) {

        var p = new Promise();

        p.then = function(callback) {
            try {
                return resolve(callback ? callback(value) : value);
            } catch(e) {
                return rejected(e);
            }
        };

        return freeze(p);
    }

    /**
     * Create an already-rejected {@link Promise} with the supplied
     * rejection reason.
     * @private
     *
     * @param reason rejection reason
     * @return {Promise}
     */
    function rejected(reason) {

        var p = new Promise();

        p.then = function(callback, errback) {
            try {
                return errback ? resolve(errback(reason)) : rejected(reason);
            } catch(e) {
                return rejected(e);
            }
        };

        return freeze(p);
    }

    /**
     * Creates a new, Deferred with fully isolated resolver and promise parts,
     * either or both of which may be given out safely to consumers.
     * The Deferred itself has the full API: resolve, reject, progress, and
     * then. The resolver has resolve, reject, and progress.  The promise
     * only has then.
     * @memberOf when
     * @function
     *
     * @return {Deferred}
     */
    function defer() {
        var deferred, promise, resolver, listeners, progressHandlers,
            _then, _progress, _resolve;

        listeners = [];
        progressHandlers = [];

        /**
         * The full Deferred object, with {@link Promise} and {@link Resolver} parts
         * @class Deferred
         * @name Deferred
         */
        deferred = {};

        /**
         * The {@link Resolver} for this {@link Deferred}
         * @memberOf Deferred
         * @name resolver
         * @class Resolver
         */
        resolver = {};

        /**
         * The {@link Promise} for this {@link Deferred}
         * @memberOf Deferred
         * @name promise
         * @type {Promise}
         */
        promise = new Promise();

        /**
         * Registers a handler for this {@link Deferred}'s {@link Promise}.  Even though all arguments
         * are optional, each argument that *is* supplied must be null, undefined, or a Function.
         * Any other value will cause an Error to be thrown.
         * @memberOf Promise
         * @name then
         * @param [callback] {Function} resolution handler
         * @param [errback] {Function} rejection handler
         * @param [progback] {Function} progress handler
         * @throw {Error} if any argument is not null, undefined, or a Function
         */
        promise.then = deferred.then = function then(callback, errback, progback) {
            return _then(callback, errback, progback);
        };

        deferred.promise = freeze(promise);

        /**
         * Resolves this {@link Deferred}'s {@link Promise} with val as the
         * resolution value.
         * @memberOf Resolver
         * @param val {*|Promise} If val is anything but a Promise, resolves this
         *  Deferred's Promise with val.  If val is a Promise, puts this Deferred's
         *  Promise into the same state as val.  For example, if val is a rejected
         *  promise, this Deferred will become rejected.
         * @return {Promise} a promise for the resolution value
         */
        resolver.resolve = deferred.resolve = function promiseResolve(val) {
            return _resolve(val);
        };

        /**
         * Rejects this {@link Deferred}'s {@link Promise} with err as the
         * reason.
         * @memberOf Resolver
         * @param err anything
         * @return {Promise} a promise for the rejection value
         */
        resolver.reject = deferred.reject = function promiseReject(err) {
            return _resolve(rejected(err));
        };

        /**
         * Emits a progress update to all progress observers registered with
         * this {@link Deferred}'s {@link Promise}
         * @memberOf Resolver
         * @param update anything
         */
        resolver.progress = deferred.progress = function promiseProgress(update) {
            _progress(update);
        };

        deferred.resolver = freeze(resolver);

        /**
         * Pre-resolution then() that adds the supplied callback, errback, and progback
         * functions to the registered listeners
         * @private
         *
         * @param [callback] {Function} resolution handler
         * @param [errback] {Function} rejection handler
         * @param [progback] {Function} progress handler
         * @throws {Error} if any argument is not null, undefined, or a Function
         */
        _then = function(callback, errback, progback) {
            var deferred = defer();

            listeners.push(function(promise) {
                promise.then(callback, errback)
                    .then(deferred.resolve, deferred.reject, deferred.progress);
            });

            progback && progressHandlers.push(progback);

            return deferred.promise;
        };

        /**
         * Issue a progress event, notifying all progress listeners
         * @private
         * @param update {*} progress event payload to pass to all listeners
         */
        _progress = function(update) {
            var progress, i = 0;

            while (progress = progressHandlers[i++]) {
                progress(update);
            }
        };

        /**
         * Transition from pre-resolution state to post-resolution state, notifying
         * all listeners of the resolution or rejection
         * @private
         * @param completed {Promise} the completed value of this deferred
         */
        _resolve = function(completed) {
            var listener, i = 0;

            completed = resolve(completed);

            // Replace _then with one that directly notifies with the result.
            _then = completed.then;

            // Replace _resolve so that this Deferred can only be completed
            // once. Also make _progress a noop, since progress can no longer
            // be issued for the resolved promise.
            _resolve = resolve;
            _progress = noop;

            // Notify listeners
            while (listener = listeners[i++]) {
                listener(completed);
            }

            // Free progressHandlers array since we'll never issue progress events
            progressHandlers = listeners = undef;

            return completed;
        };

        return deferred;
    }

    /**
     * Determines if promiseOrValue is a promise or not.  Uses the feature
     * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
     * promiseOrValue is a promise.
     *
     * @param promiseOrValue anything
     * @returns {Boolean} true if promiseOrValue is a {@link Promise}
     */
    function isPromise(promiseOrValue) {
        return promiseOrValue && typeof promiseOrValue.then === 'function';
    }

    /**
     * Return a promise that will resolve when howMany of the supplied promisesOrValues
     * have resolved. The resolution value of the returned promise will be an array of
     * length howMany containing the resolutions values of the triggering promisesOrValues.
     * @memberOf when
     *
     * @param promisesOrValues {Array} array of anything, may contain a mix
     *      of {@link Promise}s and values
     * @param howMany
     * @param [callback]
     * @param [errback]
     * @param [progressHandler]
     * @returns {Promise}
     */
    function some(promisesOrValues, howMany, callback, errback, progressHandler) {

        checkCallbacks(2, arguments);

        return when(promisesOrValues, function(promisesOrValues) {

            var toResolve, results, deferred, resolve, reject, progress, len, i;

            len = promisesOrValues.length >>> 0;

            toResolve = Math.max(0, Math.min(howMany, len));
            results = [];
            deferred = defer();

            // No items in the input, resolve immediately
            if (!toResolve) {
                deferred.resolve(results);

            } else {
                // TODO: Consider rejecting only when N (or promises.length - N?)
                // promises have been rejected instead of only one?
                reject = deferred.reject;
                progress = deferred.progress;

                // Resolver for promises.  Captures the value and resolves
                // the returned promise when toResolve reaches zero.
                // Overwrites resolver var with a noop once promise has
                // be resolved to cover case where n < promises.length
                resolve = function(val) {
                    // This orders the values based on promise resolution order
                    // Another strategy would be to use the original position of
                    // the corresponding promise.
                    results.push(val);

                    if (!--toResolve) {
                        resolve = noop;
                        deferred.resolve(results);
                    }
                };

                for(i = 0; i < len; ++i) {
                    if(i in promisesOrValues) {
                        when(promisesOrValues[i], resolve, reject, progress);
                    }
                }
            }

            return deferred.then(callback, errback, progressHandler);
        });
    }

    /**
     * Return a promise that will resolve only once all the supplied promisesOrValues
     * have resolved. The resolution value of the returned promise will be an array
     * containing the resolution values of each of the promisesOrValues.
     * @memberOf when
     *
     * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
     *      of {@link Promise}s and values
     * @param [callback] {Function}
     * @param [errback] {Function}
     * @param [progressHandler] {Function}
     * @returns {Promise}
     */
    function all(promisesOrValues, callback, errback, progressHandler) {
        checkCallbacks(1, arguments);
        return map(promisesOrValues, identity).then(callback, errback, progressHandler);
    }

    /**
     * Return a promise that will resolve when any one of the supplied promisesOrValues
     * has resolved. The resolution value of the returned promise will be the resolution
     * value of the triggering promiseOrValue.
     * @memberOf when
     *
     * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
     *      of {@link Promise}s and values
     * @param [callback] {Function}
     * @param [errback] {Function}
     * @param [progressHandler] {Function}
     * @returns {Promise}
     */
    function any(promisesOrValues, callback, errback, progressHandler) {

        function unwrapSingleResult(val) {
            return callback ? callback(val[0]) : val[0];
        }

        return some(promisesOrValues, 1, unwrapSingleResult, errback, progressHandler);
    }

    /**
     * Traditional map function, similar to `Array.prototype.map()`, but allows
     * input to contain {@link Promise}s and/or values, and mapFunc may return
     * either a value or a {@link Promise}
     *
     * @memberOf when
     *
     * @param promise {Array|Promise} array of anything, may contain a mix
     *      of {@link Promise}s and values
     * @param mapFunc {Function} mapping function mapFunc(value) which may return
     *      either a {@link Promise} or value
     * @returns {Promise} a {@link Promise} that will resolve to an array containing
     *      the mapped output values.
     */
    function map(promise, mapFunc) {
        return when(promise, function(array) {
            var results, len, toResolve, resolve, reject, i, d;

            // Since we know the resulting length, we can preallocate the results
            // array to avoid array expansions.
            toResolve = len = array.length >>> 0;
            results = [];
            d = defer();

            if(!toResolve) {
                d.resolve(results);
            } else {

                reject = d.reject;
                resolve = function resolveOne(item, i) {
                    when(item, mapFunc).then(function(mapped) {
                        results[i] = mapped;

                        if(!--toResolve) {
                            d.resolve(results);
                        }
                    }, reject);
                };

                // Since mapFunc may be async, get all invocations of it into flight
                for(i = 0; i < len; i++) {
                    if(i in array) {
                        resolve(array[i], i);
                    } else {
                        --toResolve;
                    }
                }

            }

            return d.promise;

        });
    }

    /**
     * Traditional reduce function, similar to `Array.prototype.reduce()`, but
     * input may contain {@link Promise}s and/or values, and reduceFunc
     * may return either a value or a {@link Promise}, *and* initialValue may
     * be a {@link Promise} for the starting value.
     * @memberOf when
     *
     * @param promise {Array|Promise} array of anything, may contain a mix
     *      of {@link Promise}s and values.  May also be a {@link Promise} for
     *      an array.
     * @param reduceFunc {Function} reduce function reduce(currentValue, nextValue, index, total),
     *      where total is the total number of items being reduced, and will be the same
     *      in each call to reduceFunc.
     * @param [initialValue] {*} starting value, or a {@link Promise} for the starting value
     * @returns {Promise} that will resolve to the final reduced value
     */
    function reduce(promise, reduceFunc /*, initialValue */) {
        var args = slice.call(arguments, 1);

        return when(promise, function(array) {
            var total;

            total = array.length;

            // Wrap the supplied reduceFunc with one that handles promises and then
            // delegates to the supplied.
            args[0] = function (current, val, i) {
                return when(current, function (c) {
                    return when(val, function (value) {
                        return reduceFunc(c, value, i, total);
                    });
                });
            };

            return reduceArray.apply(array, args);
        });
    }

    /**
     * Ensure that resolution of promiseOrValue will complete resolver with the completion
     * value of promiseOrValue, or instead with resolveValue if it is provided.
     * @memberOf when
     *
     * @param promiseOrValue
     * @param resolver {Resolver}
     * @param [resolveValue] anything
     * @returns {Promise}
     */
    function chain(promiseOrValue, resolver, resolveValue) {
        var useResolveValue = arguments.length > 2;

        return when(promiseOrValue,
            function(val) {
                return resolver.resolve(useResolveValue ? resolveValue : val);
            },
            resolver.reject,
            resolver.progress
        );
    }

    //
    // Utility functions
    //

    /**
     * Helper that checks arrayOfCallbacks to ensure that each element is either
     * a function, or null or undefined.
     * @private
     *
     * @param arrayOfCallbacks {Array} array to check
     * @throws {Error} if any element of arrayOfCallbacks is something other than
     * a Functions, null, or undefined.
     */
    function checkCallbacks(start, arrayOfCallbacks) {
        var arg, i = arrayOfCallbacks.length;

        while(i > start) {
            arg = arrayOfCallbacks[--i];

            if (arg != null && typeof arg != 'function') {
                throw new Error('arg '+i+' must be a function');
            }
        }
    }

    /**
     * No-Op function used in method replacement
     * @private
     */
    function noop() {}

    slice = [].slice;

    // ES5 reduce implementation if native not available
    // See: http://es5.github.com/#x15.4.4.21 as there are many
    // specifics and edge cases.
    reduceArray = [].reduce ||
        function(reduceFunc /*, initialValue */) {
            // ES5 dictates that reduce.length === 1

            // This implementation deviates from ES5 spec in the following ways:
            // 1. It does not check if reduceFunc is a Callable

            var arr, args, reduced, len, i;

            i = 0;
            // This generates a jshint warning, despite being valid
            // "Missing 'new' prefix when invoking a constructor."
            // See https://github.com/jshint/jshint/issues/392
            /*jshint newcap: false */
            arr = Object(this);
            len = arr.length >>> 0;
            args = arguments;

            // If no initialValue, use first item of array (we know length !== 0 here)
            // and adjust i to start at second item
            if(args.length <= 1) {
                // Skip to the first real element in the array
                for(;;) {
                    if(i in arr) {
                        reduced = arr[i++];
                        break;
                    }

                    // If we reached the end of the array without finding any real
                    // elements, it's a TypeError
                    if(++i >= len) {
                        throw new TypeError();
                    }
                }
            } else {
                // If initialValue provided, use it
                reduced = args[1];
            }

            // Do the actual reduce
            for(;i < len; ++i) {
                // Skip holes
                if(i in arr) {
                    reduced = reduceFunc(reduced, arr[i], i, arr);
                }
            }

            return reduced;
        };

    function identity(x) {
        return x;
    }

    return when;
});
})(typeof define == 'function' && define.amd
    ? define
    : function (deps, factory) { typeof exports === 'object'
        ? (module.exports = factory())
        : (this.when      = factory());
    },
    // Boilerplate for AMD, Node, and browser global
    this
);

/*global define*/
define('Core/TaskProcessor',[
        'require',
        './defaultValue',
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        require,
        defaultValue,
        DeveloperError,
        when) {
    

    function completeTask(processor, event) {
        --processor._activeTasks;

        var data = event.data;
        var id = data.id;
        var result = data.result;

        var deferreds = processor._deferreds;
        var deferred = deferreds[id];

        deferred.resolve(result);

        delete deferreds[id];
    }

    var cesiumScriptRegex = /(.*\/?)Cesium\w*\.js(?:\W|$)/i;
    var bootstrapperScript = 'cesiumWorkerBootstrapper.js';
    var bootstrapperUrl;
    function getBootstrapperUrl() {
        /*global CESIUM_BASE_URL*/
        if (typeof bootstrapperUrl === 'undefined') {
            if (typeof CESIUM_BASE_URL !== 'undefined') {
                bootstrapperUrl = CESIUM_BASE_URL + '/' + bootstrapperScript;
            } else if (typeof require.toUrl !== 'undefined') {
                bootstrapperUrl = require.toUrl('../Workers/' + bootstrapperScript);
            } else {
                var scripts = document.getElementsByTagName('script');
                for ( var i = 0, len = scripts.length; i < len; ++i) {
                    var src = scripts[i].getAttribute('src');
                    var result = cesiumScriptRegex.exec(src);
                    if (result !== null) {
                        bootstrapperUrl = result[1] + bootstrapperScript;
                        break;
                    }
                }
                if (typeof bootstrapperUrl === 'undefined') {
                    throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
                }
            }
        }

        return bootstrapperUrl;
    }

    function createWorker(processor) {
        var worker = new Worker(getBootstrapperUrl());
        worker.postMessage = defaultValue(worker.webkitPostMessage, worker.postMessage);

        //bootstrap
        var bootstrapMessage = {
            loaderConfig : {},
            workerModule : 'Workers/' + processor._workerName
        };

        if (typeof require.toUrl !== 'undefined') {
            bootstrapMessage.loaderConfig.baseUrl = '..';
        } else {
            bootstrapMessage.loaderConfig.paths = {
                'Workers' : '.'
            };
        }

        worker.postMessage(bootstrapMessage);

        worker.onmessage = function(event) {
            completeTask(processor, event);
        };

        processor._worker = worker;
    }

    /**
     * A wrapper around a web worker that allows scheduling tasks for a given worker,
     * returning results asynchronously via a promise.
     *
     * The Worker is not constructed until a task is scheduled.
     *
     * @alias TaskProcessor
     * @constructor
     *
     * @param {String} workerName The name of the worker.  This is expected to be a script
     *                            in the Workers folder.
     * @param {Number} [maximumActiveTasks=5] The maximum number of active tasks.  Once exceeded,
     *                                        scheduleTask will not queue any more tasks, allowing
     *                                        work to be rescheduled in future frames.
     */
    var TaskProcessor = function(workerName, maximumActiveTasks) {
        this._workerName = workerName;
        this._maximumActiveTasks = defaultValue(maximumActiveTasks, 5);
        this._activeTasks = 0;
        this._deferreds = {};
        this._nextID = 0;
    };

    /**
     * Schedule a task to be processed by the web worker asynchronously.  If there are currently more
     * tasks active than the maximum set by the constructor, will immediately return undefined.
     * Otherwise, returns a promise that will resolve to the result posted back by the worker when
     * finished.
     *
     * @param {*} parameters Any input data that will be posted to the worker.
     * @param {Array} [transferableObjects] An array of objects contained in parameters that should be
     *                                      transferred to the worker instead of copied.
     * @returns {Promise} Either a promise that will resolve to the result when available, or undefined
     *                    if there are too many active tasks,
     *
     * @example
     * var taskProcessor = new TaskProcessor('myWorkerName');
     * var promise = taskProcessor.scheduleTask({
     *     someParameter : true,
     *     another : 'hello'
     * });
     * if (typeof promise === 'undefined') {
     *     // too many active tasks - try again later
     * } else {
     *     when(promise, function(result) {
     *         // use the result of the task
     *     });
     * }
     */
    TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
        if (typeof this._worker === 'undefined') {
            createWorker(this);
        }

        if (this._activeTasks >= this._maximumActiveTasks) {
            return undefined;
        }

        ++this._activeTasks;

        var id = this._nextID++;
        var deferred = when.defer();
        this._deferreds[id] = deferred;

        this._worker.postMessage({
            id : id,
            parameters : parameters
        }, transferableObjects);

        return deferred.promise;
    };

    return TaskProcessor;
});
/*global define*/
define('Core/jsonp',[
        './defaultValue',
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        when) {
    

    function pushQueryParameter(array, name, value) {
        array.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
    }

    /**
     * Requests a resource using JSONP.
     *
     * @exports jsonp
     *
     * @param {String} url The URL to request.
     * @param {Object} [options.parameters] Any extra query parameters to append to the URL.
     * @param {String} [options.callbackParameterName='callback'] The callback parameter name that the server expects.
     * @param {Object} [options.proxy] A proxy to use for the request. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @returns {Object} a promise that will resolve to the requested data when loaded.
     *
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // load a data asynchronously
     * jsonp('some/webservice').then(function(data) {
     *     // use the loaded data
     * }, function() {
     *     // an error occurred
     * });
     */
    var jsonp = function(url, options) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        options = defaultValue(options, {});

        var deferred = when.defer();

        //generate a unique function name
        var functionName;
        do {
            functionName = 'jsonp' + Math.random().toString().substring(2, 8);
        } while (typeof window[functionName] !== 'undefined');

        //assign a function with that name in the global scope
        window[functionName] = function(data) {
            deferred.resolve(data);

            try {
                delete window[functionName];
            } catch (e) {
                window[functionName] = undefined;
            }
        };

        var callbackParameterName = defaultValue(options.callbackParameterName, 'callback');
        var queryParts = [];
        pushQueryParameter(queryParts, callbackParameterName, functionName);

        var parameters = defaultValue(options.parameters, {});
        for ( var name in parameters) {
            if (parameters.hasOwnProperty(name)) {
                pushQueryParameter(queryParts, name, parameters[name]);
            }
        }

        if (queryParts.length > 0) {
            if (url.indexOf('?') === -1) {
                url += '?';
            } else {
                url += '&';
            }

            url += queryParts.join('&');
        }

        var proxy = options.proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        jsonp.loadAndExecuteScript(url, functionName, deferred);

        return deferred.promise;
    };

    // This is broken out into a separate function so that it can be mocked for testing purposes.
    jsonp.loadAndExecuteScript = function(url, functionName, deferred) {
        var script = document.createElement('script');
        script.async = true;
        script.src = url;

        var head = document.getElementsByTagName('head')[0];
        script.onload = function() {
            script.onload = undefined;
            head.removeChild(script);
        };
        script.onerror = function(e) {
            deferred.reject(e);
        };

        head.appendChild(script);
    };

    jsonp.defaultLoadAndExecuteScript = jsonp.loadAndExecuteScript;

    return jsonp;
});
/*global define*/
define('Core/loadArrayBuffer',[
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        DeveloperError,
        when) {
    

    /**
     * Asynchronously loads the given URL as raw binary data.  Returns a promise that will resolve to
     * an ArrayBuffer once loaded, or reject if the URL failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     *
     * @exports loadArrayBuffer
     *
     * @param {String|Promise} url The URL of the binary data, or a promise for the URL.
     * @param {Object} [headers] HTTP headers to send with the requests.
     *
     * @returns {Promise} a promise that will resolve to the requested data when loaded.
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // load a single URL asynchronously
     * loadArrayBuffer('some/url').then(function(arrayBuffer) {
     *     // use the data
     * }, function() {
     *     // an error occurred
     * });
     */
    var loadArrayBuffer = function(url, headers) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        return when(url, function(url) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);

            if (typeof headers !== 'undefined') {
                for ( var key in headers) {
                    if (headers.hasOwnProperty(key)) {
                        xhr.setRequestHeader(key, headers[key]);
                    }
                }
            }

            xhr.responseType = 'arraybuffer';

            var deferred = when.defer();

            xhr.onload = function(e) {
                deferred.resolve(xhr.response);
            };

            xhr.onerror = function(e) {
                deferred.reject(e);
            };

            xhr.send();

            return deferred.promise;
        });
    };

    return loadArrayBuffer;
});
/*global define*/
define('Core/loadImage',[
        './defaultValue',
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        when) {
    

    var dataUriRegex = /^data:/;

    /**
     * Asynchronously loads the given image URL.  Returns a promise that will resolve to
     * an {@link Image} once loaded, or reject if the image failed to load.
     *
     * @exports loadImage
     *
     * @param {String|Promise} url The source of the image, or a promise for the URL.
     * @param {Boolean} [crossOrigin=true] Whether to request the image using Cross-Origin
     *        Resource Sharing (CORS).  Data URIs are never requested using CORS.
     *
     * @returns {Promise} a promise that will resolve to the requested data when loaded.
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // load a single image asynchronously
     * loadImage('some/image/url.png').then(function(image) {
     *     // use the loaded image
     * }, function() {
     *     // an error occurred
     * });
     *
     * // load several images in parallel
     * when.all([loadImage('image1.png'), loadImage('image2.png')]).then(function(images) {
     *     // images is an array containing all the loaded images
     * });
     */
    var loadImage = function(url, crossOrigin) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        crossOrigin = defaultValue(crossOrigin, true);

        return when(url, function(url) {
            // data URIs can't have crossOrigin set.
            if (dataUriRegex.test(url)) {
                crossOrigin = false;
            }

            var deferred = when.defer();

            loadImage.createImage(url, crossOrigin, deferred);

            return deferred.promise;
        });
    };

    // This is broken out into a separate function so that it can be mocked for testing purposes.
    loadImage.createImage = function(url, crossOrigin, deferred) {
        var image = new Image();

        image.onload = function(e) {
            deferred.resolve(image);
        };

        image.onerror = function(e) {
            deferred.reject(e);
        };

        if (crossOrigin) {
            image.crossOrigin = '';
        }

        image.src = url;
    };

    loadImage.defaultCreateImage = loadImage.createImage;

    return loadImage;
});

/*global define*/
define('Renderer/TextureAtlasBuilder',[
        '../Core/Event',
        '../Core/DeveloperError',
        '../Core/loadImage'
       ], function(
         Event,
         DeveloperError,
         loadImage) {
    

    function SourceHolder() {
        this.imageLoaded = new Event();
        this.index = -1;
        this.loaded = false;
    }

    /**
     * A utility class which dynamically builds a TextureAtlas by associating
     * a unique identifier with each texture as it is added.  If a texture with
     * the same id is needed later, the existing index is returned, rather than
     * adding multiple copies of the same texture.
     *
     * @alias TextureAtlasBuilder
     * @constructor
     *
     * @see TextureAtlas
     */
    var TextureAtlasBuilder  = function(textureAtlas) {
        if (typeof textureAtlas === 'undefined') {
            throw new DeveloperError('textureAtlas is required.');
        }
        this.textureAtlas = textureAtlas;
        this._idHash = {};
    };

    /**
     * Retrieves the image from the specified url and adds it to the atlas.
     * The supplied callback is triggered with the index of the texture.
     * If the url is already in the atlas, the atlas is unchanged and the callback
     * is triggered immediately with the existing index.
     *
     * @memberof TextureAtlasBuilder
     *
     * @param {String} url The url of the image to add to the atlas.
     * @param {Function} textureAvailableCallback A function taking the image index as it's only parameter.
     *
     * @exception {DeveloperError} url is required.
     * @exception {DeveloperError} textureAvailableCallback is required.
     */
    TextureAtlasBuilder.prototype.addTextureFromUrl = function(url, textureAvailableCallback) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        if (typeof textureAvailableCallback === 'undefined') {
            throw new DeveloperError('textureAvailableCallback is required.');
        }

        this.addTextureFromFunction(url, function(id, callback) {
            loadImage(id).then(callback);
        }, textureAvailableCallback);
    };

    /**
     * <p>
     * Checks the atlas for a texture with the supplied id, if the id does not
     * exist, the supplied callback is triggered to create it.  In either case,
     * once the image is in the atlas, the second supplied callback is triggered
     * with its index.
     * </p>
     *
     * <p>
     * This function is useful for dynamically generated textures that are shared
     * across many billboards.  Only the first billboard will actually create the texture
     * while subsequent billboards will re-use the existing one.
     * </p>
     *
     * @memberof TextureAtlasBuilder
     *
     * @param {String} id The id of the image to add to the atlas.
     * @param {Function} getImageCallback A function which takes two parameters; first the id of the image to
     * retrieve and second, a function to call when the image is ready.  The function takes the image as its
     * only parameter.
     * @param {Function} textureAvailableCallback A function taking the image index as it's only parameter.
     *
     * @exception {DeveloperError} id is required.
     * @exception {DeveloperError} getImageCallback is required.
     * @exception {DeveloperError} textureAvailableCallback is required.
     */
    TextureAtlasBuilder.prototype.addTextureFromFunction = function(id, getImageCallback, textureAvailableCallback) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }

        if (typeof getImageCallback === 'undefined') {
            throw new DeveloperError('getImageCallback is required.');
        }

        if (typeof textureAvailableCallback === 'undefined') {
            throw new DeveloperError('textureAvailableCallback is required.');
        }

        var sourceHolder = this._idHash[id];
        if (typeof sourceHolder !== 'undefined') {
            //we're already aware of this source
            if (sourceHolder.loaded) {
                //and it's already loaded, tell the callback what index to use
                textureAvailableCallback(sourceHolder.index);
            } else {
                //add the callback to be notified once it loads
                sourceHolder.imageLoaded.addEventListener(textureAvailableCallback);
            }
            return;
        }

        //not in atlas, create the source, which may be async
        this._idHash[id] = sourceHolder = new SourceHolder();
        sourceHolder.imageLoaded.addEventListener(textureAvailableCallback);

        var that = this;
        getImageCallback(id, function(newImage) {
            if (!that.textureAtlas.isDestroyed()) {
                var index = sourceHolder.index = that.textureAtlas.addImage(newImage);
                sourceHolder.loaded = true;
                sourceHolder.imageLoaded.raiseEvent(index, id);
                sourceHolder.imageLoaded = undefined;
            }
        });
    };

    return TextureAtlasBuilder;
});
/*global define*/
define('DynamicScene/DynamicBillboardVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Scene/BillboardCollection',
        '../Scene/HorizontalOrigin',
        '../Scene/VerticalOrigin',
        '../Renderer/TextureAtlasBuilder'
    ], function(
        DeveloperError,
        destroyObject,
        Color,
        Cartesian2,
        Cartesian3,
        BillboardCollection,
        HorizontalOrigin,
        VerticalOrigin,
        TextureAtlasBuilder) {
    

    //Callback to create a callback so that we close over all of the proper values.
    function textureReady(dynamicObject, billboardCollection, textureValue) {
        return function(imageIndex) {
            //By the time the texture was loaded, the billboard might already be
            //gone or have been assigned a different texture.  Look it up again
            //and check.
            var currentIndex = dynamicObject._billboardVisualizerIndex;
            if (typeof currentIndex !== 'undefined') {
                var cbBillboard = billboardCollection.get(currentIndex);
                if (cbBillboard._visualizerUrl === textureValue) {
                    cbBillboard._visualizerTextureAvailable = true;
                    cbBillboard.setImageIndex(imageIndex);
                }
            }
        };
    }

    /**
     * A DynamicObject visualizer which maps the DynamicBillboard instance
     * in DynamicObject.billboard to a Billboard primitive.
     * @alias DynamicBillboardVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicBillboard
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensor
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicBillboardVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }

        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;

        var billboardCollection = this._billboardCollection = new BillboardCollection();
        var atlas = this._textureAtlas = scene.getContext().createTextureAtlas();
        this._textureAtlasBuilder = new TextureAtlasBuilder(atlas);
        billboardCollection.setTextureAtlas(atlas);
        scene.getPrimitives().add(billboardCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicBillboardVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicBillboardVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicBillboardVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicBillboardVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicBillboardVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicBillboardVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicBillboardVisualizer.prototype.removeAllPrimitives = function() {
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            this._unusedIndexes = [];
            this._billboardCollection.removeAll();
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._billboardVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicBillboardVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicBillboardVisualizer#destroy
     */
    DynamicBillboardVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicBillboardVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicBillboardVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicBillboardVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._billboardCollection);
        return destroyObject(this);
    };

    var position;
    var color;
    var eyeOffset;
    var pixelOffset;
    DynamicBillboardVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicBillboard = dynamicObject.billboard;
        if (typeof dynamicBillboard === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var textureProperty = dynamicBillboard.image;
        if (typeof textureProperty === 'undefined') {
            return;
        }

        var billboard;
        var showProperty = dynamicBillboard.show;
        var billboardVisualizerIndex = dynamicObject._billboardVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof billboardVisualizerIndex !== 'undefined') {
                billboard = this._billboardCollection.get(billboardVisualizerIndex);
                billboard.setShow(false);
                billboard.setImageIndex(-1);
                billboard._visualizerUrl = undefined;
                billboard._visualizerTextureAvailable = false;
                dynamicObject._billboardVisualizerIndex = undefined;
                this._unusedIndexes.push(billboardVisualizerIndex);
            }
            return;
        }

        if (typeof billboardVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                billboardVisualizerIndex = unusedIndexes.pop();
                billboard = this._billboardCollection.get(billboardVisualizerIndex);
            } else {
                billboardVisualizerIndex = this._billboardCollection.getLength();
                billboard = this._billboardCollection.add();
            }
            dynamicObject._billboardVisualizerIndex = billboardVisualizerIndex;
            billboard.dynamicObject = dynamicObject;
            billboard._visualizerUrl = undefined;
            billboard._visualizerTextureAvailable = false;

            // CZML_TODO Determine official defaults
            billboard.setColor(Color.WHITE);
            billboard.setEyeOffset(Cartesian3.ZERO);
            billboard.setPixelOffset(Cartesian2.ZERO);
            billboard.setScale(1.0);
            billboard.setHorizontalOrigin(HorizontalOrigin.CENTER);
            billboard.setVerticalOrigin(VerticalOrigin.CENTER);
        } else {
            billboard = this._billboardCollection.get(billboardVisualizerIndex);
        }

        var textureValue = textureProperty.getValue(time);
        if (textureValue !== billboard._visualizerUrl) {
            billboard._visualizerUrl = textureValue;
            billboard._visualizerTextureAvailable = false;
            this._textureAtlasBuilder.addTextureFromUrl(textureValue, textureReady(dynamicObject, this._billboardCollection, textureValue));
        }

        billboard.setShow(billboard._visualizerTextureAvailable);
        if (!billboard._visualizerTextureAvailable) {
            return;
        }

        position = positionProperty.getValueCartesian(time, position);
        if (typeof position !== 'undefined') {
            billboard.setPosition(position);
        }

        var property = dynamicBillboard.color;

        if (typeof property !== 'undefined') {
            color = property.getValue(time, color);
            if (typeof color !== 'undefined') {
                billboard.setColor(color);
            }
        }

        property = dynamicBillboard.eyeOffset;
        if (typeof property !== 'undefined') {
            eyeOffset = property.getValue(time, eyeOffset);
            if (typeof eyeOffset !== 'undefined') {
                billboard.setEyeOffset(eyeOffset);
            }
        }

        property = dynamicBillboard.pixelOffset;
        if (typeof property !== 'undefined') {
            pixelOffset = property.getValue(time, pixelOffset);
            if (typeof pixelOffset !== 'undefined') {
                billboard.setPixelOffset(pixelOffset);
            }
        }

        property = dynamicBillboard.scale;
        if (typeof property !== 'undefined') {
            var scale = property.getValue(time);
            if (typeof scale !== 'undefined') {
                billboard.setScale(scale);
            }
        }

        property = dynamicBillboard.horizontalOrigin;
        if (typeof property !== 'undefined') {
            var horizontalOrigin = property.getValue(time);
            if (typeof horizontalOrigin !== 'undefined') {
                billboard.setHorizontalOrigin(horizontalOrigin);
            }
        }

        property = dynamicBillboard.verticalOrigin;
        if (typeof property !== 'undefined') {
            var verticalOrigin = property.getValue(time);
            if (typeof verticalOrigin !== 'undefined') {
                billboard.setVerticalOrigin(verticalOrigin);
            }
        }
    };

    DynamicBillboardVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisBillboardCollection = this._billboardCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var billboardVisualizerIndex = dynamicObject._billboardVisualizerIndex;
            if (typeof billboardVisualizerIndex !== 'undefined') {
                var billboard = thisBillboardCollection.get(billboardVisualizerIndex);
                billboard.setShow(false);
                billboard.setImageIndex(-1);
                billboard._visualizerUrl = undefined;
                billboard._visualizerTextureAvailable = false;
                dynamicObject._billboardVisualizerIndex = undefined;
                thisUnusedIndexes.push(billboardVisualizerIndex);
            }
        }
    };

    return DynamicBillboardVisualizer;
});
/*global define*/
define('DynamicScene/DynamicPointVisualizer',[
        '../Core/Event',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Scene/BillboardCollection',
        '../Renderer/TextureAtlasBuilder'
       ], function(
         Event,
         DeveloperError,
         destroyObject,
         Color,
         BillboardCollection,
         TextureAtlasBuilder) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPoint instance
     * in DynamicObject.point to a Billboard primitive with a point texture.
     * @alias DynamicPointVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPoint
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPointVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;
        var billboardCollection = this._billboardCollection = new BillboardCollection();
        var atlas = this._textureAtlas = scene.getContext().createTextureAtlas();
        this._textureAtlasBuilder = new TextureAtlasBuilder(atlas);
        billboardCollection.setTextureAtlas(atlas);
        scene.getPrimitives().add(billboardCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPointVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPointVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPointVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPointVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPointVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPointVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPointVisualizer.prototype.removeAllPrimitives = function() {
        this._unusedIndexes = [];
        this._billboardCollection.removeAll();
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._pointVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPointVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPointVisualizer#destroy
     */
    DynamicPointVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPointVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPointVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPointVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._billboardCollection);
        return destroyObject(this);
    };

    var color;
    var position;
    var outlineColor;
    DynamicPointVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPoint = dynamicObject.point;
        if (typeof dynamicPoint === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var billboard;
        var showProperty = dynamicPoint.show;
        var pointVisualizerIndex = dynamicObject._pointVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof pointVisualizerIndex !== 'undefined') {
                billboard = this._billboardCollection.get(pointVisualizerIndex);
                billboard.setShow(false);
                billboard.setImageIndex(-1);
                dynamicObject._pointVisualizerIndex = undefined;
                this._unusedIndexes.push(pointVisualizerIndex);
            }
            return;
        }

        var needRedraw = false;
        if (typeof pointVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                pointVisualizerIndex = unusedIndexes.pop();
                billboard = this._billboardCollection.get(pointVisualizerIndex);
            } else {
                pointVisualizerIndex = this._billboardCollection.getLength();
                billboard = this._billboardCollection.add();
            }
            dynamicObject._pointVisualizerIndex = pointVisualizerIndex;
            billboard.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            billboard._visualizerColor = Color.WHITE.clone(billboard._visualizerColor);
            billboard._visualizerOutlineColor = Color.BLACK.clone(billboard._visualizerOutlineColor);
            billboard._visualizerOutlineWidth = 2;
            billboard._visualizerPixelSize = 3;
            needRedraw = true;
        } else {
            billboard = this._billboardCollection.get(pointVisualizerIndex);
        }

        billboard.setShow(true);

        position = positionProperty.getValueCartesian(time, position);
        if (typeof position !== 'undefined') {
            billboard.setPosition(position);
        }

        var property = dynamicPoint.color;
        if (typeof property !== 'undefined') {
            color = property.getValue(time, color);
            if (billboard._visualizerColor !== color) {
                billboard._visualizerColor = color;
                needRedraw = true;
            }
        }

        property = dynamicPoint.outlineColor;
        if (typeof property !== 'undefined') {
            outlineColor = property.getValue(time, outlineColor);
            if (billboard._visualizerOutlineColor !== outlineColor) {
                billboard._visualizerOutlineColor = outlineColor;
                needRedraw = true;
            }
        }

        property = dynamicPoint.outlineWidth;
        if (typeof property !== 'undefined') {
            var outlineWidth = property.getValue(time);
            if (billboard._visualizerOutlineWidth !== outlineWidth) {
                billboard._visualizerOutlineWidth = outlineWidth;
                needRedraw = true;
            }
        }

        property = dynamicPoint.pixelSize;
        if (typeof property !== 'undefined') {
            var pixelSize = property.getValue(time);
            if (billboard._visualizerPixelSize !== pixelSize) {
                billboard._visualizerPixelSize = pixelSize;
                needRedraw = true;
            }
        }

        if (needRedraw) {
            var cssColor = typeof billboard._visualizerColor !== 'undefined' ? billboard._visualizerColor.toCSSColor() : '#FFFFFF';
            var cssOutlineColor = typeof billboard._visualizerOutlineColor !== 'undefined' ? billboard._visualizerOutlineColor.toCSSColor() : '#000000';
            var cssPixelSize = typeof billboard._visualizerPixelSize !== 'undefined' ? billboard._visualizerPixelSize : 3;
            var cssOutlineWidth = typeof billboard._visualizerOutlineWidth !== 'undefined' ? billboard._visualizerOutlineWidth : 2;
            var textureId = JSON.stringify([cssColor, cssPixelSize, cssOutlineColor, cssOutlineWidth]);

            this._textureAtlasBuilder.addTextureFromFunction(textureId, function(id, loadedCallback) {
                var canvas = document.createElement('canvas');

                var length = cssPixelSize + (2 * cssOutlineWidth);
                canvas.height = canvas.width = length;

                var context2D = canvas.getContext('2d');
                context2D.clearRect(0, 0, length, length);

                if (cssOutlineWidth !== 0) {
                    context2D.beginPath();
                    context2D.arc(length / 2, length / 2, length / 2, 0, 2 * Math.PI, true);
                    context2D.closePath();
                    context2D.fillStyle = cssOutlineColor;
                    context2D.fill();
                }

                context2D.beginPath();
                context2D.arc(length / 2, length / 2, cssPixelSize / 2, 0, 2 * Math.PI, true);
                context2D.closePath();
                context2D.fillStyle = cssColor;
                context2D.fill();

                loadedCallback(canvas);
            }, function(imageIndex) {
                billboard.setImageIndex(imageIndex);
            });
        }
    };

    DynamicPointVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisBillboardCollection = this._billboardCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var pointVisualizerIndex = dynamicObject._pointVisualizerIndex;
            if (typeof pointVisualizerIndex !== 'undefined') {
                var billboard = thisBillboardCollection.get(pointVisualizerIndex);
                billboard.setShow(false);
                billboard.setImageIndex(-1);
                dynamicObject._pointVisualizerIndex = undefined;
                thisUnusedIndexes.push(pointVisualizerIndex);
            }
        }
    };

    return DynamicPointVisualizer;
});
/*global define*/
define('Core/loadText',[
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        DeveloperError,
        when) {
    

    /**
     * Asynchronously loads the given URL as text.  Returns a promise that will resolve to
     * a String once loaded, or reject if the URL failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     *
     * @exports loadText
     *
     * @param {String|Promise} url The URL to request, or a promise for the URL.
     * @param {Object} [headers] HTTP headers to send with the request.
     * @returns {Promise} a promise that will resolve to the requested data when loaded.
     *
     * @exception {DeveloperError} url is required.
     *
     * @example
     * // load text from a URL, setting a custom header
     * loadText('http://someUrl.com/someJson.txt', {
     *   'X-Custom-Header' : 'some value'
     * }).then(function(text) {
     *     //Do something with the text
     * }, function() {
     *     // an error occurred
     * });
     *
     * @see <a href="http://en.wikipedia.org/wiki/XMLHttpRequest">XMLHttpRequest</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     */
    var loadText = function(url, headers) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        return when(url, function(url) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);

            if (typeof headers !== 'undefined') {
                for ( var key in headers) {
                    if (headers.hasOwnProperty(key)) {
                        xhr.setRequestHeader(key, headers[key]);
                    }
                }
            }

            var deferred = when.defer();

            xhr.onload = function(e) {
                deferred.resolve(xhr.response);
            };

            xhr.onerror = function(e) {
                deferred.reject(e);
            };

            xhr.send();

            return deferred.promise;
        });
    };

    return loadText;
});
/*global define*/
define('Core/loadJson',[
        './defaultValue',
        './loadText',
        './DeveloperError'
    ], function(
        defaultValue,
        loadText,
        DeveloperError) {
    

    /**
     * Asynchronously loads the given URL as JSON.  Returns a promise that will resolve to
     * a JSON object once loaded, or reject if the URL failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
     * always adds 'Accept: application/json' to the request headers.
     *
     * @exports loadJson
     *
     * @param {String|Promise} url The URL to request, or a promise for the URL.
     * @param {Object} [headers] HTTP headers to send with the request.
     * 'Accept: application/json' is added to the request headers automatically
     * and does not need to be specified.
     * @returns {Promise} a promise that will resolve to the requested data when loaded.
     *
     * @exception {DeveloperError} url is required.
     *
     * @example
     * loadJson('http://someUrl.com/someJson.txt').then(function(jsonData){
     *     //Do something with the JSON object
     * }, function() {
     *     // an error occurred
     * });
     *
     * @see loadText
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     */
    var loadJson = function loadJson(url, headers) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        headers = defaultValue(headers, {});
        headers.Accept = 'application/json';

        return loadText(url, headers).then(function(value) {
            return JSON.parse(value);
        });
    };

    return loadJson;
});
/*global define*/
define('Core/throttleRequestByServer',[
        './defaultValue',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        when) {
    

    var maximumRequestsPerServer = 6;
    var activeRequests = {};
    var anchor;

    function getServer(url) {
        if (typeof anchor === 'undefined') {
            anchor = document.createElement('a');
        }
        anchor.href = url;
        return anchor.hostname + '%' + anchor.port;
    }

    /**
     * Because browsers throttle the number of parallel requests allowed to each server,
     * this function tracks the number of active requests that have been made, and
     * returns undefined immediately if the request would exceed the maximum, allowing
     * the caller to retry later.
     *
     * @exports throttleRequestByServer
     *
     * @param {String} url The URL to request.
     * @param {Function} requestFunction The actual function that makes the request.
     * This function is expected to return a Promise for the requested data.
     *
     * @return {Promise} Either undefined, meaning the request would exceed the maximum
     * number of parallel requests, or a Promise that returns the requested data.
     *
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // throttle requests for an image
     * var promise = throttleRequestsByServer(
     *     'http://madeupserver.agi.com/myImage.png',
     *     function(url) {
     *        return loadImage(url);
     *     });
     * if (typeof promise === 'undefined') {
     *     // too many active requests, try again later.
     * } else {
     *     when(promise, function(image) {
     *         // handle loaded image
     *     });
     * }
     */
    function throttleRequestByServer(url, requestFunction) {
        var server = getServer(url);

        var activeRequestsForServer = defaultValue(activeRequests[server], 0);
        if (activeRequestsForServer > maximumRequestsPerServer) {
            return undefined;
        }

        activeRequests[server] = activeRequestsForServer + 1;

        return when(requestFunction(url), function(result) {
            activeRequests[server]--;
            return result;
        }, function(error) {
            activeRequests[server]--;
            return when.reject(error);
        });
    }

    return throttleRequestByServer;
});
/*global define*/
define('Scene/ImageryProvider',[
        '../Core/loadImage',
        '../Core/DeveloperError',
        '../Core/throttleRequestByServer'
    ], function(
        loadImage,
        DeveloperError,
        throttleRequestByServer) {
    

    /**
     * Provides imagery to be displayed on the surface of an ellipsoid.  This type describes an
     * interface and is not intended to be instantiated directly.
     *
     * @alias ImageryProvider
     * @constructor
     *
     * @see ArcGisMapServerImageryProvider
     * @see SingleTileImageryProvider
     * @see BingMapsImageryProvider
     * @see OpenStreetMapImageryProvider
     * @see WebMapServiceImageryProvider
     */
    var ImageryProvider = function ImageryProvider() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    ImageryProvider.prototype.isReady = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @returns {Extent} The extent.
     *
     * @exception {DeveloperError} <code>getExtent</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getExtent = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getTileWidth = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getTileHeight = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @returns {Number} The maximum level, or undefined if there is no maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getMaximumLevel = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getTilingScheme = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @memberof ImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getTileDiscardPolicy = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof ImageryProvider
     *
     * @returns {Event} The event.
     */
    ImageryProvider.prototype.getErrorEvent = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @memberof ImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.getLogo = function() {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link ImageryProvider#isReady} returns true.
     *
     * @memberof ImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    ImageryProvider.prototype.requestImage = function(hostnames, hostnameIndex, x, y, level) {
        throw new DeveloperError('This type should not be instantiated directly.');
    };

    /**
     * Loads an image from a given URL.  If the server referenced by the URL already has
     * too many requests pending, this function will instead return undefined, indicating
     * that the request should be retried later.
     *
     * @memberof ImageryProvider
     *
     * @param url {String} The URL of the image.
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     */
    ImageryProvider.loadImage = function(url) {
        return throttleRequestByServer(url, loadImage);
    };

    return ImageryProvider;
});
/*global define*/
define('Scene/OpenStreetMapImageryProvider',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/writeTextToCanvas',
        './ImageryProvider',
        './WebMercatorTilingScheme'
    ], function(
        defaultValue,
        DeveloperError,
        Event,
        writeTextToCanvas,
        ImageryProvider,
        WebMercatorTilingScheme) {
    

    var trailingSlashRegex = /\/$/;

    /**
     * Provides tiled imagery hosted by OpenStreetMap or another provider of Slippy tiles.  Please be aware
     * that a default-constructed instance of this class will connect to OpenStreetMap's volunteer-run
     * servers, so you must conform to their
     * <a href='http://wiki.openstreetmap.org/wiki/Tile_usage_policy'>Tile Usage Policy</a>.
     *
     * @alias OpenStreetMapImageryProvider
     * @constructor
     *
     * @param {String} [description.url='http://tile.openstreetmap.org'] The OpenStreetMap server url.
     * @param {String} [description.fileExtension='png'] The file extension for images on the server.
     * @param {Object} [description.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
     * @param {Extent} [description.extent=Extent.MAX_VALUE] The extent of the layer.
     * @param {Number} [description.maximumLevel=18] The maximum level-of-detail supported by the imagery provider.
     * @param {String} [description.credit='MapQuest, Open Street Map and contributors, CC-BY-SA'] A string crediting the data source, which is displayed on the canvas.
     *
     * @see ArcGisMapServerImageryProvider
     * @see BingMapsImageryProvider
     * @see SingleTileImageryProvider
     * @see WebMapServiceImageryProvider
     *
     * @see <a href='http://wiki.openstreetmap.org/wiki/Main_Page'>OpenStreetMap Wiki</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * // OpenStreetMap tile provider
     * var osm = new OpenStreetMapImageryProvider({
     *     url : 'http://tile.openstreetmap.org/'
     * });
     */
    var OpenStreetMapImageryProvider = function OpenStreetMapImageryProvider(description) {
        description = defaultValue(description, {});

        var url = defaultValue(description.url, 'http://tile.openstreetmap.org/');

        if (!trailingSlashRegex.test(url)) {
            url = url + '/';
        }

        this._url = url;
        this._fileExtension = defaultValue(description.fileExtension, 'png');
        this._proxy = description.proxy;
        this._tileDiscardPolicy = description.tileDiscardPolicy;

        this._tilingScheme = new WebMercatorTilingScheme();

        this._tileWidth = 256;
        this._tileHeight = 256;

        this._maximumLevel = defaultValue(description.maximumLevel, 18);

        this._extent = defaultValue(description.extent, this._tilingScheme.getExtent());

        this._errorEvent = new Event();

        this._ready = true;

        var credit = defaultValue(description.credit, 'MapQuest, Open Street Map and contributors, CC-BY-SA');
        this._logo = writeTextToCanvas(credit, {
            font : '12px sans-serif'
        });
    };

    function buildImageUrl(imageryProvider, x, y, level) {
        var url = imageryProvider._url + level + '/' + x + '/' + y + '.' + imageryProvider._fileExtension;

        var proxy = imageryProvider._proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        return url;
    }

    /**
     * Gets the URL of the service hosting the imagery.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {String} The URL.
     */
    OpenStreetMapImageryProvider.prototype.getUrl = function() {
        return this._url;
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Number} The maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return this._maximumLevel;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Extent} The extent.
     *
     * @exception {DeveloperError} <code>getExtent</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getExtent = function() {
        if (!this._ready) {
            throw new DeveloperError('getExtent must not be called before the imagery provider is ready.');
        }
        return this._extent;
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return this._tileDiscardPolicy;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Event} The event.
     */
    OpenStreetMapImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    OpenStreetMapImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        var url = buildImageUrl(this, x, y, level);
        return ImageryProvider.loadImage(url);
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link OpenStreetMapImageryProvider#isReady} returns true.
     *
     * @memberof OpenStreetMapImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    OpenStreetMapImageryProvider.prototype.getLogo = function() {
        if (!this._ready) {
            throw new DeveloperError('getLogo must not be called before the imagery provider is ready.');
        }
        return this._logo;
    };

    return OpenStreetMapImageryProvider;
});
/*global define*/
define('Scene/TileMapServiceImageryProvider',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/writeTextToCanvas',
        '../Core/Extent',
        './ImageryProvider',
        './WebMercatorTilingScheme'
    ], function(
        defaultValue,
        DeveloperError,
        Event,
        writeTextToCanvas,
        Extent,
        ImageryProvider,
        WebMercatorTilingScheme) {
    

    var trailingSlashRegex = /\/$/;

    /**
     * Provides tiled imagery as generated by <a href='http://www.maptiler.org/'>MapTiler</a> / <a href='http://www.klokan.cz/projects/gdal2tiles/'>GDDAL2Tiles</a> etc.
     *
     * @alias TileMapServiceImageryProvider
     * @constructor
     *
     * @param {String} [description.url='.'] Path to image tiles on server.
     * @param {String} [description.fileExtension='png'] The file extension for images on the server.
     * @param {Object} [description.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
     * @param {String} [description.credit='AGI'] A string crediting the data source, which is displayed on the canvas.
     * @param {Number} [description.maximumLevel=18] The maximum level-of-detail supported by the imagery provider.
     * @param {Extent} [description.extent=Extent.MAX_VALUE] The extent, in radians, covered by the image.
     *
     * @see ArcGisMapServerImageryProvider
     * @see BingMapsImageryProvider
     * @see SingleTileImageryProvider
     * @see WebMapServiceImageryProvider
     *
     * @see <a href='http://www.maptiler.org/'>MapTiler</a>
     * @see <a href='http://www.klokan.cz/projects/gdal2tiles/'>GDDAL2Tiles</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * // TileMapService tile provider
     * var osm = new TileMapServiceImageryProvider({
     *    url : '../images/cesium_maptiler/Cesium_Logo_Color',
     *    fileExtension: 'png',
     *    maximumLevel: 4,
     *    credit: 'AGI',
     *    extent: new Cesium.Extent(
     *        Cesium.Math.toRadians(-120.0),
     *        Cesium.Math.toRadians(20.0),
     *        Cesium.Math.toRadians(-60.0),
     *        Cesium.Math.toRadians(40.0))
     * });
     */
    var TileMapServiceImageryProvider = function TileMapServiceImageryProvider(description) {
        description = defaultValue(description, {});

        if (typeof description.url === 'undefined') {
            throw new DeveloperError('description.url is required.');
        }

        var url = description.url;

        if (!trailingSlashRegex.test(url)) {
            url = url + '/';
        }

        this._url = url;
        this._fileExtension = defaultValue(description.fileExtension, 'png');
        this._proxy = description.proxy;
        this._tileDiscardPolicy = description.tileDiscardPolicy;

        this._tilingScheme = new WebMercatorTilingScheme(); // spherical mercator

        this._tileWidth = 256;
        this._tileHeight = 256;

        this._maximumLevel = defaultValue(description.maximumLevel, 18);

        this._extent = defaultValue(description.extent, this._tilingScheme.getExtent());

        this._errorEvent = new Event();

        this._ready = true;

        var credit = defaultValue(description.credit, 'AGI');
        this._logo = writeTextToCanvas(credit, {
            font : '12px sans-serif'
        });
    };

    function buildImageUrl(imageryProvider, x, y, level) {
        var url = imageryProvider._url + level + '/' + x + '/' + (Math.pow(2,level)-y-1) + '.' + imageryProvider._fileExtension;

        var proxy = imageryProvider._proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        return url;
    }

    /**
     * Gets the URL of the service hosting the imagery.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {String} The URL.
     */
    TileMapServiceImageryProvider.prototype.getUrl = function() {
        return this._url;
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Number} The width.
     */
    TileMapServiceImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Number} The height.
     */
    TileMapServiceImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Number} The maximum level.
     */
    TileMapServiceImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return this._maximumLevel;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     */
    TileMapServiceImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Extent} The extent.
     */
    TileMapServiceImageryProvider.prototype.getExtent = function() {
        if (!this._ready) {
            throw new DeveloperError('getExtent must not be called before the imagery provider is ready.');
        }
        return this._extent;
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     */
    TileMapServiceImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return this._tileDiscardPolicy;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Event} The event.
     */
    TileMapServiceImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    TileMapServiceImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     */
    TileMapServiceImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        var url = buildImageUrl(this, x, y, level);
        return ImageryProvider.loadImage(url);
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link TileMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof TileMapServiceImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     */
    TileMapServiceImageryProvider.prototype.getLogo = function() {
        return this._logo;
    };

    return TileMapServiceImageryProvider;
});
/*global define*/
define('Scene/WebMapServiceImageryProvider',[
        '../Core/clone',
        '../Core/defaultValue',
        '../Core/freezeObject',
        '../Core/writeTextToCanvas',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/Extent',
        './ImageryProvider',
        './WebMercatorTilingScheme',
        './GeographicTilingScheme'
    ], function(
        clone,
        defaultValue,
        freezeObject,
        writeTextToCanvas,
        DeveloperError,
        Event,
        Extent,
        ImageryProvider,
        WebMercatorTilingScheme,
        GeographicTilingScheme) {
    

    /**
     * Provides tiled imagery hosted by a Web Map Service (WMS) server.
     *
     * @alias WebMapServiceImageryProvider
     * @constructor
     *
     * @param {String} description.url The URL of the WMS service.
     * @param {String} description.layers The layers to include, separated by commas.
     * @param {Object} [description.parameters=WebMapServiceImageryProvider.DefaultParameters] Additional parameters to pass to the WMS server in the GetMap URL.
     * @param {Extent} [description.extent=Extent.MAX_VALUE] The extent of the layer.
     * @param {Number} [description.maximumLevel] The maximum level-of-detail supported by the imagery provider.
     *        If not specified, there is no limit.
     * @param {String} [description.credit] A string crediting the data source, which is displayed on the canvas.
     * @param {Object} [description.proxy] A proxy to use for requests. This object is
     *        expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} <code>description.url</code> is required.
     * @exception {DeveloperError} <code>description.layers</code> is required.
     *
     * @see ArcGisMapServerImageryProvider
     * @see SingleTileImageryProvider
     * @see BingMapsImageryProvider
     * @see OpenStreetMapImageryProvider
     *
     * @see <a href='http://resources.esri.com/help/9.3/arcgisserver/apis/rest/'>ArcGIS Server REST API</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * var provider = new WebMapServiceImageryProvider({
     *     url: 'http://sampleserver1.arcgisonline.com/ArcGIS/services/Specialty/ESRI_StatesCitiesRivers_USA/MapServer/WMSServer',
     *     layerName: '0',
     *     proxy: new Cesium.DefaultProxy('/proxy/')
     * });
     */
    var WebMapServiceImageryProvider = function WebMapServiceImageryProvider(description) {
        description = defaultValue(description, {});

        if (typeof description.url === 'undefined') {
            throw new DeveloperError('description.url is required.');
        }

        if (typeof description.layers === 'undefined') {
            throw new DeveloperError('description.layers is required.');
        }

        this._url = description.url;
        this._tileDiscardPolicy = description.tileDiscardPolicy;
        this._proxy = description.proxy;
        this._layers = description.layers;

        // Merge the parameters with the defaults, and make all parameter names lowercase
        var parameters = clone(WebMapServiceImageryProvider.DefaultParameters);
        if (typeof description.parameters !== 'undefined') {
            for (var parameter in description.parameters) {
                if (description.parameters.hasOwnProperty(parameter)) {
                    var parameterLowerCase = parameter.toLowerCase();
                    parameters[parameterLowerCase] = description.parameters[parameter];
                }
            }
        }

        this._parameters = parameters;

        this._tileWidth = 256;
        this._tileHeight = 256;
        this._maximumLevel = description.maximumLevel; // undefined means no limit

        var extent = defaultValue(description.extent, Extent.MAX_VALUE);
        this._tilingScheme = new GeographicTilingScheme({
            extent : extent
        });

        // Create the credit message.
        if (typeof description.credit !== 'undefined') {
            // Create the copyright message.
            this._logo = writeTextToCanvas(description.credit, {
                font : '12px sans-serif'
            });
        }

        this._errorEvent = new Event();

        this._ready = true;
    };

    function buildImageUrl(imageryProvider, x, y, level) {
        var url = imageryProvider._url;
        var indexOfQuestionMark = url.indexOf('?');
        if (indexOfQuestionMark >= 0 && indexOfQuestionMark < url.length - 1) {
            if (url[url.length - 1] !== '&') {
                url += '&';
            }
        } else if (indexOfQuestionMark < 0) {
            url += '?';
        }

        var parameters = imageryProvider._parameters;
        for (var parameter in parameters) {
            if (parameters.hasOwnProperty(parameter)) {
                url += parameter + '=' + parameters[parameter] + '&';
            }
        }

        if (typeof parameters.layers === 'undefined') {
            url += 'layers=' + imageryProvider._layers + '&';
        }

        if (typeof parameters.srs === 'undefined') {
            url += 'srs=EPSG:4326&';
        }

        if (typeof parameters.bbox === 'undefined') {
            var nativeExtent = imageryProvider._tilingScheme.tileXYToNativeExtent(x, y, level);
            var bbox = nativeExtent.west + ',' + nativeExtent.south + ',' + nativeExtent.east + ',' + nativeExtent.north;
            url += 'bbox=' + bbox + '&';
        }

        if (typeof parameters.width === 'undefined') {
            url += 'width=256&';
        }

        if (typeof parameters.height === 'undefined') {
            url += 'height=256&';
        }

        var proxy = imageryProvider._proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        return url;
    }

    /**
     * Gets the URL of the WMS server.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {String} The URL.
     */
    WebMapServiceImageryProvider.prototype.getUrl = function() {
        return this._url;
    };

    /**
     * Gets the names of the WMS layers, separated by commas.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {String} The layer names.
     */
    WebMapServiceImageryProvider.prototype.getLayers = function() {
        return this._layers;
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Number} The maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return this._maximumLevel;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Extent} The extent.
     *
     * @exception {DeveloperError} <code>getExtent</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getExtent = function() {
        if (!this._ready) {
            throw new DeveloperError('getExtent must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme.getExtent();
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return this._tileDiscardPolicy;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Event} The event.
     */
    WebMapServiceImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    WebMapServiceImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        var url = buildImageUrl(this, x, y, level);
        return ImageryProvider.loadImage(url);
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link WebMapServiceImageryProvider#isReady} returns true.
     *
     * @memberof WebMapServiceImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    WebMapServiceImageryProvider.prototype.getLogo = function() {
        if (!this._ready) {
            throw new DeveloperError('getLogo must not be called before the imagery provider is ready.');
        }
        return this._logo;
    };

    /**
     * The default parameters to include in the WMS URL to obtain images.  The values are as follows:
     *    service=WMS
     *    version=1.1.1
     *    request=GetMap
     *    styles=
     *    format=image/jpeg
     *
     * @memberof WebMapServiceImageryProvider
     */
    WebMapServiceImageryProvider.DefaultParameters = freezeObject({
        service : 'WMS',
        version : '1.1.1',
        request : 'GetMap',
        styles : '',
        format : 'image/jpeg'
    });

    return WebMapServiceImageryProvider;
});
/*global define*/
define('Scene/ImageryProviderError',[
        '../Core/defaultValue',
        '../Core/loadImage',
        '../Core/DeveloperError',
        '../Core/throttleRequestByServer'
    ], function(
        defaultValue,
        loadImage,
        DeveloperError,
        throttleRequestByServer) {
    

    /**
     * Provides details about an error that occurred in an {@link ImageryProvider}.
     *
     * @alias ImageryProviderError
     *
     * @param {ImageryProvider} imageryProvider The imagery provider that experienced the error.
     * @param {String} message A message describing the error.
     * @param {Number} [x] The X coordinate of the tile that experienced the error, or undefined if the error
     *        is not specific to a particular tile.
     * @param {Number} [y] The Y coordinate of the tile that experienced the error, or undefined if the error
     *        is not specific to a particular tile.
     * @param {Number} [level] The level of the tile that experienced the error, or undefined if the error
     *        is not specific to a particular tile.
     * @param {Number} [timesRetried=0] The number of times this operation has been retried.
     */
    var ImageryProviderError = function ImageryProviderError(imageryProvider, message, x, y, level, timesRetried) {
        /**
         * The {@link ImageryProvider} that experienced the error.
         * @type ImageryProvider
         */
        this.imageryProvider = imageryProvider;

        /**
         * The message describing the error.
         * @type String
         */
        this.message = message;

        /**
         * The X coordinate of the tile that experienced the error.  If the error is not specific
         * to a particular tile, this property will be undefined.
         * @type Number
         */
        this.x = x;

        /**
         * The Y coordinate of the tile that experienced the error.  If the error is not specific
         * to a particular tile, this property will be undefined.
         * @type Number
         */
        this.y = y;

        /**
         * The level-of-detail of the tile that experienced the error.  If the error is not specific
         * to a particular tile, this property will be undefined.
         * @type Number
         */
        this.level = level;

        /**
         * The number of times this operation has been retried.
         * @type Number
         */
        this.timesRetried = defaultValue(timesRetried, 0);

        /**
         * True if the failed operation should be retried; otherwise, false.  The imagery provider
         * will set the initial value of this property before raising the event, but any of listeners
         * can change it.  The value after the last listener is invoked will be acted upon.
         * @type Boolean
         */
        this.retry = false;
    };

    /**
     * Handles an error in an {@link ImageryProvider} by raising an event if it has any listeners, or by
     * logging the error to the console if the event has no listeners.  This method also tracks the number
     * of times the operation has been retried and will automatically retry if requested to do so by the
     * event listeners.
     *
     * @methodof ImageryProviderError
     *
     * @param {ImageryProviderError} previousError The error instance returned by this function the last
     *        time it was called for this error, or undefined if this is the first time this error has
     *        occurred.
     * @param {ImageryProvider} imageryProvider The imagery provider that encountered the error.
     * @param {Event} event The event to raise to inform listeners of the error.
     * @param {String} message The message describing the error.
     * @param {Number} x The X coordinate of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param {Number} y The Y coordinate of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param {Number} level The level-of-detail of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param {Function} retryFunction The function to call to retry the operation.  If undefined, the
     *        operation will not be retried.
     * @returns {ImageryProviderError} The error instance that was passed to the event listeners and that
     *          should be passed to this function the next time it is called for the same error in order
     *          to track retry counts.
     */
    ImageryProviderError.handleError = function(previousError, imageryProvider, event, message, x, y, level, retryFunction) {
        var error = previousError;
        if (typeof previousError === 'undefined') {
            error = new ImageryProviderError(imageryProvider, message, x, y, level, 0);
        } else {
            error.imageryProvider = imageryProvider;
            error.message = message;
            error.x = x;
            error.y = y;
            error.level = level;
            error.retry = false;
            ++error.timesRetried;
        }

        if (event.getNumberOfListeners() > 0) {
            event.raiseEvent(error);
        } else {
            /*global console*/
            console.log('An error occurred in "' + imageryProvider.constructor.name + '":');
            console.log(message);
        }

        if (error.retry && typeof retryFunction !== 'undefined') {
            retryFunction();
        }

        return error;
    };

    /**
     * Handles success of an operation by resetting the retry count of a previous error, if any.  This way,
     * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.
     *
     * @memberof ImageryProviderError
     *
     * @param {ImageryProviderError} previousError The previous error, or undefined if this operation has
     *        not previously resulted in an error.
     */
    ImageryProviderError.handleSuccess = function(previousError) {
        if (typeof previousError !== 'undefined') {
            previousError.timesRetried = -1;
        }
    };

    return ImageryProviderError;
});
/*global define*/
define('Renderer/loadCubeMap',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/loadImage',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        loadImage,
        when) {
    

    /**
     * Asynchronously loads six images and creates a cube map.  Returns a promise that
     * will resolve to a {@link CubeMap} once loaded, or reject if any image fails to load.
     *
     * @exports loadCubeMap
     *
     * @param {Context} context The context to use to create the cube map.
     * @param {Object} urls The source of each image, or a promise for each URL.  See the example below.
     * @param {Boolean} [crossOrigin=true] Whether to request images using Cross-Origin
     *        Resource Sharing (CORS).  Data URIs are never requested using CORS.
     *
     * @returns {Promise} a promise that will resolve to the requested {@link CubeMap} when loaded.
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.
     *
     * @example
     * loadCubeMap(context, {
     *     positiveX : 'skybox_px.png',
     *     negativeX : 'skybox_nx.png',
     *     positiveY : 'skybox_py.png',
     *     negativeY : 'skybox_ny.png',
     *     positiveZ : 'skybox_pz.png',
     *     negativeZ : 'skybox_nz.png'
     * }).then(function(cubeMap) {
     *     // use the cubemap
     * }, function() {
     *     // an error occurred
     * });
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     */
    var loadCubeMap = function(context, urls, crossOrigin) {
        if (typeof context === 'undefined') {
            throw new DeveloperError('context is required.');
        }

        if ((typeof urls === 'undefined') ||
            (typeof urls.positiveX === 'undefined') ||
            (typeof urls.negativeX === 'undefined') ||
            (typeof urls.positiveY === 'undefined') ||
            (typeof urls.negativeY === 'undefined') ||
            (typeof urls.positiveZ === 'undefined') ||
            (typeof urls.negativeZ === 'undefined')) {
            throw new DeveloperError('urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.');
        }

        var cubeMap;

        function getCubeMap(image) {
            if (typeof cubeMap === 'undefined') {
                cubeMap = context.createCubeMap({
                    width: image.width,
                    height: image.height
                });
            } else if ((cubeMap.getWidth() !== image.width) || (cubeMap.getHeight() !== image.height)) {
                cubeMap.destroy();
                deferred.reject('Cube map faces do not have the same dimensions.');
            }

            return cubeMap;
        }

        var deferred = when.defer();
        var count = 0;

        function resolveIfFinished() {
            if (++count === 6) {
                deferred.resolve(cubeMap);
            }
        }

        function reject(e) {
            cubeMap = cubeMap && cubeMap.destroy();
            deferred.reject(e);
        }

        // PERFORMANCE_IDEA: Given the size of some cube maps, we should consider tiling them, which
        // would prevent hiccups when uploading, for example, six 4096x4096 textures to the GPU.
        //
        // Also, it is perhaps acceptable to use the context here in the callbacks, but
        // ideally, we would do it in the primitive's update function.

        loadImage(urls.positiveX, crossOrigin).then(function(image) {
            getCubeMap(image).getPositiveX().copyFrom(image);
            resolveIfFinished();
        }, reject);

        loadImage(urls.negativeX, crossOrigin).then(function(image) {
            getCubeMap(image).getNegativeX().copyFrom(image);
            resolveIfFinished();
        }, reject);

        loadImage(urls.positiveY, crossOrigin).then(function(image) {
            getCubeMap(image).getPositiveY().copyFrom(image);
            resolveIfFinished();
        }, reject);

        loadImage(urls.negativeY, crossOrigin).then(function(image) {
            getCubeMap(image).getNegativeY().copyFrom(image);
            resolveIfFinished();
        }, reject);

        loadImage(urls.positiveZ, crossOrigin).then(function(image) {
            getCubeMap(image).getPositiveZ().copyFrom(image);
            resolveIfFinished();
        }, reject);

        loadImage(urls.negativeZ, crossOrigin).then(function(image) {
            getCubeMap(image).getNegativeZ().copyFrom(image);
            resolveIfFinished();
        }, reject);

        return deferred.promise;
    };

    return loadCubeMap;
});

/*global define*/
define('Scene/SkyBox',[
        '../Core/BoxTessellator',
        '../Core/Cartesian3',
        '../Core/destroyObject',
        '../Core/DeveloperError',
        '../Core/Matrix4',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Renderer/loadCubeMap',
        '../Renderer/BufferUsage',
        '../Renderer/DrawCommand',
        '../Renderer/BlendingState',
        '../Scene/SceneMode',
        '../Shaders/SkyBoxVS',
        '../Shaders/SkyBoxFS'
    ], function(
        BoxTessellator,
        Cartesian3,
        destroyObject,
        DeveloperError,
        Matrix4,
        MeshFilters,
        PrimitiveType,
        loadCubeMap,
        BufferUsage,
        DrawCommand,
        BlendingState,
        SceneMode,
        SkyBoxVS,
        SkyBoxFS) {
    

    /**
     * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
     * <p>
     * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.
     * </p>
     *
     * @alias SkyBox
     * @constructor
     *
     * @param {Object} sources The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.
     *
     * @exception {DeveloperError} sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.
     * @exception {DeveloperError} sources properties must all be the same type.
     *
     * @example
     * scene.skyBox = new SkyBox({
     *     positiveX : 'skybox_px.png',
     *     negativeX : 'skybox_nx.png',
     *     positiveY : 'skybox_py.png',
     *     negativeY : 'skybox_ny.png',
     *     positiveZ : 'skybox_pz.png',
     *     negativeZ : 'skybox_nz.png'
     * });
     *
     * @see Scene#skyBox
     * @see Transforms.computeTemeToPseudoFixedMatrix
     */
    var SkyBox = function(sources) {
        if ((typeof sources === 'undefined') ||
            (typeof sources.positiveX === 'undefined') ||
            (typeof sources.negativeX === 'undefined') ||
            (typeof sources.positiveY === 'undefined') ||
            (typeof sources.negativeY === 'undefined') ||
            (typeof sources.positiveZ === 'undefined') ||
            (typeof sources.negativeZ === 'undefined')) {
            throw new DeveloperError('sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.');
        }

        if ((typeof sources.positiveX !== typeof sources.negativeX) ||
            (typeof sources.positiveX !== typeof sources.positiveY) ||
            (typeof sources.positiveX !== typeof sources.negativeY) ||
            (typeof sources.positiveX !== typeof sources.positiveZ) ||
            (typeof sources.positiveX !== typeof sources.negativeZ)) {
            throw new DeveloperError('sources properties must all be the same type.');
        }

        this._command = new DrawCommand();
        this._cubeMap = undefined;
        this._sources = sources;

        /**
         * Determines if the sky box will be shown.
         * <p>
         * The default is <code>true</code>.
         * </p>
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;
    };

    /**
     * Returns the sources used to create the cube map faces: an object
     * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,
     * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.
     * These are either URLs or <code>Image</code> objects, depending on how the sky box
     * was constructed.
     *
     * @memberof SkyBox
     *
     * @return {Object} The sources used to create the cube map faces.
     */
    SkyBox.prototype.getSources = function() {
        return this._sources;
    };

    /**
     * @private
     */
    SkyBox.prototype.update = function(context, frameState) {
        if (!this.show) {
            return undefined;
        }

        if ((frameState.mode !== SceneMode.SCENE3D) &&
            (frameState.mode !== SceneMode.MORPHING)) {
            return undefined;
        }

        // The sky box is only rendered during the color pass; it is not pickable, it doesn't cast shadows, etc.
        if (!frameState.passes.color) {
            return undefined;
        }

        var command = this._command;

        if (typeof command.vertexArray === 'undefined') {
            var sources = this._sources;
            var that = this;

            if (typeof sources.positiveX === 'string') {
                // Given urls for cube-map images.  Load them.
                loadCubeMap(context, this._sources).then(function(cubeMap) {
                    that._cubeMap = cubeMap;
                });
            } else {
                this._cubeMap = context.createCubeMap({
                    source : sources
                });
            }

            command.uniformMap = {
                u_cubeMap: function() {
                    return that._cubeMap;
                },
                u_morphTime : function() {
                    return that.morphTime;
                }
            };

            var mesh = BoxTessellator.compute({
                dimensions : new Cartesian3(2.0, 2.0, 2.0)
            });
            var attributeIndices = MeshFilters.createAttributeIndices(mesh);

            command.primitiveType = PrimitiveType.TRIANGLES;
            command.modelMatrix = Matrix4.IDENTITY.clone();
            command.vertexArray = context.createVertexArrayFromMesh({
                mesh: mesh,
                attributeIndices: attributeIndices,
                bufferUsage: BufferUsage.STATIC_DRAW
            });
            command.shaderProgram = context.getShaderCache().getShaderProgram(SkyBoxVS, SkyBoxFS, attributeIndices);
            command.renderState = context.createRenderState({
                blending : BlendingState.ALPHA_BLEND
            });
        }

        if (typeof this._cubeMap === 'undefined') {
            return undefined;
        }

        return command;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof SkyBox
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see SkyBox#destroy
     */
    SkyBox.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof SkyBox
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see SkyBox#isDestroyed
     *
     * @example
     * skyBox = skyBox && skyBox.destroy();
     */
    SkyBox.prototype.destroy = function() {
        var command = this._command;
        command.vertexArray = command.vertexArray && command.vertexArray.destroy();
        command.shaderProgram = command.shaderProgram && command.shaderProgram.release();
        this._cubeMap = this._cubeMap && this._cubeMap.destroy();
        return destroyObject(this);
    };

    return SkyBox;
});
/*global define*/
define('Scene/DiscardMissingTileImagePolicy',[
        '../Core/defaultValue',
        '../Core/loadImage',
        '../Core/getImagePixels',
        '../Core/DeveloperError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        loadImage,
        getImagePixels,
        DeveloperError,
        when) {
    

    /**
     * A policy for discarding tile images that match a known image containing a
     * "missing" image.
     *
     * @alias DiscardMissingTileImagePolicy
     * @constructor
     *
     * @param {String} description.missingImageUrl The URL of the known missing image.
     * @param {Array} description.pixelsToCheck An array of {@link Cartesian2} pixel positions to
     *        compare against the missing image.
     * @param {Boolean} [description.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled
     *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the
     *                  discard check will proceed no matter the values of the pixelsToCheck.
     *
     * @exception {DeveloperError} <code>description.missingImageUrl</code> is required.
     * @exception {DeveloperError} <code>pixelsToCheck</code> is required.
     */
    var DiscardMissingTileImagePolicy = function(description) {
        description = defaultValue(description, {});

        if (typeof description.missingImageUrl === 'undefined') {
            throw new DeveloperError('description.missingImageUrl is required.');
        }

        if (typeof description.pixelsToCheck === 'undefined') {
            throw new DeveloperError('description.pixelsToCheck is required.');
        }

        this._pixelsToCheck = description.pixelsToCheck;
        this._missingImagePixels = undefined;
        this._isReady = false;

        var that = this;

        function success(image) {
            var pixels = getImagePixels(image);

            if (description.disableCheckIfAllPixelsAreTransparent) {
                var allAreTransparent = true;
                var width = image.width;

                var pixelsToCheck = description.pixelsToCheck;
                for (var i = 0, len = pixelsToCheck.length; allAreTransparent && i < len; ++i) {
                    var pos = pixelsToCheck[i];
                    var index = pos.x * 4 + pos.y * width;
                    var alpha = pixels[index + 3];

                    if (alpha > 0) {
                        allAreTransparent = false;
                    }
                }

                if (allAreTransparent) {
                    pixels = undefined;
                }
            }

            that._missingImagePixels = pixels;
            that._isReady = true;
        }

        function failure() {
            // Failed to download "missing" image, so assume that any truly missing tiles
            // will also fail to download and disable the discard check.
            that._missingImagePixels = undefined;
            that._isReady = true;
        }

        when(loadImage(description.missingImageUrl), success, failure);
    };

    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    DiscardMissingTileImagePolicy.prototype.isReady = function() {
        return this._isReady;
    };

    /**
     * Given a tile image, decide whether to discard that image.
     *
     * @param {Image} image An image to test.
     *
     * @returns True if the image should be discarded; otherwise, false.
     *
     * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.
     */
    DiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function(image) {
        if (!this._isReady) {
            throw new DeveloperError('shouldDiscardImage must not be called before the discard policy is ready.');
        }

        var pixelsToCheck = this._pixelsToCheck;
        var missingImagePixels = this._missingImagePixels;

        // If missingImagePixels is undefined, it indicates that the discard check has been disabled.
        if (typeof missingImagePixels === 'undefined') {
            return false;
        }

        var pixels = getImagePixels(image);
        var width = image.width;

        for (var i = 0, len = pixelsToCheck.length; i < len; ++i) {
            var pos = pixelsToCheck[i];
            var index = pos.x * 4 + pos.y * width;
            for (var offset = 0; offset < 4; ++offset) {
                var pixel = index + offset;
                if (pixels[pixel] !== missingImagePixels[pixel]) {
                    return false;
                }
            }
        }
        return true;
    };

    return DiscardMissingTileImagePolicy;
});
/*global define*/
define('Scene/ArcGisMapServerImageryProvider',[
        '../Core/defaultValue',
        '../Core/jsonp',
        '../Core/writeTextToCanvas',
        '../Core/Cartesian2',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/RuntimeError',
        './DiscardMissingTileImagePolicy',
        './GeographicTilingScheme',
        './ImageryProvider',
        './ImageryProviderError',
        './WebMercatorTilingScheme',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        jsonp,
        writeTextToCanvas,
        Cartesian2,
        DeveloperError,
        Event,
        RuntimeError,
        DiscardMissingTileImagePolicy,
        GeographicTilingScheme,
        ImageryProvider,
        ImageryProviderError,
        WebMercatorTilingScheme,
        when) {
    

    /**
     * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
     * used, if available.
     *
     * @alias ArcGisMapServerImageryProvider
     * @constructor
     *
     * @param {String} description.url The URL of the ArcGIS MapServer service.
     * @param {TileDiscardPolicy} [description.tileDiscardPolicy] The policy that determines if a tile
     *        is invalid and should be discarded.  If this value is not specified, a default
     *        {@link DiscardMissingTileImagePolicy} is used for tiled map servers, and a
     *        {@link NeverTileDiscardPolicy} is used for non-tiled map servers.  In the former case,
     *        we request tile 0,0 at the maximum tile level and check pixels (0,0), (200,20), (20,200),
     *        (80,110), and (160, 130).  If all of these pixels are transparent, the discard check is
     *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any
     *        tile that has the same values in these pixel locations is discarded.  The end result of
     *        these defaults should be correct tile discarding for a standard ArcGIS Server.  To ensure
     *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
     *        parameter.
     * @param {Proxy} [description.proxy] A proxy to use for requests. This object is
     *        expected to have a getURL function which returns the proxied URL, if needed.
     * @param {Boolean} [description.usePreCachedTilesIfAvailable=true] If true, the server's pre-cached
     *        tiles are used if they are available.  If false, any pre-cached tiles are ignored and the
     *        'export' service is used.
     *
     * @exception {DeveloperError} <code>description.url</code> is required.
     *
     * @see SingleTileImageryProvider
     * @see BingMapsImageryProvider
     * @see OpenStreetMapImageryProvider
     * @see WebMapServiceImageryProvider
     *
     * @see <a href='http://resources.esri.com/help/9.3/arcgisserver/apis/rest/'>ArcGIS Server REST API</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * var esri = new ArcGisMapServerImageryProvider({
     *     url: 'http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
     * });
     */
    var ArcGisMapServerImageryProvider = function ArcGisMapServerImageryProvider(description) {
        description = defaultValue(description, {});

        if (typeof description.url === 'undefined') {
            throw new DeveloperError('description.url is required.');
        }

        this._url = description.url;
        this._tileDiscardPolicy = description.tileDiscardPolicy;
        this._proxy = description.proxy;

        this._tileWidth = undefined;
        this._tileHeight = undefined;
        this._maximumLevel = undefined;
        this._tilingScheme = undefined;
        this._logo = undefined;
        this._useTiles = defaultValue(description.usePreCachedTilesIfAvailable, true);

        this._errorEvent = new Event();

        this._ready = false;

        // Grab the details of this MapServer.
        var that = this;
        var metadataError;

        function metadataSuccess(data) {
            var tileInfo = data.tileInfo;
            if (!that._useTiles || typeof tileInfo === 'undefined') {
                that._tileWidth = 256;
                that._tileHeight = 256;
                that._tilingScheme = new GeographicTilingScheme();
                that._useTiles = false;
            } else {
                that._tileWidth = tileInfo.rows;
                that._tileHeight = tileInfo.cols;

                if (tileInfo.spatialReference.wkid === 102100) {
                    that._tilingScheme = new WebMercatorTilingScheme();
                } else if (data.tileInfo.spatialReference.wkid === 4326) {
                    that._tilingScheme = new GeographicTilingScheme();
                } else {
                    var message = 'Tile spatial reference WKID ' + data.tileInfo.spatialReference.wkid + ' is not supported.';
                    metadataError = ImageryProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
                    return;
                }
                that._maximumLevel = data.tileInfo.lods.length - 1;

                // Install the default tile discard policy if none has been supplied.
                if (typeof that._tileDiscardPolicy === 'undefined') {
                    that._tileDiscardPolicy = new DiscardMissingTileImagePolicy({
                        missingImageUrl : buildImageUrl(that, 0, 0, that._maximumLevel),
                        pixelsToCheck : [new Cartesian2(0, 0), new Cartesian2(200, 20), new Cartesian2(20, 200), new Cartesian2(80, 110), new Cartesian2(160, 130)],
                        disableCheckIfAllPixelsAreTransparent : true
                    });
                }

                that._useTiles = true;
            }

            // Create the copyright message.
            if (typeof data.copyrightText !== 'undefined' && data.copyrightText.length > 0) {
                that._logo = writeTextToCanvas(data.copyrightText, {
                    font : '12px sans-serif'
                });
            }

            that._ready = true;
            ImageryProviderError.handleSuccess(metadataError);
        }

        function metadataFailure(e) {
            var message = 'An error occurred while accessing ' + that._url + '.';
            metadataError = ImageryProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
        }

        function requestMetadata() {
            var metadata = jsonp(that._url, {
                parameters : {
                    f : 'json'
                },
                proxy : that._proxy
            });
            when(metadata, metadataSuccess, metadataFailure);
        }

        requestMetadata();
    };

    function buildImageUrl(imageryProvider, x, y, level) {
        var url;
        if (imageryProvider._useTiles) {
            url = imageryProvider._url + '/tile/' + level + '/' + y + '/' + x;
        } else {
            var nativeExtent = imageryProvider._tilingScheme.tileXYToNativeExtent(x, y, level);
            var bbox = nativeExtent.west + '%2C' + nativeExtent.south + '%2C' + nativeExtent.east + '%2C' + nativeExtent.north;

            url = imageryProvider._url + '/export?';
            url += 'bbox=' + bbox;
            url += '&bboxSR=4326&size=256%2C256&imageSR=4326&format=png&transparent=true&f=image';
        }

        var proxy = imageryProvider._proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        return url;
    }

    /**
     * Gets a value indicating whether this imagery provider is using pre-cached tiles from the
     * ArcGIS MapServer.  If the imagery provider is not yet ready ({@link ArcGisMapServerImageryProvider#isReady}), this function
     * will return the value of `description.usePreCachedTilesIfAvailable`, even if the MapServer does
     * not have pre-cached tiles.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Boolean} true if this imagery provider is using pre-cached tiles from the ArcGIS MapServer;
     *          otherwise, false.
     */
    ArcGisMapServerImageryProvider.prototype.isUsingPrecachedTiles = function() {
        return this._useTiles;
    };

    /**
     * Gets the URL of the ArcGIS MapServer.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {String} The URL.
     */
    ArcGisMapServerImageryProvider.prototype.getUrl = function() {
        return this._url;
    };

    /**
     * Gets the width of each tile, in pixels. This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Number} The maximum level, or undefined if there is no maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return this._maximumLevel;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Extent} The extent.
     *
     * @exception {DeveloperError} <code>getExtent</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getExtent = function() {
        if (!this._ready) {
            throw new DeveloperError('getExtent must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme.getExtent();
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return this._tileDiscardPolicy;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Event} The event.
     */
    ArcGisMapServerImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    ArcGisMapServerImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        var url = buildImageUrl(this, x, y, level);
        return ImageryProvider.loadImage(url);
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link ArcGisMapServerImageryProvider#isReady} returns true.
     *
     * @memberof ArcGisMapServerImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    ArcGisMapServerImageryProvider.prototype.getLogo = function() {
        if (!this._ready) {
            throw new DeveloperError('getLogo must not be called before the imagery provider is ready.');
        }
        return this._logo;
    };

    return ArcGisMapServerImageryProvider;
});
/*!
   Portions Copyright (c) 2006-2009 Microsoft Corporation.  All rights reserved.

   http://msdn.microsoft.com/en-us/library/bb259689.aspx
   http://msdn.microsoft.com/en-us/cc300389.aspx#O

   MICROSOFT LIMITED PUBLIC LICENSE

   This license governs use of code marked as 'sample' or 'example' available on
   this web site without a license agreement, as provided under the section above
   titled 'NOTICE SPECIFIC TO SOFTWARE AVAILABLE ON THIS WEB SITE.' If you use
   such code (the 'software'), you accept this license. If you do not accept the
   license, do not use the software.

   1. Definitions

   The terms 'reproduce,' 'reproduction,' 'derivative works,' and 'distribution'
   have the same meaning here as under U.S. copyright law.

   A 'contribution' is the original software, or any additions or changes to the software.

   A 'contributor' is any person that distributes its contribution under this license.

   'Licensed patents' are a contributor's patent claims that read directly on its contribution.

   2. Grant of Rights

   (A) Copyright Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a non-exclusive,
   worldwide, royalty-free copyright license to reproduce its contribution, prepare
   derivative works of its contribution, and distribute its contribution or any
   derivative works that you create.

   (B) Patent Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a
   non-exclusive, worldwide, royalty-free license under its licensed patents to
   make, have made, use, sell, offer for sale, import, and/or otherwise dispose
   of its contribution in the software or derivative works of the contribution
   in the software.

   3. Conditions and Limitations

   (A) No Trademark License- This license does not grant you rights to use any
   contributors' name, logo, or trademarks.

   (B) If you bring a patent claim against any contributor over patents that
   you claim are infringed by the software, your patent license from such
   contributor to the software ends automatically.

   (C) If you distribute any portion of the software, you must retain all
   copyright, patent, trademark, and attribution notices that are present in
   the software.

   (D) If you distribute any portion of the software in source code form, you
   may do so only under this license by including a complete copy of this license
   with your distribution. If you distribute any portion of the software in
   compiled or object code form, you may only do so under a license that
   complies with this license.

   (E) The software is licensed 'as-is.' You bear the risk of using it. The
   contributors give no express warranties, guarantees or conditions. You may
   have additional consumer rights under your local laws which this license
   cannot change. To the extent permitted under your local laws, the contributors
   exclude the implied warranties of merchantability, fitness for a particular
   purpose and non-infringement.

   (F) Platform Limitation - The licenses granted in sections 2(A) and 2(B)
   extend only to the software or derivative works that you create that run
   on a Microsoft Windows operating system product.
 */
/*global define*/
define('Scene/BingMapsImageryProvider',[
        '../Core/defaultValue',
        '../Core/jsonp',
        '../Core/Cartesian2',
        '../Core/DeveloperError',
        '../Core/Event',
        './BingMapsStyle',
        './DiscardMissingTileImagePolicy',
        './ImageryProvider',
        './ImageryProviderError',
        './WebMercatorTilingScheme',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        jsonp,
        Cartesian2,
        DeveloperError,
        Event,
        BingMapsStyle,
        DiscardMissingTileImagePolicy,
        ImageryProvider,
        ImageryProviderError,
        WebMercatorTilingScheme,
        when) {
    

    /**
     * Provides tiled imagery using the Bing Maps Imagery REST API.
     *
     * @alias BingMapsImageryProvider
     * @constructor
     *
     * @param {String} description.server The name of the Bing Maps server hosting the imagery.
     * @param {String} [description.key] An optional Bing Maps key, which can be created at
     *        <a href='https://www.bingmapsportal.com/'>https://www.bingmapsportal.com/</a>.
     * @param {Enumeration} [description.mapStyle=BingMapsStyle.AERIAL] The type of Bing Maps
     *        imagery to load.
     * @param {TileDiscardPolicy} [description.tileDiscardPolicy] The policy that determines if a tile
     *        is invalid and should be discarded.  If this value is not specified, a default
     *        {@link DiscardMissingTileImagePolicy} is used which requests
     *        tile 0,0 at the maximum tile level and checks pixels (0,0), (120,140), (130,160),
     *        (200,50), and (200,200).  If all of these pixels are transparent, the discard check is
     *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any
     *        tile that has the same values in these pixel locations is discarded.  The end result of
     *        these defaults should be correct tile discarding for a standard Bing Maps server.  To ensure
     *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
     *        parameter.
     * @param {Proxy} [description.proxy] A proxy to use for requests. This object is
     *        expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} <code>description.server</code> is required.
     *
     * @see ArcGisMapServerImageryProvider
     * @see SingleTileImageryProvider
     * @see OpenStreetMapImageryProvider
     * @see WebMapServiceImageryProvider
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/ff701713.aspx'>Bing Maps REST Services</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * var bing = new BingMapsImageryProvider({
     *     server : 'dev.virtualearth.net',
     *     mapStyle : BingMapsStyle.AERIAL
     * });
     */
    var BingMapsImageryProvider = function BingMapsImageryProvider(description) {
        description = defaultValue(description, {});

        if (typeof description.server === 'undefined') {
            throw new DeveloperError('description.server is required.');
        }

        this._server = description.server;
        this._key = defaultValue(description.key, 'AquXz3981-1ND5jGs8qQn7R7YUP8qkWi77yZSVM7o3nIvzb-Mg0W2Ta57xuUyywX');
        this._mapStyle = defaultValue(description.mapStyle, BingMapsStyle.AERIAL);
        this._tileDiscardPolicy = description.tileDiscardPolicy;
        this._proxy = description.proxy;

        /**
         * The default {@link ImageryLayer#gamma} to use for imagery layers created for this provider.
         * By default, this is set to 1.3 for the "aerial" and "aerial with labels" map styles and 1.0 for
         * all others.  Changing this value after creating an {@link ImageryLayer} for this provider will have
         * no effect.  Instead, set the layer's {@link ImageryLayer#gamma} property.
         *
         * @type {Number}
         */
        this.defaultGamma = 1.0;
        if (this._mapStyle === BingMapsStyle.AERIAL || this._mapStyle === BingMapsStyle.AERIAL_WITH_LABELS) {
            this.defaultGamma = 1.3;
        }

        this._tilingScheme = new WebMercatorTilingScheme({
            numberOfLevelZeroTilesX : 2,
            numberOfLevelZeroTilesY : 2
        });

        this._tileWidth = undefined;
        this._tileHeight = undefined;
        this._maximumLevel = undefined;
        this._imageUrlTemplate = undefined;
        this._imageUrlSubdomains = undefined;

        this._errorEvent = new Event();

        this._ready = false;

        var metadataUrl = 'http://' + this._server + '/REST/v1/Imagery/Metadata/' + this._mapStyle.imagerySetName + '?key=' + this._key;
        var that = this;
        var metadataError;

        function metadataSuccess(data) {
            var resource = data.resourceSets[0].resources[0];

            that._tileWidth = resource.imageWidth;
            that._tileHeight = resource.imageHeight;
            that._maximumLevel = resource.zoomMax - 1;
            that._imageUrlSubdomains = resource.imageUrlSubdomains;
            that._imageUrlTemplate = resource.imageUrl.replace('{culture}', '');

            // Install the default tile discard policy if none has been supplied.
            if (typeof that._tileDiscardPolicy === 'undefined') {
                that._tileDiscardPolicy = new DiscardMissingTileImagePolicy({
                    missingImageUrl : buildImageUrl(that, 0, 0, that._maximumLevel),
                    pixelsToCheck : [new Cartesian2(0, 0), new Cartesian2(120, 140), new Cartesian2(130, 160), new Cartesian2(200, 50), new Cartesian2(200, 200)],
                    disableCheckIfAllPixelsAreTransparent : true
                });
            }

            that._ready = true;
            ImageryProviderError.handleSuccess(metadataError);
        }

        function metadataFailure(e) {
            var message = 'An error occurred while accessing ' + metadataUrl + '.';
            metadataError = ImageryProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
        }

        function requestMetadata() {
            var metadata = jsonp(metadataUrl, {
                callbackParameterName : 'jsonp',
                proxy : that._proxy
            });
            when(metadata, metadataSuccess, metadataFailure);
        }

        requestMetadata();
    };

    /**
     * Gets the name of the Bing Maps server hosting the imagery.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {String} The server name.
     */
    BingMapsImageryProvider.prototype.getServer = function() {
        return this._server;
    };

    /**
     * Gets the Bing Maps key.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {String} The key.
     */
    BingMapsImageryProvider.prototype.getKey = function() {
        return this._key;
    };

    /**
     * Gets the type of Bing Maps imagery to load.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {BingMapsStyle} The style.
     */
    BingMapsImageryProvider.prototype.getMapStyle = function() {
        return this._mapStyle;
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Number} The maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return this._maximumLevel;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Extent} The extent.
     *
     * @exception {DeveloperError} <code>getExtent</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getExtent = function() {
        if (!this._ready) {
            throw new DeveloperError('getExtent must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme.getExtent();
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return this._tileDiscardPolicy;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Event} The event.
     */
    BingMapsImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    BingMapsImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        var url = buildImageUrl(this, x, y, level);
        return ImageryProvider.loadImage(url);
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link BingMapsImageryProvider#isReady} returns true.
     *
     * @memberof BingMapsImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    BingMapsImageryProvider.prototype.getLogo = function() {
        if (!this._ready) {
            throw new DeveloperError('getLogo must not be called before the imagery provider is ready.');
        }
        if (typeof BingMapsImageryProvider._logo === 'undefined') {
            var image = new Image();
            image.loaded = false;
            image.onload = function() {
                BingMapsImageryProvider._logo.loaded = true;
            };
            image.src = BingMapsImageryProvider._logoData;
            BingMapsImageryProvider._logo = image;
        }

        var logo = BingMapsImageryProvider._logo;
        return (logo && logo.loaded) ? logo : undefined;
    };

    BingMapsImageryProvider._logo = undefined;
    BingMapsImageryProvider._logoLoaded = false;
    BingMapsImageryProvider._logoData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAAAdCAYAAADIKWCvAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAABBZSURBVHja1FoJdFTVGZ6ZzJZlskMgsrcEoqAQrBhBliKBiBDAgFUL5RQkgIDaKCoqGEBAFkGSgEYrCKgoYtWICLIZBBEOFkX0YEKoDSQo2SczmX36fS/3xscUBAKxp/ecl5eZd99/7/3+/37/cker0Wi0moami4qKCvJ6vVqj0RjEL4KCgvwul8vLe3l5uRdf+cXV2CZPnqwJbHl5eZSpjY2NDcL7Oj2a3+9XxtFqtX632+3FV76qqirK9Ak5fs3/oGGu11Qe1nnJPlpx6cLDw4mNPiQkxARggggSLi8AcuOzG8rwqIC/pFwoUA9lEWyj2Ww28X8+8Hg8EOV1QawTz9xq4C/VrkQxQvHN0fzXAnRauB7AGiIiIsJCQ0PDAFIIPusAjKO+vt5WU1Njs1qtDpvN5v4VgORoioXjboAcc3BwsAWKDA8LCwuFTK3D4aiHrBorBeJ/nU7nUilTeyULlkq4CMDaS6xbGofuUiBxp2P3+7Ecf3FxsXq3+5sCurQ+WroZ4FhGpI1Mur1vvyGYltZaa/156dLF7wDscxhUoR3SDYBsXBCU4gdwftIGJwfL9TudziD00ZtMpuCYmJjY8SmdUgYl1N3H/ierwg4/t+nHPEzOh34eXARcg8VrSW3cYT6fT6seA318Kvk+SXMqalCDGHQhOZynAEX5zLXwOebeCDrH4Fr4v8FgUPrxM+T5eIcRemBQPmDlA/i+pm4Vgq7FAJyoEXdLn9v6pg4dOngCH1ZX19SsXLn8MwzoxoI5OTeA9NJipQB89omJeXH3RUZGerkYNDPkhfXvGX/jA4mfL9D765XFJcRoulnTUirmr69Zh/5OLhSL8IvF6zAOwdCpx4AcjuEDYB6A6qHiAZpXKEDBy2KxBHEdMCCK0As5FKOMC4PSYIp+QZuKAZFG0bRgVfbhQ2UN7AdZjSDxO/QlL7oxVzd2qFso2t9k0LlINAJv9njcRtVW0eFZFC4bJmbARN0EGBcthO9xEfyDf31eLNhJ7heWacD35vjIoNaBg7o9XgPHQp9gAgXZ3ML410DuV/wJ72IX+gQQ0he48MjFBgV4OZYA0IDvjbBsI+4mvEPK1EnQOVeuVewCOncDqNQEZbA/n9F/2bGr6+h3VIATXBqaC3fg7eCO83Xq1IlU0yTg9WJCnAwtg8DrfyFQRV4wJhaHxUTDmrSwbJ2YiFSMH5NUQLDb7XW1tbV15GkuDhM0rt1WeKzOcfPKkTc5h7H/8Z9Cvl35XlEBFmfAQsIgz4/FG8n5bADDjIuAy22vKBTi3fQvGMNah4Y+9QDcRZ6FsvQY04h5QkyYBWIskGumIiX1kGsBqg9yaCF6KMr88COZw264PrGb0Iv/ZHHxwdlPPv7qoUOHsiXdQHarwsLCtR07dhzaq1evUfjswfserE17NfSiyBccGET6UrstbKew4cNH3DBq9OjU1q1axUdGRoQHCqmrs9kBdtWJEyeOZmU9uw7bHr63xsGtDpCCvNFJnvdLg3aUlZbWdu9+YyuH40U9xgphpAQ6CoHFRi5YsCijffu2v4+Ojm6BYMeolk9rr6ioqjx16tR3mzZtevfgwQNFGKOSSqBPYHQEgwiHnJhHH52V3qtX0gD6kkA5DofTda68vMLpcDrbtLkuPvB5YWHREe6YpKSkBwoKCp4aMGDAc9u2bZvSoUOHVKLBXSMM9KoiI73ao0sno+JS/VtvbZofHR1lCQC5HkCQ1zQwUBppCK/4+NbXJSdvH1yw7/PdT81+YmNlZWU9I6H0u9NHJCZ26cr+lVVV1ry8l/bh+1iAZH755Vce6t79hh6CVxtBxhh1Uj6fxcW1iMXV7+abk/oWFRWfyM5elbdnz+4f6BdgGKGPPPLonaNGpd2rNopAOQS5bZvrWl8MjBUrln0MC3Zx82JH/Iw7Zcfl5+cvSklJGQPQvcLR0qleE9D/q1ksYcFqKzly5KvD72x++71vvv66hE5FOCLj+PETBtwx+I67YDyK9aQMHjQ0MfH9m+4ZO2YOF+5Xh2/4wFCSBP7O5nfnqUEoOX2mbNfOXfnr16/bS/4W4ZoxNXVYj3vvu/fPlE8FdO2akPj8888vzMzMXHD48KHTU6ZO6z9u3H0TpOJoFPsPfLHv+cUL3wA49cKAgqdOm56WOnRIKhTQuK4jR/75bfGpUyfhpRwwkiqAbsOcbQMHDlxCeklOTn6YQM+dO/cgeR2WztTFR1prKugEQ09LgRDs7Oj28+cvfDA9fVS6utPp06Vl999/79zq6uoyTKoaW9pOXuN2w2KM4M8wyIjNzJx1z8iRw0fKxZeUnCmbMGH8wuzs3BnXX981QbH0yiprevrds5ctWz4xKalnD2mRa9et3/BK3ks7QNc/Q75Vgk6HxyiI8tPSRiXPmDk9wxLWYAxU0qSJf13ywQcfLKEe+R0Iv37WY7OeO3Bg/3HIqpSgQ3nB4PoorDFu87tbFsa1bBEjx54586GsgoLPjsHPnMbY5RjbjnG9MoIh+HQs+I6Ri4evlZaW+i6Us1x2nC77U3hgh59+Plcxdmz6M+fOnSthvI4J0bs7pNfGO0xk7Viga8GCrLf5HZQ2mve2ba9rnTF12h2BtAUlGTt37txFfj745eGDq3Ozd8LSSrGoSsi3cmFCPsMaDG1zvPXWG/sTEhLapaePVuS3bhUXN2lSxiAJOFv2qpy8vXv3FCL3qgSAVcDKLuSYIZvRjiHr2axVq1fnZAml6tLSRvYBVR2ilTMe4Dt03gwdIZu0qyiHpQsCLQBvsqXr1IBfCPQPP8j/EBljJRwlF1FNS8cEajGpGt7xuRYOrRqgwLdVVSxfvmQrt7d8P6lnz56BuSHjaDV1lZWVnYWMGsqHZXInUXYNxqgGCByzis8IZHb2i582WgwAg5zz/M2OHZ+cgCwH3qMjd9L3MLrizuFnfO88duzrsyLWVlqbtm3aITojXyulCVInI1vMk1SihKkA340QkRZ+wRrUFXO6zChxIUXTnrdl3nxzw2EsuB4AKBN3NjSX2FrM+FgQ08sYGs/cJSUl/05M7KpYcjS85Vm08zStCjkFx1GWA2PUQw4VVg8lS1AArIVxI+N+ZR7qd9u1axuv/pySMrTLhg2vVwBgM/qbmE0KYzJBSSb6kzvvvCtRvTvKSs+eJI+jP52oG8r14LqYNV91YU4nrZzZGBdktdZWqDsMHjwkgXQgkg2m9ibwK4tYRoR7TCyMMjFRshuTydAKoaV832az2y6rQqZVlO3morFrZBGMFyuSHkYUzAoZQajf++77738gj8vP4PzJAwYOTEC6Hot5RoHHoxGaxkRERMQijIzD3KKnTMmYqA4QsrLmbCB/cVcwEQuwZH/ApbkmoDOtFlZsf+3vr+7iRGSH8ePH3wNjjcLEI5FQ8GI5Mhygh2OCESwd4ArH4qCDyGg402EIuy2/8PWXhy89VcXwvSqKO2+R8nsqRoCidlwehLWbyblKxAUnu+KFFc/k5q75G+Lrjrg6tG/fviOuTstfWJmxdevHK+T8+M6GjRs3IECoRj5BSvKw7PxrBa1r0fSCY5nK0zMz2Svfv//Ap4MGDVQyyDZt4luvWfPywzNmPLgCCY+B3EsFMXqhgwQIBlYS0WInT56Syuil0Qn/dK5izeqcHTk5q7v8quZ1SqHJJ6w9cLGyoOaTV8Bm98JQCuDoy6dNnfoAAWXY2qdPcp9du3b1qa6uqWW3wKSOUdSWLe/9Izc3ey+ozEYeF/WdZq/rE3Q/BvUilKLDIZeWP/307NXBwSvCb7vt1tsVZ5jUo8dHH23N2bNn7yc5Oavy2Y90JONocGTP4SOGp4HGu0rBVVXV1jlz57xAC9IEOGgoLIBaFMCVYlOgJasrgKQXPPcGPsOc7Rs3rD/wUf6HRzIypvXr379fSgvkUkzYLpRBs4WHW0LbtWsXH9TQdDLCCoy0ms3SiYOnodVjYdWMvzMzH1n4+BOzxw3o3+8uTpwWNHr0yDEjRtx1t8zyZBytTja4ZQuLTv6A+HlRRUWFjY5Lq9UEgu49P/PVuyCHTsyroheNurSL3cSdRWt0BERCbkY5rNGzGLV06eKSl17KfZ++hzmEKOixiGaGf7px4qSJ4xijM/IZMmTwHUing6dPn7YI1GJiSRp37dVUEC/b0oW1eFjQohfHAgiM59m5z6yBA9qcmfnYGHU9I9B6Amsj+/fvKwRN1jEsY2JTW2M9g23OzFOLHVDBwhjutaJ660eEV8pKpgjTAi3dz/hYJGMMAatramqrpUXa7Ha+a8X3dSyKQbYGY1eyeikiJRbyGAQEr1v3WvnWrfnH33578zzSJp/37v2H5D59b+/86Y7tZ0ExDAR08KnNaunawGM7AM8JMjoJxmKDydes3PH0h4cSDLvG/2VCHzjNKK1G69+9e/fho0e/KmNZVFYB0eyMK0WtPBh9w3lAwrMD+AzWpVnt4skSlWtn7I9Wjjifcb9ThIuNloZAhKgbMbewli1bxsBpx0A5oQDZR2qBr7G7GqIB7gaWmLljqCifTOAAfigunmDFDRkytNvq1blZUv6BL74smDY14ynszB9FvsHd5G2KtV9JRip7+gAYC/Us6JByXOLIrhZgl7N8SjpZvGhhMbcna9T0+FwwLRGLpiU6leIEKISgQ56NoMLyzKzbs5bNgQCUErEAPNaxmcg4eBaL6MgnKsYyctEiOeNpDUuq9XSYAIWOz4guPKwwsTQMhZg4H44N4OqZHPkaGg8naPFOzIF+y33s2DdKciRjdeQSsSwnywOO34rT1cD7haV5eUqCuxJKMkrhVmW8ztMWeczla6gA0cEpFMBLfJagBeF9ngjZ1YvicZg8oBDveHkqJc5LA5sPFuqFopysibDwRLDFcWDIcwsXTxTJkKaosLDw9dfXHmDxCruOPsotDkXMrKFjh5lT7xx2XnJ05kxpMRO7i/mU5gQ9MFTzAnxanUecO9KCdeQ8eQYpowrubIJM7gVNBGZybtCD8o66Do3/Gw99eTEDxOVXW7k8JKG1y/SbZ5SsofPwg6VngKi/tXfvsRERlsiGZOePSPfdKzZvfucg5s+SglOciYaw4NW7d3LXmTNmZKjPAubNm7sWu6PW03DW52tuS9dewXPtr7xzzZKJi8XJ6jNT6grg87QpLA5t0KDBt8ye/eSLoaEhodKxFxWdPJGfn//h9u2fHBflgW7Dhw8f0bnz7xJkFZRJYE5O7pKNG9dvA22dYc2HVUmVT2kWTtdeQwVpLiexUIPXlEREvK8F9RkY7oHLI3G17D9gYM/pD06f1aFDu06XIweUUrps2bLFe/fuOQra+glUxGKbDbTkbKoTbQ7QmzzINd2aAnT+toYRDaMsUAcjrCgoosUtvXt3uWfsn+7u2LHj9SaT0cgTI0EjdU6ny3X27Nl/7dy1c9t7W94l/TB8rQS11LCkS/8FJ+25mjrLbwL6hX5W19xN/mxP/kiK1USEtiHgeQuPB3lAzViXzl8cciu/LGMkg6iFoW0dwGbtnGesdvgXhwBcFtr8zWmE/5egq4GnxQNERlT8iYjy8wv5cw6Gp+L3OhpR4vXJErQ4mXLhXZf4DY36533NCvp/BBgAjIr8TQiNmVwAAAAASUVORK5CYII=';

    /**
     * Converts a tiles (x, y, level) position into a quadkey used to request an image
     * from a Bing Maps server.
     *
     * @memberof BingMapsImageryProvider
     *
     * @param {Number} x The tile's x coordinate.
     * @param {Number} y The tile's y coordinate.
     * @param {Number} level The tile's zoom level.
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/bb259689.aspx'>Bing Maps Tile System</a>
     * @see BingMapsImageryProvider#quadKeyToTileXY
     */
    BingMapsImageryProvider.tileXYToQuadKey = function(x, y, level) {
        ++level;
        var quadkey = '';
        for ( var i = level; i > 0; --i) {
            var digit = '0'.charCodeAt(0);
            var mask = 1 << (i - 1);
            if ((x & mask) !== 0) {
                digit++;
            }
            if ((y & mask) !== 0) {
                digit += 2;
            }
            quadkey += String.fromCharCode(digit);
        }
        return quadkey;
    };

    /**
     * Converts a tile's quadkey used to request an image from a Bing Maps server into the
     * (x, y, level) position.
     *
     * @memberof BingMapsImageryProvider
     *
     * @param {String} quadkey The tile's quad key
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/bb259689.aspx'>Bing Maps Tile System</a>
     * @see BingMapsImageryProvider#tileXYToQuadKey
     */
    BingMapsImageryProvider.quadKeyToTileXY = function(quadkey) {
        var result = {
            x : 0,
            y : 0,
            level : quadkey.length
        };

        for ( var i = result.level; i > 0; --i) {
            var mask = 1 << (i - 1);
            var c = quadkey[result.level - i];
            if (c === '1') {
                result.x |= mask;
            } else if (c === '2') {
                result.y |= mask;
            } else if (c === '3') {
                result.x |= mask;
                result.y |= mask;
            }
        }

        --result.level;

        return result;
    };

    function buildImageUrl(imageryProvider, x, y, level) {
        var imageUrl = imageryProvider._imageUrlTemplate;

        var quadkey = BingMapsImageryProvider.tileXYToQuadKey(x, y, level);
        imageUrl = imageUrl.replace('{quadkey}', quadkey);

        var subdomains = imageryProvider._imageUrlSubdomains;
        var subdomainIndex = (x + y + level) % subdomains.length;
        imageUrl = imageUrl.replace('{subdomain}', subdomains[subdomainIndex]);

        var proxy = imageryProvider._proxy;
        if (typeof proxy !== 'undefined') {
            imageUrl = proxy.getURL(imageUrl);
        }

        return imageUrl;
    }

    return BingMapsImageryProvider;
});
/*global define*/
define('Scene/EllipsoidTerrainProvider',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/BoundingSphere',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/Ellipsoid',
        '../Core/ExtentTessellator',
        '../Core/Occluder',
        '../Core/PlaneTessellator',
        '../Core/TaskProcessor',
        './TerrainProvider',
        './TileState',
        './GeographicTilingScheme',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Cartographic,
        Ellipsoid,
        ExtentTessellator,
        Occluder,
        PlaneTessellator,
        TaskProcessor,
        TerrainProvider,
        TileState,
        GeographicTilingScheme,
        when) {
    

    /**
     * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
     * surface.
     *
     * @alias EllipsoidTerrainProvider
     * @constructor
     * @private
     *
     * @param {TilingScheme} [description.tilingScheme] The tiling scheme specifying how the ellipsoidal
     * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
     * is used.
     * @param {Ellipsoid} [description.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
     * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     * parameter is specified, the WGS84 ellipsoid is used.
     *
     * @see TerrainProvider
     */
    function EllipsoidTerrainProvider(description) {
        description = defaultValue(description, {});

        /**
         * The tiling scheme used to tile the surface.
         *
         * @type TilingScheme
         */
        this.tilingScheme = defaultValue(description.tilingScheme, new GeographicTilingScheme({ ellipsoid : defaultValue(description.ellipsoid, Ellipsoid.WGS84) }));

        // Note: the 64 below does NOT need to match the actual vertex dimensions.
        this.levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this.tilingScheme.getEllipsoid(), 64, this.tilingScheme.getNumberOfXTilesAtLevel(0));

        this.ready = true;
    }

    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     *
     * @param {Number} level The tile level for which to get the maximum geometric error.
     * @returns {Number} The maximum geometric error.
     */
    EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = TerrainProvider.prototype.getLevelMaximumGeometricError;

    /**
     * Request the tile geometry from the remote server.  Once complete, the
     * tile state should be set to RECEIVED.  Alternatively, tile state can be set to
     * UNLOADED to indicate that the request should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Tile} The tile to request geometry for.
     */
    EllipsoidTerrainProvider.prototype.requestTileGeometry = function(tile) {
        tile.state = TileState.RECEIVED;
    };

    var taskProcessor = new TaskProcessor('createVerticesFromExtent');

    /**
     * Transform the tile geometry from the format requested from the remote server
     * into a format suitable for resource creation.  Once complete, the tile
     * state should be set to TRANSFORMED.  Alternatively, tile state can be set to
     * RECEIVED to indicate that the transformation should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Context} context The context to use to create resources.
     * @param {Tile} tile The tile to transform geometry for.
     */
    EllipsoidTerrainProvider.prototype.transformGeometry = function(context, tile) {
        var tilingScheme = this.tilingScheme;
        var ellipsoid = tilingScheme.getEllipsoid();
        var extent = tile.extent;

        tile.center = ellipsoid.cartographicToCartesian(extent.getCenter());

        var width = 16;
        var height = 16;

        var verticesPromise = taskProcessor.scheduleTask({
            extent : extent,
            surfaceHeight : 0,
            width : width,
            height : height,
            relativeToCenter : tile.center,
            radiiSquared : ellipsoid.getRadiiSquared()
        });

        if (typeof verticesPromise === 'undefined') {
            //postponed
            tile.state = TileState.RECEIVED;
            return;
        }

        when(verticesPromise, function(result) {
            tile.transientData = {
                vertices : result,
                indices : TerrainProvider.getRegularGridIndices(width, height)
            };
            tile.state = TileState.TRANSFORMED;
        }, function(e) {
            /*global console*/
            console.error('failed to transform geometry: ' + e);
            tile.state = TileState.FAILED;
        });
    };

    var scratch = new Cartesian3();

    /**
     * Create WebGL resources for the tile using whatever data the transformGeometry step produced.
     * Once complete, the tile state should be set to READY.  Alternatively, tile state can be set to
     * TRANSFORMED to indicate that resource creation should be attempted again next update, if the tile
     * is still needed.
     *
     * @param {Context} context The context to use to create resources.
     * @param {Tile} tile The tile to create resources for.
     */
    EllipsoidTerrainProvider.prototype.createResources = function(context, tile) {
        var buffers = tile.transientData;
        tile.transientData = undefined;

        TerrainProvider.createTileEllipsoidGeometryFromBuffers(context, tile, buffers);
        tile.maxHeight = 0;
        tile.boundingSphere3D = BoundingSphere.fromVertices(buffers.vertices, tile.center, 5);

        var ellipsoid = this.tilingScheme.getEllipsoid();
        var extent = tile.extent;
        tile.southwestCornerCartesian = ellipsoid.cartographicToCartesian(extent.getSouthwest());
        tile.southeastCornerCartesian = ellipsoid.cartographicToCartesian(extent.getSoutheast());
        tile.northeastCornerCartesian = ellipsoid.cartographicToCartesian(extent.getNortheast());
        tile.northwestCornerCartesian = ellipsoid.cartographicToCartesian(extent.getNorthwest());

        tile.westNormal = Cartesian3.UNIT_Z.cross(tile.southwestCornerCartesian.negate(scratch), scratch).normalize();
        tile.eastNormal = tile.northeastCornerCartesian.negate(scratch).cross(Cartesian3.UNIT_Z, scratch).normalize();
        tile.southNormal = ellipsoid.geodeticSurfaceNormal(tile.southeastCornerCartesian).cross(tile.southwestCornerCartesian.subtract(tile.southeastCornerCartesian, scratch)).normalize();
        tile.northNormal = ellipsoid.geodeticSurfaceNormal(tile.northwestCornerCartesian).cross(tile.northeastCornerCartesian.subtract(tile.northwestCornerCartesian, scratch)).normalize();

        var occludeePoint = Occluder.computeOccludeePointFromExtent(tile.extent, ellipsoid);
        if (typeof occludeePoint !== 'undefined') {
            Cartesian3.multiplyComponents(occludeePoint, ellipsoid.getOneOverRadii(), occludeePoint);
        }
        tile.occludeePointInScaledSpace = occludeePoint;

        tile.state = TileState.READY;
    };

    return EllipsoidTerrainProvider;
});
/*global define*/
define('Scene/ImageryLayer',[
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/BoundingRectangle',
        '../Core/ComponentDatatype',
        '../Core/Cartesian2',
        '../Core/Cartesian4',
        '../Core/Color',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/Extent',
        '../Core/Math',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Renderer/MipmapHint',
        '../Renderer/TextureMagnificationFilter',
        '../Renderer/TextureMinificationFilter',
        '../Renderer/TextureWrap',
        './GeographicTilingScheme',
        './Imagery',
        './ImageryProviderError',
        './ImageryState',
        './TileImagery',
        './TexturePool',
        '../ThirdParty/when',
        '../Shaders/ReprojectWebMercatorFS',
        '../Shaders/ReprojectWebMercatorVS'
    ], function(
        defaultValue,
        destroyObject,
        BoundingRectangle,
        ComponentDatatype,
        Cartesian2,
        Cartesian4,
        Color,
        DeveloperError,
        Event,
        Extent,
        CesiumMath,
        PrimitiveType,
        BufferUsage,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        GeographicTilingScheme,
        Imagery,
        ImageryProviderError,
        ImageryState,
        TileImagery,
        TexturePool,
        when,
        ReprojectWebMercatorFS,
        ReprojectWebMercatorVS) {
    

    /**
     * An imagery layer that displays tiled image data from a single imagery provider
     * on a {@link CentralBody}.
     *
     * @alias ImageryLayer
     * @constructor
     *
     * @param {ImageryProvider} imageryProvider The imagery provider to use.
     * @param {Extent} [description.extent=imageryProvider.extent] The extent of the layer.  This extent
     *        can limit the visible portion of the imagery provider.
     * @param {Number|Function} [description.alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current {@link FrameState}, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the alpha is required, and it is expected to return
     *                          the alpha value to use for the tile.
     * @param {Number|Function} [description.brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery
     *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current {@link FrameState}, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the brightness is required, and it is expected to return
     *                          the brightness value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * @param {Number|Function} [description.contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.
     *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current {@link FrameState}, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the contrast is required, and it is expected to return
     *                          the contrast value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * @param {Number|Function} [description.gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current {@link FrameState}, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the gamma is required, and it is expected to return
     *                          the gamma value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * @param {Boolean} [description.show=true] True if the layer is shown; otherwise, false.
     * @param {Number} [description.maximumAnisotropy=maximum supported] The maximum anisotropy level to use
     *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported
     *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon
     *        views.
     */
    var ImageryLayer = function ImageryLayer(imageryProvider, description) {
        this._imageryProvider = imageryProvider;

        description = defaultValue(description, {});

        /**
         * The alpha blending value of this layer, usually from 0.0 to 1.0.
         * This can either be a simple number or a function with the signature
         * <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
         * current {@link FrameState}, this layer, and the x, y, and level coordinates of the
         * imagery tile for which the alpha is required, and it is expected to return
         * the alpha value to use for the tile.  The function is executed for every
         * frame and for every tile, so it must be fast.
         *
         * @type {Number}
         */
        this.alpha = defaultValue(description.alpha, defaultValue(imageryProvider.defaultAlpha, 1.0));

        /**
         * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0
         * makes the imagery darker while greater than 1.0 makes it brighter.
         * This can either be a simple number or a function with the signature
         * <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
         * current {@link FrameState}, this layer, and the x, y, and level coordinates of the
         * imagery tile for which the brightness is required, and it is expected to return
         * the brightness value to use for the tile.  The function is executed for every
         * frame and for every tile, so it must be fast.
         *
         * @type {Number}
         */
        this.brightness = defaultValue(description.brightness, defaultValue(imageryProvider.defaultBrightness, 1.0));

        /**
         * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
         * the contrast while greater than 1.0 increases it.
         * This can either be a simple number or a function with the signature
         * <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
         * current {@link FrameState}, this layer, and the x, y, and level coordinates of the
         * imagery tile for which the contrast is required, and it is expected to return
         * the contrast value to use for the tile.  The function is executed for every
         * frame and for every tile, so it must be fast.
         *
         * @type {Number}
         */
        this.contrast = defaultValue(description.contrast, defaultValue(imageryProvider.defaultContrast, 1.0));

        /**
         * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
         * This can either be a simple number or a function with the signature
         * <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
         * current {@link FrameState}, this layer, and the x, y, and level coordinates of the
         * imagery tile for which the gamma is required, and it is expected to return
         * the gamma value to use for the tile.  The function is executed for every
         * frame and for every tile, so it must be fast.
         *
         * @type {Number}
         */
        this.gamma = defaultValue(description.gamma, defaultValue(imageryProvider.defaultGamma, 1.0));

        /**
         * Determines if this layer is shown.
         *
         * @type {Boolean}
         */
        this.show = defaultValue(description.show, true);

        this._extent = defaultValue(description.extent, Extent.MAX_VALUE);
        this._maximumAnisotropy = description.maximumAnisotropy;

        this._imageryCache = {};
        this._texturePool = new TexturePool();

        this._spReproject = undefined;
        this._vaReproject = undefined;
        this._fbReproject = undefined;

        this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));

        // The value of the show property on the last update.
        this._show = false;

        // The index of this layer in the ImageryLayerCollection.
        this._layerIndex = -1;

        // true if this is the base (lowest shown) layer.
        this._isBaseLayer = false;

        this._requestImageError = undefined;
    };

    /**
     * Gets the imagery provider for this layer.
     *
     * @memberof ImageryLayer
     *
     * @returns {ImageryProvider} The imagery provider.
     */
    ImageryLayer.prototype.getImageryProvider = function() {
        return this._imageryProvider;
    };

    /**
     * Gets the extent of this layer.  If this extent is smaller than the extent of the
     * {@link ImageryProvider}, only a portion of the imagery provider is shown.
     *
     * @memberof ImageryLayer
     *
     * @returns {Extent} The extent.
     */
    ImageryLayer.prototype.getExtent = function() {
        return this._extent;
    };

    /**
     * Gets a value indicating whether this layer is the base layer in the
     * {@link ImageryLayerCollection}.  The base layer is the one that underlies all
     * others.  It is special in that it is treated as if it has global extent, even if
     * it actually does not, by stretching the texels at the edges over the entire
     * globe.
     *
     * @memberof ImageryLayer
     *
     * @returns {Boolean} true if this is the base layer; otherwise, false.
     */
    ImageryLayer.prototype.isBaseLayer = function() {
        return this._isBaseLayer;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof ImageryLayer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ImageryLayer#destroy
     */
    ImageryLayer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof ImageryLayer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see ImageryLayer#isDestroyed
     *
     * @example
     * imageryLayer = imageryLayer && imageryLayer.destroy();
     */
    ImageryLayer.prototype.destroy = function() {
        this._texturePool = this._texturePool && this._texturePool.destroy();

        return destroyObject(this);
    };

    /**
     * Create skeletons for the imagery tiles that partially or completely overlap a given terrain
     * tile.
     *
     * @memberof ImageryLayer
     * @private
     *
     * @param {Tile} tile The terrain tile.
     * @param {TerrainProvider} terrainProvider The terrain provider associated with the terrain tile.
     * @param {Number} insertionPoint The position to insert new skeletons before in the tile's imagery lsit.
     * @returns {Boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.
     */
    ImageryLayer.prototype._createTileImagerySkeletons = function(tile, terrainProvider, insertionPoint) {
        var imageryProvider = this._imageryProvider;

        if (typeof insertionPoint === 'undefined') {
            insertionPoint = tile.imagery.length;
        }

        if (!imageryProvider.isReady()) {
            // The imagery provider is not ready, so we can't create skeletons, yet.
            // Instead, add a placeholder so that we'll know to create
            // the skeletons once the provider is ready.
            this._skeletonPlaceholder.imagery.addReference();
            tile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);
            return true;
        }

        // Compute the extent of the imagery from this imageryProvider that overlaps
        // the geometry tile.  The ImageryProvider and ImageryLayer both have the
        // opportunity to constrain the extent.  The imagery TilingScheme's extent
        // always fully contains the ImageryProvider's extent.
        var extent = tile.extent.intersectWith(imageryProvider.getExtent());
        extent = extent.intersectWith(this._extent);

        if (extent.east <= extent.west || extent.north <= extent.south) {
            // There is no overlap between this terrain tile and this imagery
            // provider, so no skeletons need to be created.
            return false;
        }

        var latitudeClosestToEquator = 0.0;
        if (extent.south > 0.0) {
            latitudeClosestToEquator = extent.south;
        } else if (extent.north < 0.0) {
            latitudeClosestToEquator = extent.north;
        }

        // Compute the required level in the imagery tiling scheme.
        // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.
        // But first we need configurable imagery SSE and we need the rendering to be able to handle more
        // images attached to a terrain tile than there are available texture units.  So that's for the future.
        var errorRatio = 1.0;
        var targetGeometricError = errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);
        var imageryLevel = getLevelWithMaximumTexelSpacing(this, targetGeometricError, latitudeClosestToEquator);
        imageryLevel = Math.max(0, imageryLevel);
        var maximumLevel = imageryProvider.getMaximumLevel();
        if (imageryLevel > maximumLevel) {
            imageryLevel = maximumLevel;
        }

        var imageryTilingScheme = imageryProvider.getTilingScheme();
        var northwestTileCoordinates = imageryTilingScheme.positionToTileXY(extent.getNorthwest(), imageryLevel);
        var southeastTileCoordinates = imageryTilingScheme.positionToTileXY(extent.getSoutheast(), imageryLevel);

        // If the southeast corner of the extent lies very close to the north or west side
        // of the southeast tile, we don't actually need the southernmost or easternmost
        // tiles.
        // Similarly, if the northwest corner of the extent list very close to the south or east side
        // of the northwest tile, we don't actually need the northernmost or westernmost tiles.

        // We define "very close" as being within 1/512 of the width of the tile.
        var veryCloseX = (tile.extent.north - tile.extent.south) / 512.0;
        var veryCloseY = (tile.extent.east - tile.extent.west) / 512.0;

        var northwestTileExtent = imageryTilingScheme.tileXYToExtent(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);
        if (Math.abs(northwestTileExtent.south - extent.north) < veryCloseY) {
            ++northwestTileCoordinates.y;
        }
        if (Math.abs(northwestTileExtent.east - extent.west) < veryCloseX) {
            ++northwestTileCoordinates.x;
        }

        var southeastTileExtent = imageryTilingScheme.tileXYToExtent(southeastTileCoordinates.x, southeastTileCoordinates.y, imageryLevel);
        if (Math.abs(southeastTileExtent.north - extent.south) < veryCloseY) {
            --southeastTileCoordinates.y;
        }
        if (Math.abs(southeastTileExtent.west - extent.east) < veryCloseX) {
            --southeastTileCoordinates.x;
        }

        var imageryMaxX = imageryTilingScheme.getNumberOfXTilesAtLevel(imageryLevel);
        var imageryMaxY = imageryTilingScheme.getNumberOfYTilesAtLevel(imageryLevel);

        // Create TileImagery instances for each imagery tile overlapping this terrain tile.
        // We need to do all texture coordinate computations in the imagery tile's tiling scheme.

        var terrainExtent = tile.extent;
        var imageryExtent = imageryTilingScheme.tileXYToExtent(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);

        var minU;
        var maxU = 0.0;

        var minV = 1.0;
        var maxV;

        // If this is the northern-most or western-most tile in the imagery tiling scheme,
        // it may not start at the northern or western edge of the terrain tile.
        // Calculate where it does start.
        if (!this.isBaseLayer() && northwestTileCoordinates.x === 0) {
            maxU = Math.min(1.0, (imageryExtent.west - terrainExtent.west) / (terrainExtent.east - terrainExtent.west));
        }

        if (!this.isBaseLayer() && northwestTileCoordinates.y === 0) {
            minV = Math.max(0.0, (imageryExtent.north - terrainExtent.south) / (terrainExtent.north - terrainExtent.south));
        }

        var initialMinV = minV;

        for ( var i = northwestTileCoordinates.x; i <= southeastTileCoordinates.x; i++) {
            minU = maxU;

            imageryExtent = imageryTilingScheme.tileXYToExtent(i, northwestTileCoordinates.y, imageryLevel);
            maxU = Math.min(1.0, (imageryExtent.east - terrainExtent.west) / (terrainExtent.east - terrainExtent.west));

            // If this is the eastern-most imagery tile mapped to this terrain tile,
            // and there are more imagery tiles to the east of this one, the maxU
            // should be 1.0 to make sure rounding errors don't make the last
            // image fall shy of the edge of the terrain tile.
            if (i === southeastTileCoordinates.x && (this.isBaseLayer() || i < imageryMaxX - 1)) {
                maxU = 1.0;
            }

            minV = initialMinV;

            for ( var j = northwestTileCoordinates.y; j <= southeastTileCoordinates.y; j++) {
                maxV = minV;

                imageryExtent = imageryTilingScheme.tileXYToExtent(i, j, imageryLevel);
                minV = Math.max(0.0, (imageryExtent.south - terrainExtent.south) / (terrainExtent.north - terrainExtent.south));

                // If this is the southern-most imagery tile mapped to this terrain tile,
                // and there are more imagery tiles to the south of this one, the minV
                // should be 0.0 to make sure rounding errors don't make the last
                // image fall shy of the edge of the terrain tile.
                if (j === southeastTileCoordinates.y && (this.isBaseLayer() || j < imageryMaxY - 1)) {
                    minV = 0.0;
                }

                var texCoordsExtent = new Cartesian4(minU, minV, maxU, maxV);
                var imagery = this.getImageryFromCache(i, j, imageryLevel, imageryExtent);
                tile.imagery.splice(insertionPoint, 0, new TileImagery(imagery, texCoordsExtent));
                ++insertionPoint;
            }
        }

        return true;
    };

    /**
     * Calculate the translation and scale for a particular {@link TileImagery} attached to a
     * particular terrain {@link Tile}.
     *
     * @memberof ImageryLayer
     * @private
     *
     * @param {Tile} tile The terrain tile.
     * @param {TileImagery} tileImagery The imagery tile mapping.
     * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W
     *          are the scale.
     */
    ImageryLayer.prototype._calculateTextureTranslationAndScale = function(tile, tileImagery) {
        var imageryExtent = tileImagery.imagery.extent;
        var terrainExtent = tile.extent;
        var terrainWidth = terrainExtent.east - terrainExtent.west;
        var terrainHeight = terrainExtent.north - terrainExtent.south;

        var scaleX = terrainWidth / (imageryExtent.east - imageryExtent.west);
        var scaleY = terrainHeight / (imageryExtent.north - imageryExtent.south);
        return new Cartesian4(
                scaleX * (terrainExtent.west - imageryExtent.west) / terrainWidth,
                scaleY * (terrainExtent.south - imageryExtent.south) / terrainHeight,
                scaleX,
                scaleY);
    };

    /**
     * Request a particular piece of imagery from the imagery provider.  This method handles raising an
     * error event if the request fails, and retrying the request if necessary.
     *
     * @memberof ImageryLayer
     * @private
     *
     * @param {Imagery} imagery The imagery to request.
     */
    ImageryLayer.prototype._requestImagery = function(imagery) {
        var imageryProvider = this._imageryProvider;

        var that = this;

        function success(image) {
            if (typeof image === 'undefined') {
                return failure();
            }

            imagery.image = image;
            imagery.state = ImageryState.RECEIVED;

            ImageryProviderError.handleSuccess(that._requestImageError);
        }

        function failure(e) {
            // Initially assume failure.  handleError may retry, in which case the state will
            // change to TRANSITIONING.
            imagery.state = ImageryState.FAILED;

            var message = 'Failed to obtain image tile X: ' + imagery.x + ' Y: ' + imagery.y + ' Level: ' + imagery.level + '.';
            that._requestImageError = ImageryProviderError.handleError(
                    that._requestImageError,
                    imageryProvider,
                    imageryProvider.getErrorEvent(),
                    message,
                    imagery.x, imagery.y, imagery.level,
                    doRequest);
        }

        function doRequest() {
            imagery.state = ImageryState.TRANSITIONING;
            var imagePromise = imageryProvider.requestImage(imagery.x, imagery.y, imagery.level);

            if (typeof imagePromise === 'undefined') {
                // Too many parallel requests, so postpone loading tile.
                imagery.state = ImageryState.UNLOADED;
                return;
            }

            when(imagePromise, success, failure);
        }

        doRequest();
    };

    /**
     * Create a WebGL texture for a given {@link Imagery} instance.
     *
     *  @memberof ImageryLayer
     *  @private
     *
     *  @param {Context} context The rendered context to use to create textures.
     *  @param {Imagery} imagery The imagery for which to create a texture.
     */
    ImageryLayer.prototype._createTexture = function(context, imagery) {
        var imageryProvider = this._imageryProvider;

        // If this imagery provider has a discard policy, use it to check if this
        // image should be discarded.
        if (typeof imageryProvider.getTileDiscardPolicy !== 'undefined') {
            var discardPolicy = imageryProvider.getTileDiscardPolicy();
            if (typeof discardPolicy !== 'undefined') {
                // If the discard policy is not ready yet, transition back to the
                // RECEIVED state and we'll try again next time.
                if (!discardPolicy.isReady()) {
                    imagery.state = ImageryState.RECEIVED;
                    return;
                }

                // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.
                if (discardPolicy.shouldDiscardImage(imagery.image)) {
                    imagery.state = ImageryState.INVALID;
                    return;
                }
            }
        }

        // Imagery does not need to be discarded, so upload it to WebGL.
        var texture = this._texturePool.createTexture2D(context, {
            source : imagery.image
        });

        imagery.texture = texture;
        imagery.image = undefined;
        imagery.state = ImageryState.TEXTURE_LOADED;
    };

    /**
     * Reproject a texture to a {@link GeographicProjection}, if necessary, and generate
     * mipmaps for the geographic texture.
     *
     * @memberof ImageryLayer
     * @private
     *
     * @param {Context} context The rendered context to use.
     * @param {Imagery} imagery The imagery instance to reproject.
     */
    ImageryLayer.prototype._reprojectTexture = function(context, imagery) {
        var texture = imagery.texture;
        var extent = imagery.extent;

        // Reproject this texture if it is not already in a geographic projection and
        // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff
        // avoids precision problems in the reprojection transformation while making
        // no noticeable difference in the georeferencing of the image.
        if (!(this._imageryProvider.getTilingScheme() instanceof GeographicTilingScheme) &&
            (extent.east - extent.west) / texture.getWidth() > 1e-5) {
                var reprojectedTexture = reprojectToGeographic(this, context, texture, imagery.extent);
                texture.destroy();
                imagery.texture = texture = reprojectedTexture;
        }

        var maximumSupportedAnisotropy = context.getMaximumTextureFilterAnisotropy();

        // Use mipmaps if this texture has power-of-two dimensions.
        if (CesiumMath.isPowerOfTwo(texture.getWidth()) && CesiumMath.isPowerOfTwo(texture.getHeight())) {
            texture.generateMipmap(MipmapHint.NICEST);
            texture.setSampler({
                wrapS : TextureWrap.CLAMP,
                wrapT : TextureWrap.CLAMP,
                minificationFilter : TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,
                magnificationFilter : TextureMagnificationFilter.LINEAR,
                maximumAnisotropy : Math.min(maximumSupportedAnisotropy, defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy))
            });
        } else {
            texture.setSampler({
                wrapS : TextureWrap.CLAMP,
                wrapT : TextureWrap.CLAMP,
                minificationFilter : TextureMinificationFilter.LINEAR,
                magnificationFilter : TextureMagnificationFilter.LINEAR
            });
        }

        imagery.state = ImageryState.READY;
    };

    ImageryLayer.prototype.getImageryFromCache = function(x, y, level, imageryExtent) {
        var cacheKey = getImageryCacheKey(x, y, level);
        var imagery = this._imageryCache[cacheKey];

        if (typeof imagery === 'undefined') {
            imagery = new Imagery(this, x, y, level, imageryExtent);
            this._imageryCache[cacheKey] = imagery;
        }

        imagery.addReference();
        return imagery;
    };

    ImageryLayer.prototype.removeImageryFromCache = function(imagery) {
        var cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);
        delete this._imageryCache[cacheKey];
    };

    function getImageryCacheKey(x, y, level) {
        return JSON.stringify([x, y, level]);
    }

    var uniformMap = {
        u_textureDimensions : function() {
            return this.textureDimensions;
        },
        u_texture : function() {
            return this.texture;
        },
        u_northLatitude : function() {
            return this.northLatitude;
        },
        u_southLatitude : function() {
            return this.southLatitude;
        },
        u_southMercatorYLow : function() {
            return this.southMercatorYLow;
        },
        u_southMercatorYHigh : function() {
            return this.southMercatorYHigh;
        },
        u_oneOverMercatorHeight : function() {
            return this.oneOverMercatorHeight;
        },

        textureDimensions : new Cartesian2(0.0, 0.0),
        texture : undefined,
        northLatitude : 0,
        southLatitude : 0,
        southMercatorYHigh : 0,
        southMercatorYLow : 0,
        oneOverMercatorHeight : 0
    };

    var float32ArrayScratch = typeof Float32Array === 'undefined' ? undefined : new Float32Array(1);

    function reprojectToGeographic(imageryLayer, context, texture, extent) {
        if (typeof imageryLayer._fbReproject === 'undefined') {
            imageryLayer._fbReproject = context.createFramebuffer();
            imageryLayer._fbReproject.destroyAttachments = false;

            var reprojectMesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 2,
                        values : [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]
                    }
                }
            };

            var reprojectAttribInds = {
                position : 0
            };

            imageryLayer._vaReproject = context.createVertexArrayFromMesh({
                mesh : reprojectMesh,
                attributeIndices : reprojectAttribInds,
                bufferUsage : BufferUsage.STATIC_DRAW
            });

            imageryLayer._spReproject = context.getShaderCache().getShaderProgram(
                ReprojectWebMercatorVS,
                ReprojectWebMercatorFS,
                reprojectAttribInds);

            imageryLayer._rsColor = context.createRenderState();
        }

        var maximumSupportedAnisotropy = context.getMaximumTextureFilterAnisotropy();

        texture.setSampler({
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : Math.min(maximumSupportedAnisotropy, defaultValue(imageryLayer._maximumAnisotropy, maximumSupportedAnisotropy))
        });

        var width = texture.getWidth();
        var height = texture.getHeight();

        uniformMap.textureDimensions.x = width;
        uniformMap.textureDimensions.y = height;
        uniformMap.texture = texture;

        uniformMap.northLatitude = extent.north;
        uniformMap.southLatitude = extent.south;

        var sinLatitude = Math.sin(extent.south);
        var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));

        float32ArrayScratch[0] = southMercatorY;
        uniformMap.southMercatorYHigh = float32ArrayScratch[0];
        uniformMap.southMercatorYLow = southMercatorY - float32ArrayScratch[0];

        sinLatitude = Math.sin(extent.north);
        var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
        uniformMap.oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);

        var outputTexture = imageryLayer._texturePool.createTexture2D(context, {
            width : width,
            height : height,
            pixelFormat : texture.getPixelFormat(),
            pixelDatatype : texture.getPixelDatatype(),
            preMultiplyAlpha : texture.getPreMultiplyAlpha()
        });

        // Allocate memory for the mipmaps.  Failure to do this before rendering
        // to the texture via the FBO, and calling generateMipmap later,
        // will result in the texture appearing blank.  I can't pretend to
        // understand exactly why this is.
        outputTexture.generateMipmap(MipmapHint.NICEST);

        imageryLayer._fbReproject.setColorTexture(outputTexture);

        context.clear(context.createClearState({
            framebuffer : imageryLayer._fbReproject,
            color : new Color(0.0, 0.0, 0.0, 0.0)
        }));

        var renderState = imageryLayer._rsColor;
        var viewport = renderState.viewport;
        if (typeof viewport === 'undefined') {
            viewport = new BoundingRectangle();
            renderState.viewport = viewport;
        }
        viewport.width = width;
        viewport.height = height;

        context.draw({
            framebuffer : imageryLayer._fbReproject,
            shaderProgram : imageryLayer._spReproject,
            renderState : renderState,
            primitiveType : PrimitiveType.TRIANGLE_FAN,
            vertexArray : imageryLayer._vaReproject,
            uniformMap : uniformMap
        });

        return outputTexture;
    }

    /**
     * Gets the level with the specified world coordinate spacing between texels, or less.
     *
     * @param {Number} texelSpacing The texel spacing for which to find a corresponding level.
     * @param {Number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.
     * @returns {Number} The level with the specified texel spacing or less.
     */
    function getLevelWithMaximumTexelSpacing(layer, texelSpacing, latitudeClosestToEquator) {
        // PERFORMANCE_IDEA: factor out the stuff that doesn't change.
        var imageryProvider = layer._imageryProvider;
        var tilingScheme = imageryProvider.getTilingScheme();
        var ellipsoid = tilingScheme.getEllipsoid();
        var latitudeFactor = Math.cos(latitudeClosestToEquator);
        var tilingSchemeExtent = tilingScheme.getExtent();
        var levelZeroMaximumTexelSpacing = ellipsoid.getMaximumRadius() * (tilingSchemeExtent.east - tilingSchemeExtent.west) * latitudeFactor / (imageryProvider.getTileWidth() * tilingScheme.getNumberOfXTilesAtLevel(0));

        var twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;
        var level = Math.log(twoToTheLevelPower) / Math.log(2);
        var rounded = Math.round(level);
        return rounded | 0;
    }

    return ImageryLayer;
});
/*global define*/
define('Scene/ImageryLayerCollection',[
        '../Core/DeveloperError',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/Event',
        '../Core/Math',
        './ImageryLayer'
    ], function(
        DeveloperError,
        defaultValue,
        destroyObject,
        Event,
        CesiumMath,
        ImageryLayer) {
    

    /**
     * An ordered collection of imagery layers.
     *
     * @alias ImageryLayerCollection
     */
    var ImageryLayerCollection = function ImageryLayerCollection() {
        this._layers = [];

        /**
         * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that
         * was added and the index at which it was added.
         * @type {Event}
         */
        this.layerAdded = new Event();

        /**
         * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that
         * was removed and the index from which it was removed.
         * @type {Event}
         */
        this.layerRemoved = new Event();

        /**
         * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that
         * was moved, its new index after the move, and its old index prior to the move.
         * @type {Event}
         */
        this.layerMoved = new Event();

        /**
         * An event that is raised when a layer is shown or hidden by setting the
         * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,
         * the index of the layer in the collection, and a flag that is true if the layer is now
         * shown or false if it is now hidden.
         *
         * @type {Event}
         */
        this.layerShownOrHidden = new Event();
    };

    /**
     * Adds a layer to the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to add.
     * @param {Number} [index] the index to add the layer at.  If omitted, the layer will
     *                         added on top of all existing layers.
     *
     * @exception {DeveloperError} layer is required.
     * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.
     */
    ImageryLayerCollection.prototype.add = function(layer, index) {
        if (typeof layer === 'undefined') {
            throw new DeveloperError('layer is required.');
        }

        if (typeof index === 'undefined') {
            index = this._layers.length;
            this._layers.push(layer);
        } else {
            if (index < 0) {
                throw new DeveloperError('index must be greater than or equal to zero.');
            } else if (index > this._layers.length) {
                throw new DeveloperError('index must be less than or equal to the number of layers.');
            }
            this._layers.splice(index, 0, layer);
        }

        this._update();

        this.layerAdded.raiseEvent(layer, index);
    };

    /**
     * Creates a new layer using the given ImageryProvider and adds it to the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.
     * @param {Number} [index] the index to add the layer at.  If omitted, the layer will
     *                         added on top of all existing layers.
     *
     * @returns {ImageryLayer} The newly created layer.
     *
     * @exception {DeveloperError} imageryProvider is required.
     */
    ImageryLayerCollection.prototype.addImageryProvider = function(imageryProvider, index) {
        if (typeof imageryProvider === 'undefined') {
            throw new DeveloperError('imageryProvider is required.');
        }

        var layer = new ImageryLayer(imageryProvider);
        this.add(layer, index);
        return layer;
    };

    /**
     * Removes a layer from this collection, if present.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer The layer to remove.
     * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.
     *
     * @returns {Boolean} true if the layer was in the collection and was removed,
     *                    false if the layer was not in the collection.
     */
    ImageryLayerCollection.prototype.remove = function(layer, destroy) {
        destroy = defaultValue(destroy, true);

        var index = this._layers.indexOf(layer);
        if (index !== -1) {
            this._layers.splice(index, 1);

            this._update();

            this.layerRemoved.raiseEvent(layer, index);

            if (destroy) {
                layer.destroy();
            }

            return true;
        }

        return false;
    };

    /**
     * Removes all layers from this collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.
     */
    ImageryLayerCollection.prototype.removeAll = function(destroy) {
        destroy = defaultValue(destroy, true);

        var layers = this._layers;
        for ( var i = 0, len = layers.length; i < len; i++) {
            var layer = layers[i];
            this.layerRemoved.raiseEvent(layer, i);

            if (destroy) {
                layer.destroy();
            }
        }

        this._layers = [];
    };

    /**
     * Checks to see if the collection contains a given layer.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to check for.
     *
     * @returns {Boolean} true if the collection contains the layer, false otherwise.
     */
    ImageryLayerCollection.prototype.contains = function(layer) {
        return this.indexOf(layer) !== -1;
    };

    /**
     * Determines the index of a given layer in the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer The layer to find the index of.
     *
     * @returns {Number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.
     */
    ImageryLayerCollection.prototype.indexOf = function(layer) {
        return this._layers.indexOf(layer);
    };

    /**
     * Gets a layer by index from the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {Number} index the index to retrieve.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.', 'index');
        }

        return this._layers[index];
    };

    /**
     * Gets the number of layers in this collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.getLength = function() {
        return this._layers.length;
    };

    function getLayerIndex(layers, layer) {
        if (typeof layer === 'undefined') {
            throw new DeveloperError('layer is required.');
        }

        var index = layers.indexOf(layer);
        if (index === -1) {
            throw new DeveloperError('layer is not in this collection.');
        }

        return index;
    }

    function swapLayers(collection, i, j) {
        var arr = collection._layers;
        i = CesiumMath.clamp(i, 0, arr.length - 1);
        j = CesiumMath.clamp(j, 0, arr.length - 1);

        if (i === j) {
            return;
        }

        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;

        collection._update();

        collection.layerMoved.raiseEvent(temp, j, i);
    }

    /**
     * Raises a layer up one position in the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to move.
     *
     * @exception {DeveloperError} layer is not in this collection.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.raise = function(layer) {
        var index = getLayerIndex(this._layers, layer);
        swapLayers(this, index, index + 1);
    };

    /**
     * Lowers a layer down one position in the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to move.
     *
     * @exception {DeveloperError} layer is not in this collection.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.lower = function(layer) {
        var index = getLayerIndex(this._layers, layer);
        swapLayers(this, index, index - 1);
    };

    /**
     * Raises a layer to the top of the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to move.
     *
     * @exception {DeveloperError} layer is not in this collection.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.raiseToTop = function(layer) {
        var index = getLayerIndex(this._layers, layer);
        this._layers.splice(index, 1);
        this._layers.push(layer);

        this._update();

        this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);
    };

    /**
     * Lowers a layer to the bottom of the collection.
     *
     * @memberof ImageryLayerCollection
     *
     * @param {ImageryLayer} layer the layer to move.
     *
     * @exception {DeveloperError} layer is not in this collection.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    ImageryLayerCollection.prototype.lowerToBottom = function(layer) {
        var index = getLayerIndex(this._layers, layer);
        this._layers.splice(index, 1);
        this._layers.splice(0, 0, layer);

        this._update();

        this.layerMoved.raiseEvent(layer, 0, index);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof ImageryLayerCollection
     *
     * @return {Boolean} true if this object was destroyed; otherwise, false.
     *
     * @see ImageryLayerCollection#destroy
     */
    ImageryLayerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this
     * object allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector.
     * <br /><br />
     * Once this object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof ImageryLayerCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see ImageryLayerCollection#isDestroyed
     *
     * @example
     * layerCollection = layerCollection && layerCollection.destroy();
     */
    ImageryLayerCollection.prototype.destroy = function() {
        this.removeAll(true);
        return destroyObject(this);
    };

    ImageryLayerCollection.prototype._update = function() {
        var isBaseLayer = true;
        var layers = this._layers;
        var layersShownOrHidden;
        var layer;
        for (var i = 0, len = layers.length; i < len; ++i) {
            layer = layers[i];

            layer._layerIndex = i;

            if (layer.show) {
                layer._isBaseLayer = isBaseLayer;
                isBaseLayer = false;
            } else {
                layer._isBaseLayer = false;
            }

            if (layer.show !== layer._show) {
                layer._show = layer.show;
                if (typeof layersShownOrHidden === 'undefined') {
                    layersShownOrHidden = [];
                }
                layersShownOrHidden.push(layer);
            }
        }

        if (typeof layersShownOrHidden !== 'undefined') {
            for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {
                layer = layersShownOrHidden[i];
                this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);
            }
        }
    };

    return ImageryLayerCollection;
});
/*global define*/
define('Scene/CentralBody',[
        '../Core/combine',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/BoundingRectangle',
        '../Core/BoundingSphere',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/ComponentDatatype',
        '../Core/CubeMapEllipsoidTessellator',
        '../Core/Ellipsoid',
        '../Core/Extent',
        '../Core/GeographicProjection',
        '../Core/Intersect',
        '../Core/Math',
        '../Core/Matrix4',
        '../Core/MeshFilters',
        '../Core/Occluder',
        '../Core/PrimitiveType',
        '../Core/Transforms',
        '../Renderer/BufferUsage',
        '../Renderer/ClearCommand',
        '../Renderer/CommandLists',
        '../Renderer/CullFace',
        '../Renderer/DepthFunction',
        '../Renderer/DrawCommand',
        '../Renderer/PixelFormat',
        '../Renderer/BlendingState',
        './CentralBodySurface',
        './CentralBodySurfaceShaderSet',
        './EllipsoidTerrainProvider',
        './ImageryLayerCollection',
        './SceneMode',
        './ViewportQuad',
        '../Shaders/CentralBodyFS',
        '../Shaders/CentralBodyFSDepth',
        '../Shaders/CentralBodyFSPole',
        '../Shaders/CentralBodyVS',
        '../Shaders/CentralBodyVSDepth',
        '../Shaders/CentralBodyVSPole'
    ], function(
        combine,
        defaultValue,
        destroyObject,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        ComponentDatatype,
        CubeMapEllipsoidTessellator,
        Ellipsoid,
        Extent,
        GeographicProjection,
        Intersect,
        CesiumMath,
        Matrix4,
        MeshFilters,
        Occluder,
        PrimitiveType,
        Transforms,
        BufferUsage,
        ClearCommand,
        CommandLists,
        CullFace,
        DepthFunction,
        DrawCommand,
        PixelFormat,
        BlendingState,
        CentralBodySurface,
        CentralBodySurfaceShaderSet,
        EllipsoidTerrainProvider,
        ImageryLayerCollection,
        SceneMode,
        ViewportQuad,
        CentralBodyFS,
        CentralBodyFSDepth,
        CentralBodyFSPole,
        CentralBodyVS,
        CentralBodyVSDepth,
        CentralBodyVSPole) {
    

    /**
     * DOC_TBA
     *
     * @alias CentralBody
     * @constructor
     *
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the
     * central body.
     */
    var CentralBody = function(ellipsoid) {
        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        var terrainProvider = new EllipsoidTerrainProvider({ellipsoid : ellipsoid});
        var imageryLayerCollection = new ImageryLayerCollection();

        this._ellipsoid = ellipsoid;
        this._imageryLayerCollection = imageryLayerCollection;
        this._surface = new CentralBodySurface({
            terrainProvider : terrainProvider,
            imageryLayerCollection : imageryLayerCollection
        });

        this._occluder = new Occluder(new BoundingSphere(Cartesian3.ZERO, ellipsoid.getMinimumRadius()), Cartesian3.ZERO);

        this._surfaceShaderSet = new CentralBodySurfaceShaderSet(attributeIndices);

        this._rsColor = undefined;
        this._rsColorWithoutDepthTest = undefined;

        this._clearDepthCommand = new ClearCommand();

        this._depthCommand = new DrawCommand();
        this._depthCommand.primitiveType = PrimitiveType.TRIANGLES;
        this._depthCommand.boundingVolume = new BoundingSphere(Cartesian3.ZERO, ellipsoid.getMaximumRadius());

        this._northPoleCommand = new DrawCommand();
        this._northPoleCommand.primitiveType = PrimitiveType.TRIANGLE_FAN;
        this._southPoleCommand = new DrawCommand();
        this._southPoleCommand.primitiveType = PrimitiveType.TRIANGLE_FAN;

        this._drawNorthPole = false;
        this._drawSouthPole = false;

        this._commandLists = new CommandLists();

        /**
         * Determines the color of the north pole. If the day tile provider imagery does not
         * extend over the north pole, it will be filled with this color before applying lighting.
         *
         * @type {Cartesian3}
         */
        this.northPoleColor = new Cartesian3(2.0 / 255.0, 6.0 / 255.0, 18.0 / 255.0);

        /**
         * Determines the color of the south pole. If the day tile provider imagery does not
         * extend over the south pole, it will be filled with this color before applying lighting.
         *
         * @type {Cartesian3}
         */
        this.southPoleColor = new Cartesian3(1.0, 1.0, 1.0);

        /**
         * The offset, relative to the bottom left corner of the viewport,
         * where the logo for terrain and imagery providers will be drawn.
         *
         * @type {Cartesian2}
         */
        this.logoOffset = Cartesian2.ZERO;
        this._logoOffset = this.logoOffset;
        this._logos = [];
        this._logoQuad = undefined;

        /**
         * Determines if the central body will be shown.
         *
         * @type {Boolean}
         * @default true
         */
        this.show = true;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         *
         * @default 1.0
         */
        this.morphTime = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        var that = this;

        this._drawUniforms = {
            u_mode : function() {
                return that._mode;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
    };

    var attributeIndices = {
        position3D : 0,
        textureCoordinates : 1
    };

    /**
     * Gets an ellipsoid describing the shape of this central body.
     *
     * @memberof CentralBody
     *
     * @return {Ellipsoid}
     */
    CentralBody.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Gets the collection of image layers that will be rendered on this central body.
     *
     * @returns {ImageryLayerCollection}
     */
    CentralBody.prototype.getImageryLayers = function() {
        return this._imageryLayerCollection;
    };

    CentralBody.prototype._computeDepthQuad = function(frameState) {
        var radii = this._ellipsoid.getRadii();
        var p = frameState.camera.getPositionWC();

        // Find the corresponding position in the scaled space of the ellipsoid.
        var q = this._ellipsoid.getOneOverRadii().multiplyComponents(p);

        var qMagnitude = q.magnitude();
        var qUnit = q.normalize();

        // Determine the east and north directions at q.
        var eUnit = Cartesian3.UNIT_Z.cross(q).normalize();
        var nUnit = qUnit.cross(eUnit).normalize();

        // Determine the radius of the 'limb' of the ellipsoid.
        var wMagnitude = Math.sqrt(q.magnitudeSquared() - 1.0);

        // Compute the center and offsets.
        var center = qUnit.multiplyByScalar(1.0 / qMagnitude);
        var scalar = wMagnitude / qMagnitude;
        var eastOffset = eUnit.multiplyByScalar(scalar);
        var northOffset = nUnit.multiplyByScalar(scalar);

        // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.
        var upperLeft = radii.multiplyComponents(center.add(northOffset).subtract(eastOffset));
        var upperRight = radii.multiplyComponents(center.add(northOffset).add(eastOffset));
        var lowerLeft = radii.multiplyComponents(center.subtract(northOffset).subtract(eastOffset));
        var lowerRight = radii.multiplyComponents(center.subtract(northOffset).add(eastOffset));
        return [upperLeft.x, upperLeft.y, upperLeft.z, lowerLeft.x, lowerLeft.y, lowerLeft.z, upperRight.x, upperRight.y, upperRight.z, lowerRight.x, lowerRight.y, lowerRight.z];
    };

    CentralBody.prototype._computePoleQuad = function(frameState, maxLat, maxGivenLat, viewProjMatrix, viewportTransformation) {
        var pt1 = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, maxGivenLat));
        var pt2 = this._ellipsoid.cartographicToCartesian(new Cartographic(Math.PI, maxGivenLat));
        var radius = pt1.subtract(pt2).magnitude() * 0.5;

        var center = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, maxLat));

        var right;
        var dir = frameState.camera.direction;
        if (1.0 - Cartesian3.UNIT_Z.negate().dot(dir) < CesiumMath.EPSILON6) {
            right = Cartesian3.UNIT_X;
        } else {
            right = dir.cross(Cartesian3.UNIT_Z).normalize();
        }

        var screenRight = center.add(right.multiplyByScalar(radius));
        var screenUp = center.add(Cartesian3.UNIT_Z.cross(right).normalize().multiplyByScalar(radius));

        Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, center, center);
        Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, screenRight, screenRight);
        Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, screenUp, screenUp);

        var halfWidth = Math.floor(Math.max(screenUp.subtract(center).magnitude(), screenRight.subtract(center).magnitude()));
        var halfHeight = halfWidth;

        return new BoundingRectangle(
                Math.floor(center.x) - halfWidth,
                Math.floor(center.y) - halfHeight,
                halfWidth * 2.0,
                halfHeight * 2.0);
    };

    var viewportScratch = new BoundingRectangle();
    var vpTransformScratch = new Matrix4();
    CentralBody.prototype._fillPoles = function(context, frameState) {
        var terrainProvider = this._surface._terrainProvider;
        if (frameState.mode !== SceneMode.SCENE3D) {
            return;
        }

        if (!terrainProvider.ready) {
            return;
        }
        var terrainMaxExtent = terrainProvider.tilingScheme.getExtent();

        var viewProjMatrix = context.getUniformState().getViewProjection();
        var viewport = viewportScratch;
        viewport.width = context.getCanvas().clientWidth;
        viewport.height = context.getCanvas().clientHeight;
        var viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, vpTransformScratch);
        var latitudeExtension = 0.05;

        var extent;
        var boundingVolume;
        var frustumCull;
        var occludeePoint;
        var occluded;
        var datatype;
        var mesh;
        var rect;
        var positions;
        var occluder = this._occluder;

        // handle north pole
        if (terrainMaxExtent.north < CesiumMath.PI_OVER_TWO) {
            extent = new Extent(
                -Math.PI,
                terrainMaxExtent.north,
                Math.PI,
                CesiumMath.PI_OVER_TWO
            );
            boundingVolume = BoundingSphere.fromExtent3D(extent, this._ellipsoid);
            frustumCull = frameState.cullingVolume.getVisibility(boundingVolume) === Intersect.OUTSIDE;
            occludeePoint = Occluder.computeOccludeePointFromExtent(extent, this._ellipsoid);
            occluded = (occludeePoint && !occluder.isPointVisible(occludeePoint, 0.0)) || !occluder.isBoundingSphereVisible(boundingVolume);

            this._drawNorthPole = !frustumCull && !occluded;
            if (this._drawNorthPole) {
                rect = this._computePoleQuad(frameState, extent.north, extent.south - latitudeExtension, viewProjMatrix, viewportTransformation);
                positions = [
                    rect.x, rect.y,
                    rect.x + rect.width, rect.y,
                    rect.x + rect.width, rect.y + rect.height,
                    rect.x, rect.y + rect.height
                ];

                if (typeof this._northPoleCommand.vertexArray === 'undefined') {
                    this._northPoleCommand.boundingVolume = BoundingSphere.fromExtent3D(extent, this._ellipsoid);
                    mesh = {
                        attributes : {
                            position : {
                                componentDatatype : ComponentDatatype.FLOAT,
                                componentsPerAttribute : 2,
                                values : positions
                            }
                        }
                    };
                    this._northPoleCommand.vertexArray = context.createVertexArrayFromMesh({
                        mesh : mesh,
                        attributeIndices : {
                            position : 0
                        },
                        bufferUsage : BufferUsage.STREAM_DRAW
                    });
                } else {
                    datatype = ComponentDatatype.FLOAT;
                    this._northPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(positions));
                }
            }
        }

        // handle south pole
        if (terrainMaxExtent.south > -CesiumMath.PI_OVER_TWO) {
            extent = new Extent(
                -Math.PI,
                -CesiumMath.PI_OVER_TWO,
                Math.PI,
                terrainMaxExtent.south
            );
            boundingVolume = BoundingSphere.fromExtent3D(extent, this._ellipsoid);
            frustumCull = frameState.cullingVolume.getVisibility(boundingVolume) === Intersect.OUTSIDE;
            occludeePoint = Occluder.computeOccludeePointFromExtent(extent, this._ellipsoid);
            occluded = (occludeePoint && !occluder.isPointVisible(occludeePoint)) || !occluder.isBoundingSphereVisible(boundingVolume);

            this._drawSouthPole = !frustumCull && !occluded;
            if (this._drawSouthPole) {
                rect = this._computePoleQuad(frameState, extent.south, extent.north + latitudeExtension, viewProjMatrix, viewportTransformation);
                positions = [
                     rect.x, rect.y,
                     rect.x + rect.width, rect.y,
                     rect.x + rect.width, rect.y + rect.height,
                     rect.x, rect.y + rect.height
                 ];

                 if (typeof this._southPoleCommand.vertexArray === 'undefined') {
                     this._southPoleCommand.boundingVolume = BoundingSphere.fromExtent3D(extent, this._ellipsoid);
                     mesh = {
                         attributes : {
                             position : {
                                 componentDatatype : ComponentDatatype.FLOAT,
                                 componentsPerAttribute : 2,
                                 values : positions
                             }
                         }
                     };
                     this._southPoleCommand.vertexArray = context.createVertexArrayFromMesh({
                         mesh : mesh,
                         attributeIndices : {
                             position : 0
                         },
                         bufferUsage : BufferUsage.STREAM_DRAW
                     });
                 } else {
                     datatype = ComponentDatatype.FLOAT;
                     this._southPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(positions));
                 }
            }
        }

        var poleIntensity = 0.0;
        var baseLayer = this._imageryLayerCollection.getLength() > 0 ? this._imageryLayerCollection.get(0) : undefined;
        if (typeof baseLayer !== 'undefined' && typeof baseLayer.getImageryProvider() !== 'undefined' && typeof baseLayer.getImageryProvider().getPoleIntensity !== 'undefined') {
            poleIntensity = baseLayer.getImageryProvider().getPoleIntensity();
        }

        var drawUniforms = {
            u_dayIntensity : function() {
                return poleIntensity;
            }
        };

        var that = this;
        if (typeof this._northPoleCommand.uniformMap === 'undefined') {
            var northPoleUniforms = combine([drawUniforms, {
                u_color : function() {
                    return that.northPoleColor;
                }
            }], false, false);
            this._northPoleCommand.uniformMap = combine([northPoleUniforms, this._drawUniforms], false, false);
        }

        if (typeof this._southPoleCommand.uniformMap === 'undefined') {
            var southPoleUniforms = combine([drawUniforms, {
                u_color : function() {
                    return that.southPoleColor;
                }
            }], false, false);
            this._southPoleCommand.uniformMap = combine([southPoleUniforms, this._drawUniforms], false, false);
        }
    };

    /**
     * @private
     */
    CentralBody.prototype.update = function(context, frameState, commandList) {
        if (!this.show) {
            return;
        }

        var width = context.getCanvas().clientWidth;
        var height = context.getCanvas().clientHeight;

        if (width === 0 || height === 0) {
            return;
        }

        var mode = frameState.mode;
        var projection = frameState.scene2D.projection;
        var modeChanged = false;

        if (this._mode !== mode || typeof this._rsColor === 'undefined') {
            modeChanged = true;
            if (mode === SceneMode.SCENE3D) {
                this._rsColor = context.createRenderState({ // Write color and depth
                    cull : {
                        enabled : true
                    },
                    depthTest : {
                        enabled : true
                    }
                });
                this._rsColorWithoutDepthTest = context.createRenderState({ // Write color, not depth
                    cull : {
                        enabled : true
                    }
                });
                this._depthCommand.renderState = context.createRenderState({ // Write depth, not color
                    cull : {
                        enabled : true
                    },
                    depthTest : {
                        enabled : true,
                        func : DepthFunction.ALWAYS
                    },
                    colorMask : {
                        red : false,
                        green : false,
                        blue : false,
                        alpha : false
                    }
                });
                this._clearDepthCommand.clearState = context.createClearState({ // Clear depth only
                    depth : 1.0,
                    stencil : 0.0
                });
            } else {
                this._rsColor = context.createRenderState();
                this._rsColorWithoutDepthTest = context.createRenderState();
                this._depthCommand.renderState = context.createRenderState();
            }
        }

        var cull = (mode === SceneMode.SCENE3D) || (mode === SceneMode.MORPHING);
        this._rsColor.cull.enabled = cull;
        this._rsColorWithoutDepthTest.cull.enabled = cull;
        this._depthCommand.renderState.cull.enabled = cull;

        this._northPoleCommand.renderState = this._rsColorWithoutDepthTest;
        this._southPoleCommand.renderState = this._rsColorWithoutDepthTest;

        // update depth plane
        var depthQuad = this._computeDepthQuad(frameState);

        // depth plane
        if (!this._depthCommand.vertexArray) {
            var mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : depthQuad
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [0, 1, 2, 2, 1, 3]
                }]
            };
            this._depthCommand.vertexArray = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : {
                    position : 0
                },
                bufferUsage : BufferUsage.DYNAMIC_DRAW
            });
        } else {
            var datatype = ComponentDatatype.FLOAT;
            this._depthCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(depthQuad));
        }

        var shaderCache = context.getShaderCache();

        if (!this._depthCommand.shaderProgram) {
            this._depthCommand.shaderProgram = shaderCache.getShaderProgram(
                    CentralBodyVSDepth,
                    '#line 0\n' +
                    CentralBodyFSDepth, {
                        position : 0
                    });
        }

        // Initial compile or re-compile if uber-shader parameters changed
        var projectionChanged = this._projection !== projection;

        if (typeof this._surfaceShaderSet === 'undefined' ||
            typeof this._northPoleCommand.shaderProgram === 'undefined' ||
            typeof this._southPoleCommand.shaderProgram === 'undefined' ||
            modeChanged ||
            projectionChanged) {

            var getPosition3DMode = 'vec4 getPosition(vec3 position3DWC) { return getPosition3DMode(position3DWC); }';
            var getPosition2DMode = 'vec4 getPosition(vec3 position3DWC) { return getPosition2DMode(position3DWC); }';
            var getPositionColumbusViewMode = 'vec4 getPosition(vec3 position3DWC) { return getPositionColumbusViewMode(position3DWC); }';
            var getPositionMorphingMode = 'vec4 getPosition(vec3 position3DWC) { return getPositionMorphingMode(position3DWC); }';

            var getPositionMode;

            switch (mode) {
            case SceneMode.SCENE3D:
                getPositionMode = getPosition3DMode;
                break;
            case SceneMode.SCENE2D:
                getPositionMode = getPosition2DMode;
                break;
            case SceneMode.COLUMBUS_VIEW:
                getPositionMode = getPositionColumbusViewMode;
                break;
            case SceneMode.MORPHING:
                getPositionMode = getPositionMorphingMode;
                break;
            }

            var get2DYPositionFractionGeographicProjection = 'float get2DYPositionFraction() { return get2DGeographicYPositionFraction(); }';
            var get2DYPositionFractionMercatorProjection = 'float get2DYPositionFraction() { return get2DMercatorYPositionFraction(); }';

            var get2DYPositionFraction;

            if (projection instanceof GeographicProjection) {
                get2DYPositionFraction = get2DYPositionFractionGeographicProjection;
            } else {
                get2DYPositionFraction = get2DYPositionFractionMercatorProjection;
            }

            this._surfaceShaderSet.baseVertexShaderString =
                 CentralBodyVS + '\n' +
                 getPositionMode + '\n' +
                 get2DYPositionFraction;
            this._surfaceShaderSet.baseFragmentShaderString = CentralBodyFS;
            this._surfaceShaderSet.invalidateShaders();

            var poleShaderProgram = this._northPoleCommand.shaderProgram && this._northPoleCommand.shaderProgram.release();
            poleShaderProgram = shaderCache.getShaderProgram(CentralBodyVSPole, CentralBodyFSPole, attributeIndices);

            this._northPoleCommand.shaderProgram = poleShaderProgram;
            this._southPoleCommand.shaderProgram = poleShaderProgram;
        }

        var cameraPosition = frameState.camera.getPositionWC();

        this._occluder.setCameraPosition(cameraPosition);

        this._fillPoles(context, frameState);

        this._mode = mode;
        this._projection = projection;

        var pass = frameState.passes;
        var commandLists = this._commandLists;
        commandLists.removeAll();

        if (pass.color) {
            var colorCommandList = commandLists.colorList;

            // render quads to fill the poles
            if (mode === SceneMode.SCENE3D) {
                if (this._drawNorthPole) {
                    colorCommandList.push(this._northPoleCommand);
                }

                if (this._drawSouthPole) {
                    colorCommandList.push(this._southPoleCommand);
                }
            }

            this._surface.update(context,
                    frameState,
                    colorCommandList,
                    this._drawUniforms,
                    this._surfaceShaderSet,
                    this._rsColor,
                    this._mode,
                    this._projection);

            updateLogos(this, context, frameState, commandList);

            // render depth plane
            if (mode === SceneMode.SCENE3D) {
                // TODO: clearing depth here will not be acceptable for actual terrain.
                colorCommandList.push(this._clearDepthCommand);

                colorCommandList.push(this._depthCommand);
            }
        }

        if (pass.pick) {
            // Not actually pickable, but render depth-only so primitives on the backface
            // of the globe are not picked.
            commandLists.pickList.push(this._depthCommand);
        }

        if (!commandLists.empty()) {
            commandList.push(commandLists);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CentralBody
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CentralBody#destroy
     */
    CentralBody.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CentralBody
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CentralBody#isDestroyed
     *
     * @example
     * centralBody = centralBody && centralBody.destroy();
     */
    CentralBody.prototype.destroy = function() {
        this._northPoleCommand.vertexArray = this._northPoleCommand.vertexArray && this._northPoleCommand.vertexArray.destroy();
        this._southPoleCommand.vertexArray = this._southPoleCommand.vertexArray && this._southPoleCommand.vertexArray.destroy();

        this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy();

        this._northPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram && this._northPoleCommand.shaderProgram.release();
        this._southPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram;

        this._depthCommand.shaderProgram = this._depthCommand.shaderProgram && this._depthCommand.shaderProgram.release();
        this._depthCommand.vertexArray = this._depthCommand.vertexArray && this._depthCommand.vertexArray.destroy();

        this._surface = this._surface && this._surface.destroy();

        return destroyObject(this);
    };

    var logoData = {
        logos : undefined,
        logoIndex : 0,
        rebuildLogo : false,
        totalLogoWidth : 0,
        totalLogoHeight : 0
    };

    function updateLogos(centralBody, context, frameState, commandList) {
        logoData.logos = centralBody._logos;
        logoData.logoIndex = 0;
        logoData.rebuildLogo = false;
        logoData.totalLogoWidth = 0;
        logoData.totalLogoHeight = 0;

        checkLogo(logoData, centralBody._surface._terrainProvider);

        var imageryLayerCollection = centralBody._imageryLayerCollection;
        for ( var i = 0, len = imageryLayerCollection.getLength(); i < len; ++i) {
            var layer = imageryLayerCollection.get(i);
            if (layer.show) {
                checkLogo(logoData, layer.getImageryProvider());
            }
        }

        if (logoData.logos.length !== logoData.logoIndex) {
            logoData.rebuildLogo = true;
            logoData.logos.length = logoData.logoIndex;
        }

        if (logoData.rebuildLogo) {
            var width = logoData.totalLogoWidth;
            var height = logoData.totalLogoHeight;
            var logoRectangle = new BoundingRectangle(centralBody.logoOffset.x, centralBody.logoOffset.y, width, height);
            if (typeof centralBody._logoQuad === 'undefined') {
                centralBody._logoQuad = new ViewportQuad(logoRectangle);
                centralBody._logoQuad.enableBlending = true;
            } else {
                centralBody._logoQuad.setRectangle(logoRectangle);
            }

            var texture = centralBody._logoQuad.getTexture();
            if (typeof texture === 'undefined' || texture.getWidth() !== width || texture.getHeight() !== height) {
                if (width === 0 || height === 0) {
                    if (typeof texture !== 'undefined') {
                        centralBody._logoQuad.destroy();
                        centralBody._logoQuad = undefined;
                    }
                } else {
                    texture = context.createTexture2D({
                        width : width,
                        height : height
                    });
                    centralBody._logoQuad.setTexture(texture);
                }
            }

            var heightOffset = 0;
            for (i = 0, len = logoData.logos.length; i < len; i++) {
                var logo = logoData.logos[i];
                if (typeof logo !== 'undefined') {
                    texture.copyFrom(logo, 0, heightOffset);
                    heightOffset += logo.height + 2;
                }
            }
        }

        if (typeof centralBody._logoQuad !== 'undefined') {
            centralBody._logoQuad.update(context, frameState, commandList);
        }
    }

    function checkLogo(logoData, logoSource) {
        if (typeof logoSource.isReady === 'function' && !logoSource.isReady()) {
            return;
        }

        var logo;
        if (typeof logoSource.getLogo === 'function') {
            logo = logoSource.getLogo();
        } else {
            logo = undefined;
        }

        if (logoData.logos[logoData.logoIndex] !== logo) {
            logoData.rebuildLogo = true;
            logoData.logos[logoData.logoIndex] = logo;
        }
        logoData.logoIndex++;

        if (typeof logo !== 'undefined') {
            logoData.totalLogoWidth = Math.max(logoData.totalLogoWidth, logo.width);
            logoData.totalLogoHeight += logo.height + 2;
        }
    }

    return CentralBody;
});

/*global define*/
define('Scene/Material',[
        '../ThirdParty/when',
        '../Core/loadImage',
        '../Core/DeveloperError',
        '../Core/createGuid',
        '../Core/clone',
        '../Core/Color',
        '../Core/combine',
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/Matrix2',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Renderer/Texture',
        '../Renderer/CubeMap',
        '../Shaders/Materials/AsphaltMaterial',
        '../Shaders/Materials/BlobMaterial',
        '../Shaders/Materials/BrickMaterial',
        '../Shaders/Materials/BumpMapMaterial',
        '../Shaders/Materials/CementMaterial',
        '../Shaders/Materials/CheckerboardMaterial',
        '../Shaders/Materials/DotMaterial',
        '../Shaders/Materials/FacetMaterial',
        '../Shaders/Materials/FresnelMaterial',
        '../Shaders/Materials/GrassMaterial',
        '../Shaders/Materials/NormalMapMaterial',
        '../Shaders/Materials/ReflectionMaterial',
        '../Shaders/Materials/RefractionMaterial',
        '../Shaders/Materials/StripeMaterial',
        '../Shaders/Materials/TieDyeMaterial',
        '../Shaders/Materials/Water',
        '../Shaders/Materials/WoodMaterial'
    ], function(
        when,
        loadImage,
        DeveloperError,
        createGuid,
        clone,
        Color,
        combine,
        defaultValue,
        destroyObject,
        Matrix2,
        Matrix3,
        Matrix4,
        Texture,
        CubeMap,
        AsphaltMaterial,
        BlobMaterial,
        BrickMaterial,
        BumpMapMaterial,
        CementMaterial,
        CheckerboardMaterial,
        DotMaterial,
        FacetMaterial,
        FresnelMaterial,
        GrassMaterial,
        NormalMapMaterial,
        ReflectionMaterial,
        RefractionMaterial,
        StripeMaterial,
        TieDyeMaterial,
        WaterMaterial,
        WoodMaterial) {
    

    /**
     * A Material defines surface appearance through a combination of diffuse, specular,
     * normal, emission, and alpha components. These values are specified using a
     * JSON schema called Fabric which gets parsed and assembled into glsl shader code
     * behind-the-scenes. Check out the <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>wiki page</a>
     * for more details on Fabric.
     * <br /><br />
     * <style type="text/css">
     *  #materialDescriptions code {
     *      font-weight: normal;
     *      font-family: Consolas, 'Lucida Console', Monaco, monospace;
     *      color: #A35A00;
     *  }
     *  #materialDescriptions ul, #materialDescriptions ul ul {
     *      list-style-type: none;
     *  }
     *  #materialDescriptions ul ul {
     *      margin-bottom: 10px;
     *  }
     *  #materialDescriptions ul ul li {
     *      font-weight: normal;
     *      color: #000000;
     *      text-indent: -2em;
     *      margin-left: 2em;
     *  }
     *  #materialDescriptions ul li {
     *      font-weight: bold;
     *      color: #0053CF;
     *  }
     * </style>
     *
     * Base material types and their uniforms:
     * <div id='materialDescriptions'>
     * <ul>
     *  <li>Color</li>
     *  <ul>
     *      <li><code>color</code>:  rgba color object.</li>
     *  </ul>
     *  <li>Image</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *  </ul>
     *  <li>DiffuseMap</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *  </ul>
     *  <li>AlphaMap</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *  </ul>
     *  <li>SpecularMap</li>
     *  <ul>
     *      <li><code>image</code>: path to image.</li>
     *      <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
     *      <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
     *  </ul>
     *  <li>EmissionMap</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *  </ul>
     *  <li>BumpMap</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
     *  </ul>
     *  <li>NormalMap</li>
     *  <ul>
     *      <li><code>image</code>:  path to image.</li>
     *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
     *  </ul>
     *  <li>Reflection</li>
     *  <ul>
     *      <li><code>cubeMap</code>:  Object with positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ image paths. </li>
     *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
     *  </ul>
     *  <li>Refraction</li>
     *  <ul>
     *      <li><code>cubeMap</code>:  Object with positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ image paths. </li>
     *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
     *      <li><code>indexOfRefractionRatio</code>:  Number representing the refraction strength where 1.0 is the lowest and 0.0 is the highest.</li>
     *  </ul>
     *  <li>Fresnel</li>
     *  <ul>
     *      <li><code>reflection</code>:  Reflection Material.</li>
     *      <li><code>refraction</code>:  Refraction Material.</li>
     *  </ul>
     *  <li>Brick</li>
     *  <ul>
     *      <li><code>brickColor</code>:  rgba color object for the brick color.</li>
     *      <li><code>mortarColor</code>:  rgba color object for the mortar color.</li>
     *      <li><code>brickSize</code>:  Number between 0.0 and 1.0 where 0.0 is many small bricks and 1.0 is one large brick.</li>
     *      <li><code>brickPct</code>:  Number for the ratio of brick to mortar where 0.0 is all mortar and 1.0 is all brick.</li>
     *      <li><code>brickRoughness</code>:  Number between 0.0 and 1.0 representing how rough the brick looks.</li>
     *      <li><code>mortarRoughness</code>:  Number between 0.0 and 1.0 representing how rough the mortar looks.</li>
     *  </ul>
     *  <li>Wood</li>
     *  <ul>
     *      <li><code>lightWoodColor</code>:  rgba color object for the wood's base color.</li>
     *      <li><code>darkWoodColor</code>:  rgba color object for the color of rings in the wood.</li>
     *      <li><code>ringFrequency</code>:  Number for the frequency of rings in the wood.</li>
     *      <li><code>noiseScale</code>:  Object with x and y values specifying the noisiness of the ring patterns in both directions.</li>
     *  </ul>
     *  <li>Asphalt</li>
     *  <ul>
     *      <li><code>asphaltColor</code>:  rgba color object for the asphalt's color.</li>
     *      <li><code>bumpSize</code>:  Number for the size of the asphalt's bumps.</li>
     *      <li><code>roughness</code>:  Number that controls how rough the asphalt looks.</li>
     *  </ul>
     *  <li>Cement</li>
     *  <ul>
     *  <li><code>cementColor</code>:  rgba color object for the cement's color. </li>
     *  <li><code>grainScale</code>:  Number for the size of rock grains in the cement. </li>
     *  <li><code>roughness</code>:  Number that controls how rough the cement looks.</li>
     *  </ul>
     *  <li>Grass</li>
     *  <ul>
     *      <li><code>grassColor</code>:  rgba color object for the grass' color. </li>
     *      <li><code>dirtColor</code>:  rgba color object for the dirt's color. </li>
     *      <li><code>patchiness</code>:  Number that controls the size of the color patches in the grass.</li>
     *  </ul>
     *  <li>Stripe</li>
     *  <ul>
     *      <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
     *      <li><code>lightColor</code>:  rgba color object for the stripe's light alternating color.</li>
     *      <li><code>darkColor</code>:  rgba color object for the stripe's dark alternating color.</li>
     *      <li><code>offset</code>:  Number that controls the stripe offset from the edge.</li>
     *      <li><code>repeat</code>:  Number that controls the total number of stripes, half light and half dark.</li>
     *  </ul>
     *  <li>Checkerboard</li>
     *  <ul>
     *      <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
     *      <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
     *  </ul>
     *  <li>Dot</li>
     *  <ul>
     *      <li><code>lightColor</code>:  rgba color object for the dot color.</li>
     *      <li><code>darkColor</code>:  rgba color object for the background color.</li>
     *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
     *  </ul>
     *  <li>TieDye</li>
     *  <ul>
     *      <li><code>lightColor</code>:  rgba color object for the light color.</li>
     *      <li><code>darkColor</code>:  rgba color object for the dark color.</li>
     *      <li><code>frequency</code>:  Number that controls the frequency of the pattern.</li>
     *  </ul>
     *  <li>Facet</li>
     *  <ul>
     *      <li><code>lightColor</code>:  rgba color object for the light color.</li>
     *      <li><code>darkColor</code>:  rgba color object for the dark color.</li>
     *      <li><code>frequency</code>:  Number that controls the frequency of the pattern.</li>
     *  </ul>
     *  <li>Blob</li>
     *  <ul>
     *      <li><code>lightColor</code>:  rgba color object for the light color.</li>
     *      <li><code>darkColor</code>:  rgba color object for the dark color.</li>
     *      <li><code>frequency</code>:  Number that controls the frequency of the pattern.</li>
     *  </ul>
     *  <li>Water</li>
     *  <ul>
     *      <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
     *      <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
     *      <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
     *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     *      <li><code>frequency</code>:  Number that controls the number of waves.</li>
     *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     *      <li><code>animationSpeed</code>:  Number that controls the animations speed of the water.</li>
     *      <li><code>amplitude</code>:  Number that controls the amplitude of water waves.</li>
     *      <li><code>specularIntensity</code>:  Number that controls the intensity of specular reflections.</li>
     *  </ul>
     * </ul>
     * </div>
     *
     * @alias Material
     *
     * @param {Context} description.context The context used to create textures if the material uses them.
     * @param {Boolean} [description.strict = false] Throws errors for issues that would normally be ignored, including unused uniforms or materials.
     * @param {Object} description.fabric The fabric JSON used to generate the material.
     *
     * @constructor
     *
     * @exception {DeveloperError} fabric: uniform has invalid type.
     * @exception {DeveloperError} fabric: uniforms and materials cannot share the same property.
     * @exception {DeveloperError} fabric: cannot have source and components in the same section.
     * @exception {DeveloperError} fabric: property name is not valid. It should be 'type', 'materials', 'uniforms', 'components', or 'source'.
     * @exception {DeveloperError} fabric: property name is not valid. It should be 'diffuse', 'specular', 'shininess', 'normal', 'emission', or 'alpha'.
     * @exception {DeveloperError} image: context is not defined.
     * @exception {DeveloperError} strict: shader source does not use string.
     * @exception {DeveloperError} strict: shader source does not use uniform.
     * @exception {DeveloperError} strict: shader source does not use material.
     *
     * @example
     * // Create a color material with fromType:
     * polygon.material = Material.fromType(context, 'Color');
     * polygon.material.uniforms.color = {
     *     red : 1.0,
     *     green : 1.0,
     *     blue : 0.0
     *     alpha : 1.0
     * };
     *
     * // Create the default material:
     * polygon.material = new Material();
     *
     * // Create a color material with full Fabric notation:
     * polygon.material = new Material({
     *     context : context,
     *     fabric : {
     *         type : 'Color',
     *         uniforms : {
     *             color : {
     *                 red : 1.0,
     *                 green : 1.0,
     *                 blue : 0.0,
     *                 alpha : 1.0
     *             }
     *         }
     *     }
     * });
     *
     * @see <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric wiki page</a> for a more detailed description of Fabric.
     */
    var Material = function(description) {
        /**
         * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
         * @type String
         */
        this.type = undefined;

        /**
         * The glsl shader source for this material.
         * @type String
         */
        this.shaderSource = undefined;

        /**
         * Maps sub-material names to Material objects.
         * @type Object
         */
        this.materials = undefined;

        /**
         * Maps uniform names to their values.
         * @type Object
         */
        this.uniforms = undefined;
        this._uniforms = undefined;

        this._context = undefined;
        this._strict = undefined;
        this._template = undefined;

        initializeMaterial(description, 0, this);
        Object.defineProperty(this, 'type', {
            value : this.type,
            writable : false
        });
    };

    /**
     * Creates a new material using an existing material type.
     * <br /><br />
     * Shorthand for: new Material({context : context, fabric : {type : type}});
     *
     * @param {Context} context The context used to create textures if the material uses them.
     * @param {String} type The base material type.
     *
     * @returns {Material} New material object.
     *
     * @exception {DeveloperError} material with that type does not exist.
     *
     * @example
     * var material = Material.fromType(context, 'Color');
     * material.uniforms.color = vec4(1.0, 0.0, 0.0, 1.0);
     */
    Material.fromType = function(context, type) {
        if (typeof Material._materialCache.getMaterial(type) === 'undefined') {
            throw new DeveloperError('material with type \'' + type + '\' does not exist.');
        }
        return new Material({
            context : context,
            fabric : {
                type : type
            }
        });
    };

    /**
    * Returns true if this object was destroyed; otherwise, false.
    * <br /><br />
    * If this object was destroyed, it should not be used; calling any function other than
    * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
    *
    * @memberof Material
    *
    * @returns {Boolean} True if this object was destroyed; otherwise, false.
    *
    * @see Material#destroy
    */
    Material.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Material
     *
     * @returns {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Material#isDestroyed
     *
     * @example
     * material = material && material.destroy();
     */
    Material.prototype.destroy = function() {
        var materials = this.materials;
        var uniforms = this.uniforms;
        for ( var uniformId in uniforms) {
            if (uniforms.hasOwnProperty(uniformId)) {
                var uniformValue = uniforms[uniformId];
                if (uniformValue instanceof Texture || uniformValue instanceof CubeMap) {
                    Material._textureCache.releaseTexture(this, uniformValue);
                }
            }
        }
        for ( var material in materials) {
            if (materials.hasOwnProperty(material)) {
                material.destroy();
            }
        }
        return destroyObject(this);
    };

    function initializeMaterial(description, count, result) {
        description = defaultValue(description, {});
        result._context = description.context;
        result._strict = defaultValue(description.strict, false);
        result._template = defaultValue(description.fabric, {});
        result._template.uniforms = defaultValue(result._template.uniforms, {});
        result._template.materials = defaultValue(result._template.materials, {});

        result.type = (typeof result._template.type !== 'undefined') ? result._template.type : createGuid();

        result.shaderSource = '';
        result.materials = {};
        result.uniforms = {};
        result._uniforms = {};

        // If the cache contains this material type, build the material template off of the stored template.
        var cachedTemplate = Material._materialCache.getMaterial(result.type);
        if (typeof cachedTemplate !== 'undefined') {
            var template = clone(cachedTemplate);
            result._template = combine([result._template, template]);
        }

        // Make sure the template has no obvious errors. More error checking happens later.
        checkForTemplateErrors(result);

        // If the material has a new type, add it to the cache.
        if (typeof cachedTemplate === 'undefined') {
            Material._materialCache.addMaterial(result.type, result._template);
        }

        createMethodDefinition(result);
        count = createUniforms(result, count);
        count = createSubMaterials(result, count);
        return count;
    }

    function checkForValidProperties(object, properties, result, throwNotFound) {
        if (typeof object !== 'undefined') {
            for ( var property in object) {
                if (object.hasOwnProperty(property)) {
                    var hasProperty = properties.indexOf(property) !== -1;
                    if ((throwNotFound && !hasProperty) || (!throwNotFound && hasProperty)) {
                        result(property, properties);
                    }
                }
            }
        }
    }

    function invalidNameError(property, properties) {
        var errorString = 'fabric: property name \'' + property + '\' is not valid. It should be ';
        for ( var i = 0; i < properties.length; i++) {
            var propertyName = '\'' + properties[i] + '\'';
            errorString += (i === properties.length - 1) ? ('or ' + propertyName + '.') : (propertyName + ', ');
        }
        throw new DeveloperError(errorString);
    }

    function duplicateNameError(property, properties) {
        var errorString = 'fabric: uniforms and materials cannot share the same property \'' + property + '\'';
        throw new DeveloperError(errorString);
    }

    var templateProperties = ['type', 'materials', 'uniforms', 'components', 'source'];
    var componentProperties = ['diffuse', 'specular', 'shininess', 'normal', 'emission', 'alpha'];

    function checkForTemplateErrors(material) {
        var template = material._template;
        var uniforms = template.uniforms;
        var materials = template.materials;
        var components = template.components;

        // Make sure source and components do not exist in the same template.
        if ((typeof components !== 'undefined') && (typeof template.source !== 'undefined')) {
            throw new DeveloperError('fabric: cannot have source and components in the same template.');
        }

        // Make sure all template and components properties are valid.
        checkForValidProperties(template, templateProperties, invalidNameError, true);
        checkForValidProperties(components, componentProperties, invalidNameError, true);

        // Make sure uniforms and materials do not share any of the same names.
        var materialNames = [];
        for ( var property in materials) {
            if (materials.hasOwnProperty(property)) {
                materialNames.push(property);
            }
        }
        checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
    }

    // Create the czm_getMaterial method body using source or components.
    function createMethodDefinition(material) {
        var components = material._template.components;
        var source = material._template.source;
        if (typeof source !== 'undefined') {
            material.shaderSource += source + '\n';
        } else {
            material.shaderSource += 'czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n';
            material.shaderSource += 'czm_material material = czm_getDefaultMaterial(materialInput);\n';
            if (typeof components !== 'undefined') {
                for ( var component in components) {
                    if (components.hasOwnProperty(component)) {
                        material.shaderSource += 'material.' + component + ' = ' + components[component] + ';\n';
                    }
                }
            }
            material.shaderSource += 'return material;\n}\n';
        }
    }

    function createUniforms(material, count) {
        var uniforms = material._template.uniforms;
        for ( var uniformId in uniforms) {
            if (uniforms.hasOwnProperty(uniformId)) {
                count = createUniform(material, uniformId, count);
            }
        }
        return count;
    }

    // Writes uniform declarations to the shader file and connects uniform values with
    // corresponding material properties through the returnUniforms function.
    function createUniform(material, uniformId, count) {
        var strict = material._strict;
        var materialUniforms = material._template.uniforms;
        var uniformValue = materialUniforms[uniformId];
        var uniformType = getUniformType(uniformValue);
        if (typeof uniformType === 'undefined') {
            throw new DeveloperError('fabric: uniform \'' + uniformId + '\' has invalid type.');
        } else if (uniformType === 'channels') {
            if (replaceToken(material, uniformId, uniformValue, false) === 0 && strict) {
                throw new DeveloperError('strict: shader source does not use channels \'' + uniformId + '\'.');
            }
        } else {
            // If uniform type is an image, add image dimension uniforms.
            if (uniformType.indexOf('sampler') !== -1) {
                if (typeof material._context === 'undefined') {
                    throw new DeveloperError('image: context is not defined');
                }
            }
            // Since webgl doesn't allow texture dimension queries in glsl, create a uniform to do it.
            // Check if the shader source actually uses texture dimensions before creating the uniform.
            if (uniformType === 'sampler2D') {
                var imageDimensionsUniformName = uniformId + 'Dimensions';
                if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
                    materialUniforms[imageDimensionsUniformName] = {
                        type : 'ivec3',
                        x : 1,
                        y : 1
                    };
                    createUniform(material, imageDimensionsUniformName);
                }
            }
            // Add uniform declaration to source code.
            var uniformPhrase = 'uniform ' + uniformType + ' ' + uniformId + ';\n';
            if (material.shaderSource.indexOf(uniformPhrase) === -1) {
                material.shaderSource = uniformPhrase + material.shaderSource;
            }

            var newUniformId = uniformId + '_' + count++;
            if (replaceToken(material, uniformId, newUniformId) === 1 && strict) {
                throw new DeveloperError('strict: shader source does not use uniform \'' + uniformId + '\'.');
            }
            // Set uniform value
            material.uniforms[uniformId] = uniformValue;
            material._uniforms[newUniformId] = returnUniform(material, uniformId, uniformType);
        }

        return count;
    }

    // Checks for updates to material values to refresh the uniforms.
    var matrixMap = {
        'mat2' : Matrix2,
        'mat3' : Matrix3,
        'mat4' : Matrix4
    };
    function returnUniform(material, uniformId, originalUniformType) {
        return function() {
            var uniforms = material.uniforms;
            var uniformValue = uniforms[uniformId];
            var uniformType = getUniformType(uniformValue);

            if (originalUniformType === 'sampler2D' && (uniformType === originalUniformType || uniformValue instanceof Texture)) {
                if (uniformType === originalUniformType) {
                    uniformValue = Material._textureCache.registerTexture2DToMaterial(material, uniformId, uniformValue);
                }
                // Since texture dimensions can't be updated manually, update them when the texture is updated.
                var uniformDimensionsName = uniformId + 'Dimensions';
                if (uniforms.hasOwnProperty(uniformDimensionsName)) {
                    var uniformDimensions = uniforms[uniformDimensionsName];
                    uniformDimensions.x = uniformValue._width;
                    uniformDimensions.y = uniformValue._height;
                }
            } else if (originalUniformType === 'samplerCube' && (uniformType === originalUniformType || uniformValue instanceof CubeMap)) {
                if (uniformType === originalUniformType) {
                    uniformValue = Material._textureCache.registerCubeMapToMaterial(material, uniformId, uniformValue);
                }
            } else if (originalUniformType.indexOf('mat') !== -1 && (uniformType === originalUniformType || uniformValue instanceof matrixMap[originalUniformType])) {
                if (uniformType === originalUniformType) {
                    uniformValue = matrixMap[originalUniformType].fromColumnMajorArray(uniformValue);
                }
            } else if (typeof uniformType === 'undefined' || originalUniformType !== uniformType) {
                throw new DeveloperError('fabric: uniform \'' + uniformId + '\' has invalid value.');
            }
            uniforms[uniformId] = uniformValue;
            return uniforms[uniformId];
        };
    }

    // Determines the uniform type based on the uniform in the template.
    function getUniformType(uniformValue) {
        var uniformType = uniformValue.type;
        if (typeof uniformType === 'undefined') {
            var type = typeof uniformValue;
            if (type === 'number') {
                uniformType = 'float';
            } else if (type === 'boolean') {
                uniformType = 'bool';
            } else if (type === 'string') {
                if (/^([rgba]){1,4}$/i.test(uniformValue)) {
                    uniformType = 'channels';
                } else if (uniformValue === Material.DefaultCubeMapId) {
                    uniformType = 'samplerCube';
                } else {
                    uniformType = 'sampler2D';
                }
            } else if (type === 'object') {
                if (Array.isArray(uniformValue)) {
                    if (uniformValue.length === 4 || uniformValue.length === 9 || uniformValue.length === 16) {
                        uniformType = 'mat' + Math.sqrt(uniformValue.length);
                    }
                } else {
                    var numAttributes = 0;
                    for ( var attribute in uniformValue) {
                        if (uniformValue.hasOwnProperty(attribute)) {
                            numAttributes += 1;
                        }
                    }
                    if (numAttributes >= 2 && numAttributes <= 4) {
                        uniformType = 'vec' + numAttributes;
                    } else if (numAttributes === 6) {
                        uniformType = 'samplerCube';
                    }
                }
            }
        }
        return uniformType;
    }

    // Create all sub-materials by combining source and uniforms together.
    function createSubMaterials(material, count) {
        var context = material._context;
        var strict = material._strict;
        var subMaterialTemplates = material._template.materials;
        for ( var subMaterialId in subMaterialTemplates) {
            if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
                // Construct the sub-material.
                var subMaterial = {};
                count = initializeMaterial({
                    context : context,
                    strict : strict,
                    fabric : subMaterialTemplates[subMaterialId]
                }, count, subMaterial);

                material._uniforms = combine([material._uniforms, subMaterial._uniforms]);
                material.materials[subMaterialId] = subMaterial;

                // Make the material's czm_getMaterial unique by appending the sub-material type.
                var originalMethodName = 'czm_getMaterial';
                var newMethodName = originalMethodName + '_' + count++;
                replaceToken(subMaterial, originalMethodName, newMethodName);
                material.shaderSource = subMaterial.shaderSource + material.shaderSource;

                // Replace each material id with an czm_getMaterial method call.
                var materialMethodCall = newMethodName + '(materialInput)';
                if (replaceToken(material, subMaterialId, materialMethodCall) === 0 && strict) {
                    throw new DeveloperError('strict: shader source does not use material \'' + subMaterialId + '\'.');
                }
            }
        }
        return count;
    }

    // Used for searching or replacing a token in a material's shader source with something else.
    // If excludePeriod is true, do not accept tokens that are preceded by periods.
    // http://stackoverflow.com/questions/641407/javascript-negative-lookbehind-equivalent
    function replaceToken(material, token, newToken, excludePeriod) {
        excludePeriod = defaultValue(excludePeriod, true);
        var count = 0;
        var invalidCharacters = 'a-zA-Z0-9_';
        var suffixChars = '([' + invalidCharacters + '])?';
        var prefixChars = '([' + invalidCharacters + (excludePeriod ? '.' : '') + '])?';
        var regExp = new RegExp(prefixChars + token + suffixChars, 'g');
        material.shaderSource = material.shaderSource.replace(regExp, function($0, $1, $2) {
            if ($1 || $2) {
                return $0;
            }
            count += 1;
            return newToken;
        });
        return count;
    }

    function getNumberOfTokens(material, token, excludePeriod) {
        return replaceToken(material, token, token, excludePeriod);
    }

    Material._textureCache = {
        _pathsToMaterials : {},

        _pathsToTextures : {},

        _updateMaterialsOnLoad : function(texture, path) {
            this._pathsToTextures[path] = texture;
            var materialContainers = this._pathsToMaterials[path];
            for ( var i = 0; i < materialContainers.length; i++) {
                var materialContainer = materialContainers[i];
                var material = materialContainer.material;
                var property = materialContainer.property;
                this.releaseTexture(material, material.uniforms[property]);
                material.uniforms[property] = texture;
            }
        },

        releaseTexture : function(material, texture) {
            var pathsToTexture = this._pathsToTextures;
            for ( var path in pathsToTexture) {
                if (pathsToTexture[path] === texture) {
                    var materialsWithTexture = this._pathsToMaterials[path];
                    for ( var i = 0; i < materialsWithTexture.length; i++) {
                        if (materialsWithTexture[i].material === material) {
                            materialsWithTexture.splice(i, 1);
                            var numMaterialsWithTexture = materialsWithTexture.length;
                            if (numMaterialsWithTexture === 0) {
                                texture.destroy();
                                delete pathsToTexture.path;
                                delete materialsWithTexture.path;
                            }
                        }
                    }
                }
            }
        },

        registerCubeMapToMaterial : function(material, property, info) {
            var that = this;
            var texture;
            if (info === Material.DefaultCubeMapId) {
                texture = material._context.getDefaultCubeMap();
            } else {
                var path = info.positiveX + info.negativeX + info.positiveY + info.negativeY + info.positiveZ + info.negativeZ;
                this._pathsToMaterials[path] = defaultValue(this._pathsToMaterials[path], []);
                this._pathsToMaterials[path].push({
                    'material' : material,
                    'property' : property
                });
                texture = this._pathsToTextures[path];
                if (typeof texture === 'undefined') {
                    var oldTexture = material.uniforms[property];
                    var hasOldTexture = oldTexture instanceof CubeMap;
                    texture = hasOldTexture ? oldTexture : material._context.getDefaultCubeMap();
                    if (this._pathsToMaterials[path].length === 1) {
                        when.all([loadImage(info.positiveX), loadImage(info.negativeX), loadImage(info.positiveY), loadImage(info.negativeY), loadImage(info.positiveZ), loadImage(info.negativeZ)]).then(function(images) {
                            texture = material._context.createCubeMap({
                                source : {
                                    positiveX : images[0],
                                    negativeX : images[1],
                                    positiveY : images[2],
                                    negativeY : images[3],
                                    positiveZ : images[4],
                                    negativeZ : images[5]
                                }
                            });
                            that._updateMaterialsOnLoad(texture, path);
                        });
                    }
                }
            }
            return texture;
        },

        registerTexture2DToMaterial : function(material, property, info) {
            var that = this;
            var texture;
            if (info === Material.DefaultImageId) {
                texture = material._context.getDefaultTexture();
            } else {
                var path = info;
                this._pathsToMaterials[path] = defaultValue(this._pathsToMaterials[path], []);
                this._pathsToMaterials[path].push({
                    'material' : material,
                    'property' : property
                });
                texture = this._pathsToTextures[path];
                if (typeof texture === 'undefined') {
                    var oldTexture = material.uniforms[property];
                    var hasOldTexture = oldTexture instanceof Texture;
                    texture = hasOldTexture ? oldTexture : material._context.getDefaultTexture();
                    if (this._pathsToMaterials[path].length === 1) {
                        when(loadImage(path), function(image) {
                            texture = material._context.createTexture2D({
                                source : image
                            });
                            that._updateMaterialsOnLoad(texture, path);
                        });
                    }
                }
            }
            return texture;
        }
    };

    Material._materialCache = {
        _materials : {},
        addMaterial : function(type, materialTemplate) {
            this._materials[type] = materialTemplate;
        },
        getMaterial : function(type) {
            return this._materials[type];
        }
    };

    Material.DefaultImageId = 'czm_defaultImage';
    Material.DefaultCubeMapId = 'czm_defaultCubeMap';

    Material.ColorType = 'Color';
    Material._materialCache.addMaterial(Material.ColorType, {
        type : Material.ColorType,
        uniforms : {
            color : new Color(1.0, 0.0, 0.0, 0.5)
        },
        components : {
            diffuse : 'color.rgb',
            alpha : 'color.a'
        }
    });

    Material.ImageType = 'Image';
    Material._materialCache.addMaterial(Material.ImageType, {
        type : Material.ImageType,
        uniforms : {
            image : Material.DefaultImageId,
            repeat : {
                x : 1,
                y : 1
            }
        },
        components : {
            diffuse : 'texture2D(image, fract(repeat * materialInput.st)).rgb',
            alpha : 'texture2D(image, fract(repeat * materialInput.st)).a'
        }
    });

    Material.DiffuseMapType = 'DiffuseMap';
    Material._materialCache.addMaterial(Material.DiffuseMapType, {
        type : Material.DiffuseMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channels : 'rgb',
            repeat : {
                x : 1,
                y : 1
            }
        },
        components : {
            diffuse : 'texture2D(image, fract(repeat * materialInput.st)).channels'
        }
    });

    Material.AlphaMapType = 'AlphaMap';
    Material._materialCache.addMaterial(Material.AlphaMapType, {
        type : Material.AlphaMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channel : 'a',
            repeat : {
                x : 1,
                y : 1
            }
        },
        components : {
            alpha : 'texture2D(image, fract(repeat * materialInput.st)).channel'
        }
    });

    Material.SpecularMapType = 'SpecularMap';
    Material._materialCache.addMaterial(Material.SpecularMapType, {
        type : Material.SpecularMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channel : 'r',
            repeat : {
                x : 1,
                y : 1
            }
        },
        components : {
            specular : 'texture2D(image, fract(repeat * materialInput.st)).channel'
        }
    });

    Material.EmissionMapType = 'EmissionMap';
    Material._materialCache.addMaterial(Material.EmissionMapType, {
        type : Material.EmissionMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channels : 'rgb',
            repeat : {
                x : 1,
                y : 1
            }
        },
        components : {
            emission : 'texture2D(image, fract(repeat * materialInput.st)).channels'
        }
    });

    Material.BumpMapType = 'BumpMap';
    Material._materialCache.addMaterial(Material.BumpMapType, {
        type : Material.BumpMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channel : 'r',
            strength : 0.8,
            repeat : {
                x : 1,
                y : 1
            }
        },
        source : BumpMapMaterial
    });

    Material.NormalMapType = 'NormalMap';
    Material._materialCache.addMaterial(Material.NormalMapType, {
        type : Material.NormalMapType,
        uniforms : {
            image : Material.DefaultImageId,
            channels : 'rgb',
            strength : 0.8,
            repeat : {
                x : 1,
                y : 1
            }
        },
        source : NormalMapMaterial
    });

    Material.ReflectionType = 'Reflection';
    Material._materialCache.addMaterial(Material.ReflectionType, {
        type : Material.ReflectionType,
        uniforms : {
            cubeMap : Material.DefaultCubeMapId,
            channels : 'rgb'
        },
        source : ReflectionMaterial
    });

    Material.RefractionType = 'Refraction';
    Material._materialCache.addMaterial(Material.RefractionType, {
        type : Material.RefractionType,
        uniforms : {
            cubeMap : Material.DefaultCubeMapId,
            channels : 'rgb',
            indexOfRefractionRatio : 0.9
        },
        source : RefractionMaterial
    });

    Material.FresnelType = 'Fresnel';
    Material._materialCache.addMaterial(Material.FresnelType, {
        type : Material.FresnelType,
        materials : {
            reflection : {
                type : Material.ReflectionType
            },
            refraction : {
                type : Material.RefractionType
            }
        },
        source : FresnelMaterial
    });

    Material.BrickType = 'Brick';
    Material._materialCache.addMaterial(Material.BrickType, {
        type : Material.BrickType,
        uniforms : {
            brickColor : {
                red : 0.6,
                green : 0.3,
                blue : 0.1,
                alpha : 1.0
            },
            mortarColor : {
                red : 0.8,
                green : 0.8,
                blue : 0.7,
                alpha : 1.0
            },
            brickSize : {
                x : 0.30,
                y : 0.15
            },
            brickPct : {
                x : 0.90,
                y : 0.85
            },
            brickRoughness : 0.2,
            mortarRoughness : 0.1
        },
        source : BrickMaterial
    });

    Material.WoodType = 'Wood';
    Material._materialCache.addMaterial(Material.WoodType, {
        type : Material.WoodType,
        uniforms : {
            lightWoodColor : {
                red : 0.6,
                green : 0.3,
                blue : 0.1,
                alpha : 1.0
            },
            darkWoodColor : {
                red : 0.4,
                green : 0.2,
                blue : 0.07,
                alpha : 1.0
            },
            ringFrequency : 3.0,
            noiseScale : {
                x : 0.7,
                y : 0.5
            },
            grainFrequency : 27.0
        },
        source : WoodMaterial
    });

    Material.AsphaltType = 'Asphalt';
    Material._materialCache.addMaterial(Material.AsphaltType, {
        type : Material.AsphaltType,
        uniforms : {
            asphaltColor : {
                red : 0.15,
                green : 0.15,
                blue : 0.15,
                alpha : 1.0
            },
            bumpSize : 0.02,
            roughness : 0.2
        },
        source : AsphaltMaterial
    });

    Material.CementType = 'Cement';
    Material._materialCache.addMaterial(Material.CementType, {
        type : Material.CementType,
        uniforms : {
            cementColor : {
                red : 0.95,
                green : 0.95,
                blue : 0.85,
                alpha : 1.0
            },
            grainScale : 0.01,
            roughness : 0.3
        },
        source : CementMaterial
    });

    Material.GrassType = 'Grass';
    Material._materialCache.addMaterial(Material.GrassType, {
        type : Material.GrassType,
        uniforms : {
            grassColor : {
                red : 0.25,
                green : 0.4,
                blue : 0.1,
                alpha : 1.0
            },
            dirtColor : {
                red : 0.1,
                green : 0.1,
                blue : 0.1,
                alpha : 1.0
            },
            patchiness : 1.5
        },
        source : GrassMaterial
    });

    Material.StripeType = 'Stripe';
    Material._materialCache.addMaterial(Material.StripeType, {
        type : Material.StripeType,
        uniforms : {
            horizontal : true,
            lightColor : {
                red : 1.0,
                green : 1.0,
                blue : 1.0,
                alpha : 0.5
            },
            darkColor : {
                red : 0.0,
                green : 0.0,
                blue : 1.0,
                alpha : 0.5
            },
            offset : 0.0,
            repeat : 5.0
        },
        source : StripeMaterial
    });

    Material.CheckerboardType = 'Checkerboard';
    Material._materialCache.addMaterial(Material.CheckerboardType, {
        type : Material.CheckerboardType,
        uniforms : {
            lightColor : {
                red : 1.0,
                green : 1.0,
                blue : 1.0,
                alpha : 0.5
            },
            darkColor : {
                red : 0.0,
                green : 0.0,
                blue : 0.0,
                alpha : 0.5
            },
            repeat : {
                x : 5.0,
                y : 5.0
            }
        },
        source : CheckerboardMaterial
    });

    Material.DotType = 'Dot';
    Material._materialCache.addMaterial(Material.DotType, {
        type : Material.DotType,
        uniforms : {
            lightColor : {
                red : 1.0,
                green : 1.0,
                blue : 0.0,
                alpha : 0.75
            },
            darkColor : {
                red : 0.0,
                green : 1.0,
                blue : 1.0,
                alpha : 0.75
            },
            repeat : {
                x : 5.0,
                y : 5.0
            }
        },
        source : DotMaterial
    });

    Material.TyeDyeType = 'TieDye';
    Material._materialCache.addMaterial(Material.TyeDyeType, {
        type : Material.TyeDyeType,
        uniforms : {
            lightColor : {
                red : 1.0,
                green : 1.0,
                blue : 0.0,
                alpha : 0.75
            },
            darkColor : {
                red : 1.0,
                green : 0.0,
                blue : 0.0,
                alpha : 0.75
            },
            frequency : 5.0
        },
        source : TieDyeMaterial
    });

    Material.FacetType = 'Facet';
    Material._materialCache.addMaterial(Material.FacetType, {
        type : Material.FacetType,
        uniforms : {
            lightColor : {
                red : 0.25,
                green : 0.25,
                blue : 0.25,
                alpha : 0.75
            },
            darkColor : {
                red : 0.75,
                green : 0.75,
                blue : 0.75,
                alpha : 0.75
            },
            frequency : 10.0
        },
        source : FacetMaterial
    });

    Material.BlobType = 'Blob';
    Material._materialCache.addMaterial(Material.BlobType, {
        type : Material.BlobType,
        uniforms : {
            lightColor : {
                red : 1.0,
                green : 1.0,
                blue : 1.0,
                alpha : 0.5
            },
            darkColor : {
                red : 0.0,
                green : 0.0,
                blue : 1.0,
                alpha : 0.5
            },
            frequency : 10.0
        },
        source : BlobMaterial
    });

    Material.WaterType = 'Water';
    Material._materialCache.addMaterial(Material.WaterType, {
        type : Material.WaterType,
        uniforms : {
            baseWaterColor : {
                red : 0.2,
                green : 0.3,
                blue : 0.6,
                alpha : 1.0
            },
            blendColor : {
                red : 0.0,
                green : 1.0,
                blue : 0.699,
                alpha : 1.0
            },
            specularMap : Material.DefaultImageId,
            normalMap : Material.DefaultImageId,
            frequency : 10.0,
            animationSpeed : 0.01,
            amplitude : 1.0,
            specularIntensity : 0.5,
            fadeFactor : 1.0
        },
        source : WaterMaterial
    });

    return Material;
});

/*global define*/
define('DynamicScene/DynamicColorMaterial',[
        './DynamicProperty',
        './CzmlColor',
        '../Scene/Material'
    ], function(
         DynamicProperty,
         CzmlColor,
         Material) {
    

    /**
     * A utility class for processing CZML color materials.
     * @alias DynamicColorMaterial
     * @constructor
     */
    var DynamicColorMaterial = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the material's color.
         * @type DynamicProperty
         */
        this.color = undefined;
    };

    /**
     * Returns true if the provided CZML interval contains color material data.
     * @param czmlInterval The CZML interval to check.
     * @returns {Boolean} true if the interval contains CZML color material data, false otherwise.
     */
    DynamicColorMaterial.isMaterial = function(czmlInterval) {
        return typeof czmlInterval !== 'undefined' && typeof czmlInterval.solidColor !== 'undefined';
    };

    /**
     * Provided a CZML interval containing color material data, processes the
     * interval into a new or existing instance of this class.
     *
     * @param {Object} czmlInterval The interval to process.
     * @param {DynamicColorMaterial} [existingMaterial] The DynamicColorMaterial to modify.
     */
    DynamicColorMaterial.prototype.processCzmlIntervals = function(czmlInterval) {
        var materialData = czmlInterval.solidColor;
        if (typeof materialData !== 'undefined') {
            if (typeof materialData.color !== 'undefined') {
                var color = this.color;
                if (typeof color === 'undefined') {
                    this.color = color = new DynamicProperty(CzmlColor);
                }
                color.processCzmlIntervals(materialData.color);
            }
        }
    };

    /**
     * Gets a Color Material that represents this dynamic material at the provided time.
     *
     * @param {JulianDate} time The desired time.
     * @param {Context} context The context in which this material exists.
     * @param {Material} [existingMaterial] An existing material to be modified.  If the material is undefined or not a Color Material, a new instance is created.
     * @returns The modified existingMaterial parameter or a new Color Material instance if existingMaterial was undefined or not a Color Material.
     */
    DynamicColorMaterial.prototype.getValue = function(time, context, existingMaterial) {
        if (typeof existingMaterial === 'undefined' || (existingMaterial.type !== Material.ColorType)) {
            existingMaterial = Material.fromType(context, Material.ColorType);
        }
        existingMaterial.uniforms.color = this.color.getValue(time, existingMaterial.uniforms.color);
        return existingMaterial;
    };

    return DynamicColorMaterial;
});
/*global define*/
define('DynamicScene/DynamicImageMaterial',[
        './DynamicProperty',
        './CzmlImage',
        './CzmlNumber',
        '../Scene/Material'
    ], function(
         DynamicProperty,
         CzmlImage,
         CzmlNumber,
         Material) {
    

    /**
     * A utility class for processing CZML image materials.
     * @alias DynamicImageMaterial
     * @constructor
     */
    var DynamicImageMaterial = function() {
        /**
         * A DynamicProperty of type CzmlNumber which determines the material's image.
         * @type DynamicProperty
         */
        this.image = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the material's vertical repeat.
         * @type DynamicProperty
         */
        this.verticalRepeat = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the material's horizontal repeat.
         *
         * @type DynamicProperty
         */
        this.horizontalRepeat = undefined;
    };

    /**
     * Returns true if the provided CZML interval contains image material data.
     * @param czmlInterval The CZML interval to check.
     * @returns {Boolean} true if the interval contains CZML image material data, false otherwise.
     */
    DynamicImageMaterial.isMaterial = function(czmlInterval) {
        return typeof czmlInterval.image !== 'undefined';
    };

    /**
     * Provided a CZML interval containing image material data, processes the
     * interval into a new or existing instance of this class.
     *
     * @param {Object} czmlInterval The interval to process.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns The modified existingMaterial parameter or a new DynamicImageMaterial instance if existingMaterial was undefined or not a DynamicImageMaterial.
     */
    DynamicImageMaterial.prototype.processCzmlIntervals = function(czmlInterval, sourceUri) {
        var materialData = czmlInterval.image;
        if (typeof materialData === 'undefined') {
            return;
        }

        if (typeof materialData.image !== 'undefined') {
            var image = this.image;
            if (typeof image === 'undefined') {
                this.image = image = new DynamicProperty(CzmlImage);
            }
            image.processCzmlIntervals(materialData.image, undefined, sourceUri);
        }

        if (typeof materialData.verticalRepeat !== 'undefined') {
            var verticalRepeat = this.verticalRepeat;
            if (typeof verticalRepeat === 'undefined') {
                this.verticalRepeat = verticalRepeat = new DynamicProperty(CzmlNumber);
            }
            verticalRepeat.processCzmlIntervals(materialData.verticalRepeat);
        }

        if (typeof materialData.horizontalRepeat !== 'undefined') {
            var horizontalRepeat = this.horizontalRepeat;
            if (typeof horizontalRepeat === 'undefined') {
                this.horizontalRepeat = horizontalRepeat = new DynamicProperty(CzmlNumber);
            }
            horizontalRepeat.processCzmlIntervals(materialData.horizontalRepeat);
        }
    };

    /**
     * Gets an Image Material that represents this dynamic material at the provided time.
     *
     * @param {JulianDate} time The desired time.
     * @param {Context} context The context in which this material exists.
     * @param {Material} [existingMaterial] An existing material to be modified.  If the material is undefined or not an Image Material, a new instance is created.
     * @returns The modified existingMaterial parameter or a new Image Material instance if existingMaterial was undefined or not a Image Material.
     */
    DynamicImageMaterial.prototype.getValue = function(time, context, existingMaterial) {
        if (typeof existingMaterial === 'undefined' || (existingMaterial.type !== Material.ImageType)) {
            existingMaterial = Material.fromType(context, Material.ImageType);
        }

        var xRepeat;
        var property = this.verticalRepeat;
        if (typeof property !== 'undefined') {
            xRepeat = property.getValue(time);
            if (typeof xRepeat !== 'undefined') {
                existingMaterial.uniforms.repeat.x = xRepeat;
            }
        }

        var yRepeat;
        property = this.horizontalRepeat;
        if (typeof property !== 'undefined') {
            yRepeat = property.getValue(time);
            if (typeof yRepeat !== 'undefined') {
                existingMaterial.uniforms.repeat.y = yRepeat;
            }
        }

        property = this.image;
        if (typeof property !== 'undefined') {
            var url = this.image.getValue(time);
            if (typeof url !== 'undefined' && existingMaterial.currentUrl !== url) {
                existingMaterial.currentUrl = url;
                existingMaterial.uniforms.image = url;
            }
        }
        return existingMaterial;
    };

    return DynamicImageMaterial;
});
/*global define*/
define('DynamicScene/DynamicMaterialProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        './DynamicColorMaterial',
        './DynamicImageMaterial'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        DynamicColorMaterial,
        DynamicImageMaterial) {
    

    var potentialMaterials = [DynamicColorMaterial, DynamicImageMaterial];

    /**
     * A dynamic property which stores data for multiple types of materials
     * associated with the same property over time. Rather than creating instances
     * of this object directly, it's typically created and managed via loading CZML
     * data into a DynamicObjectCollection.
     *
     * @alias DynamicMaterialProperty
     * @internalconstructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicMaterialProperty = function() {
        this._intervals = new TimeIntervalCollection();
    };


    /**
     * Processes the provided CZML interval or intervals into this property.
     * @memberof DynamicMaterialProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     */
    DynamicMaterialProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, sourceUri) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, sourceUri);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, sourceUri);
        }
    };

    /**
     * Returns the value of the property at the specified time.
     * @memberof DynamicMaterialProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Context} [context] The context in which the material exists.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    DynamicMaterialProperty.prototype.getValue = function(time, context, existingMaterial) {
        var value = this._intervals.findIntervalContainingDate(time);
        var material = typeof value !== 'undefined' ? value.data : undefined;
        if (typeof material !== 'undefined') {
            return material.getValue(time, context, existingMaterial);
        }
        return existingMaterial;
    };

    DynamicMaterialProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, sourceUri) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._intervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);
        var foundMaterial = false;
        var existingMaterial;

        if (typeof existingInterval !== 'undefined') {
            //We have an interval, but we need to make sure the
            //new data is the same type of material as the old data.
            existingMaterial = existingInterval.data;
            foundMaterial = existingMaterial.isMaterial(czmlInterval);
        } else {
            //If not, create it.
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        //If the new data was a different type, look for a handler for this type.
        if (foundMaterial === false) {
            for ( var i = 0, len = potentialMaterials.length; i < len; i++) {
                var Material = potentialMaterials[i];
                foundMaterial = Material.isMaterial(czmlInterval);
                if (foundMaterial) {
                    existingInterval.data = existingMaterial = new Material();
                    break;
                }
            }
        }

        //We could handle the data, prcess it.
        if (foundMaterial) {
            existingMaterial.processCzmlIntervals(czmlInterval, sourceUri);
        }
    };

    return DynamicMaterialProperty;
});
/*global define*/
define('DynamicScene/DynamicCone',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty',
        './DynamicMaterialProperty'
       ], function(
         TimeInterval,
         defaultValue,
         CzmlBoolean,
         CzmlNumber,
         CzmlColor,
         DynamicProperty,
         DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic cone, typically used in conjunction with DynamicConeVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicCone
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicConeVisualizer
     * @see VisualizerCollection
     * @see ComplexConicSensor
     * @see CzmlDefaults
     */
    var DynamicCone = function() {
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's minimum clock-angle.
         * @type DynamicProperty
         */
        this.minimumClockAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's maximum clock-angle.
         * @type DynamicProperty
         */
        this.maximumClockAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's inner half-angle.
         * @type DynamicProperty
         */
        this.innerHalfAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's outer half-angle.
         * @type DynamicProperty
         */
        this.outerHalfAngle = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's cap material.
         * @type DynamicMaterialProperty
         */
        this.capMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's inner material.
         * @type DynamicMaterialProperty
         */
        this.innerMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's outer material.
         * @type DynamicMaterialProperty
         */
        this.outerMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's silhouette material.
         * @type DynamicMaterialProperty
         */
        this.silhouetteMaterial = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the color of the line formed by the intersection of the cone and other central bodies.
         * @type DynamicProperty
         */
        this.intersectionColor = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the cone's intersection visibility
         * @type DynamicProperty
         */
        this.showIntersection = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's radius.
         * @type DynamicProperty
         */
        this.radius = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the cone's visibility
         * @type DynamicProperty
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's cone.
     * If the DynamicObject does not have a cone, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the cone data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicCone.processCzmlPacket = function(dynamicObject, packet) {
        var coneData = packet.cone;
        if (typeof coneData === 'undefined') {
            return false;
        }

        var coneUpdated = false;
        var cone = dynamicObject.cone;
        coneUpdated = typeof cone === 'undefined';
        if (coneUpdated) {
            dynamicObject.cone = cone = new DynamicCone();
        }

        var interval = coneData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof coneData.show !== 'undefined') {
            var show = cone.show;
            if (typeof show === 'undefined') {
                cone.show = show = new DynamicProperty(CzmlBoolean);
                coneUpdated = true;
            }
            show.processCzmlIntervals(coneData.show, interval);
        }

        if (typeof coneData.innerHalfAngle !== 'undefined') {
            var innerHalfAngle = cone.innerHalfAngle;
            if (typeof innerHalfAngle === 'undefined') {
                cone.innerHalfAngle = innerHalfAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            innerHalfAngle.processCzmlIntervals(coneData.innerHalfAngle, interval);
        }

        if (typeof coneData.outerHalfAngle !== 'undefined') {
            var outerHalfAngle = cone.outerHalfAngle;
            if (typeof outerHalfAngle === 'undefined') {
                cone.outerHalfAngle = outerHalfAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            outerHalfAngle.processCzmlIntervals(coneData.outerHalfAngle, interval);
        }

        if (typeof coneData.minimumClockAngle !== 'undefined') {
            var minimumClockAngle = cone.minimumClockAngle;
            if (typeof minimumClockAngle === 'undefined') {
                cone.minimumClockAngle = minimumClockAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            minimumClockAngle.processCzmlIntervals(coneData.minimumClockAngle, interval);
        }

        if (typeof coneData.maximumClockAngle !== 'undefined') {
            var maximumClockAngle = cone.maximumClockAngle;
            if (typeof maximumClockAngle === 'undefined') {
                cone.maximumClockAngle = maximumClockAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            maximumClockAngle.processCzmlIntervals(coneData.maximumClockAngle, interval);
        }

        if (typeof coneData.radius !== 'undefined') {
            var radius = cone.radius;
            if (typeof radius === 'undefined') {
                cone.radius = radius = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            radius.processCzmlIntervals(coneData.radius, interval);
        }

        if (typeof coneData.showIntersection !== 'undefined') {
            var showIntersection = cone.showIntersection;
            if (typeof showIntersection === 'undefined') {
                cone.showIntersection = showIntersection = new DynamicProperty(CzmlBoolean);
                coneUpdated = true;
            }
            showIntersection.processCzmlIntervals(coneData.showIntersection, interval);
        }

        if (typeof coneData.intersectionColor !== 'undefined') {
            var intersectionColor = cone.intersectionColor;
            if (typeof intersectionColor === 'undefined') {
                cone.intersectionColor = intersectionColor = new DynamicProperty(CzmlColor);
                coneUpdated = true;
            }
            intersectionColor.processCzmlIntervals(coneData.intersectionColor, interval);
        }

        if (typeof coneData.capMaterial !== 'undefined') {
            var capMaterial = cone.capMaterial;
            if (typeof capMaterial === 'undefined') {
                cone.capMaterial = capMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            capMaterial.processCzmlIntervals(coneData.capMaterial, interval);
        }

        if (typeof coneData.innerMaterial !== 'undefined') {
            var innerMaterial = cone.innerMaterial;
            if (typeof innerMaterial === 'undefined') {
                cone.innerMaterial = innerMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            innerMaterial.processCzmlIntervals(coneData.innerMaterial, interval);
        }

        if (typeof coneData.outerMaterial !== 'undefined') {
            var outerMaterial = cone.outerMaterial;
            if (typeof outerMaterial === 'undefined') {
                cone.outerMaterial = outerMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            outerMaterial.processCzmlIntervals(coneData.outerMaterial, interval);
        }

        if (typeof coneData.silhouetteMaterial !== 'undefined') {
            var silhouetteMaterial = cone.silhouetteMaterial;
            if (typeof silhouetteMaterial === 'undefined') {
                cone.silhouetteMaterial = silhouetteMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            silhouetteMaterial.processCzmlIntervals(coneData.silhouetteMaterial, interval);
        }

        return coneUpdated;
    };

    /**
     * Given two DynamicObjects, takes the cone properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicCone.mergeProperties = function(targetObject, objectToMerge) {
        var coneToMerge = objectToMerge.cone;
        if (typeof coneToMerge !== 'undefined') {

            var targetCone = targetObject.cone;
            if (typeof targetCone === 'undefined') {
                targetObject.cone = targetCone = new DynamicCone();
            }

            targetCone.show = defaultValue(targetCone.show, coneToMerge.show);
            targetCone.innerHalfAngle = defaultValue(targetCone.innerHalfAngle, coneToMerge.innerHalfAngle);
            targetCone.outerHalfAngle = defaultValue(targetCone.outerHalfAngle, coneToMerge.outerHalfAngle);
            targetCone.minimumClockAngle = defaultValue(targetCone.minimumClockAngle, coneToMerge.minimumClockAngle);
            targetCone.maximumClockAngle = defaultValue(targetCone.maximumClockAngle, coneToMerge.maximumClockAngle);
            targetCone.radius = defaultValue(targetCone.radius, coneToMerge.radius);
            targetCone.showIntersection = defaultValue(targetCone.showIntersection, coneToMerge.showIntersection);
            targetCone.intersectionColor = defaultValue(targetCone.intersectionColor, coneToMerge.intersectionColor);
            targetCone.capMaterial = defaultValue(targetCone.capMaterial, coneToMerge.capMaterial);
            targetCone.innerMaterial = defaultValue(targetCone.innerMaterial, coneToMerge.innerMaterial);
            targetCone.outerMaterial = defaultValue(targetCone.outerMaterial, coneToMerge.outerMaterial);
            targetCone.silhouetteMaterial = defaultValue(targetCone.silhouetteMaterial, coneToMerge.silhouetteMaterial);
        }
    };

    /**
     * Given a DynamicObject, undefines the cone associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the cone from.
     *
     * @see CzmlDefaults
     */
    DynamicCone.undefineProperties = function(dynamicObject) {
        dynamicObject.cone = undefined;
    };

    return DynamicCone;
});
/*global define*/
define('DynamicScene/DynamicEllipsoid',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlCartesian3',
        './CzmlColor',
        './DynamicProperty',
        './DynamicMaterialProperty'
    ], function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlCartesian3,
        CzmlColor,
        DynamicProperty,
        DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic ellipsoid, typically used in conjunction with DynamicEllipsoidVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicEllipsoid
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicEllipsoidVisualizer
     * @see VisualizerCollection
     * @see CustomSensor
     * @see CzmlDefaults
     */
    var DynamicEllipsoid = function() {
        /**
         * A DynamicProperty of type CzmlBoolean which determines the ellipsoid's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian3 which determines the ellipsoid's radii.
         * @type DynamicProperty
         */
        this.radii = undefined;
        /**
         * A DynamicMaterialProperty which determines the material.
         * @type DynamicMaterialProperty
         */
        this.material = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's ellipsoid.
     * If the DynamicObject does not have a ellipsoid, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the ellipsoid data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObject} dynamicObjectCollection The DynamicObjectCollection to which the DynamicObject belongs.
     *
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicEllipsoid.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection) {
        var ellipsoidData = packet.ellipsoid;
        if (typeof ellipsoidData === 'undefined') {
            return false;
        }

        var ellipsoidUpdated = false;
        var ellipsoid = dynamicObject.ellipsoid;
        ellipsoidUpdated = typeof ellipsoid === 'undefined';
        if (ellipsoidUpdated) {
            dynamicObject.ellipsoid = ellipsoid = new DynamicEllipsoid();
        }

        var interval = ellipsoidData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof ellipsoidData.show !== 'undefined') {
            var show = ellipsoid.show;
            if (typeof show === 'undefined') {
                ellipsoid.show = show = new DynamicProperty(CzmlBoolean);
                ellipsoidUpdated = true;
            }
            show.processCzmlIntervals(ellipsoidData.show, interval);
        }

        if (typeof ellipsoidData.radii !== 'undefined') {
            var radii = ellipsoid.radii;
            if (typeof radii === 'undefined') {
                ellipsoid.radii = radii = new DynamicProperty(CzmlCartesian3);
                ellipsoidUpdated = true;
            }
            radii.processCzmlIntervals(ellipsoidData.radii, interval);
        }

        if (typeof ellipsoidData.material !== 'undefined') {
            var material = ellipsoid.material;
            if (typeof material === 'undefined') {
                ellipsoid.material = material = new DynamicMaterialProperty();
                ellipsoidUpdated = true;
            }
            material.processCzmlIntervals(ellipsoidData.material, interval);
        }

        return ellipsoidUpdated;
    };

    /**
     * Given two DynamicObjects, takes the ellipsoid properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicEllipsoid.mergeProperties = function(targetObject, objectToMerge) {
        var ellipsoidToMerge = objectToMerge.ellipsoid;
        if (typeof ellipsoidToMerge !== 'undefined') {

            var targetEllipsoid = targetObject.ellipsoid;
            if (typeof targetEllipsoid === 'undefined') {
                targetObject.ellipsoid = targetEllipsoid = new DynamicEllipsoid();
            }

            targetEllipsoid.show = defaultValue(targetEllipsoid.show, ellipsoidToMerge.show);
            targetEllipsoid.radii = defaultValue(targetEllipsoid.radii, ellipsoidToMerge.radii);
            targetEllipsoid.material = defaultValue(targetEllipsoid.material, ellipsoidToMerge.material);
        }
    };

    /**
     * Given a DynamicObject, undefines the ellipsoid associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the ellipsoid from.
     *
     * @see CzmlDefaults
     */
    DynamicEllipsoid.undefineProperties = function(dynamicObject) {
        dynamicObject.ellipsoid = undefined;
    };

    return DynamicEllipsoid;
});

/*global define*/
define('DynamicScene/DynamicPolygon',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './DynamicProperty',
        './DynamicMaterialProperty'
    ], function(
         TimeInterval,
         defaultValue,
         CzmlBoolean,
         DynamicProperty,
         DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic polygon, typically used in conjunction with DynamicPolygonVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPolygon
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPolygonVisualizer
     * @see VisualizerCollection
     * @see Polygon
     * @see CzmlDefaults
     */
    var DynamicPolygon = function() {
        /**
         * A DynamicProperty of type CzmlBoolean which determines the polygon's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
        /**
         * A DynamicMaterialProperty which determines the polygon's material.
         * @type DynamicMaterialProperty
         */
        this.material = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's polygon.
     * If the DynamicObject does not have a polygon, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the polygon data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The collection into which objects are being loaded.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPolygon.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var polygonData = packet.polygon;
        if (typeof polygonData === 'undefined') {
            return false;
        }

        var polygonUpdated = false;
        var polygon = dynamicObject.polygon;
        polygonUpdated = typeof polygon === 'undefined';
        if (polygonUpdated) {
            dynamicObject.polygon = polygon = new DynamicPolygon();
        }

        var interval = polygonData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof polygonData.show !== 'undefined') {
            var show = polygon.show;
            if (typeof show === 'undefined') {
                polygon.show = show = new DynamicProperty(CzmlBoolean);
                polygonUpdated = true;
            }
            show.processCzmlIntervals(polygonData.show, interval);
        }

        if (typeof polygonData.material !== 'undefined') {
            var material = polygon.material;
            if (typeof material === 'undefined') {
                polygon.material = material = new DynamicMaterialProperty();
                polygonUpdated = true;
            }
            material.processCzmlIntervals(polygonData.material, interval, sourceUri);
        }
        return polygonUpdated;
    };

    /**
     * Given two DynamicObjects, takes the polygon properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPolygon.mergeProperties = function(targetObject, objectToMerge) {
        var polygonToMerge = objectToMerge.polygon;
        if (typeof polygonToMerge !== 'undefined') {

            var targetPolygon = targetObject.polygon;
            if (typeof targetPolygon === 'undefined') {
                targetObject.polygon = targetPolygon = new DynamicPolygon();
            }

            targetPolygon.show = defaultValue(targetPolygon.show, polygonToMerge.show);
            targetPolygon.material = defaultValue(targetPolygon.material, polygonToMerge.material);
        }
    };

    /**
     * Given a DynamicObject, undefines the polygon associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the polygon from.
     *
     * @see CzmlDefaults
     */
    DynamicPolygon.undefineProperties = function(dynamicObject) {
        dynamicObject.polygon = undefined;
    };

    return DynamicPolygon;
});
/*global define*/
define('DynamicScene/DynamicPyramid',[
        '../Core/TimeInterval',
        '../Core/defaultValue',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty',
        './DynamicDirectionsProperty',
        './DynamicMaterialProperty'
    ], function(
        TimeInterval,
        defaultValue,
        CzmlBoolean,
        CzmlNumber,
        CzmlColor,
        DynamicProperty,
        DynamicDirectionsProperty,
        DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic pyramid, typically used in conjunction with DynamicPyramidVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPyramid
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPyramidVisualizer
     * @see VisualizerCollection
     * @see CustomSensor
     * @see CzmlDefaults
     */
    var DynamicPyramid = function() {
        /**
         * A DynamicProperty of type CzmlBoolean which determines the pyramid's visibility.
         * @type DynamicProperty
         */
        this.show = undefined;
        /**
         * A DynamicDirectionsProperty which determines the projection of the pyramid.
         * @type DynamicDirectionsProperty
         */
        this.directions = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the pyramid's radius.
         * @type DynamicProperty
         */
        this.radius = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the pyramid's intersection visibility.
         * @type DynamicProperty
         */
        this.showIntersection = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the color of the line formed by the intersection of the pyramid and other central bodies.
         * @type DynamicProperty
         */
        this.intersectionColor = undefined;
        /**
         * A DynamicMaterialProperty which determines the material.
         * @type DynamicMaterialProperty
         */
        this.material = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's pyramid.
     * If the DynamicObject does not have a pyramid, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the pyramid data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObject} dynamicObjectCollection The DynamicObjectCollection to which the DynamicObject belongs.
     *
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPyramid.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection) {
        var pyramidData = packet.pyramid;
        if (typeof pyramidData === 'undefined') {
            return false;
        }

        var pyramidUpdated = false;
        var pyramid = dynamicObject.pyramid;
        pyramidUpdated = typeof pyramid === 'undefined';
        if (pyramidUpdated) {
            dynamicObject.pyramid = pyramid = new DynamicPyramid();
        }

        var interval = pyramidData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof pyramidData.show !== 'undefined') {
            var show = pyramid.show;
            if (typeof show === 'undefined') {
                pyramid.show = show = new DynamicProperty(CzmlBoolean);
                pyramidUpdated = true;
            }
            show.processCzmlIntervals(pyramidData.show, interval);
        }

        if (typeof pyramidData.radius !== 'undefined') {
            var radius = pyramid.radius;
            if (typeof radius === 'undefined') {
                pyramid.radius = radius = new DynamicProperty(CzmlNumber);
                pyramidUpdated = true;
            }
            radius.processCzmlIntervals(pyramidData.radius, interval);
        }

        if (typeof pyramidData.showIntersection !== 'undefined') {
            var showIntersection = pyramid.showIntersection;
            if (typeof showIntersection === 'undefined') {
                pyramid.showIntersection = showIntersection = new DynamicProperty(CzmlBoolean);
                pyramidUpdated = true;
            }
            showIntersection.processCzmlIntervals(pyramidData.showIntersection, interval);
        }

        if (typeof pyramidData.intersectionColor !== 'undefined') {
            var intersectionColor = pyramid.intersectionColor;
            if (typeof intersectionColor === 'undefined') {
                pyramid.intersectionColor = intersectionColor = new DynamicProperty(CzmlColor);
                pyramidUpdated = true;
            }
            intersectionColor.processCzmlIntervals(pyramidData.intersectionColor, interval);
        }

        if (typeof pyramidData.material !== 'undefined') {
            var material = pyramid.material;
            if (typeof material === 'undefined') {
                pyramid.material = material = new DynamicMaterialProperty();
                pyramidUpdated = true;
            }
            material.processCzmlIntervals(pyramidData.material, interval);
        }

        if (typeof pyramidData.directions !== 'undefined') {
            var directions = pyramid.directions;
            if (typeof directions === 'undefined') {
                pyramid.directions = directions = new DynamicDirectionsProperty();
                pyramidUpdated = true;
            }
            directions.processCzmlIntervals(pyramidData.directions, interval);
        }
        return pyramidUpdated;
    };

    /**
     * Given two DynamicObjects, takes the pyramid properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPyramid.mergeProperties = function(targetObject, objectToMerge) {
        var pyramidToMerge = objectToMerge.pyramid;
        if (typeof pyramidToMerge !== 'undefined') {

            var targetPyramid = targetObject.pyramid;
            if (typeof targetPyramid === 'undefined') {
                targetObject.pyramid = targetPyramid = new DynamicPyramid();
            }

            targetPyramid.show = defaultValue(targetPyramid.show, pyramidToMerge.show);
            targetPyramid.directions = defaultValue(targetPyramid.directions, pyramidToMerge.directions);
            targetPyramid.radius = defaultValue(targetPyramid.radius, pyramidToMerge.radius);
            targetPyramid.showIntersection = defaultValue(targetPyramid.showIntersection, pyramidToMerge.showIntersection);
            targetPyramid.intersectionColor = defaultValue(targetPyramid.intersectionColor, pyramidToMerge.intersectionColor);
            targetPyramid.material = defaultValue(targetPyramid.material, pyramidToMerge.material);
        }
    };

    /**
     * Given a DynamicObject, undefines the pyramid associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the pyramid from.
     *
     * @see CzmlDefaults
     */
    DynamicPyramid.undefineProperties = function(dynamicObject) {
        dynamicObject.pyramid = undefined;
    };

    return DynamicPyramid;
});

/*global define*/
define('Scene/ComplexConicSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Core/BoxTessellator',
        '../Core/BoundingSphere',
        '../Renderer/BufferUsage',
        '../Renderer/CommandLists',
        '../Renderer/CullFace',
        '../Renderer/DrawCommand',
        '../Renderer/BlendingState',
        './Material',
        '../Shaders/Noise',
        '../Shaders/Ray',
        '../Shaders/ConstructiveSolidGeometry',
        '../Shaders/SensorVolume',
        '../Shaders/ComplexConicSensorVolumeVS',
        '../Shaders/ComplexConicSensorVolumeFS',
        './SceneMode'
    ], function(
        DeveloperError,
        Color,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BoxTessellator,
        BoundingSphere,
        BufferUsage,
        CommandLists,
        CullFace,
        DrawCommand,
        BlendingState,
        Material,
        ShadersNoise,
        ShadersRay,
        ShadersConstructiveSolidGeometry,
        ShadersSensorVolume,
        ComplexConicSensorVolumeVS,
        ComplexConicSensorVolumeFS,
        SceneMode) {
    

    var attributeIndices = {
        position : 0
    };

    /**
     * DOC_TBA
     *
     * @alias ComplexConicSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addComplexConic
     */
    var ComplexConicSensorVolume = function(template) {
        var t = template || {};

        this._pickId = undefined;

        this._colorCommand = new DrawCommand();
        this._pickCommand = new DrawCommand();
        this._commandLists = new CommandLists();

        this._colorCommand.primitiveType = this._pickCommand.primitiveType = PrimitiveType.TRIANGLES;
        this._colorCommand.boundingVolume = this._pickCommand.boundingVolume = new BoundingSphere();

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * When <code>true</code>, a polyline is shown where the sensor outline intersections the central body.  The default is <code>true</code>.
         *
         * @type Boolean
         *
         * @see ComplexConicSensorVolume#intersectionColor
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Minimum and maximum clock
         * angles are measured from the x-axis.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link czm_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/ComplexConicSensorVolume.setModelMatrix.png' width='400' height='258' /><br />
         * Model coordinate system for a conic sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see czm_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's cone opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY.clone();

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#outerHalfAngle
         */
        this.innerHalfAngle = (typeof t.innerHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.innerHalfAngle;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.outerHalfAngle = (typeof t.outerHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.outerHalfAngle;
        this._outerHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.maximumClockAngle = (typeof t.maximumClockAngle === 'undefined') ? Math.PI : t.maximumClockAngle;
        this._maximumClockAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.minimumClockAngle = (typeof t.minimumClockAngle === 'undefined') ? -Math.PI : t.minimumClockAngle;
        this._minimumClockAnglee = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;
        this._radius = undefined;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.minimumClockAngle = (typeof t.minimumClockAngle === 'undefined') ? (-Math.PI / 4.0) : t.minimumClockAngle;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.maximumClockAngle = (typeof t.maximumClockAngle === 'undefined') ? (Math.PI / 4.0) : t.maximumClockAngle;

        /**
         * DOC_TBA
         */
        this.outerMaterial = (typeof t.outerMaterial !== 'undefined') ? t.outerMaterial : Material.fromType(undefined, Material.ColorType);
        this._outerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.innerMaterial = (typeof t.innerMaterial !== 'undefined') ? t.innerMaterial : Material.fromType(undefined, Material.ColorType);
        this._innerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.capMaterial = (typeof t.capMaterial !== 'undefined') ? t.capMaterial : Material.fromType(undefined, Material.ColorType);
        this._capMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.silhouetteMaterial = (typeof t.silhouetteMaterial !== 'undefined') ? t.silhouetteMaterial : Material.fromType(undefined, Material.ColorType);
        this._silhouetteMaterial = undefined;

        /**
         * The color of the polyline where the sensor outline intersects the central body.  The default is {@link Color.WHITE}.
         *
         * @type Color
         *
         * @see ComplexConicSensorVolume#showIntersection
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : Color.clone(Color.WHITE);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_sensorRadius : function() {
                return isFinite(that.radius) ? that.radius : FAR;
            },
            u_outerHalfAngle : function() {
                return that.outerHalfAngle;
            },
            u_innerHalfAngle : function() {
                return that.innerHalfAngle;
            },
            u_maximumClockAngle : function() {
                return that.maximumClockAngle;
            },
            u_minimumClockAngle : function() {
                return that.minimumClockAngle;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };
        this._mode = SceneMode.SCENE3D;
    };

    ComplexConicSensorVolume.prototype._getBoundingVolume = function() {
        var r = isFinite(this.radius) ? this.radius : FAR;

        var mesh;
        var minimumCorner;
        var maximumCorner;
        if (this.outerHalfAngle <= CesiumMath.toRadians(45.0)) {
            // Bound sensor with a frustum
            var l = Math.tan(this.outerHalfAngle) * r;

            var positions = [
                Cartesian3.ZERO,           // Sensor vertex
                new Cartesian3(l, -l, r),  // Sensor cap: ( x, -y)
                new Cartesian3(l, l, r),   // Sensor cap: ( x,  y)
                new Cartesian3(-l, l, r),  // Sensor cap: (-x,  y)
                new Cartesian3(-l, -l, r)  // Sensor cap: (-x, -y)
            ];

            var values = [];
            for (var i = 0; i < positions.length; ++i) {
                values.push(positions[i].x, positions[i].y, positions[i].z);
            }

            mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : values
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [
                              0, 1, 4, // bottom side
                              0, 4, 3, // left side
                              0, 3, 2, // top side
                              0, 2, 1, // right side
                              1, 2, 3, // top
                              1, 3, 4
                          ]
                }]
            };

            BoundingSphere.fromPoints(positions, this._colorCommand.boundingVolume);
        } else if (this.outerHalfAngle <= CesiumMath.toRadians(90.0)) {
         // Bound sensor with box in the +z half-space
            minimumCorner = new Cartesian3(-r, -r, 0.0);
            maximumCorner = new Cartesian3(r, r, r);

            mesh = BoxTessellator.compute({
                minimumCorner : minimumCorner,
                maximumCorner : maximumCorner
            });

            BoundingSphere.fromPoints([minimumCorner, maximumCorner], this._colorCommand.boundingVolume);
        } else {
            // Bound sensor with box
            minimumCorner = new Cartesian3(-r, -r, -r);
            maximumCorner = new Cartesian3(r, r, r);

            mesh = BoxTessellator.compute({
                minimumCorner : minimumCorner,
                maximumCorner : maximumCorner
            });

            BoundingSphere.fromPoints([minimumCorner, maximumCorner], this._colorCommand.boundingVolume);
        }

        return mesh;
    };

    ComplexConicSensorVolume.prototype._combineMaterials = function() {
        // On older/mobile hardware, we could do one pass per material to avoid
        // going over the maximum uniform limit

        var materials = {
            'czm_getOuterMaterial' : this.outerMaterial,
            'czm_getInnerMaterial' : this.innerMaterial,
            'czm_getCapMaterial' : this.capMaterial,
            'czm_getSilhouetteMaterial' : this.silhouetteMaterial
        };

        var combinedUniforms = {};
        var concatenatedSource = '';
        for (var materialId in materials) {
            if (materials.hasOwnProperty(materialId)) {
                var material = materials[materialId];
                var materialSource = material.shaderSource.replace(/czm_getMaterial/g, materialId);
                var materialUniforms = material._uniforms;
                for (var uniformName in materialUniforms) {
                    if (materialUniforms.hasOwnProperty(uniformName)) {
                        var count = 1;
                        var newUniformName = uniformName;
                        while (combinedUniforms.hasOwnProperty(newUniformName)) {
                            newUniformName = uniformName + count;
                            count += 1;
                        }
                        materialSource = materialSource.replace(new RegExp(uniformName, 'g'), newUniformName);
                        combinedUniforms[newUniformName] = materialUniforms[uniformName];
                    }
                }
                concatenatedSource += materialSource;
            }
        }
        return {
            _uniforms : combinedUniforms,
            shaderSource : concatenatedSource
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof ComplexConicSensorVolume
     *
     * @exception {DeveloperError} this.innerHalfAngle cannot be greater than this.outerHalfAngle.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     * @exception {DeveloperError} this.outerMaterial must be defined.
     * @exception {DeveloperError} this.innerMaterial must be defined.
     * @exception {DeveloperError} this.capMaterial must be defined.
     * @exception {DeveloperError} this.silhouetteMaterial must be defined.
     */
    ComplexConicSensorVolume.prototype.update = function(context, frameState, commandList) {
        this._mode = frameState.mode;
        if (!this.show || this._mode !== SceneMode.SCENE3D) {
            return;
        }

        if (this.innerHalfAngle > this.outerHalfAngle) {
            throw new DeveloperError('this.innerHalfAngle cannot be greater than this.outerHalfAngle.');
        }

        if (this.radius < 0.0) {
            throw new DeveloperError('this.radius must be greater than or equal to zero.');
        }

        if (typeof this.outerMaterial === 'undefined') {
            throw new DeveloperError('this.outerMaterial must be defined.');
        }

        if (typeof this.innerMaterial === 'undefined') {
            throw new DeveloperError('this.innerMaterial must be defined.');
        }

        if (typeof this.capMaterial === 'undefined') {
            throw new DeveloperError('this.capMaterial must be defined.');
        }

        if (typeof this.silhouetteMaterial === 'undefined') {
            throw new DeveloperError('this.silhouetteMaterial must be defined.');
        }

        // Recreate vertex array when proxy geometry needs to change
        if ((this._outerHalfAngle !== this.outerHalfAngle) || (this._radius !== this.radius)) {
            this._outerHalfAngle = this.outerHalfAngle;
            this._radius = this.radius;

            this._colorCommand.vertexArray = this._pickCommand.vertexArray = context.createVertexArrayFromMesh({
                mesh : this._getBoundingVolume(),
                attributeIndices : attributeIndices,
                bufferUsage : BufferUsage.STATIC_DRAW
            });
        }

        if (typeof this._colorCommand.renderState === 'undefined') {
            this._colorCommand.renderState = this._pickCommand.renderState = context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                },
                blending : BlendingState.ALPHA_BLEND
               // Does not read or write depth
            });
        }

        var pass = frameState.passes;
        this._colorCommand.modelMatrix = this._colorCommand.modelMatrix = this.modelMatrix;

        this._commandLists.removeAll();
        if (pass.color) {
            var outerChanged = this._outerMaterial !== this.outerMaterial;
            var innerChanged = this._innerMaterial !== this.innerMaterial;
            var capChanged = this._capMaterial !== this.capMaterial;
            var silhouetteChanged = this._silhouetteMaterial !== this.silhouetteMaterial;
            var materialChanged = outerChanged || innerChanged || capChanged || silhouetteChanged;

            if (materialChanged) {
                this._outerMaterial = this.outerMaterial;
                this._innerMaterial = this.innerMaterial;
                this._capMaterial = this.capMaterial;
                this._silhouetteMaterial = this.silhouetteMaterial;

                var material = this._combineMaterials();
                this._colorCommand.uniformMap = combine([this._uniforms, material._uniforms], false, false);

                var fsSource =
                    '#line 0\n' +
                    ShadersNoise +
                    '#line 0\n' +
                    ShadersRay +
                    '#line 0\n' +
                    ShadersConstructiveSolidGeometry +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    material.shaderSource +
                    '#line 0\n' +
                    ComplexConicSensorVolumeFS;

                this._colorCommand.shaderProgram = this._colorCommand.shaderProgram && this._colorCommand.shaderProgram.release();
                this._colorCommand.shaderProgram = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsSource, attributeIndices);
            }

            this._commandLists.colorList.push(this._colorCommand);
        }

        if (pass.pick) {
            if (typeof this._pickId === 'undefined') {
                // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
                var fsPickSource =
                    '#define RENDER_FOR_PICK 1\n' +
                    '#line 0\n' +
                    ShadersRay +
                    '#line 0\n' +
                    ShadersConstructiveSolidGeometry +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    ComplexConicSensorVolumeFS;

                this._pickCommand.shaderProgram = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsPickSource, attributeIndices);
                this._pickId = context.createPickId(this);

                var that = this;
                this._pickCommand.uniformMap = combine([this._uniforms, {
                    u_pickColor : function() {
                        return that._pickId.normalizedRgba;
                    }
                }], false, false);
            }

            this._commandLists.pickList.push(this._pickCommand);
        }

        if (!this._commandLists.empty()) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.destroy = function() {
        this._colorCommand.vertexArray = this._colorCommand.vertexArray && this._colorCommand.vertexArray.destroy();
        this._colorCommand.shaderProgram = this._colorCommand.shaderProgram && this._colorCommand.shaderProgram.release();
        this._pickCommand.shaderProgram = this._pickCommand.shaderProgram && this._pickCommand.shaderProgram.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return ComplexConicSensorVolume;
});

/*global define*/
define('DynamicScene/DynamicConeVisualizer',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Math',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Scene/ComplexConicSensorVolume',
        '../Scene/Material'
       ], function(
         defaultValue,
         DeveloperError,
         destroyObject,
         Color,
         CesiumMath,
         Matrix3,
         Matrix4,
         ComplexConicSensorVolume,
         Material) {
    

    var matrix3Scratch = new Matrix3();

    /**
     * A DynamicObject visualizer which maps the DynamicCone instance
     * in DynamicObject.cone to a ComplexConicSensor primitive.
     * @alias DynamicConeVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicCone
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizerUsingCustomSensor
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicConeVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }

        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._coneCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicConeVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicConeVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicConeVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicConeVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicConeVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicConeVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicConeVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._coneCollection.length; i < len; i++) {
            this._primitives.remove(this._coneCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._coneVisualizerIndex = undefined;
            }
        }
        this._unusedIndexes = [];
        this._coneCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicConeVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicConeVisualizer#destroy
     */
    DynamicConeVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicConeVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicConeVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicConeVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    var intersectionColor;
    DynamicConeVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var context = this._scene.getContext();
        var dynamicCone = dynamicObject.cone;
        if (typeof dynamicCone === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var cone;
        var showProperty = dynamicCone.show;
        var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof coneVisualizerIndex !== 'undefined') {
                cone = this._coneCollection[coneVisualizerIndex];
                cone.show = false;
                dynamicObject._coneVisualizerIndex = undefined;
                this._unusedIndexes.push(coneVisualizerIndex);
            }
            return;
        }

        if (typeof coneVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                coneVisualizerIndex = unusedIndexes.pop();
                cone = this._coneCollection[coneVisualizerIndex];
            } else {
                coneVisualizerIndex = this._coneCollection.length;
                cone = new ComplexConicSensorVolume();
                this._coneCollection.push(cone);
                this._primitives.add(cone);
            }
            dynamicObject._coneVisualizerIndex = coneVisualizerIndex;
            cone.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            cone.capMaterial = Material.fromType(context, Material.ColorType);
            cone.innerHalfAngle = 0;
            cone.outerHalfAngle = Math.PI;
            cone.innerMaterial = Material.fromType(context, Material.ColorType);
            cone.intersectionColor = Color.YELLOW;
            cone.maximumClockAngle =  CesiumMath.TWO_PI;
            cone.minimumClockAngle = 0;
            cone.outerMaterial = Material.fromType(context, Material.ColorType);
            cone.radius = Number.POSITIVE_INFINITY;
            cone.showIntersection = true;
            cone.silhouetteMaterial = Material.fromType(context, Material.ColorType);
        } else {
            cone = this._coneCollection[coneVisualizerIndex];
        }

        cone.show = true;
        var property = dynamicCone.minimumClockAngle;
        if (typeof property !== 'undefined') {
            var minimumClockAngle = property.getValue(time);
            if (typeof minimumClockAngle !== 'undefined') {
                cone.minimumClockAngle = minimumClockAngle;
            }
        }

        property = dynamicCone.maximumClockAngle;
        if (typeof property !== 'undefined') {
            var maximumClockAngle = property.getValue(time);
            if (typeof maximumClockAngle !== 'undefined') {
                cone.maximumClockAngle = maximumClockAngle;
            } else {
                cone.maximumClockAngle = CesiumMath.TWO_PI;
            }
        }

        property = dynamicCone.innerHalfAngle;
        if (typeof property !== 'undefined') {
            var innerHalfAngle = property.getValue(time);
            if (typeof innerHalfAngle !== 'undefined') {
                cone.innerHalfAngle = innerHalfAngle;
            }
        }

        property = dynamicCone.outerHalfAngle;
        if (typeof property !== 'undefined') {
            var outerHalfAngle = property.getValue(time);
            if (typeof outerHalfAngle !== 'undefined') {
                cone.outerHalfAngle = outerHalfAngle;
            } else {
                cone.outerHalfAngle = Math.PI;
            }
        }

        property = dynamicCone.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time);
            if (typeof radius !== 'undefined') {
                cone.radius = radius;
            }
        }

        position = defaultValue(positionProperty.getValueCartesian(time, position), cone._visualizerPosition);
        orientation = defaultValue(orientationProperty.getValue(time, orientation), cone._visualizerOrientation);

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(cone._visualizerPosition) ||
             !orientation.equals(cone._visualizerOrientation))) {
            Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, cone.modelMatrix);
            position.clone(cone._visualizerPosition);
            orientation.clone(cone._visualizerOrientation);
        }

        var material = dynamicCone.capMaterial;
        if (typeof material !== 'undefined') {
            cone.capMaterial = material.getValue(time, context, cone.capMaterial);
        }

        material = dynamicCone.innerMaterial;
        if (typeof material !== 'undefined') {
            cone.innerMaterial = material.getValue(time, context, cone.innerMaterial);
        }

        material = dynamicCone.outerMaterial;
        if (typeof material !== 'undefined') {
            cone.outerMaterial = material.getValue(time, context, cone.outerMaterial);
        }

        material = dynamicCone.silhouetteMaterial;
        if (typeof material !== 'undefined') {
            cone.silhouetteMaterial = material.getValue(time, context, cone.silhouetteMaterial);
        }

        property = dynamicCone.intersectionColor;
        if (typeof property !== 'undefined') {
            intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                cone.intersectionColor = intersectionColor;
            }
        }
    };

    DynamicConeVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisConeCollection = this._coneCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
            if (typeof coneVisualizerIndex !== 'undefined') {
                var cone = thisConeCollection[coneVisualizerIndex];
                cone.show = false;
                thisUnusedIndexes.push(coneVisualizerIndex);
                dynamicObject._coneVisualizerIndex = undefined;
            }
        }
    };

    return DynamicConeVisualizer;
});

/*global define*/
define('Scene/CustomSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Core/BoundingSphere',
        '../Renderer/BufferUsage',
        '../Renderer/BlendingState',
        '../Renderer/CommandLists',
        '../Renderer/DrawCommand',
        './Material',
        '../Shaders/Noise',
        '../Shaders/SensorVolume',
        '../Shaders/CustomSensorVolumeVS',
        '../Shaders/CustomSensorVolumeFS',
        './SceneMode'
    ], function(
        DeveloperError,
        Color,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BoundingSphere,
        BufferUsage,
        BlendingState,
        CommandLists,
        DrawCommand,
        Material,
        ShadersNoise,
        ShadersSensorVolume,
        CustomSensorVolumeVS,
        CustomSensorVolumeFS,
        SceneMode) {
    

    var attributeIndices = {
        position : 0,
        normal : 1
    };

    /**
     * DOC_TBA
     *
     * @alias CustomSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addCustom
     */
    var CustomSensorVolume = function(template) {
        var t = template || {};

        this._pickId = undefined;
        this._pickIdThis = t._pickIdThis || this;

        this._colorCommand = new DrawCommand();
        this._pickCommand = new DrawCommand();
        this._commandLists = new CommandLists();

        this._colorCommand.primitiveType = this._pickCommand.primitiveType = PrimitiveType.TRIANGLES;
        this._colorCommand.boundingVolume = this._pickCommand.boundingVolume = new BoundingSphere();

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * When <code>true</code>, a polyline is shown where the sensor outline intersections the central body.  The default is <code>true</code>.
         *
         * @type Boolean
         *
         * @see CustomSensorVolume#intersectionColor
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * <p>
         * Determines if a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out
         * to the other side, or if the part of the sensor intersecting the ellipsoid stops at the ellipsoid.
         * </p>
         * <p>
         * The default is <code>false</code>, meaning the sensor will not go through the ellipsoid.
         * </p>
         *
         * @type Boolean
         */
        this.showThroughEllipsoid = (typeof t.showThroughEllipsoid === 'undefined') ? false : t.showThroughEllipsoid;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  The clock angle, sometimes
         * called azimuth, is the angle in the sensor's X-Y plane measured from the positive X-axis toward the positive
         * Y-axis.  The cone angle, sometimes called elevation, is the angle out of the X-Y plane along the positive Z-axis.
         * This matrix is available to GLSL vertex and fragment shaders via
         * {@link czm_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/CustomSensorVolume.setModelMatrix.png' /><br />
         * Model coordinate system for a custom sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see czm_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY.clone();

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;
        this._bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;

        this._directions = undefined;
        this._directionsDirty = false;
        this.setDirections(t.directions);

        /**
         * The surface appearance of the sensor.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
         * <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>.
         * <p>
         * The default material is <code>Material.ColorType</code>.
         * </p>
         *
         * @type Material
         *
         * @example
         * // 1. Change the color of the default material to yellow
         * sensor.material.uniforms.color = new Color(1.0, 1.0, 0.0, 1.0);
         *
         * // 2. Change material to horizontal stripes
         * sensor.material = Material.fromType(scene.getContext(), Material.StripeType);
         *
         * @see <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>
         */
        this.material = (typeof t.material !== 'undefined') ? t.material : Material.fromType(undefined, Material.ColorType);
        this._material = undefined;

        /**
         * The color of the polyline where the sensor outline intersects the central body.  The default is {@link Color.WHITE}.
         *
         * @type Color
         *
         * @see CustomSensorVolume#showIntersection
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : Color.clone(Color.WHITE);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_showThroughEllipsoid : function() {
                return that.showThroughEllipsoid;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_sensorRadius : function() {
                return isFinite(that.radius) ? that.radius : FAR;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };

        this._mode = SceneMode.SCENE3D;
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#getDirections
     */
    CustomSensorVolume.prototype.setDirections = function(directions) {
        this._directions = directions;
        this._directionsDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#setDirections
     */
    CustomSensorVolume.prototype.getDirections = function() {
        return this._directions;
    };

    CustomSensorVolume.prototype._computePositions = function() {
        var directions = this._directions;
        var length = directions.length;
        var positions = new Float32Array(3 * length);
        var r = isFinite(this.radius) ? this.radius : FAR;

        var boundingVolumePositions = [Cartesian3.ZERO];

        for ( var i = length - 2, j = length - 1, k = 0; k < length; i = j++, j = k++) {
            // PERFORMANCE_IDEA:  We can avoid redundant operations for adjacent edges.
            var n0 = Cartesian3.fromSpherical(directions[i]);
            var n1 = Cartesian3.fromSpherical(directions[j]);
            var n2 = Cartesian3.fromSpherical(directions[k]);

            // Extend position so the volume encompasses the sensor's radius.
            var theta = Math.max(Cartesian3.angleBetween(n0, n1), Cartesian3.angleBetween(n1, n2));
            var distance = r / Math.cos(theta * 0.5);
            var p = n1.multiplyByScalar(distance);

            positions[(j * 3) + 0] = p.x;
            positions[(j * 3) + 1] = p.y;
            positions[(j * 3) + 2] = p.z;

            boundingVolumePositions.push(p);
        }

        BoundingSphere.fromPoints(boundingVolumePositions, this._colorCommand.boundingVolume);

        return positions;
    };

    CustomSensorVolume.prototype._createVertexArray = function(context) {
        var positions = this._computePositions();

        var length = this._directions.length;
        var vertices = new Float32Array(2 * 3 * 3 * length);

        var k = 0;
        for ( var i = length - 1, j = 0; j < length; i = j++) {
            var p0 = new Cartesian3(positions[(i * 3) + 0], positions[(i * 3) + 1], positions[(i * 3) + 2]);
            var p1 = new Cartesian3(positions[(j * 3) + 0], positions[(j * 3) + 1], positions[(j * 3) + 2]);
            var n = p1.cross(p0).normalize(); // Per-face normals

            vertices[k++] = 0.0; // Sensor vertex
            vertices[k++] = 0.0;
            vertices[k++] = 0.0;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p1.x;
            vertices[k++] = p1.y;
            vertices[k++] = p1.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p0.x;
            vertices[k++] = p0.y;
            vertices[k++] = p0.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;
        }

        var vertexBuffer = context.createVertexBuffer(new Float32Array(vertices), this.bufferUsage);
        var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

        var attributes = [{
            index : attributeIndices.position,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 0,
            strideInBytes : stride
        }, {
            index : attributeIndices.normal,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 3 * Float32Array.BYTES_PER_ELEMENT,
            strideInBytes : stride
        }];

        return context.createVertexArray(attributes);
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     * @exception {DeveloperError} this.material must be defined.
     */
    CustomSensorVolume.prototype.update = function(context, frameState, commandList) {
        this._mode = frameState.mode;
        if (!this.show || this._mode !== SceneMode.SCENE3D) {
            return;
        }

        if (this.radius < 0.0) {
            throw new DeveloperError('this.radius must be greater than or equal to zero.');
        }

        if (typeof this.material === 'undefined') {
            throw new DeveloperError('this.material must be defined.');
        }

        // Initial render state creation
        if (typeof this._colorCommand.renderState === 'undefined') {
            this._colorCommand.renderState = this._pickCommand.renderState = context.createRenderState({
                depthTest : {
                    enabled : true
                },
                depthMask : false,
                blending : BlendingState.ALPHA_BLEND
            });
        }
        // This would be better served by depth testing with a depth buffer that does not
        // include the ellipsoid depth - or a g-buffer containing an ellipsoid mask
        // so we can selectively depth test.
        this._colorCommand.renderState.depthTest.enabled = !this.showThroughEllipsoid;

        // Recreate vertex buffer when directions change
        if ((this._directionsDirty) || (this._bufferUsage !== this.bufferUsage)) {
            this._directionsDirty = false;
            this._bufferUsage = this.bufferUsage;
            this._va = this._va && this._va.destroy();

            var directions = this._directions;
            if (directions && (directions.length >= 3)) {
                this._colorCommand.vertexArray = this._pickCommand.vertexArray = this._createVertexArray(context);
            }
        }

        if (typeof this._colorCommand.vertexArray === 'undefined') {
            return;
        }

        var pass = frameState.passes;
        this._colorCommand.modelMatrix = this._pickCommand.modelMatrix = this.modelMatrix;
        this._commandLists.removeAll();

        if (pass.color) {
            var materialChanged = typeof this._material === 'undefined' ||
                this._material !== this.material;

            // Recompile shader when material changes
            if (materialChanged) {
                this._material = this.material;

                var fsSource =
                    '#line 0\n' +
                    ShadersNoise +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    this._material.shaderSource +
                    '#line 0\n' +
                    CustomSensorVolumeFS;

                this._colorCommand.shaderProgram = this._colorCommand.shaderProgram && this._colorCommand.shaderProgram.release();
                this._colorCommand.shaderProgram = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsSource, attributeIndices);

                this._colorCommand.uniformMap = combine([this._uniforms, this._material._uniforms], false, false);
            }

            this._commandLists.colorList.push(this._colorCommand);
        }

        if (pass.pick) {
            if (typeof this._pickId === 'undefined') {
                // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
                var fsPickSource =
                    '#define RENDER_FOR_PICK 1\n' +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    CustomSensorVolumeFS;

                this._pickCommand.shaderProgram = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsPickSource, attributeIndices);
                this._pickId = context.createPickId(this._pickIdThis);

                var that = this;
                this._pickCommand.uniformMap = combine([this._uniforms, {
                    u_pickColor : function() {
                        return that._pickId.normalizedRgba;
                    }
                }], false, false);
            }

            this._commandLists.pickList.push(this._pickCommand);
        }

        if (!this._commandLists.empty()) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.destroy = function() {
        this._colorCommand.vertexArray = this._colorCommand.vertexArray && this._colorCommand.vertexArray.destroy();
        this._colorCommand.shaderProgram = this._colorCommand.shaderProgram && this._colorCommand.shaderProgram.release();
        this._pickCommand.shaderProgram = this._pickCommand.shaderProgram && this._pickCommand.shaderProgram.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return CustomSensorVolume;
});

/*global define*/
define('DynamicScene/DynamicConeVisualizerUsingCustomSensor',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Math',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Core/Spherical',
        '../Scene/CustomSensorVolume',
        '../Scene/Material'
       ], function(
         defaultValue,
         DeveloperError,
         destroyObject,
         Color,
         CesiumMath,
         Matrix3,
         Matrix4,
         Spherical,
         CustomSensorVolume,
         Material) {
    

    //CZML_TODO DynamicConeVisualizerUsingCustomSensor is a temporary workaround
    //because ComplexConicSensor has major performance issues.  As soon as
    //ComplexConicSensor is working, this class can be deleted and
    //DynamicConeVisualizer is a drop in replacement that already does things
    //"the right way".

    var matrix3Scratch = new Matrix3();

    function assignSpherical(index, array, clock, cone) {
        var spherical = array[index];
        if (typeof spherical === 'undefined') {
            array[index] = spherical = new Spherical();
        }
        spherical.clock = clock;
        spherical.cone = cone;
        spherical.magnitude = 1.0;
    }

    function computeDirections(minimumClockAngle, maximumClockAngle, innerHalfAngle, outerHalfAngle, result) {
        var angle;
        var i = 0;
        var angleStep = CesiumMath.toRadians(2.0);
        if (minimumClockAngle === 0.0 && maximumClockAngle === CesiumMath.TWO_PI) {
            // No clock angle limits, so this is just a circle.
            // There might be a hole but we're ignoring it for now.
            for (angle = 0.0; angle < CesiumMath.TWO_PI; angle += angleStep) {
                assignSpherical(i++, result, angle, outerHalfAngle);
            }
        } else {
            // There are clock angle limits.
            for (angle = minimumClockAngle; angle < maximumClockAngle; angle += angleStep) {
                assignSpherical(i++, result, angle, outerHalfAngle);
            }
            assignSpherical(i++, result, maximumClockAngle, outerHalfAngle);
            if (innerHalfAngle) {
                for (angle = maximumClockAngle; angle > minimumClockAngle; angle -= angleStep) {
                    assignSpherical(i++, result, angle, innerHalfAngle);
                }
                assignSpherical(i++, result, minimumClockAngle, innerHalfAngle);
            } else {
                assignSpherical(i++, result, maximumClockAngle, 0.0);
            }
        }
        result.length = i;
        return result;
    }

    /**
     * A DynamicObject visualizer which maps the DynamicCone instance
     * in DynamicObject.cone to a CustomSensor primitive.
     * @alias DynamicConeVisualizerUsingCustomSensor
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicCone
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicConeVisualizerUsingCustomSensor = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._coneCollection = [];
        this._dynamicObjectCollection = undefined;
        this._directionsScratch = [];
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._coneCollection.length; i < len; i++) {
            this._primitives.remove(this._coneCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._coneVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._coneCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicConeVisualizerUsingCustomSensor
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicConeVisualizerUsingCustomSensor#destroy
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicConeVisualizerUsingCustomSensor
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicConeVisualizerUsingCustomSensor#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    var intersectionColor;
    DynamicConeVisualizerUsingCustomSensor.prototype._updateObject = function(time, dynamicObject) {
        var context = this._scene.getContext();
        var dynamicCone = dynamicObject.cone;
        if (typeof dynamicCone === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var cone;
        var showProperty = dynamicCone.show;
        var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof coneVisualizerIndex !== 'undefined') {
                cone = this._coneCollection[coneVisualizerIndex];
                cone.show = false;
                dynamicObject._coneVisualizerIndex = undefined;
                this._unusedIndexes.push(coneVisualizerIndex);
            }
            return;
        }

        if (typeof coneVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                coneVisualizerIndex = unusedIndexes.pop();
                cone = this._coneCollection[coneVisualizerIndex];
            } else {
                coneVisualizerIndex = this._coneCollection.length;
                cone = new CustomSensorVolume();
                this._coneCollection.push(cone);
                this._primitives.add(cone);
            }
            dynamicObject._coneVisualizerIndex = coneVisualizerIndex;
            cone.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            cone.material = Material.fromType(context, Material.ColorType);
            cone.intersectionColor = Color.YELLOW;
            cone.radius = Number.POSITIVE_INFINITY;
            cone.showIntersection = true;
        } else {
            cone = this._coneCollection[coneVisualizerIndex];
        }

        cone.show = true;

        var minimumClockAngle;
        var property = dynamicCone.minimumClockAngle;
        if (typeof property !== 'undefined') {
            minimumClockAngle = property.getValue(time);
        }
        if (typeof minimumClockAngle === 'undefined') {
            minimumClockAngle = 0;
        }

        var maximumClockAngle;
        property = dynamicCone.maximumClockAngle;
        if (typeof property !== 'undefined') {
            maximumClockAngle = property.getValue(time);
        }
        if (typeof maximumClockAngle === 'undefined') {
            maximumClockAngle = CesiumMath.TWO_PI;
        }

        var innerHalfAngle;
        property = dynamicCone.innerHalfAngle;
        if (typeof property !== 'undefined') {
            innerHalfAngle = property.getValue(time);
        }
        if (typeof innerHalfAngle === 'undefined') {
            innerHalfAngle = 0;
        }

        var outerHalfAngle;
        property = dynamicCone.outerHalfAngle;
        if (typeof property !== 'undefined') {
            outerHalfAngle = property.getValue(time);
        }
        if (typeof outerHalfAngle === 'undefined') {
            outerHalfAngle = Math.PI;
        }

        if (minimumClockAngle !== cone.minimumClockAngle ||
            maximumClockAngle !== cone.maximumClockAngle ||
            innerHalfAngle !== cone.innerHalfAngle ||
            outerHalfAngle !== cone.outerHalfAngle) {
            cone.setDirections(computeDirections(minimumClockAngle, maximumClockAngle, innerHalfAngle, outerHalfAngle, this._directionsScratch));
            cone.innerHalfAngle = innerHalfAngle;
            cone.maximumClockAngle = maximumClockAngle;
            cone.outerHalfAngle = outerHalfAngle;
            cone.minimumClockAngle = minimumClockAngle;
        }

        property = dynamicCone.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time);
            if (typeof radius !== 'undefined') {
                cone.radius = radius;
            }
        }

        position = defaultValue(positionProperty.getValueCartesian(time, position), cone._visualizerPosition);
        orientation = defaultValue(orientationProperty.getValue(time, orientation), cone._visualizerOrientation);

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(cone._visualizerPosition) ||
             !orientation.equals(cone._visualizerOrientation))) {
            Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, cone.modelMatrix);
            position.clone(cone._visualizerPosition);
            orientation.clone(cone._visualizerOrientation);
        }

        var material = dynamicCone.outerMaterial;
        if (typeof material !== 'undefined') {
            cone.material = material.getValue(time, context, cone.material);
        }

        property = dynamicCone.intersectionColor;
        if (typeof property !== 'undefined') {
            intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                cone.intersectionColor = intersectionColor;
            }
        }
    };

    DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisConeCollection = this._coneCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
            if (typeof coneVisualizerIndex !== 'undefined') {
                var cone = thisConeCollection[coneVisualizerIndex];
                cone.show = false;
                thisUnusedIndexes.push(coneVisualizerIndex);
                dynamicObject._coneVisualizerIndex = undefined;
            }
        }
    };

    return DynamicConeVisualizerUsingCustomSensor;
});

/*global define*/
define('DynamicScene/DynamicPyramidVisualizer',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Scene/CustomSensorVolume',
        '../Scene/Material'
       ], function(
         defaultValue,
         DeveloperError,
         destroyObject,
         Color,
         Matrix3,
         Matrix4,
         CustomSensorVolume,
         Material) {
    

    var matrix3Scratch = new Matrix3();

    /**
     * A DynamicObject visualizer which maps the DynamicPyramid instance
     * in DynamicObject.pyramid to a Pyramid primitive.
     * @alias DynamicPyramidVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPyramid
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     *
     */
    var DynamicPyramidVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._pyramidCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPyramidVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPyramidVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPyramidVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPyramidVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPyramidVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPyramidVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPyramidVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._pyramidCollection.length; i < len; i++) {
            this._primitives.remove(this._pyramidCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._pyramidVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._pyramidCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPyramidVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPyramidVisualizer#destroy
     */
    DynamicPyramidVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPyramidVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPyramidVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPyramidVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    DynamicPyramidVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var context = this._scene.getContext();
        var dynamicPyramid = dynamicObject.pyramid;
        if (typeof dynamicPyramid === 'undefined') {
            return;
        }

        var directionsProperty = dynamicPyramid.directions;
        if (typeof directionsProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var pyramid;
        var showProperty = dynamicPyramid.show;
        var pyramidVisualizerIndex = dynamicObject._pyramidVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof pyramidVisualizerIndex !== 'undefined') {
                pyramid = this._pyramidCollection[pyramidVisualizerIndex];
                pyramid.show = false;
                dynamicObject._pyramidVisualizerIndex = undefined;
                this._unusedIndexes.push(pyramidVisualizerIndex);
            }
            return;
        }

        if (typeof pyramidVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                pyramidVisualizerIndex = unusedIndexes.pop();
                pyramid = this._pyramidCollection[pyramidVisualizerIndex];
            } else {
                pyramidVisualizerIndex = this._pyramidCollection.length;
                pyramid = new CustomSensorVolume();

                this._pyramidCollection.push(pyramid);
                this._primitives.add(pyramid);
            }
            dynamicObject._pyramidVisualizerIndex = pyramidVisualizerIndex;
            pyramid.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            pyramid.radius = Number.POSITIVE_INFINITY;
            pyramid.showIntersection = true;
            pyramid.intersectionColor = Color.YELLOW;
            pyramid.material = Material.fromType(context, Material.ColorType);
        } else {
            pyramid = this._pyramidCollection[pyramidVisualizerIndex];
        }

        pyramid.show = true;

        var directions = directionsProperty.getValueSpherical(time);
        if (typeof directions !== 'undefined' && pyramid._visualizerDirections !== directions) {
            pyramid.setDirections(directions);
            pyramid._visualizerDirections = directions;
        }

        position = defaultValue(positionProperty.getValueCartesian(time, position), pyramid._visualizerPosition);
        orientation = defaultValue(orientationProperty.getValue(time, orientation), pyramid._visualizerOrientation);

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(pyramid._visualizerPosition) ||
             !orientation.equals(pyramid._visualizerOrientation))) {
            Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, pyramid.modelMatrix);
            position.clone(pyramid._visualizerPosition);
            orientation.clone(pyramid._visualizerOrientation);
        }

        var material = dynamicPyramid.material;
        if (typeof material !== 'undefined') {
            pyramid.material = material.getValue(time, context, pyramid.material);
        }

        var property = dynamicPyramid.intersectionColor;
        if (typeof property !== 'undefined') {
            var intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                pyramid.intersectionColor = intersectionColor;
            }
        }

        property = dynamicPyramid.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time, radius);
            if (typeof radius !== 'undefined') {
                pyramid.radius = radius;
            }
        }
    };

    DynamicPyramidVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPyramidCollection = this._pyramidCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var pyramidVisualizerIndex = dynamicObject._pyramidVisualizerIndex;
            if (typeof pyramidVisualizerIndex !== 'undefined') {
                var pyramid = thisPyramidCollection[pyramidVisualizerIndex];
                pyramid.show = false;
                thisUnusedIndexes.push(pyramidVisualizerIndex);
                dynamicObject._pyramidVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPyramidVisualizer;
});
/*global define*/
define('Scene/EllipsoidPrimitive',[
        '../Core/BoxTessellator',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Color',
        '../Core/combine',
        '../Core/ComponentDatatype',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Matrix4',
        '../Core/MeshFilters',
        '../Core/BoundingSphere',
        '../Core/PrimitiveType',
        '../Renderer/CullFace',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CommandLists',
        '../Renderer/DrawCommand',
        './Material',
        './SceneMode',
        '../Shaders/Noise',
        '../Shaders/EllipsoidVS',
        '../Shaders/EllipsoidFS'
    ], function(
        BoxTessellator,
        Cartesian3,
        Cartesian4,
        Color,
        combine,
        ComponentDatatype,
        DeveloperError,
        destroyObject,
        Ellipsoid,
        Matrix4,
        MeshFilters,
        BoundingSphere,
        PrimitiveType,
        CullFace,
        BlendingState,
        BufferUsage,
        CommandLists,
        DrawCommand,
        Material,
        SceneMode,
        Noise,
        EllipsoidVS,
        EllipsoidFS) {
    

    var attributeIndices = {
        position : 0
    };

    /**
     * A renderable ellipsoid.  It can also draw spheres when the three {@link EllipsoidPrimitive#radii} components are equal.
     * <p>
     * This is only supported in 3D.  The ellipsoid is not shown in 2D or Columbus view.
     * </p>
     *
     * @alias EllipsoidPrimitive
     * @constructor
     *
     * @example
     * // 1. Create a sphere using the ellipsoid primitive
     * var e = new EllipsoidPrimitive();
     * e.center = ellipsoid.cartographicToCartesian(
     *   Cartographic.fromDegrees(-75.0, 40.0, 500000.0));
     * e.radii = new Cartesian3(500000.0, 500000.0, 500000.0);
     * primitives.add(e);
     *
     * @example
     * // 2. Create a tall ellipsoid in an east-north-up reference frame
     * var e = new EllipsoidPrimitive();
     * e.modelMatrix = Transforms.eastNorthUpToFixedFrame(
     *   ellipsoid.cartographicToCartesian(
     *     Cartographic.fromDegrees(-95.0, 40.0, 200000.0)));
     * e.radii = new Cartesian3(100000.0, 100000.0, 200000.0);
     * primitives.add(e);
     */
    var EllipsoidPrimitive = function() {
        /**
         * The center of the ellipsoid in the ellipsoid's model coordinates.
         * <p>
         * The default is {@link Cartesian3.ZERO}.
         * </p>
         *
         * @type Cartesian3
         *
         * @see EllipsoidPrimitive#modelMatrix
         */
        this.center = Cartesian3.ZERO.clone();

        /**
         * The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.
         * When these are the same, the ellipsoid is a sphere.
         * <p>
         * The default is <code>undefined</code>.  The ellipsoid is not drawn until a radii is provided.
         * </p>
         *
         * @type Cartesian3
         *
         * @example
         * // A sphere with a radius of 2.0
         * e.radii = new Cartesian3(2.0, 2.0, 2.0);
         *
         * @see EllipsoidPrimitive#modelMatrix
         */
        this.radii = undefined;
        this._radii = new Cartesian3();

        this._oneOverEllipsoidRadiiSquared = new Cartesian3();
        this._boundingSphere = new BoundingSphere();

        /**
         * The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.
         * When this is the identity matrix, the ellipsoid is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link czm_model} and derived uniforms.
         * <p>
         * The default is {@link Matrix4.IDENTITY}.
         * </p>
         *
         * @type Matrix4
         *
         * @example
         * var origin = ellipsoid.cartographicToCartesian(
         *   Cartographic.fromDegrees(-95.0, 40.0, 200000.0));
         * e.modelMatrix = Transforms.eastNorthUpToFixedFrame(origin);
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see czm_model
         */
        this.modelMatrix = Matrix4.IDENTITY.clone();
        this._computedModelMatrix = Matrix4.IDENTITY.clone();

        /**
         * Determines if the ellipsoid primitive will be shown.
         * <p>
         * The default is <code>true</code>.
         * </p>
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The surface appearance of the ellipsoid.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
         * <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>.
         * <p>
         * The default material is <code>Material.ColorType</code>.
         * </p>
         *
         * @type Material
         *
         * @example
         * // 1. Change the color of the default material to yellow
         * e.material.uniforms.color = new Color(1.0, 1.0, 0.0, 1.0);
         *
         * // 2. Change material to horizontal stripes
         * e.material = Material.fromType(scene.getContext(), Material.StripeType);
         *
         * @see <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>
         */
        this.material = Material.fromType(undefined, Material.ColorType);
        this._material = undefined;

        this._sp = undefined;
        this._rs = undefined;
        this._va = undefined;

        this._pickSP = undefined;
        this._pickMaterial = undefined;
        this._pickId = undefined;

        this._colorCommand = new DrawCommand();
        this._pickCommand = new DrawCommand();
        this._commandLists = new CommandLists();

        var that = this;
        this._uniforms = {
            u_radii : function() {
                return that.radii;
            },
            u_oneOverEllipsoidRadiiSquared : function() {
                return that._oneOverEllipsoidRadiiSquared;
            }
        };
    };

    // Per-context cache for ellipsoids
    var vertexArrayCache = {};

    function getVertexArray(context) {
        var c = vertexArrayCache[context.getId()];

        if (typeof c !== 'undefined' &&
            typeof c.vertexArray !== 'undefined') {

            ++c.referenceCount;
            return c;
        }

        var mesh = BoxTessellator.compute({
            dimensions : new Cartesian3(2.0, 2.0, 2.0)
        });

        var va = context.createVertexArrayFromMesh({
            mesh: mesh,
            attributeIndices: attributeIndices,
            bufferUsage: BufferUsage.STATIC_DRAW
        });

        var cachedVA = {
            vertexArray : va,
            referenceCount : 1,

            release : function() {
                if (typeof this.vertexArray !== 'undefined' &&
                    --this.referenceCount === 0) {

                    // PERFORMANCE_IDEA: Schedule this for a few hundred frames later so we don't thrash the cache
                    this.vertexArray = this.vertexArray.destroy();
                }

                return undefined;
            }
        };

        vertexArrayCache[context.getId()] = cachedVA;
        return cachedVA;
    }

    /**
     * @private
     *
     * @exception {DeveloperError} this.material must be defined.
     */
    EllipsoidPrimitive.prototype.update = function(context, frameState, commandList) {
        if (!this.show ||
            (frameState.mode !== SceneMode.SCENE3D) ||
            (typeof this.center === 'undefined') ||
            (typeof this.radii === 'undefined')) {
            return;
        }

        if (typeof this.material === 'undefined') {
            throw new DeveloperError('this.material must be defined.');
        }

        if (typeof this._rs === 'undefined') {
            this._rs = context.createRenderState({
                // Cull front faces - not back faces - so the ellipsoid doesn't
                // disappear if the viewer enters the bounding box.
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                },
                depthTest : {
                    enabled : true
                },
                // Do not write depth since the depth for the bounding box is
                // wrong; it is not the true of the ray casted ellipsoid.
                // Once WebGL has the extension for writing gl_FragDepth,
                // we can write the correct depth.  For now, most ellipsoids
                // will be translucent so we don't want to write depth anyway.
                depthMask : false,
                blending : BlendingState.ALPHA_BLEND
            });
        }

        if (typeof this._va === 'undefined') {
            this._va = getVertexArray(context);
        }

        var radii = this.radii;
        if (!Cartesian3.equals(this._radii, radii)) {
            Cartesian3.clone(radii, this._radii);

            var r = this._oneOverEllipsoidRadiiSquared;
            r.x = 1.0 / (radii.x * radii.x);
            r.y = 1.0 / (radii.y * radii.y);
            r.z = 1.0 / (radii.z * radii.z);

            this._boundingSphere.radius = Cartesian3.getMaximumComponent(radii);
        }

        // Translate model coordinates used for rendering such that the origin is the center of the ellipsoid.
        Matrix4.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix);

        var ellipsoidCommandLists = this._commandLists;
        ellipsoidCommandLists.removeAll();

        if (frameState.passes.color) {
            var colorCommand = this._colorCommand;

            // Recompile shader when material changes
            if (typeof this._material === 'undefined' ||
                this._material !== this.material) {

                this._material = this.material;

                var fsSource =
                    '#line 0\n' +
                    Noise +
                    '#line 0\n' +
                    this.material.shaderSource +
                    '#line 0\n' +
                    EllipsoidFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(EllipsoidVS, fsSource, attributeIndices);

                colorCommand.primitiveType = PrimitiveType.TRIANGLES;
                colorCommand.vertexArray = this._va.vertexArray;
                colorCommand.renderState = this._rs;
                colorCommand.shaderProgram = this._sp;
                colorCommand.uniformMap = combine([this._uniforms, this._material._uniforms], false, false);
            }

            colorCommand.boundingVolume = this._boundingSphere;
            colorCommand.modelMatrix = this._computedModelMatrix;

            ellipsoidCommandLists.colorList.push(colorCommand);
        }

        if (frameState.passes.pick) {
            var pickCommand = this._pickCommand;

            if (typeof this._pickId === 'undefined') {
                var pickId = context.createPickId(this);

                var pickMaterial = Material.fromType(context, Material.ColorType);
                pickMaterial.uniforms.color = pickId.normalizedRgba;

                var pickFS =
                    '#line 0\n' +
                    Noise +
                    '#line 0\n' +
                    pickMaterial.shaderSource +
                    '#line 0\n' +
                    EllipsoidFS;

                this._pickId = pickId;
                this._pickMaterial = pickMaterial;
                this._pickSP = context.getShaderCache().getShaderProgram(EllipsoidVS, pickFS, attributeIndices);

                pickCommand.primitiveType = PrimitiveType.TRIANGLES;
                pickCommand.vertexArray = this._va.vertexArray;
                pickCommand.renderState = this._rs;
                pickCommand.shaderProgram = this._pickSP;
                pickCommand.uniformMap = combine([this._uniforms, pickMaterial._uniforms], false, false);
            }

            pickCommand.boundingVolume = this._boundingSphere;
            pickCommand.modelMatrix = this._computedModelMatrix;

            ellipsoidCommandLists.pickList.push(pickCommand);
        }

        commandList.push(this._commandLists);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof EllipsoidPrimitive
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see EllipsoidPrimitive#destroy
     */
    EllipsoidPrimitive.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof EllipsoidPrimitive
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EllipsoidPrimitive#isDestroyed
     *
     * @example
     * e = e && e.destroy();
     */
    EllipsoidPrimitive.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._va = this._va && this._va.release();
        this._pickSP = this._pickSP && this._pickSP.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return EllipsoidPrimitive;
});
/*global define*/
define('DynamicScene/DynamicEllipsoidVisualizer',[
        '../Core/defaultValue',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Scene/EllipsoidPrimitive',
        '../Scene/Material'
       ], function(
         defaultValue,
         DeveloperError,
         destroyObject,
         Color,
         Matrix3,
         Matrix4,
         EllipsoidPrimitive,
         Material) {
    

    var matrix3Scratch = new Matrix3();

    /**
     * A DynamicObject visualizer which maps the DynamicEllipsoid instance
     * in DynamicObject.ellipsoid to a Ellipsoid primitive.
     * @alias DynamicEllipsoidVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicEllipsoid
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     */
    var DynamicEllipsoidVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._ellipsoidCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicEllipsoidVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicEllipsoidVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicEllipsoidVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicEllipsoidVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicEllipsoidVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicEllipsoidVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicEllipsoidVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._ellipsoidCollection.length; i < len; i++) {
            this._primitives.remove(this._ellipsoidCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._ellipsoidVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._ellipsoidCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicEllipsoidVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicEllipsoidVisualizer#destroy
     */
    DynamicEllipsoidVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicEllipsoidVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicEllipsoidVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicEllipsoidVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    DynamicEllipsoidVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var context = this._scene.getContext();
        var dynamicEllipsoid = dynamicObject.ellipsoid;
        if (typeof dynamicEllipsoid === 'undefined') {
            return;
        }

        var radiiProperty = dynamicEllipsoid.radii;
        if (typeof radiiProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var ellipsoid;
        var showProperty = dynamicEllipsoid.show;
        var ellipsoidVisualizerIndex = dynamicObject._ellipsoidVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof ellipsoidVisualizerIndex !== 'undefined') {
                ellipsoid = this._ellipsoidCollection[ellipsoidVisualizerIndex];
                ellipsoid.show = false;
                dynamicObject._ellipsoidVisualizerIndex = undefined;
                this._unusedIndexes.push(ellipsoidVisualizerIndex);
            }
            return;
        }

        if (typeof ellipsoidVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                ellipsoidVisualizerIndex = unusedIndexes.pop();
                ellipsoid = this._ellipsoidCollection[ellipsoidVisualizerIndex];
            } else {
                ellipsoidVisualizerIndex = this._ellipsoidCollection.length;
                ellipsoid = new EllipsoidPrimitive();

                this._ellipsoidCollection.push(ellipsoid);
                this._primitives.add(ellipsoid);
            }
            dynamicObject._ellipsoidVisualizerIndex = ellipsoidVisualizerIndex;
            ellipsoid.dynamicObject = dynamicObject;

            ellipsoid.material = Material.fromType(context, Material.ColorType);
        } else {
            ellipsoid = this._ellipsoidCollection[ellipsoidVisualizerIndex];
        }

        ellipsoid.show = true;

        ellipsoid.radii = radiiProperty.getValue(time, ellipsoid.radii);

        position = defaultValue(positionProperty.getValueCartesian(time, position), ellipsoid._visualizerPosition);
        orientation = defaultValue(orientationProperty.getValue(time, orientation), ellipsoid._visualizerOrientation);

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(ellipsoid._visualizerPosition) ||
             !orientation.equals(ellipsoid._visualizerOrientation))) {
            Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, ellipsoid.modelMatrix);
            position.clone(ellipsoid._visualizerPosition);
            orientation.clone(ellipsoid._visualizerOrientation);
        }

        var material = dynamicEllipsoid.material;
        if (typeof material !== 'undefined') {
            ellipsoid.material = material.getValue(time, context, ellipsoid.material);
        }
    };

    DynamicEllipsoidVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisEllipsoidCollection = this._ellipsoidCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var ellipsoidVisualizerIndex = dynamicObject._ellipsoidVisualizerIndex;
            if (typeof ellipsoidVisualizerIndex !== 'undefined') {
                var ellipsoid = thisEllipsoidCollection[ellipsoidVisualizerIndex];
                ellipsoid.show = false;
                thisUnusedIndexes.push(ellipsoidVisualizerIndex);
                dynamicObject._ellipsoidVisualizerIndex = undefined;
            }
        }
    };

    return DynamicEllipsoidVisualizer;
});
/*global define*/
define('Scene/Polygon',[
        '../Core/DeveloperError',
        '../Core/defaultValue',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/BoundingRectangle',
        '../Core/BoundingSphere',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/ComponentDatatype',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/EllipsoidTangentPlane',
        '../Core/PolygonPipeline',
        '../Core/WindingOrder',
        '../Core/ExtentTessellator',
        '../Core/Queue',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CommandLists',
        '../Renderer/CullFace',
        '../Renderer/DrawCommand',
        '../Renderer/VertexLayout',
        './Material',
        './SceneMode',
        '../Shaders/Noise',
        '../Shaders/PolygonVS',
        '../Shaders/PolygonFS',
        '../Shaders/PolygonVSPick',
        '../Shaders/PolygonFSPick'
    ], function(
        DeveloperError,
        defaultValue,
        Color,
        combine,
        destroyObject,
        Cartesian2,
        CesiumMath,
        Ellipsoid,
        BoundingRectangle,
        BoundingSphere,
        Cartesian3,
        Cartographic,
        ComponentDatatype,
        MeshFilters,
        PrimitiveType,
        EllipsoidTangentPlane,
        PolygonPipeline,
        WindingOrder,
        ExtentTessellator,
        Queue,
        BlendingState,
        BufferUsage,
        CommandLists,
        CullFace,
        DrawCommand,
        VertexLayout,
        Material,
        SceneMode,
        Noise,
        PolygonVS,
        PolygonFS,
        PolygonVSPick,
        PolygonFSPick) {
    

    var attributeIndices = {
        position2D : 0,
        position3D : 1,
        textureCoordinates : 2
    };

    function PositionVertices() {
        this._va = undefined;
    }

    PositionVertices.prototype.getVertexArrays = function() {
        return this._va;
    };

    PositionVertices.prototype.update = function(context, meshes, bufferUsage) {
        if (typeof meshes !== 'undefined') {
            // Initially create or recreate vertex array and buffers
            this._destroyVA();

            var va = [];

            var length = meshes.length;
            for ( var i = 0; i < length; ++i) {
                va.push(context.createVertexArrayFromMesh({
                    mesh : meshes[i],
                    attributeIndices : attributeIndices,
                    bufferUsage : bufferUsage,
                    vertexLayout : VertexLayout.INTERLEAVED
                }));
            }

            this._va = va;
        } else {
            this._destroyVA();
        }
    };

    PositionVertices.prototype._destroyVA = function() {
        var va = this._va;
        if (typeof va !== 'undefined') {
            this._va = undefined;

            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                va[i].destroy();
            }
        }
    };

    PositionVertices.prototype.isDestroyed = function() {
        return false;
    };

    PositionVertices.prototype.destroy = function() {
        this._destroyVA();
        return destroyObject(this);
    };

    /**
     * DOC_TBA
     *
     * @alias Polygon
     * @constructor
     *
     * @example
     * var polygon = new Polygon();
     * polygon.material.uniforms.color = {
     *   red   : 1.0,
     *   green : 0.0,
     *   blue  : 0.0,
     *   alpha : 1.0
     * };
     * polygon.setPositions([
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...))
     * ]);
     */
    var Polygon = function() {
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._rsPick = undefined;

        this._vertices = new PositionVertices();
        this._pickId = undefined;

        this._boundingVolume = new BoundingSphere();
        this._boundingVolume2D = new BoundingSphere();

        this._commandLists = new CommandLists();

        /**
         * DOC_TBA
         */
        this.ellipsoid = Ellipsoid.WGS84;
        this._ellipsoid = undefined;

        /**
         * DOC_TBA
         */
        this.height = 0.0;
        this._height = undefined;

        /**
         * DOC_TBA
         */
        this.granularity = CesiumMath.toRadians(1.0);
        this._granularity = undefined;

        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * DOC_TBA
             */
            granularity : CesiumMath.toRadians(30.0)
        };

        /**
         * DOC_TBA
         */
        this.scene3D = {
        /**
         * DOC_TBA
         *
         * granularity can override object-level granularity
         */
        };

        this._positions = undefined;
        this._extent = undefined;
        this._polygonHierarchy = undefined;
        this._createVertexArray = false;

        /**
         * Determines if this polygon will be shown.
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The usage hint for the polygon's vertex buffer.
         *
         * @type BufferUsage
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link Polygon#update} is called, the polygon's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the polygon
         * will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If the polygon will change every frame, use <code>BufferUsage.STREAM_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
        this._bufferUsage = BufferUsage.STATIC_DRAW;

        /**
         * The surface appearance of the polygon.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
         * <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>.
         * <p>
         * The default material is <code>Material.ColorType</code>.
         * </p>
         *
         * @type Material
         *
         * @example
         * // 1. Change the color of the default material to yellow
         * polygon.material.uniforms.color = new Color(1.0, 1.0, 0.0, 1.0);
         *
         * // 2. Change material to horizontal stripes
         * polygon.material = Material.fromType(scene.getContext(), Material.StripeType);
         *
         * @see <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>
         */
        this.material = Material.fromType(undefined, Material.ColorType);
        this.material.uniforms.color = new Color(1.0, 1.0, 0.0, 0.5);
        this._material = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = this._mode.morphTime;

        var that = this;
        this._uniforms = {
            u_erosion : function() {
                return that.erosion;
            },
            u_morphTime : function() {
                return that.morphTime;
            },
            u_height : function() {
                return (that._mode !== SceneMode.SCENE2D) ? that.height : 0.0;
            }
        };
        this._pickUniforms = undefined;
        this._drawUniforms = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#setPositions
     */
    Polygon.prototype.getPositions = function() {
        return this._positions;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} At least three positions are required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#getPositions
     *
     * @param {Array} positions. The cartesian positions of the polygon.
     * @param {double} [height=0.0]. The height of the polygon.
     *
     * @example
     * polygon.setPositions([
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...))
     * ], 10.0);
     */
    Polygon.prototype.setPositions = function(positions, height) {
        // positions can be undefined
        if (typeof positions !== 'undefined' && (positions.length < 3)) {
            throw new DeveloperError('At least three positions are required.');
        }
        this.height = defaultValue(height, 0.0);
        this._extent = undefined;
        this._polygonHierarchy = undefined;
        this._positions = positions;
        this._createVertexArray = true;
    };

    /**
     * Create a set of polygons with holes from a nested hierarchy.
     *
     * @memberof Polygon
     *
     * @param {Object} hierarchy An object defining the vertex positions of each nested polygon.
     * For example, the following polygon has two holes, and one hole has a hole. <code>holes</code> is optional.
     * Leaf nodes only have <code>positions</code>.
     * <pre>
     * <code>
     * {
     *  positions : [ ... ],    // The polygon's outer boundary
     *  holes : [               // The polygon's inner holes
     *    {
     *      positions : [ ... ]
     *    },
     *    {
     *      positions : [ ... ],
     *      holes : [           // A polygon within a hole
     *       {
     *         positions : [ ... ]
     *       }
     *      ]
     *    }
     *  ]
     * }
     * </code>
     * </pre>
     * @param {double} [height=0.0] The height of the polygon.
     *
     * @exception {DeveloperError} At least three positions are required.
     *
     * @example
     * // A triangle within a triangle
     * var hierarchy = {
     *     positions : [new Cartesian3(-634066.5629045101,-4608738.034138676,4348640.761750969),
     *                  new Cartesian3(-1321523.0597310204,-5108871.981065817,3570395.2500986718),
     *                  new Cartesian3(46839.74837473363,-5303481.972379478,3530933.5841716)],
     *     holes : [{
     *         positions :[new Cartesian3(-646079.44483647,-4811233.11175887,4123187.2266941597),
     *                     new Cartesian3(-1024015.4454943262,-5072141.413164587,3716492.6173834214),
     *                     new Cartesian3(-234678.22583880965,-5189078.820849883,3688809.059214336)]
     *      }]
     *  };
     */
    Polygon.prototype.configureFromPolygonHierarchy  = function(hierarchy, height) {
        // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
        var polygons = [];
        var queue = new Queue();
        queue.enqueue(hierarchy);

        while (queue.length !== 0) {
            var outerNode = queue.dequeue();
            var outerRing = outerNode.positions;

            if (outerRing.length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var numChildren = outerNode.holes ? outerNode.holes.length : 0;
            if (numChildren === 0) {
                // The outer polygon is a simple polygon with no nested inner polygon.
                polygons.push(outerNode.positions);
            } else {
                // The outer polygon contains inner polygons
                var holes = [];
                for ( var i = 0; i < numChildren; i++) {
                    var hole = outerNode.holes[i];
                    holes.push(hole.positions);

                    var numGrandchildren = 0;
                    if (hole.holes) {
                        numGrandchildren = hole.holes.length;
                    }

                    for ( var j = 0; j < numGrandchildren; j++) {
                        queue.enqueue(hole.holes[j]);
                    }
                }
                var combinedPolygon = PolygonPipeline.eliminateHoles(outerRing, holes);
                polygons.push(combinedPolygon);
            }
        }

        this.height = defaultValue(height, 0.0);
        this._positions = undefined;
        this._extent = undefined;
        this._polygonHierarchy = polygons;
        this._createVertexArray = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @param {extent} extent. The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     *
     * @param {double} [height=0.0]. The height of the cartographic extent.
     * @example
     * polygon.configureExtent(new Extent(
     *     CesiumMath.toRadians(0.0),
     *     CesiumMath.toRadians(0.0),
     *     CesiumMath.toRadians(10.0),
     *     CesiumMath.toRadians(10.0)
     * ));
     */
    Polygon.prototype.configureExtent = function(extent, height){
        this._extent = extent;
        this.height = defaultValue(height, 0.0);
        this._positions = undefined;
        this._polygonHierarchy = undefined;
        this._createVertexArray = true;
    };

    var appendTextureCoordinatesCartesian2 = new Cartesian2();
    var appendTextureCoordinatesCartesian3 = new Cartesian3();

    function appendTextureCoordinates(tangentPlane, positions2D, mesh) {
        var boundingRectangle = new BoundingRectangle.fromPoints(positions2D);
        var origin = new Cartesian2(boundingRectangle.x, boundingRectangle.y);

        var positions = mesh.attributes.position.values;
        var length = positions.length;

        var textureCoordinates = new Float32Array(2 * (length / 3));
        var j = 0;

        // PERFORMANCE_IDEA:  Instead of storing texture coordinates per-vertex, we could
        // save memory by computing them in the fragment shader.  However, projecting
        // the point onto the plane may have precision issues.
        for ( var i = 0; i < length; i += 3) {
            var p = appendTextureCoordinatesCartesian3;
            p.x = positions[i];
            p.y = positions[i + 1];
            p.z = positions[i + 2];
            var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);
            st.subtract(origin, st);

            textureCoordinates[j++] = st.x / boundingRectangle.width;
            textureCoordinates[j++] = st.y / boundingRectangle.height;
        }

        mesh.attributes.textureCoordinates = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 2,
            values : textureCoordinates
        };

        return mesh;
    }

    var createMeshFromPositionsPositions = [];

    function createMeshFromPositions(polygon, positions, outerPositions2D) {
        var cleanedPositions = PolygonPipeline.cleanUp(positions);
        if (cleanedPositions.length < 3) {
            // Duplicate positions result in not enough positions to form a polygon.
            return undefined;
        }

        var tangentPlane = EllipsoidTangentPlane.fromPoints(cleanedPositions, polygon.ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(cleanedPositions, createMeshFromPositionsPositions);

        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
        if (originalWindingOrder === WindingOrder.CLOCKWISE) {
            positions2D.reverse();
            cleanedPositions.reverse();
        }
        var indices = PolygonPipeline.earClip2D(positions2D);
        var mesh = PolygonPipeline.computeSubdivision(cleanedPositions, indices, polygon._granularity);
        var boundary2D = outerPositions2D || positions2D;
        mesh = appendTextureCoordinates(tangentPlane, boundary2D, mesh);
        return mesh;
    }

    var createMeshesOuterPositions2D = [];

    function createMeshes(polygon) {
        // PERFORMANCE_IDEA:  Move this to a web-worker.
        var i;
        var meshes = [];
        var mesh;

        if ((typeof polygon._extent !== 'undefined') && !polygon._extent.isEmpty()) {
            meshes.push(ExtentTessellator.compute({extent: polygon._extent, generateTextureCoordinates:true}));

            polygon._boundingVolume = BoundingSphere.fromExtent3D(polygon._extent, polygon._ellipsoid, polygon._boundingVolume);
            if (polygon._mode !== SceneMode.SCENE3D) {
                polygon._boundingVolume2D = BoundingSphere.fromExtent2D(polygon._extent, polygon._projection, polygon._boundingVolume2D);
                var center2D = polygon._boundingVolume2D.center;
                polygon._boundingVolume2D.center = new Cartesian3(0.0, center2D.x, center2D.y);
            }
        } else if (typeof polygon._positions !== 'undefined') {
            mesh = createMeshFromPositions(polygon, polygon._positions);
            if (typeof mesh !== 'undefined') {
                meshes.push(mesh);
                polygon._boundingVolume = BoundingSphere.fromPoints(polygon._positions, polygon._boundingVolume);
            }
        } else if (typeof polygon._polygonHierarchy !== 'undefined') {
            var outerPositions =  polygon._polygonHierarchy[0];
            var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, polygon.ellipsoid);
            var outerPositions2D = tangentPlane.projectPointsOntoPlane(outerPositions, createMeshesOuterPositions2D);
            for (i = 0; i < polygon._polygonHierarchy.length; i++) {
                mesh = createMeshFromPositions(polygon, polygon._polygonHierarchy[i], outerPositions2D);
                if (typeof mesh !== 'undefined') {
                    meshes.push(mesh);
                }
            }

            if (meshes.length > 0) {
                // The bounding volume is just around the boundary points, so there could be cases for
                // contrived polygons on contrived ellipsoids - very oblate ones - where the bounding
                // volume doesn't cover the polygon.
                polygon._boundingVolume = BoundingSphere.fromPoints(outerPositions, polygon._boundingVolume);
            }
        }

        if (meshes.length === 0) {
            return undefined;
        }

        var processedMeshes = [];
        for (i = 0; i < meshes.length; i++) {
            mesh = meshes[i];
            mesh = PolygonPipeline.scaleToGeodeticHeight(mesh, polygon.height, polygon.ellipsoid);
            mesh = MeshFilters.reorderForPostVertexCache(mesh);
            mesh = MeshFilters.reorderForPreVertexCache(mesh);

            if (polygon._mode === SceneMode.SCENE3D) {
                mesh.attributes.position2D = { // Not actually used in shader
                        value : [0.0, 0.0]
                    };
                mesh.attributes.position3D = mesh.attributes.position;
                delete mesh.attributes.position;
            } else {
                mesh = MeshFilters.projectTo2D(mesh, polygon._projection);
            }
            processedMeshes = processedMeshes.concat(MeshFilters.fitToUnsignedShortIndices(mesh));
        }

        if (polygon._mode !== SceneMode.SCENE3D) {
            mesh = meshes[0];
            var projectedPositions = mesh.attributes.position2D.values;
            var positions = [];

            for (i = 0; i < projectedPositions.length; i += 2) {
                positions.push(new Cartesian3(projectedPositions[i], projectedPositions[i + 1], 0.0));
            }

            polygon._boundingVolume2D = BoundingSphere.fromPoints(positions, polygon._boundingVolume2D);
            var center2DPositions = polygon._boundingVolume2D.center;
            polygon._boundingVolume2D.center = new Cartesian3(0.0, center2DPositions.x, center2DPositions.y);
        }

        return processedMeshes;
    }

    function getGranularity(polygon, mode) {
        if (mode === SceneMode.SCENE3D) {
            return polygon.scene3D.granularity || polygon.granularity;
        }

        return polygon.scene2D.granularity || polygon.granularity;
    }

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} this.ellipsoid must be defined.
     * @exception {DeveloperError} this.material must be defined.
     * @exception {DeveloperError} this.granularity must be greater than zero.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polygon.prototype.update = function(context, frameState, commandList) {
        if (typeof this.ellipsoid === 'undefined') {
            throw new DeveloperError('this.ellipsoid must be defined.');
        }

        if (typeof this.material === 'undefined') {
            throw new DeveloperError('this.material must be defined.');
        }

        var mode = frameState.mode;
        var granularity = getGranularity(this, mode);

        if (granularity < 0.0) {
            throw new DeveloperError('this.granularity and scene2D/scene3D overrides must be greater than zero.');
        }

        if (!this.show) {
            return;
        }

        if (this._ellipsoid !== this.ellipsoid) {
            this._createVertexArray = true;
            this._ellipsoid = this.ellipsoid;
        }

        if (this._height !== this.height) {
            this._createVertexArray = true;
            this._height = this.height;
        }

        if (this._granularity !== granularity) {
            this._createVertexArray = true;
            this._granularity = granularity;
        }

        if (this._bufferUsage !== this.bufferUsage) {
            this._createVertexArray = true;
            this._bufferUsage = this.bufferUsage;
        }

        var projection = frameState.scene2D.projection;
        if (this._projection !== projection) {
            this._createVertexArray = true;
            this._projection = projection;
        }

        if (this._mode !== mode) {
            // SCENE2D, COLUMBUS_VIEW, and MORPHING use the same rendering path, so a
            // transition only occurs when switching from/to SCENE3D
            this._createVertexArray = this._mode === SceneMode.SCENE3D || mode === SceneMode.SCENE3D;
            this._mode = mode;

            if (typeof mode.morphTime !== 'undefined') {
                this.morphTime = mode.morphTime;
            }
        }

        if (this._createVertexArray) {
            this._createVertexArray = false;
            this._vertices.update(context, createMeshes(this), this.bufferUsage);
        }

        if (typeof this._vertices.getVertexArrays() === 'undefined') {
            return;
        }

        var boundingVolume;
        if (mode === SceneMode.SCENE3D) {
            boundingVolume = this._boundingVolume;
        } else if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {
            boundingVolume = this._boundingVolume2D;
        } else {
            boundingVolume = this._boundingVolume.union(this._boundingVolume2D);
        }

        var pass = frameState.passes;
        var vas = this._vertices.getVertexArrays();
        var length = vas.length;
        var commands;
        var command;

        this._commandLists.removeAll();
        if (pass.color) {
            if (typeof this._rs === 'undefined') {
                // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
                this._rs = context.createRenderState({
                    cull : {
                        enabled : true,
                        face : CullFace.BACK
                    },
                    blending : BlendingState.ALPHA_BLEND
                });
            }

            var materialChanged = typeof this._material === 'undefined' ||
                this._material !== this.material;

            // Recompile shader when material changes
            if (materialChanged) {
                this._material = this.material;

                var fsSource =
                    '#line 0\n' +
                    Noise +
                    '#line 0\n' +
                    this._material.shaderSource +
                    '#line 0\n' +
                    PolygonFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(PolygonVS, fsSource, attributeIndices);

                this._drawUniforms = combine([this._uniforms, this._material._uniforms], false, false);
            }

            commands = this._commandLists.colorList;
            commands.length = length;

            for (var i = 0; i < length; ++i) {
                command = commands[i];
                if (typeof command === 'undefined') {
                    command = commands[i] = new DrawCommand();
                }

                command.boundingVolume = boundingVolume;
                command.primitiveType = PrimitiveType.TRIANGLES;
                command.shaderProgram = this._sp,
                command.uniformMap = this._drawUniforms;
                command.vertexArray = vas[i];
                command.renderState = this._rs;
            }
        }

        if (pass.pick) {
            if (typeof this._pickId === 'undefined') {
                this._spPick = context.getShaderCache().getShaderProgram(PolygonVSPick, PolygonFSPick, attributeIndices);

                this._rsPick = context.createRenderState({
                    // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
                    cull : {
                        enabled : true,
                        face : CullFace.BACK
                    }
                });

                this._pickId = context.createPickId(this);

                var that = this;
                this._pickUniforms = {
                    u_pickColor : function() {
                        return that._pickId.normalizedRgba;
                    },
                    u_morphTime : function() {
                        return that.morphTime;
                    },
                    u_height : function() {
                        return that.height;
                    }
                };
            }

            commands = this._commandLists.pickList;
            commands.length = length;

            for (var j = 0; j < length; ++j) {
                command = commands[j];
                if (typeof command === 'undefined') {
                    command = commands[j] = new DrawCommand();
                }

                command.boundingVolume = boundingVolume;
                command.primitiveType = PrimitiveType.TRIANGLES;
                command.shaderProgram = this._spPick,
                command.uniformMap = this._pickUniforms;
                command.vertexArray = vas[j];
                command.renderState = this._rsPick;
            }
        }

        if (!this._commandLists.empty()) {
            commandList.push(this._commandLists);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Polygon
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Polygon#destroy
     */
    Polygon.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Polygon
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#isDestroyed
     *
     * @example
     * polygon = polygon && polygon.destroy();
     */
    Polygon.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vertices = this._vertices.destroy();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return Polygon;
});

/*global define*/
define('DynamicScene/DynamicPolygonVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Scene/Polygon',
        '../Scene/Material'
       ], function(
         DeveloperError,
         destroyObject,
         Polygon,
         Material) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPolygon instance
     * in DynamicObject.polygon to a Polygon primitive.
     * @alias DynamicPolygonVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPolygon
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPolygonVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._polygonCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPolygonVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPolygonVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPolygonVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPolygonVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPolygonVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPolygonVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPolygonVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._polygonCollection.length; i < len; i++) {
            this._primitives.remove(this._polygonCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._polygonVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._polygonCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPolygonVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPolygonVisualizer#destroy
     */
    DynamicPolygonVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPolygonVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPolygonVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPolygonVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    DynamicPolygonVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var context = this._scene.getContext();
        var dynamicPolygon = dynamicObject.polygon;
        if (typeof dynamicPolygon === 'undefined') {
            return;
        }

        var vertexPositionsProperty = dynamicObject.vertexPositions;
        if (typeof vertexPositionsProperty === 'undefined') {
            return;
        }

        var vertexPositions = vertexPositionsProperty.getValueCartesian(time);

        var polygon;
        var showProperty = dynamicPolygon.show;
        var polygonVisualizerIndex = dynamicObject._polygonVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));


        if (!show || typeof vertexPositions === 'undefined' || vertexPositions.length < 3) {
            //don't bother creating or updating anything else
            if (typeof polygonVisualizerIndex !== 'undefined') {
                polygon = this._polygonCollection[polygonVisualizerIndex];
                polygon.show = false;
                dynamicObject._polygonVisualizerIndex = undefined;
                this._unusedIndexes.push(polygonVisualizerIndex);
            }
            return;
        }

        if (typeof polygonVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                polygonVisualizerIndex = unusedIndexes.pop();
                polygon = this._polygonCollection[polygonVisualizerIndex];
            } else {
                polygonVisualizerIndex = this._polygonCollection.length;
                polygon = new Polygon();
                this._polygonCollection.push(polygon);
                this._primitives.add(polygon);
            }
            dynamicObject._polygonVisualizerIndex = polygonVisualizerIndex;
            polygon.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            polygon.material = Material.fromType(context, Material.ColorType);

        } else {
            polygon = this._polygonCollection[polygonVisualizerIndex];
        }

        polygon.show = true;

        if (polygon._visualizerPositions !== vertexPositions) {
            polygon.setPositions(vertexPositions);
            polygon._visualizerPositions = vertexPositions;
        }

        var material = dynamicPolygon.material;
        if (typeof material !== 'undefined') {
            polygon.material = material.getValue(time, context, polygon.material);
        }
    };

    DynamicPolygonVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPolygonCollection = this._polygonCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var polygonVisualizerIndex = dynamicObject._polygonVisualizerIndex;
            if (typeof polygonVisualizerIndex !== 'undefined') {
                var polygon = thisPolygonCollection[polygonVisualizerIndex];
                polygon.show = false;
                thisUnusedIndexes.push(polygonVisualizerIndex);
                dynamicObject._polygonVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPolygonVisualizer;
});
/*global define*/
define('DynamicScene/CzmlDefaults',[
        './DynamicObject',
        './DynamicBillboard',
        './DynamicEllipsoid',
        './DynamicCone',
        './DynamicLabel',
        './DynamicPath',
        './DynamicPoint',
        './DynamicPolygon',
        './DynamicPolyline',
        './DynamicPyramid',
        './DynamicBillboardVisualizer',
        './DynamicEllipsoidVisualizer',
        './DynamicConeVisualizerUsingCustomSensor', //CZML_TODO Replace with './DynamicConeVisualizer', once ComplexConicSensor works.
        './DynamicLabelVisualizer',
        './DynamicPathVisualizer',
        './DynamicPointVisualizer',
        './DynamicPolygonVisualizer',
        './DynamicPolylineVisualizer',
        './DynamicPyramidVisualizer'
       ], function(
        DynamicObject,
        DynamicBillboard,
        DynamicEllipsoid,
        DynamicCone,
        DynamicLabel,
        DynamicPath,
        DynamicPoint,
        DynamicPolygon,
        DynamicPolyline,
        DynamicPyramid,
        DynamicBillboardVisualizer,
        DynamicEllipsoidVisualizer,
        DynamicConeVisualizer,
        DynamicLabelVisualizer,
        DynamicPathVisualizer,
        DynamicPointVisualizer,
        DynamicPolygonVisualizer,
        DynamicPolylineVisualizer,
        DynamicPyramidVisualizer) {
    

    /**
     * Helper class which provides the default set of CZML processing methods
     * needed to visualize the complete CZML standard.  There's no reason to
     * access this class directly, as it just holds the defaults used by
     * DynamicObjectCollection, CompositeDynamicObjectCollection, and VisualizerCollection.
     *
     * @exports CzmlDefaults
     *
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection#createCzmlDefaultsCollection
     */
    var CzmlDefaults = {
        //Any change to updaters needs to be reflected in the DynamicObject constructor,
        //which has the superset of all properties created by the various updaters.
        /**
         * The standard set of updaters for processing CZML.  This array is the default
         * set of updater methods used by DynamicObjectCollection.
         * @see DynamicObjectCollection
         */
        updaters : [DynamicBillboard.processCzmlPacket,
                    DynamicEllipsoid.processCzmlPacket,
                    DynamicCone.processCzmlPacket,
                    DynamicLabel.processCzmlPacket,
                    DynamicPath.processCzmlPacket,
                    DynamicPoint.processCzmlPacket,
                    DynamicPolygon.processCzmlPacket,
                    DynamicPolyline.processCzmlPacket,
                    DynamicPyramid.processCzmlPacket,
                    DynamicObject.processCzmlPacketPosition,
                    DynamicObject.processCzmlPacketViewFrom,
                    DynamicObject.processCzmlPacketOrientation,
                    DynamicObject.processCzmlPacketVertexPositions,
                    DynamicObject.processCzmlPacketAvailability],

        /**
         * The standard set of mergers for processing CZML.  This array is the default
         * set of updater methods used by CompositeDynamicObjectCollection.
         *
         * @see CompositeDynamicObjectCollection
         */
        mergers : [DynamicBillboard.mergeProperties,
                   DynamicEllipsoid.mergeProperties,
                   DynamicCone.mergeProperties,
                   DynamicLabel.mergeProperties,
                   DynamicPath.mergeProperties,
                   DynamicPoint.mergeProperties,
                   DynamicPolygon.mergeProperties,
                   DynamicPolyline.mergeProperties,
                   DynamicPyramid.mergeProperties,
                   DynamicObject.mergeProperties],

       /**
        * The standard set of cleaners for processing CZML.  This array is the default
        * set of updater methods used by CompositeDynamicObjectCollection.
        *
        * @see CompositeDynamicObjectCollection
        */
        cleaners : [DynamicBillboard.undefineProperties,
                    DynamicEllipsoid.undefineProperties,
                    DynamicCone.undefineProperties,
                    DynamicLabel.undefineProperties,
                    DynamicPath.undefineProperties,
                    DynamicPoint.undefineProperties,
                    DynamicPolygon.undefineProperties,
                    DynamicPolyline.undefineProperties,
                    DynamicPyramid.undefineProperties,
                    DynamicObject.undefineProperties],

        /**
         * Creates an array containing the standard CZML visualizers,
         * configured for the provided scene.
         *
         * @param scene The scene being used for visualization.
         * @returns {Array} The CZML standard visualizers.
         * @see VisualizerCollection#createCzmlDefaultsCollection
         */
        createVisualizers : function(scene) {
            return [new DynamicBillboardVisualizer(scene),
                    new DynamicEllipsoidVisualizer(scene),
                    new DynamicConeVisualizer(scene),
                    new DynamicLabelVisualizer(scene),
                    new DynamicPointVisualizer(scene),
                    new DynamicPolygonVisualizer(scene),
                    new DynamicPolylineVisualizer(scene),
                    new DynamicPyramidVisualizer(scene),
                    new DynamicPathVisualizer(scene)];
        }
    };

    return CzmlDefaults;
});
/*global define*/
define('DynamicScene/CompositeDynamicObjectCollection',[
        '../Core/Event',
        '../Core/Iso8601',
        '../Core/TimeInterval',
        '../Core/DeveloperError',
        './DynamicObject',
        './DynamicObjectCollection',
        './CzmlDefaults'
    ], function(
        Event,
        Iso8601,
        TimeInterval,
        DeveloperError,
        DynamicObject,
        DynamicObjectCollection,
        CzmlDefaults) {
    

    /**
     * Non-destructively composites multiple DynamicObjectCollection instances into a single collection.
     * If a DynamicObject with the same ID exists in multiple collections, it is non-destructively
     * merged into a single new object instance.  If an object has the same property in multiple
     * collections, the property of the DynamicObject in the last collection of the list it
     * belongs to is used.  CompositeDynamicObjectCollection can be used almost anywhere that a
     * DynamicObjectCollection is used.
     *
     * @alias CompositeDynamicObjectCollection
     * @constructor
     *
     * @param {Array} [collections] The initial list of DynamicObjectCollection instances to merge.
     * @param {Array} [mergeFunctions] The list of CZML merge functions.
     * @param {Array} [cleanFunctions] The list of CZML clean functions.
     *
     * @see DynamicObjectCollection
     * @see DynamicObject
     * @see CzmlDefaults
     */
    var CompositeDynamicObjectCollection = function(collections, mergeFunctions, cleanFunctions) {
        this._hash = {};
        this._array = [];
        this._collections = [];

        /**
         * The array of functions which merge DynamicObject instances together.
         */
        this.mergeFunctions = typeof mergeFunctions === 'undefined' ? CzmlDefaults.mergers : mergeFunctions;

        /**
         * The array of functions which remove data from a DynamicObject instance.
         */
        this.cleanFunctions = typeof cleanFunctions === 'undefined' ? CzmlDefaults.cleaners : cleanFunctions;

        /**
         * An {@link Event} that is fired whenever DynamicObjects in the collection have properties added.
         */
        this.objectPropertiesChanged = new Event();

        /**
         * An {@link Event} that is fired whenever DynamicObjects are removed from the collection.
         */
        this.objectsRemoved = new Event();

        this.setCollections(collections);
    };

    /**
     * Computes the maximum availability of the DynamicObjects in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * It will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     * @memberof CompositeDynamicObjectCollection
     *
     * @returns {TimeInterval} The availability of DynamicObjects in the collection.
     */
    CompositeDynamicObjectCollection.prototype.computeAvailability = function() {
        var startTime = Iso8601.MAXIMUM_VALUE;
        var stopTime = Iso8601.MINIMUM_VALUE;
        var i;
        var len;
        var collection;
        var collections = this._collections;
        for (i = 0, len = collections.length; i < len; i++) {
            collection = collections[i];
            var availability = collection.computeAvailability();
            var start = availability.start;
            var stop = availability.stop;
            if (start.lessThan(startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
                startTime = availability.start;
            }
            if (stop.greaterThan(stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
                stopTime = availability.stop;
            }
        }

        if (startTime === Iso8601.MAXIMUM_VALUE) {
            startTime = Iso8601.MINIMUM_VALUE;
        }
        if (stopTime === Iso8601.MINIMUM_VALUE) {
            stopTime = Iso8601.MAXIMUM_VALUE;
        }
        return new TimeInterval(startTime, stopTime, true, true);
    };

    /**
     * Returns a copy of the current array of collections being composited.  Changes to this
     * array will have no affect, to change which collections are being used, call setCollections.
     * @memberof CompositeDynamicObjectCollection
     *
     * @see CompositeDynamicObjectCollection#setCollections
     */
    CompositeDynamicObjectCollection.prototype.getCollections = function() {
        return this._collections.slice(0);
    };

    /**
     * Sets the array of collections to be composited.  Collections are composited
     * last to first, so higher indices into the array take precedence over lower indices.
     * @memberof CompositeDynamicObjectCollection
     *
     * @param {Array} collections The collections to be composited.
     */
    CompositeDynamicObjectCollection.prototype.setCollections = function(collections) {
        collections = typeof collections !== 'undefined' ? collections : [];

        var thisCollections = this._collections;
        if (collections !== thisCollections) {
            var collection;
            var iCollection;

            //Unsubscribe from old collections.
            for (iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                collection = thisCollections[iCollection];
                collection.compositeCollection = undefined;
                collection.objectPropertiesChanged.removeEventListener(CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged);
            }

            //Make a copy of the new collections.
            thisCollections = this._collections = collections;

            //Clear all existing objects and rebuild the colleciton.
            this._clearObjects();
            var thisMergeFunctions = this.mergeFunctions;
            for (iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                collection = thisCollections[iCollection];

                //Subscribe to the new collection.
                collection.compositeCollection = this;
                collection.objectPropertiesChanged.addEventListener(CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged, this);

                //Merge all of the existing objects.
                var objects = collection.getObjects();
                for ( var iObjects = objects.length - 1; iObjects > -1; iObjects--) {
                    var object = objects[iObjects];
                    var compositeObject = this._getOrCreateObject(object.id);
                    for ( var iMergeFuncs = thisMergeFunctions.length - 1; iMergeFuncs > -1; iMergeFuncs--) {
                        var mergeFunc = thisMergeFunctions[iMergeFuncs];
                        mergeFunc(compositeObject, object);
                    }
                }
            }
        }
    };

    /**
     * Gets an object with the specified id.
     * @memberof CompositeDynamicObjectCollection
     *
     * @param {Object} id The id of the object to retrieve.
     * @returns The DynamicObject with the provided id, or undefined if no such object exists.
     *
     * @exception {DeveloperError} id is required.
     */
    CompositeDynamicObjectCollection.prototype.getObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        return this._hash[id];
    };

    /**
     * Gets the array of DynamicObject instances in this composite collection.
     * @memberof CompositeDynamicObjectCollection
     *
     * @returns {Array} the array of DynamicObject instances in this composite collection.
     */
    CompositeDynamicObjectCollection.prototype.getObjects = function() {
        return this._array;
    };

    /**
     * Clears all collections and DynamicObjects from this collection.
     * @memberof CompositeDynamicObjectCollection
     */
    CompositeDynamicObjectCollection.prototype.clear = function() {
        this.setCollections([]);
    };

    CompositeDynamicObjectCollection.prototype._getOrCreateObject = function(id) {
        var obj = this._hash[id];
        if (!obj) {
            obj = new DynamicObject(id);
            this._hash[id] = obj;
            this._array.push(obj);
        }
        return obj;
    };

    CompositeDynamicObjectCollection.prototype._clearObjects = function() {
        var removedObjects = this._array;
        this._hash = {};
        this._array = [];
        if (removedObjects.length > 0) {
            this.objectsRemoved.raiseEvent(this, removedObjects);
        }
    };

    CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged = function(dynamicObjectCollection, updatedObjects) {
        var thisMergeFunctions = this.mergeFunctions;
        var thisCleanFunctions = this.cleanFunctions;
        var thisCollections = this._collections;

        var updatedObject, compositeObject, compositeObjects = [];
        for ( var i = updatedObjects.length - 1; i > -1; i--) {
            updatedObject = updatedObjects[i];
            compositeObject = this.getObject(updatedObject.id);
            if (typeof compositeObject !== 'undefined') {
                for ( var iDeleteFuncs = thisCleanFunctions.length - 1; iDeleteFuncs > -1; iDeleteFuncs--) {
                    var deleteFunc = thisCleanFunctions[iDeleteFuncs];
                    deleteFunc(compositeObject);
                }
            } else {
                compositeObject = this._getOrCreateObject(updatedObject.id);
            }

            compositeObjects.push(compositeObject);
            for ( var iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                var currentCollection = thisCollections[iCollection];
                var objectToUpdate = currentCollection.getObject(updatedObject.id);
                if (typeof objectToUpdate !== 'undefined') {
                    for ( var iMergeFuncs = thisMergeFunctions.length - 1; iMergeFuncs > -1; iMergeFuncs--) {
                        var mergeFunc = thisMergeFunctions[iMergeFuncs];
                        mergeFunc(compositeObject, objectToUpdate);
                    }
                }
            }
        }
        if (compositeObjects.length > 0) {
            this.objectPropertiesChanged.raiseEvent(this, compositeObjects);
        }
    };

    return CompositeDynamicObjectCollection;
});
/*global define*/
define('DynamicScene/VisualizerCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './CzmlDefaults'
       ], function(
         DeveloperError,
         destroyObject,
         CzmlDefaults) {
    

    /**
     * A collection of visualizers which makes it easy to manage and
     * update them in unison.
     * @alias VisualizerCollection
     * @constructor
     *
     * @param {Object} The array of visualizers to use.
     * @param {DynamicObjectCollection} The objects to be visualized.
     *
     * @see CzmlDefaults#createVisualizers
     */
    var VisualizerCollection = function(visualizers, dynamicObjectCollection) {
        if (typeof visualizers === 'undefined') {
            visualizers = [];
        }
        this._visualizers = visualizers;
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Creates a new VisualizerCollection which includes all standard visualizers.
     *
     * @memberof VisualizerCollection
     *
     * @param {Scene} The scene where visualization will take place.
     * @param {DynamicObjectCollection} The objects to be visualized.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see CzmlDefaults#createVisualizers
     */
    VisualizerCollection.createCzmlStandardCollection = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        return new VisualizerCollection(CzmlDefaults.createVisualizers(scene), dynamicObjectCollection);
    };

    /**
     * Gets a copy of the array of visualizers in the collection.
     * @returns {Array} the array of visualizers in the collection.
     */
    VisualizerCollection.prototype.getVisualizers = function() {
        return this._visualizers.slice(0);
    };

    /**
     * Sets the array of visualizers in the collection.
     *
     * @param {Array} visualizers The new array of visualizers.  This array can partially overlap with visualizers currently in the collection.
     * @param {Boolean} destroyOldVisualizers If true, visualizers no longer in the collection will be destroyed.
     */
    VisualizerCollection.prototype.setVisualizers = function(visualizers, destroyOldVisualizers) {
        destroyOldVisualizers = (typeof destroyOldVisualizers !== 'undefined') ? destroyOldVisualizers : true;

        var i;
        var thisVisualizers = this._visualizers;
        if (destroyOldVisualizers) {
            for (i = thisVisualizers.length - 1; i > -1; i--) {
                var visualizer = thisVisualizers[i];
                if (visualizers.indexOf(visualizer) === -1) {
                    visualizer.destroy();
                }
            }
        }

        if (typeof visualizers === 'undefined') {
            visualizers = [];
        }
        this._visualizers = visualizers;
        var dynamicObjectCollection = this._dynamicObjectCollection;
        for (i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].setDynamicObjectCollection(dynamicObjectCollection);
        }
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     * @returns the DynamicObjectCollection being visualized
     */
    VisualizerCollection.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection being visualized.
     * @param {DynamicObjectCollection} dynamicObjectCollection the DynamicObjectCollection being visualized.
     */
    VisualizerCollection.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            this._dynamicObjectCollection = dynamicObjectCollection;
            var visualizers = this._visualizers;
            for ( var i = visualizers.length - 1; i > -1; i--) {
                visualizers[i].setDynamicObjectCollection(dynamicObjectCollection);
            }
        }
    };

    /**
     * Updates all visualizers to the provided time.
     * @param {JulianDate} time The time to updated to.
     */
    VisualizerCollection.prototype.update = function(time) {
        var visualizers = this._visualizers;
        for ( var i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].update(time);
        }
    };

    /**
     * Removes all primitives from visualization.
     */
    VisualizerCollection.prototype.removeAllPrimitives = function() {
        var visualizers = this._visualizers;
        for ( var i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].removeAllPrimitives();
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof VisualizerCollection
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see VisualizerCollection#destroy
     */
    VisualizerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof VisualizerCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see VisualizerCollection#isDestroyed
     *
     * @example
     * visualizerCollection = visualizerCollection && visualizerCollection.destroy();
     */
    VisualizerCollection.prototype.destroy = function(destroyVisualizers) {
        destroyVisualizers = (typeof destroyVisualizers !== 'undefined') ? destroyVisualizers : true;
        this.removeAllPrimitives();
        if (destroyVisualizers) {
            var visualizers = this._visualizers;
            for ( var i = visualizers.length - 1; i > -1; i--) {
                visualizers[i].destroy();
            }
        }
        return destroyObject(this);
    };

    return VisualizerCollection;
});
/*global define*/
define('DynamicScene/processCzml',[
        '../Core/createGuid',
        '../Core/DeveloperError',
        './CzmlDefaults'
       ], function(
        createGuid,
        DeveloperError,
        CzmlDefaults) {
    

    function processCzmlPacket(packet, dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri) {
        var objectId = packet.id;
        if (typeof objectId === 'undefined') {
            objectId = createGuid();
        }

        var object = dynamicObjectCollection.getOrCreateObject(objectId);
        for ( var i = updaterFunctions.length - 1; i > -1; i--) {
            if (updaterFunctions[i](object, packet, dynamicObjectCollection, sourceUri) && typeof updatedObjectsHash[objectId] === 'undefined') {
                updatedObjectsHash[objectId] = true;
                updatedObjects.push(object);
            }
        }
    }

    /**
     * Processes the provided CZML, creating or updating DynamicObject instances for each
     * corresponding CZML identifier.
     * @exports processCzml
     *
     * @param {Object} czml The parsed CZML object to be processed.
     * @param {DynamicObjectCollection} dynamicObjectCollection The collection to create or updated objects within.
     * @param {String} [sourceUri] The uri of the file where the CZML originated from.  If provided, relative uri look-ups will use this as their base.
     * @param {Array} [updaterFunctions=CzmlDefaults.updaters] The array of updated functions to use for processing.  If left undefined, all standard CZML data is processed.
     *
     * @exception {DeveloperError} czml is required.
     * @exception {DeveloperError} dynamicObjectCollection is required.
     *
     * @returns An array containing all DynamicObject instances that were created or updated.
     *
     * @example
     * var url = 'http://someUrl.com/myCzmlFile.czml';
     * var dynamicObjectCollection = new DynamicObjectCollection();
     * getJson(url).then(function(czml) {
     *     processCzml(czml, dynamicObjectCollection, url);
     * });
     */
    var processCzml = function(czml, dynamicObjectCollection, sourceUri, updaterFunctions) {
        if (typeof czml === 'undefined') {
            throw new DeveloperError('czml is required.');
        }
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }

        var updatedObjects = [];
        var updatedObjectsHash = {};
        updaterFunctions = typeof updaterFunctions !== 'undefined' ? updaterFunctions : CzmlDefaults.updaters;

        if (Array.isArray(czml)) {
            for ( var i = 0, len = czml.length; i < len; i++) {
                processCzmlPacket(czml[i], dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri);
            }
        } else {
            processCzmlPacket(czml, dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri);
        }

        if (updatedObjects.length > 0) {
            dynamicObjectCollection.objectPropertiesChanged.raiseEvent(dynamicObjectCollection, updatedObjects);
        }

        return updatedObjects;
    };

    return processCzml;
});
/*global define*/
define('Scene/RectangularPyramidSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix4',
        '../Renderer/BufferUsage',
        './Material',
        './CustomSensorVolume'
    ], function(
        DeveloperError,
        Color,
        destroyObject,
        CesiumMath,
        Matrix4,
        BufferUsage,
        Material,
        CustomSensorVolume) {
    

    /**
     * DOC_TBA
     *
     * @alias RectangularPyramidSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     */
    var RectangularPyramidSensorVolume = function(template) {
        var t = template || {};

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * When <code>true</code>, a polyline is shown where the sensor outline intersections the central body.  The default is <code>true</code>.
         *
         * @type Boolean
         *
         * @see RectangularPyramidSensorVolume#intersectionColor
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * <p>
         * Determines if a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out
         * to the other side, or if the part of the sensor intersecting the ellipsoid stops at the ellipsoid.
         * </p>
         * <p>
         * The default is <code>false</code>, meaning the sensor will not go through the ellipsoid.
         * </p>
         *
         * @type Boolean
         */
        this.showThroughEllipsoid = (typeof t.showThroughEllipsoid === 'undefined') ? false : t.showThroughEllipsoid;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Half angles measured from the
         * principal direction and in the direction of the x-axis and y-axis define the extent of the rectangular
         * cross section.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link czm_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/RectangularPyramidSensorVolume.setModelMatrix.png' /><br />
         * Model coordinate system for a sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see czm_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY.clone();

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#yHalfAngle
         */
        this.xHalfAngle = (typeof t.xHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.xHalfAngle;
        this._xHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#xHalfAngle
         */
        this.yHalfAngle = (typeof t.yHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.yHalfAngle;
        this._yHalfAngle = undefined;

        /**
         * The surface appearance of the sensor.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
         * <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>.
         * <p>
         * The default material is <code>Material.ColorType</code>.
         * </p>
         *
         * @type Material
         *
         * @example
         * // 1. Change the color of the default material to yellow
         * sensor.material.uniforms.color = new Color(1.0, 1.0, 0.0, 1.0);
         *
         * // 2. Change material to horizontal stripes
         * sensor.material = Material.fromType(scene.getContext(), Material.StripeType);
         *
         * @see <a href='https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric'>Fabric</a>
         */
        this.material = (typeof t.material !== 'undefined') ? t.material : Material.fromType(undefined, Material.ColorType);

        /**
         * The color of the polyline where the sensor outline intersects the central body.  The default is {@link Color.WHITE}.
         *
         * @type Color
         *
         * @see RectangularPyramidSensorVolume#showIntersection
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : Color.clone(Color.WHITE);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        t._pickIdThis = t._pickIdThis || this;
        this._customSensor = new CustomSensorVolume(t);
    };

    /**
     * DOC_TBA
     *
     * @memberof RectangularPyramidSensorVolume
     *
     * @exception {DeveloperError} this.xHalfAngle and this.yHalfAngle must each be less than 90 degrees.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    RectangularPyramidSensorVolume.prototype.update = function(context, frameState, commandList) {
        if ((this.xHalfAngle > CesiumMath.PI_OVER_TWO) || (this.yHalfAngle > CesiumMath.PI_OVER_TWO)) {
            throw new DeveloperError('this.xHalfAngle and this.yHalfAngle must each be less than or equal to 90 degrees.');
        }

        var s = this._customSensor;

        s.show = this.show;
        s.showIntersection = this.showIntersection;
        s.showThroughEllipsoid = this.showThroughEllipsoid;
        s.modelMatrix = this.modelMatrix;
        s.bufferUsage = this.bufferUsage;
        s.radius = this.radius;
        s.material = this.material;
        s.intersectionColor = this.intersectionColor;
        s.erosion = this.erosion;

        if ((this._xHalfAngle !== this.xHalfAngle) || (this._yHalfAngle !== this.yHalfAngle)) {

            this._xHalfAngle = this.xHalfAngle;
            this._yHalfAngle = this.yHalfAngle;

            // At 90 degrees the sensor is completely open, and tan() goes to infinity.
            var tanX = Math.tan(Math.min(this.xHalfAngle, CesiumMath.toRadians(89.0)));
            var tanY = Math.tan(Math.min(this.yHalfAngle, CesiumMath.toRadians(89.0)));
            var theta = Math.atan(tanX / tanY);
            var cone = Math.atan(Math.sqrt(tanX * tanX + tanY * tanY));

            s.setDirections([{
                clock : theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) - theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) + theta,
                cone : cone
            }, {
                clock : -theta,
                cone : cone
            }]);
        }

        s.update(context, frameState, commandList);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.destroy = function() {
        this._customSensor = this._customSensor && this._customSensor.destroy();
        return destroyObject(this);
    };

    return RectangularPyramidSensorVolume;
});
/*global define*/
define('Scene/SensorVolumeCollection',[
        '../Core/defaultValue',
        '../Core/destroyObject',
        '../Core/BoundingSphere',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/DeveloperError',
        '../Core/Intersect',
        '../Core/Matrix4',
        './ComplexConicSensorVolume',
        './CustomSensorVolume',
        './RectangularPyramidSensorVolume',
        './SceneMode'
    ], function(
        defaultValue,
        destroyObject,
        BoundingSphere,
        Cartesian3,
        Cartesian4,
        DeveloperError,
        Intersect,
        Matrix4,
        ComplexConicSensorVolume,
        CustomSensorVolume,
        RectangularPyramidSensorVolume,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @alias SensorVolumeCollection
     * @constructor
     */
    var SensorVolumeCollection = function() {
        this._sensors = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addCustom
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addRectangularPyramid = function(template) {
        var sensor = new RectangularPyramidSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addCustom
     */
    SensorVolumeCollection.prototype.addComplexConic = function(template) {
        var sensor = new ComplexConicSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addCustom = function(template) {
        var sensor = new CustomSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#removeAll
     */
    SensorVolumeCollection.prototype.remove = function(sensor) {
        if (sensor) {
            var sensors = this._sensors;
            var i = sensors.indexOf(sensor);
            if (i !== -1) {
                sensors[i].destroy();
                sensors.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#remove
     */
    SensorVolumeCollection.prototype.removeAll = function() {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].destroy();
        }

        this._sensors = [];
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.contains = function(sensor) {
        if (sensor) {
            return (this._sensors.indexOf(sensor) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#getLength
     */
    SensorVolumeCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._sensors[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#get
     */
    SensorVolumeCollection.prototype.getLength = function() {
        return this._sensors.length;
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.update = function(context, frameState, commandList) {
        var mode = frameState.mode;
        if (mode !== SceneMode.SCENE3D) {
            return;
        }

        var sensors = this._sensors;
        var length = sensors.length;
        for (var i = 0; i < length; ++i) {
            sensors[i].update(context, frameState, commandList);
        }
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return SensorVolumeCollection;
});

/*global define*/
define('Scene/SingleTileImageryProvider',[
        '../Core/defaultValue',
        '../Core/loadImage',
        '../Core/writeTextToCanvas',
        '../Core/DeveloperError',
        '../Core/Event',
        '../Core/Extent',
        './GeographicTilingScheme',
        './ImageryProviderError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        loadImage,
        writeTextToCanvas,
        DeveloperError,
        Event,
        Extent,
        GeographicTilingScheme,
        ImageryProviderError,
        when) {
    

    /**
     * Provides a single, top-level imagery tile.  The single image is assumed to use a
     * {@link GeographicTilingScheme}.
     *
     * @alias SingleTileImageryProvider
     * @constructor
     *
     * @param {String} description.url The url for the tile.
     * @param {Extent} [description.extent=Extent.MAX_VALUE] The extent, in radians, covered by the image.
     * @param {String} [description.credit] A string crediting the data source, which is displayed on the canvas.
     * @param {Object} [description.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} description.url is required.
     *
     * @see ArcGisMapServerImageryProvider
     * @see BingMapsImageryProvider
     * @see OpenStreetMapImageryProvider
     * @see WebMapServiceImageryProvider
     */
    var SingleTileImageryProvider = function(description) {
        description = defaultValue(description, {});

        var url = description.url;
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        this._url = url;

        var proxy = description.proxy;
        this._proxy = proxy;

        var extent = defaultValue(description.extent, Extent.MAX_VALUE);
        var tilingScheme = new GeographicTilingScheme({
            extent : extent,
            numberOfLevelZeroTilesX : 1,
            numberOfLevelZeroTilesY : 1
        });
        this._tilingScheme = tilingScheme;

        this._image = undefined;
        this._texture = undefined;
        this._tileWidth = 0;
        this._tileHeight = 0;

        this._errorEvent = new Event();

        this._ready = false;

        var imageUrl = url;
        if (typeof proxy !== 'undefined') {
            imageUrl = proxy.getURL(imageUrl);
        }

        // Create the credit message.
        if (typeof description.credit !== 'undefined') {
            // Create the copyright message.
            this._logo = writeTextToCanvas(description.credit, {
                font : '12px sans-serif'
            });
        }

        var that = this;
        var error;

        function success(image) {
            that._image = image;
            that._tileWidth = image.width;
            that._tileHeight = image.height;
            that._ready = true;
            ImageryProviderError.handleSuccess(that._errorEvent);
        }

        function failure(e) {
            var message = 'Failed to load image ' + imageUrl + '.';
            error = ImageryProviderError.handleError(
                    error,
                    that,
                    that._errorEvent,
                    message,
                    0, 0, 0,
                    doRequest);
        }

        function doRequest() {
            when(loadImage(imageUrl), success, failure);
        }

        doRequest();
    };

    /**
     * Gets the URL of the single, top-level imagery tile.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {String} The URL.
     */
    SingleTileImageryProvider.prototype.getUrl = function() {
        return this._url;
    };

    /**
     * Gets the width of each tile, in pixels.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Number} The width.
     *
     * @exception {DeveloperError} <code>getTileWidth</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getTileWidth = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileWidth must not be called before the imagery provider is ready.');
        }
        return this._tileWidth;
    };

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Number} The height.
     *
     * @exception {DeveloperError} <code>getTileHeight</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getTileHeight = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileHeight must not be called before the imagery provider is ready.');
        }
        return this._tileHeight;
    };

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Number} The maximum level.
     *
     * @exception {DeveloperError} <code>getMaximumLevel</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getMaximumLevel = function() {
        if (!this._ready) {
            throw new DeveloperError('getMaximumLevel must not be called before the imagery provider is ready.');
        }
        return 0;
    };

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {TilingScheme} The tiling scheme.
     * @see WebMercatorTilingScheme
     * @see GeographicTilingScheme
     *
     * @exception {DeveloperError} <code>getTilingScheme</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getTilingScheme = function() {
        if (!this._ready) {
            throw new DeveloperError('getTilingScheme must not be called before the imagery provider is ready.');
        }
        return this._tilingScheme;
    };

    /**
     * Gets the extent, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Extent} The extent.
     */
    SingleTileImageryProvider.prototype.getExtent = function() {
        return this._tilingScheme.getExtent();
    };

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {TileDiscardPolicy} The discard policy.
     *
     * @see DiscardMissingTileImagePolicy
     * @see NeverTileDiscardPolicy
     *
     * @exception {DeveloperError} <code>getTileDiscardPolicy</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getTileDiscardPolicy = function() {
        if (!this._ready) {
            throw new DeveloperError('getTileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        return undefined;
    };

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ImageryProviderError}.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Event} The event.
     */
    SingleTileImageryProvider.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Boolean} True if the provider is ready to use; otherwise, false.
     */
    SingleTileImageryProvider.prototype.isReady = function() {
        return this._ready;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     *
     * @returns {Promise} A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.requestImage = function(x, y, level) {
        if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
        }
        return this._image;
    };

    /**
     * Gets the logo to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#isReady} returns true.
     *
     * @memberof SingleTileImageryProvider
     *
     * @returns {Image|Canvas} A canvas or image containing the log to display, or undefined if there is no logo.
     *
     * @exception {DeveloperError} <code>getLogo</code> must not be called before the imagery provider is ready.
     */
    SingleTileImageryProvider.prototype.getLogo = function() {
        if (!this._ready) {
            throw new DeveloperError('getLogo must not be called before the imagery provider is ready.');
        }
        return this._logo;
    };

    return SingleTileImageryProvider;
});
/*global define*/
define('Cesium',['Core/AnimationController', 'Core/AxisAlignedBoundingBox', 'Core/BoundingRectangle', 'Core/BoundingSphere', 'Core/BoxTessellator', 'Core/Cartesian2', 'Core/Cartesian3', 'Core/Cartesian4', 'Core/Cartographic', 'Core/CatmullRomSpline', 'Core/Clock', 'Core/ClockRange', 'Core/ClockStep', 'Core/Color', 'Core/ComponentDatatype', 'Core/CubeMapEllipsoidTessellator', 'Core/CubicRealPolynomial', 'Core/DefaultProxy', 'Core/DeveloperError', 'Core/Ellipsoid', 'Core/EllipsoidTangentPlane', 'Core/EllipsoidalOccluder', 'Core/EncodedCartesian3', 'Core/Enumeration', 'Core/Event', 'Core/EventHandler', 'Core/EventModifier', 'Core/Extent', 'Core/ExtentTessellator', 'Core/FAR', 'Core/FeatureDetection', 'Core/Fullscreen', 'Core/GeographicProjection', 'Core/HermitePolynomialApproximation', 'Core/HermiteSpline', 'Core/IndexDatatype', 'Core/Intersect', 'Core/IntersectionTests', 'Core/Interval', 'Core/Iso8601', 'Core/JulianDate', 'Core/LagrangePolynomialApproximation', 'Core/LeapSecond', 'Core/LinearApproximation', 'Core/Math', 'Core/Matrix2', 'Core/Matrix3', 'Core/Matrix4', 'Core/MeshFilters', 'Core/MouseEventType', 'Core/Occluder', 'Core/OrientationInterpolator', 'Core/PlaneTessellator', 'Core/PolygonPipeline', 'Core/PolylinePipeline', 'Core/PrimitiveType', 'Core/QuadraticRealPolynomial', 'Core/QuarticRealPolynomial', 'Core/Quaternion', 'Core/Queue', 'Core/Ray', 'Core/RuntimeError', 'Core/Shapes', 'Core/Spherical', 'Core/TaskProcessor', 'Core/TimeConstants', 'Core/TimeInterval', 'Core/TimeIntervalCollection', 'Core/TimeStandard', 'Core/Tipsify', 'Core/Transforms', 'Core/TridiagonalSystemSolver', 'Core/Visibility', 'Core/WebMercatorProjection', 'Core/WindingOrder', 'Core/binarySearch', 'Core/clone', 'Core/combine', 'Core/computeSunPosition', 'Core/createGuid', 'Core/defaultValue', 'Core/destroyObject', 'Core/freezeObject', 'Core/getImagePixels', 'Core/isLeapYear', 'Core/jsonp', 'Core/loadArrayBuffer', 'Core/loadImage', 'Core/loadJson', 'Core/loadText', 'Core/pointInsideTriangle2D', 'Core/requestAnimationFrame', 'Core/throttleRequestByServer', 'Core/writeTextToCanvas', 'DynamicScene/CompositeDynamicObjectCollection', 'DynamicScene/CzmlBoolean', 'DynamicScene/CzmlCartesian2', 'DynamicScene/CzmlCartesian3', 'DynamicScene/CzmlCartographic', 'DynamicScene/CzmlColor', 'DynamicScene/CzmlDefaults', 'DynamicScene/CzmlHorizontalOrigin', 'DynamicScene/CzmlImage', 'DynamicScene/CzmlLabelStyle', 'DynamicScene/CzmlNumber', 'DynamicScene/CzmlString', 'DynamicScene/CzmlUnitCartesian3', 'DynamicScene/CzmlUnitQuaternion', 'DynamicScene/CzmlUnitSpherical', 'DynamicScene/CzmlVerticalOrigin', 'DynamicScene/DynamicBillboard', 'DynamicScene/DynamicBillboardVisualizer', 'DynamicScene/DynamicColorMaterial', 'DynamicScene/DynamicCone', 'DynamicScene/DynamicConeVisualizer', 'DynamicScene/DynamicConeVisualizerUsingCustomSensor', 'DynamicScene/DynamicDirectionsProperty', 'DynamicScene/DynamicEllipsoid', 'DynamicScene/DynamicEllipsoidVisualizer', 'DynamicScene/DynamicImageMaterial', 'DynamicScene/DynamicLabel', 'DynamicScene/DynamicLabelVisualizer', 'DynamicScene/DynamicMaterialProperty', 'DynamicScene/DynamicObject', 'DynamicScene/DynamicObjectCollection', 'DynamicScene/DynamicObjectView', 'DynamicScene/DynamicPath', 'DynamicScene/DynamicPathVisualizer', 'DynamicScene/DynamicPoint', 'DynamicScene/DynamicPointVisualizer', 'DynamicScene/DynamicPolygon', 'DynamicScene/DynamicPolygonVisualizer', 'DynamicScene/DynamicPolyline', 'DynamicScene/DynamicPolylineVisualizer', 'DynamicScene/DynamicPositionProperty', 'DynamicScene/DynamicProperty', 'DynamicScene/DynamicPyramid', 'DynamicScene/DynamicPyramidVisualizer', 'DynamicScene/DynamicVertexPositionsProperty', 'DynamicScene/ReferenceProperty', 'DynamicScene/VisualizerCollection', 'DynamicScene/processCzml', 'Renderer/BlendEquation', 'Renderer/BlendFunction', 'Renderer/BlendingState', 'Renderer/Buffer', 'Renderer/BufferUsage', 'Renderer/ClearCommand', 'Renderer/CommandLists', 'Renderer/Context', 'Renderer/CubeMap', 'Renderer/CubeMapFace', 'Renderer/CullFace', 'Renderer/DepthFunction', 'Renderer/DrawCommand', 'Renderer/Framebuffer', 'Renderer/MipmapHint', 'Renderer/PickFramebuffer', 'Renderer/PixelDatatype', 'Renderer/PixelFormat', 'Renderer/Renderbuffer', 'Renderer/RenderbufferFormat', 'Renderer/ShaderCache', 'Renderer/ShaderProgram', 'Renderer/StencilFunction', 'Renderer/StencilOperation', 'Renderer/Texture', 'Renderer/TextureAtlas', 'Renderer/TextureAtlasBuilder', 'Renderer/TextureMagnificationFilter', 'Renderer/TextureMinificationFilter', 'Renderer/TextureWrap', 'Renderer/UniformDatatype', 'Renderer/UniformState', 'Renderer/VertexArray', 'Renderer/VertexArrayFacade', 'Renderer/VertexLayout', 'Renderer/loadCubeMap', 'Scene/AnimationCollection', 'Scene/ArcGisMapServerImageryProvider', 'Scene/Billboard', 'Scene/BillboardCollection', 'Scene/BingMapsImageryProvider', 'Scene/BingMapsStyle', 'Scene/Camera', 'Scene/Camera2DController', 'Scene/CameraCentralBodyController', 'Scene/CameraColumbusViewController', 'Scene/CameraControllerCollection', 'Scene/CameraEventHandler', 'Scene/CameraEventType', 'Scene/CameraFlightController', 'Scene/CameraFreeLookController', 'Scene/CameraHelpers', 'Scene/CameraSpindleController', 'Scene/CameraSpindleControllerMode', 'Scene/CentralBody', 'Scene/CentralBodySurface', 'Scene/CentralBodySurfaceShaderSet', 'Scene/ComplexConicSensorVolume', 'Scene/CompositePrimitive', 'Scene/CullingVolume', 'Scene/CustomSensorVolume', 'Scene/DiscardMissingTileImagePolicy', 'Scene/EllipsoidPrimitive', 'Scene/EllipsoidTerrainProvider', 'Scene/FrameState', 'Scene/FrustumCommands', 'Scene/GeographicTilingScheme', 'Scene/HorizontalOrigin', 'Scene/Imagery', 'Scene/ImageryLayer', 'Scene/ImageryLayerCollection', 'Scene/ImageryProvider', 'Scene/ImageryProviderError', 'Scene/ImageryState', 'Scene/Label', 'Scene/LabelCollection', 'Scene/LabelStyle', 'Scene/Material', 'Scene/NeverTileDiscardPolicy', 'Scene/OpenStreetMapImageryProvider', 'Scene/OrthographicFrustum', 'Scene/PerformanceDisplay', 'Scene/PerspectiveFrustum', 'Scene/PerspectiveOffCenterFrustum', 'Scene/Polygon', 'Scene/Polyline', 'Scene/PolylineCollection', 'Scene/Projections', 'Scene/RectangularPyramidSensorVolume', 'Scene/Scene', 'Scene/SceneMode', 'Scene/SceneTransitioner', 'Scene/SensorVolumeCollection', 'Scene/SingleTileImageryProvider', 'Scene/SkyAtmosphere', 'Scene/SkyBox', 'Scene/TerrainProvider', 'Scene/TexturePool', 'Scene/Tile', 'Scene/TileDiscardPolicy', 'Scene/TileImagery', 'Scene/TileLoadQueue', 'Scene/TileMapServiceImageryProvider', 'Scene/TileReplacementQueue', 'Scene/TileState', 'Scene/TilingScheme', 'Scene/VerticalOrigin', 'Scene/ViewportQuad', 'Scene/WebMapServiceImageryProvider', 'Scene/WebMercatorTilingScheme', 'Shaders/BillboardCollectionFS', 'Shaders/BillboardCollectionVS', 'Shaders/BuiltinFunctions', 'Shaders/CentralBodyFS', 'Shaders/CentralBodyFSDepth', 'Shaders/CentralBodyFSPole', 'Shaders/CentralBodyVS', 'Shaders/CentralBodyVSDepth', 'Shaders/CentralBodyVSPole', 'Shaders/ComplexConicSensorVolumeFS', 'Shaders/ComplexConicSensorVolumeVS', 'Shaders/ConstructiveSolidGeometry', 'Shaders/CustomSensorVolumeFS', 'Shaders/CustomSensorVolumeVS', 'Shaders/EllipsoidFS', 'Shaders/EllipsoidVS', 'Shaders/Materials/AsphaltMaterial', 'Shaders/Materials/BlobMaterial', 'Shaders/Materials/BrickMaterial', 'Shaders/Materials/BumpMapMaterial', 'Shaders/Materials/CementMaterial', 'Shaders/Materials/CheckerboardMaterial', 'Shaders/Materials/DotMaterial', 'Shaders/Materials/FacetMaterial', 'Shaders/Materials/FresnelMaterial', 'Shaders/Materials/GrassMaterial', 'Shaders/Materials/NormalMapMaterial', 'Shaders/Materials/ReflectionMaterial', 'Shaders/Materials/RefractionMaterial', 'Shaders/Materials/StripeMaterial', 'Shaders/Materials/TieDyeMaterial', 'Shaders/Materials/Water', 'Shaders/Materials/WoodMaterial', 'Shaders/Noise', 'Shaders/PolygonFS', 'Shaders/PolygonFSPick', 'Shaders/PolygonVS', 'Shaders/PolygonVSPick', 'Shaders/PolylineFS', 'Shaders/PolylineVS', 'Shaders/Ray', 'Shaders/ReprojectWebMercatorFS', 'Shaders/ReprojectWebMercatorVS', 'Shaders/SensorVolume', 'Shaders/SkyAtmosphereFS', 'Shaders/SkyAtmosphereVS', 'Shaders/SkyBoxFS', 'Shaders/SkyBoxVS', 'Shaders/ViewportQuadFS', 'Shaders/ViewportQuadVS', 'ThirdParty/Tween', 'ThirdParty/Uri', 'ThirdParty/measureText', 'ThirdParty/when'], function(Core_AnimationController, Core_AxisAlignedBoundingBox, Core_BoundingRectangle, Core_BoundingSphere, Core_BoxTessellator, Core_Cartesian2, Core_Cartesian3, Core_Cartesian4, Core_Cartographic, Core_CatmullRomSpline, Core_Clock, Core_ClockRange, Core_ClockStep, Core_Color, Core_ComponentDatatype, Core_CubeMapEllipsoidTessellator, Core_CubicRealPolynomial, Core_DefaultProxy, Core_DeveloperError, Core_Ellipsoid, Core_EllipsoidTangentPlane, Core_EllipsoidalOccluder, Core_EncodedCartesian3, Core_Enumeration, Core_Event, Core_EventHandler, Core_EventModifier, Core_Extent, Core_ExtentTessellator, Core_FAR, Core_FeatureDetection, Core_Fullscreen, Core_GeographicProjection, Core_HermitePolynomialApproximation, Core_HermiteSpline, Core_IndexDatatype, Core_Intersect, Core_IntersectionTests, Core_Interval, Core_Iso8601, Core_JulianDate, Core_LagrangePolynomialApproximation, Core_LeapSecond, Core_LinearApproximation, Core_Math, Core_Matrix2, Core_Matrix3, Core_Matrix4, Core_MeshFilters, Core_MouseEventType, Core_Occluder, Core_OrientationInterpolator, Core_PlaneTessellator, Core_PolygonPipeline, Core_PolylinePipeline, Core_PrimitiveType, Core_QuadraticRealPolynomial, Core_QuarticRealPolynomial, Core_Quaternion, Core_Queue, Core_Ray, Core_RuntimeError, Core_Shapes, Core_Spherical, Core_TaskProcessor, Core_TimeConstants, Core_TimeInterval, Core_TimeIntervalCollection, Core_TimeStandard, Core_Tipsify, Core_Transforms, Core_TridiagonalSystemSolver, Core_Visibility, Core_WebMercatorProjection, Core_WindingOrder, Core_binarySearch, Core_clone, Core_combine, Core_computeSunPosition, Core_createGuid, Core_defaultValue, Core_destroyObject, Core_freezeObject, Core_getImagePixels, Core_isLeapYear, Core_jsonp, Core_loadArrayBuffer, Core_loadImage, Core_loadJson, Core_loadText, Core_pointInsideTriangle2D, Core_requestAnimationFrame, Core_throttleRequestByServer, Core_writeTextToCanvas, DynamicScene_CompositeDynamicObjectCollection, DynamicScene_CzmlBoolean, DynamicScene_CzmlCartesian2, DynamicScene_CzmlCartesian3, DynamicScene_CzmlCartographic, DynamicScene_CzmlColor, DynamicScene_CzmlDefaults, DynamicScene_CzmlHorizontalOrigin, DynamicScene_CzmlImage, DynamicScene_CzmlLabelStyle, DynamicScene_CzmlNumber, DynamicScene_CzmlString, DynamicScene_CzmlUnitCartesian3, DynamicScene_CzmlUnitQuaternion, DynamicScene_CzmlUnitSpherical, DynamicScene_CzmlVerticalOrigin, DynamicScene_DynamicBillboard, DynamicScene_DynamicBillboardVisualizer, DynamicScene_DynamicColorMaterial, DynamicScene_DynamicCone, DynamicScene_DynamicConeVisualizer, DynamicScene_DynamicConeVisualizerUsingCustomSensor, DynamicScene_DynamicDirectionsProperty, DynamicScene_DynamicEllipsoid, DynamicScene_DynamicEllipsoidVisualizer, DynamicScene_DynamicImageMaterial, DynamicScene_DynamicLabel, DynamicScene_DynamicLabelVisualizer, DynamicScene_DynamicMaterialProperty, DynamicScene_DynamicObject, DynamicScene_DynamicObjectCollection, DynamicScene_DynamicObjectView, DynamicScene_DynamicPath, DynamicScene_DynamicPathVisualizer, DynamicScene_DynamicPoint, DynamicScene_DynamicPointVisualizer, DynamicScene_DynamicPolygon, DynamicScene_DynamicPolygonVisualizer, DynamicScene_DynamicPolyline, DynamicScene_DynamicPolylineVisualizer, DynamicScene_DynamicPositionProperty, DynamicScene_DynamicProperty, DynamicScene_DynamicPyramid, DynamicScene_DynamicPyramidVisualizer, DynamicScene_DynamicVertexPositionsProperty, DynamicScene_ReferenceProperty, DynamicScene_VisualizerCollection, DynamicScene_processCzml, Renderer_BlendEquation, Renderer_BlendFunction, Renderer_BlendingState, Renderer_Buffer, Renderer_BufferUsage, Renderer_ClearCommand, Renderer_CommandLists, Renderer_Context, Renderer_CubeMap, Renderer_CubeMapFace, Renderer_CullFace, Renderer_DepthFunction, Renderer_DrawCommand, Renderer_Framebuffer, Renderer_MipmapHint, Renderer_PickFramebuffer, Renderer_PixelDatatype, Renderer_PixelFormat, Renderer_Renderbuffer, Renderer_RenderbufferFormat, Renderer_ShaderCache, Renderer_ShaderProgram, Renderer_StencilFunction, Renderer_StencilOperation, Renderer_Texture, Renderer_TextureAtlas, Renderer_TextureAtlasBuilder, Renderer_TextureMagnificationFilter, Renderer_TextureMinificationFilter, Renderer_TextureWrap, Renderer_UniformDatatype, Renderer_UniformState, Renderer_VertexArray, Renderer_VertexArrayFacade, Renderer_VertexLayout, Renderer_loadCubeMap, Scene_AnimationCollection, Scene_ArcGisMapServerImageryProvider, Scene_Billboard, Scene_BillboardCollection, Scene_BingMapsImageryProvider, Scene_BingMapsStyle, Scene_Camera, Scene_Camera2DController, Scene_CameraCentralBodyController, Scene_CameraColumbusViewController, Scene_CameraControllerCollection, Scene_CameraEventHandler, Scene_CameraEventType, Scene_CameraFlightController, Scene_CameraFreeLookController, Scene_CameraHelpers, Scene_CameraSpindleController, Scene_CameraSpindleControllerMode, Scene_CentralBody, Scene_CentralBodySurface, Scene_CentralBodySurfaceShaderSet, Scene_ComplexConicSensorVolume, Scene_CompositePrimitive, Scene_CullingVolume, Scene_CustomSensorVolume, Scene_DiscardMissingTileImagePolicy, Scene_EllipsoidPrimitive, Scene_EllipsoidTerrainProvider, Scene_FrameState, Scene_FrustumCommands, Scene_GeographicTilingScheme, Scene_HorizontalOrigin, Scene_Imagery, Scene_ImageryLayer, Scene_ImageryLayerCollection, Scene_ImageryProvider, Scene_ImageryProviderError, Scene_ImageryState, Scene_Label, Scene_LabelCollection, Scene_LabelStyle, Scene_Material, Scene_NeverTileDiscardPolicy, Scene_OpenStreetMapImageryProvider, Scene_OrthographicFrustum, Scene_PerformanceDisplay, Scene_PerspectiveFrustum, Scene_PerspectiveOffCenterFrustum, Scene_Polygon, Scene_Polyline, Scene_PolylineCollection, Scene_Projections, Scene_RectangularPyramidSensorVolume, Scene_Scene, Scene_SceneMode, Scene_SceneTransitioner, Scene_SensorVolumeCollection, Scene_SingleTileImageryProvider, Scene_SkyAtmosphere, Scene_SkyBox, Scene_TerrainProvider, Scene_TexturePool, Scene_Tile, Scene_TileDiscardPolicy, Scene_TileImagery, Scene_TileLoadQueue, Scene_TileMapServiceImageryProvider, Scene_TileReplacementQueue, Scene_TileState, Scene_TilingScheme, Scene_VerticalOrigin, Scene_ViewportQuad, Scene_WebMapServiceImageryProvider, Scene_WebMercatorTilingScheme, Shaders_BillboardCollectionFS, Shaders_BillboardCollectionVS, Shaders_BuiltinFunctions, Shaders_CentralBodyFS, Shaders_CentralBodyFSDepth, Shaders_CentralBodyFSPole, Shaders_CentralBodyVS, Shaders_CentralBodyVSDepth, Shaders_CentralBodyVSPole, Shaders_ComplexConicSensorVolumeFS, Shaders_ComplexConicSensorVolumeVS, Shaders_ConstructiveSolidGeometry, Shaders_CustomSensorVolumeFS, Shaders_CustomSensorVolumeVS, Shaders_EllipsoidFS, Shaders_EllipsoidVS, Shaders_Materials_AsphaltMaterial, Shaders_Materials_BlobMaterial, Shaders_Materials_BrickMaterial, Shaders_Materials_BumpMapMaterial, Shaders_Materials_CementMaterial, Shaders_Materials_CheckerboardMaterial, Shaders_Materials_DotMaterial, Shaders_Materials_FacetMaterial, Shaders_Materials_FresnelMaterial, Shaders_Materials_GrassMaterial, Shaders_Materials_NormalMapMaterial, Shaders_Materials_ReflectionMaterial, Shaders_Materials_RefractionMaterial, Shaders_Materials_StripeMaterial, Shaders_Materials_TieDyeMaterial, Shaders_Materials_Water, Shaders_Materials_WoodMaterial, Shaders_Noise, Shaders_PolygonFS, Shaders_PolygonFSPick, Shaders_PolygonVS, Shaders_PolygonVSPick, Shaders_PolylineFS, Shaders_PolylineVS, Shaders_Ray, Shaders_ReprojectWebMercatorFS, Shaders_ReprojectWebMercatorVS, Shaders_SensorVolume, Shaders_SkyAtmosphereFS, Shaders_SkyAtmosphereVS, Shaders_SkyBoxFS, Shaders_SkyBoxVS, Shaders_ViewportQuadFS, Shaders_ViewportQuadVS, ThirdParty_Tween, ThirdParty_Uri, ThirdParty_measureText, ThirdParty_when) {
  
  var Cesium = {
    _shaders : {}
  };
  Cesium.AnimationController = Core_AnimationController;
  Cesium.AxisAlignedBoundingBox = Core_AxisAlignedBoundingBox;
  Cesium.BoundingRectangle = Core_BoundingRectangle;
  Cesium.BoundingSphere = Core_BoundingSphere;
  Cesium.BoxTessellator = Core_BoxTessellator;
  Cesium.Cartesian2 = Core_Cartesian2;
  Cesium.Cartesian3 = Core_Cartesian3;
  Cesium.Cartesian4 = Core_Cartesian4;
  Cesium.Cartographic = Core_Cartographic;
  Cesium.CatmullRomSpline = Core_CatmullRomSpline;
  Cesium.Clock = Core_Clock;
  Cesium.ClockRange = Core_ClockRange;
  Cesium.ClockStep = Core_ClockStep;
  Cesium.Color = Core_Color;
  Cesium.ComponentDatatype = Core_ComponentDatatype;
  Cesium.CubeMapEllipsoidTessellator = Core_CubeMapEllipsoidTessellator;
  Cesium.CubicRealPolynomial = Core_CubicRealPolynomial;
  Cesium.DefaultProxy = Core_DefaultProxy;
  Cesium.DeveloperError = Core_DeveloperError;
  Cesium.Ellipsoid = Core_Ellipsoid;
  Cesium.EllipsoidTangentPlane = Core_EllipsoidTangentPlane;
  Cesium.EllipsoidalOccluder = Core_EllipsoidalOccluder;
  Cesium.EncodedCartesian3 = Core_EncodedCartesian3;
  Cesium.Enumeration = Core_Enumeration;
  Cesium.Event = Core_Event;
  Cesium.EventHandler = Core_EventHandler;
  Cesium.EventModifier = Core_EventModifier;
  Cesium.Extent = Core_Extent;
  Cesium.ExtentTessellator = Core_ExtentTessellator;
  Cesium.FAR = Core_FAR;
  Cesium.FeatureDetection = Core_FeatureDetection;
  Cesium.Fullscreen = Core_Fullscreen;
  Cesium.GeographicProjection = Core_GeographicProjection;
  Cesium.HermitePolynomialApproximation = Core_HermitePolynomialApproximation;
  Cesium.HermiteSpline = Core_HermiteSpline;
  Cesium.IndexDatatype = Core_IndexDatatype;
  Cesium.Intersect = Core_Intersect;
  Cesium.IntersectionTests = Core_IntersectionTests;
  Cesium.Interval = Core_Interval;
  Cesium.Iso8601 = Core_Iso8601;
  Cesium.JulianDate = Core_JulianDate;
  Cesium.LagrangePolynomialApproximation = Core_LagrangePolynomialApproximation;
  Cesium.LeapSecond = Core_LeapSecond;
  Cesium.LinearApproximation = Core_LinearApproximation;
  Cesium.Math = Core_Math;
  Cesium.Matrix2 = Core_Matrix2;
  Cesium.Matrix3 = Core_Matrix3;
  Cesium.Matrix4 = Core_Matrix4;
  Cesium.MeshFilters = Core_MeshFilters;
  Cesium.MouseEventType = Core_MouseEventType;
  Cesium.Occluder = Core_Occluder;
  Cesium.OrientationInterpolator = Core_OrientationInterpolator;
  Cesium.PlaneTessellator = Core_PlaneTessellator;
  Cesium.PolygonPipeline = Core_PolygonPipeline;
  Cesium.PolylinePipeline = Core_PolylinePipeline;
  Cesium.PrimitiveType = Core_PrimitiveType;
  Cesium.QuadraticRealPolynomial = Core_QuadraticRealPolynomial;
  Cesium.QuarticRealPolynomial = Core_QuarticRealPolynomial;
  Cesium.Quaternion = Core_Quaternion;
  Cesium.Queue = Core_Queue;
  Cesium.Ray = Core_Ray;
  Cesium.RuntimeError = Core_RuntimeError;
  Cesium.Shapes = Core_Shapes;
  Cesium.Spherical = Core_Spherical;
  Cesium.TaskProcessor = Core_TaskProcessor;
  Cesium.TimeConstants = Core_TimeConstants;
  Cesium.TimeInterval = Core_TimeInterval;
  Cesium.TimeIntervalCollection = Core_TimeIntervalCollection;
  Cesium.TimeStandard = Core_TimeStandard;
  Cesium.Tipsify = Core_Tipsify;
  Cesium.Transforms = Core_Transforms;
  Cesium.TridiagonalSystemSolver = Core_TridiagonalSystemSolver;
  Cesium.Visibility = Core_Visibility;
  Cesium.WebMercatorProjection = Core_WebMercatorProjection;
  Cesium.WindingOrder = Core_WindingOrder;
  Cesium.binarySearch = Core_binarySearch;
  Cesium.clone = Core_clone;
  Cesium.combine = Core_combine;
  Cesium.computeSunPosition = Core_computeSunPosition;
  Cesium.createGuid = Core_createGuid;
  Cesium.defaultValue = Core_defaultValue;
  Cesium.destroyObject = Core_destroyObject;
  Cesium.freezeObject = Core_freezeObject;
  Cesium.getImagePixels = Core_getImagePixels;
  Cesium.isLeapYear = Core_isLeapYear;
  Cesium.jsonp = Core_jsonp;
  Cesium.loadArrayBuffer = Core_loadArrayBuffer;
  Cesium.loadImage = Core_loadImage;
  Cesium.loadJson = Core_loadJson;
  Cesium.loadText = Core_loadText;
  Cesium.pointInsideTriangle2D = Core_pointInsideTriangle2D;
  Cesium.requestAnimationFrame = Core_requestAnimationFrame;
  Cesium.throttleRequestByServer = Core_throttleRequestByServer;
  Cesium.writeTextToCanvas = Core_writeTextToCanvas;
  Cesium.CompositeDynamicObjectCollection = DynamicScene_CompositeDynamicObjectCollection;
  Cesium.CzmlBoolean = DynamicScene_CzmlBoolean;
  Cesium.CzmlCartesian2 = DynamicScene_CzmlCartesian2;
  Cesium.CzmlCartesian3 = DynamicScene_CzmlCartesian3;
  Cesium.CzmlCartographic = DynamicScene_CzmlCartographic;
  Cesium.CzmlColor = DynamicScene_CzmlColor;
  Cesium.CzmlDefaults = DynamicScene_CzmlDefaults;
  Cesium.CzmlHorizontalOrigin = DynamicScene_CzmlHorizontalOrigin;
  Cesium.CzmlImage = DynamicScene_CzmlImage;
  Cesium.CzmlLabelStyle = DynamicScene_CzmlLabelStyle;
  Cesium.CzmlNumber = DynamicScene_CzmlNumber;
  Cesium.CzmlString = DynamicScene_CzmlString;
  Cesium.CzmlUnitCartesian3 = DynamicScene_CzmlUnitCartesian3;
  Cesium.CzmlUnitQuaternion = DynamicScene_CzmlUnitQuaternion;
  Cesium.CzmlUnitSpherical = DynamicScene_CzmlUnitSpherical;
  Cesium.CzmlVerticalOrigin = DynamicScene_CzmlVerticalOrigin;
  Cesium.DynamicBillboard = DynamicScene_DynamicBillboard;
  Cesium.DynamicBillboardVisualizer = DynamicScene_DynamicBillboardVisualizer;
  Cesium.DynamicColorMaterial = DynamicScene_DynamicColorMaterial;
  Cesium.DynamicCone = DynamicScene_DynamicCone;
  Cesium.DynamicConeVisualizer = DynamicScene_DynamicConeVisualizer;
  Cesium.DynamicConeVisualizerUsingCustomSensor = DynamicScene_DynamicConeVisualizerUsingCustomSensor;
  Cesium.DynamicDirectionsProperty = DynamicScene_DynamicDirectionsProperty;
  Cesium.DynamicEllipsoid = DynamicScene_DynamicEllipsoid;
  Cesium.DynamicEllipsoidVisualizer = DynamicScene_DynamicEllipsoidVisualizer;
  Cesium.DynamicImageMaterial = DynamicScene_DynamicImageMaterial;
  Cesium.DynamicLabel = DynamicScene_DynamicLabel;
  Cesium.DynamicLabelVisualizer = DynamicScene_DynamicLabelVisualizer;
  Cesium.DynamicMaterialProperty = DynamicScene_DynamicMaterialProperty;
  Cesium.DynamicObject = DynamicScene_DynamicObject;
  Cesium.DynamicObjectCollection = DynamicScene_DynamicObjectCollection;
  Cesium.DynamicObjectView = DynamicScene_DynamicObjectView;
  Cesium.DynamicPath = DynamicScene_DynamicPath;
  Cesium.DynamicPathVisualizer = DynamicScene_DynamicPathVisualizer;
  Cesium.DynamicPoint = DynamicScene_DynamicPoint;
  Cesium.DynamicPointVisualizer = DynamicScene_DynamicPointVisualizer;
  Cesium.DynamicPolygon = DynamicScene_DynamicPolygon;
  Cesium.DynamicPolygonVisualizer = DynamicScene_DynamicPolygonVisualizer;
  Cesium.DynamicPolyline = DynamicScene_DynamicPolyline;
  Cesium.DynamicPolylineVisualizer = DynamicScene_DynamicPolylineVisualizer;
  Cesium.DynamicPositionProperty = DynamicScene_DynamicPositionProperty;
  Cesium.DynamicProperty = DynamicScene_DynamicProperty;
  Cesium.DynamicPyramid = DynamicScene_DynamicPyramid;
  Cesium.DynamicPyramidVisualizer = DynamicScene_DynamicPyramidVisualizer;
  Cesium.DynamicVertexPositionsProperty = DynamicScene_DynamicVertexPositionsProperty;
  Cesium.ReferenceProperty = DynamicScene_ReferenceProperty;
  Cesium.VisualizerCollection = DynamicScene_VisualizerCollection;
  Cesium.processCzml = DynamicScene_processCzml;
  Cesium.BlendEquation = Renderer_BlendEquation;
  Cesium.BlendFunction = Renderer_BlendFunction;
  Cesium.BlendingState = Renderer_BlendingState;
  Cesium.Buffer = Renderer_Buffer;
  Cesium.BufferUsage = Renderer_BufferUsage;
  Cesium.ClearCommand = Renderer_ClearCommand;
  Cesium.CommandLists = Renderer_CommandLists;
  Cesium.Context = Renderer_Context;
  Cesium.CubeMap = Renderer_CubeMap;
  Cesium.CubeMapFace = Renderer_CubeMapFace;
  Cesium.CullFace = Renderer_CullFace;
  Cesium.DepthFunction = Renderer_DepthFunction;
  Cesium.DrawCommand = Renderer_DrawCommand;
  Cesium.Framebuffer = Renderer_Framebuffer;
  Cesium.MipmapHint = Renderer_MipmapHint;
  Cesium.PickFramebuffer = Renderer_PickFramebuffer;
  Cesium.PixelDatatype = Renderer_PixelDatatype;
  Cesium.PixelFormat = Renderer_PixelFormat;
  Cesium.Renderbuffer = Renderer_Renderbuffer;
  Cesium.RenderbufferFormat = Renderer_RenderbufferFormat;
  Cesium.ShaderCache = Renderer_ShaderCache;
  Cesium.ShaderProgram = Renderer_ShaderProgram;
  Cesium.StencilFunction = Renderer_StencilFunction;
  Cesium.StencilOperation = Renderer_StencilOperation;
  Cesium.Texture = Renderer_Texture;
  Cesium.TextureAtlas = Renderer_TextureAtlas;
  Cesium.TextureAtlasBuilder = Renderer_TextureAtlasBuilder;
  Cesium.TextureMagnificationFilter = Renderer_TextureMagnificationFilter;
  Cesium.TextureMinificationFilter = Renderer_TextureMinificationFilter;
  Cesium.TextureWrap = Renderer_TextureWrap;
  Cesium.UniformDatatype = Renderer_UniformDatatype;
  Cesium.UniformState = Renderer_UniformState;
  Cesium.VertexArray = Renderer_VertexArray;
  Cesium.VertexArrayFacade = Renderer_VertexArrayFacade;
  Cesium.VertexLayout = Renderer_VertexLayout;
  Cesium.loadCubeMap = Renderer_loadCubeMap;
  Cesium.AnimationCollection = Scene_AnimationCollection;
  Cesium.ArcGisMapServerImageryProvider = Scene_ArcGisMapServerImageryProvider;
  Cesium.Billboard = Scene_Billboard;
  Cesium.BillboardCollection = Scene_BillboardCollection;
  Cesium.BingMapsImageryProvider = Scene_BingMapsImageryProvider;
  Cesium.BingMapsStyle = Scene_BingMapsStyle;
  Cesium.Camera = Scene_Camera;
  Cesium.Camera2DController = Scene_Camera2DController;
  Cesium.CameraCentralBodyController = Scene_CameraCentralBodyController;
  Cesium.CameraColumbusViewController = Scene_CameraColumbusViewController;
  Cesium.CameraControllerCollection = Scene_CameraControllerCollection;
  Cesium.CameraEventHandler = Scene_CameraEventHandler;
  Cesium.CameraEventType = Scene_CameraEventType;
  Cesium.CameraFlightController = Scene_CameraFlightController;
  Cesium.CameraFreeLookController = Scene_CameraFreeLookController;
  Cesium.CameraHelpers = Scene_CameraHelpers;
  Cesium.CameraSpindleController = Scene_CameraSpindleController;
  Cesium.CameraSpindleControllerMode = Scene_CameraSpindleControllerMode;
  Cesium.CentralBody = Scene_CentralBody;
  Cesium.CentralBodySurface = Scene_CentralBodySurface;
  Cesium.CentralBodySurfaceShaderSet = Scene_CentralBodySurfaceShaderSet;
  Cesium.ComplexConicSensorVolume = Scene_ComplexConicSensorVolume;
  Cesium.CompositePrimitive = Scene_CompositePrimitive;
  Cesium.CullingVolume = Scene_CullingVolume;
  Cesium.CustomSensorVolume = Scene_CustomSensorVolume;
  Cesium.DiscardMissingTileImagePolicy = Scene_DiscardMissingTileImagePolicy;
  Cesium.EllipsoidPrimitive = Scene_EllipsoidPrimitive;
  Cesium.EllipsoidTerrainProvider = Scene_EllipsoidTerrainProvider;
  Cesium.FrameState = Scene_FrameState;
  Cesium.FrustumCommands = Scene_FrustumCommands;
  Cesium.GeographicTilingScheme = Scene_GeographicTilingScheme;
  Cesium.HorizontalOrigin = Scene_HorizontalOrigin;
  Cesium.Imagery = Scene_Imagery;
  Cesium.ImageryLayer = Scene_ImageryLayer;
  Cesium.ImageryLayerCollection = Scene_ImageryLayerCollection;
  Cesium.ImageryProvider = Scene_ImageryProvider;
  Cesium.ImageryProviderError = Scene_ImageryProviderError;
  Cesium.ImageryState = Scene_ImageryState;
  Cesium.Label = Scene_Label;
  Cesium.LabelCollection = Scene_LabelCollection;
  Cesium.LabelStyle = Scene_LabelStyle;
  Cesium.Material = Scene_Material;
  Cesium.NeverTileDiscardPolicy = Scene_NeverTileDiscardPolicy;
  Cesium.OpenStreetMapImageryProvider = Scene_OpenStreetMapImageryProvider;
  Cesium.OrthographicFrustum = Scene_OrthographicFrustum;
  Cesium.PerformanceDisplay = Scene_PerformanceDisplay;
  Cesium.PerspectiveFrustum = Scene_PerspectiveFrustum;
  Cesium.PerspectiveOffCenterFrustum = Scene_PerspectiveOffCenterFrustum;
  Cesium.Polygon = Scene_Polygon;
  Cesium.Polyline = Scene_Polyline;
  Cesium.PolylineCollection = Scene_PolylineCollection;
  Cesium.Projections = Scene_Projections;
  Cesium.RectangularPyramidSensorVolume = Scene_RectangularPyramidSensorVolume;
  Cesium.Scene = Scene_Scene;
  Cesium.SceneMode = Scene_SceneMode;
  Cesium.SceneTransitioner = Scene_SceneTransitioner;
  Cesium.SensorVolumeCollection = Scene_SensorVolumeCollection;
  Cesium.SingleTileImageryProvider = Scene_SingleTileImageryProvider;
  Cesium.SkyAtmosphere = Scene_SkyAtmosphere;
  Cesium.SkyBox = Scene_SkyBox;
  Cesium.TerrainProvider = Scene_TerrainProvider;
  Cesium.TexturePool = Scene_TexturePool;
  Cesium.Tile = Scene_Tile;
  Cesium.TileDiscardPolicy = Scene_TileDiscardPolicy;
  Cesium.TileImagery = Scene_TileImagery;
  Cesium.TileLoadQueue = Scene_TileLoadQueue;
  Cesium.TileMapServiceImageryProvider = Scene_TileMapServiceImageryProvider;
  Cesium.TileReplacementQueue = Scene_TileReplacementQueue;
  Cesium.TileState = Scene_TileState;
  Cesium.TilingScheme = Scene_TilingScheme;
  Cesium.VerticalOrigin = Scene_VerticalOrigin;
  Cesium.ViewportQuad = Scene_ViewportQuad;
  Cesium.WebMapServiceImageryProvider = Scene_WebMapServiceImageryProvider;
  Cesium.WebMercatorTilingScheme = Scene_WebMercatorTilingScheme;
  Cesium._shaders.BillboardCollectionFS = Shaders_BillboardCollectionFS;
  Cesium._shaders.BillboardCollectionVS = Shaders_BillboardCollectionVS;
  Cesium._shaders.BuiltinFunctions = Shaders_BuiltinFunctions;
  Cesium._shaders.CentralBodyFS = Shaders_CentralBodyFS;
  Cesium._shaders.CentralBodyFSDepth = Shaders_CentralBodyFSDepth;
  Cesium._shaders.CentralBodyFSPole = Shaders_CentralBodyFSPole;
  Cesium._shaders.CentralBodyVS = Shaders_CentralBodyVS;
  Cesium._shaders.CentralBodyVSDepth = Shaders_CentralBodyVSDepth;
  Cesium._shaders.CentralBodyVSPole = Shaders_CentralBodyVSPole;
  Cesium._shaders.ComplexConicSensorVolumeFS = Shaders_ComplexConicSensorVolumeFS;
  Cesium._shaders.ComplexConicSensorVolumeVS = Shaders_ComplexConicSensorVolumeVS;
  Cesium._shaders.ConstructiveSolidGeometry = Shaders_ConstructiveSolidGeometry;
  Cesium._shaders.CustomSensorVolumeFS = Shaders_CustomSensorVolumeFS;
  Cesium._shaders.CustomSensorVolumeVS = Shaders_CustomSensorVolumeVS;
  Cesium._shaders.EllipsoidFS = Shaders_EllipsoidFS;
  Cesium._shaders.EllipsoidVS = Shaders_EllipsoidVS;
  Cesium._shaders.AsphaltMaterial = Shaders_Materials_AsphaltMaterial;
  Cesium._shaders.BlobMaterial = Shaders_Materials_BlobMaterial;
  Cesium._shaders.BrickMaterial = Shaders_Materials_BrickMaterial;
  Cesium._shaders.BumpMapMaterial = Shaders_Materials_BumpMapMaterial;
  Cesium._shaders.CementMaterial = Shaders_Materials_CementMaterial;
  Cesium._shaders.CheckerboardMaterial = Shaders_Materials_CheckerboardMaterial;
  Cesium._shaders.DotMaterial = Shaders_Materials_DotMaterial;
  Cesium._shaders.FacetMaterial = Shaders_Materials_FacetMaterial;
  Cesium._shaders.FresnelMaterial = Shaders_Materials_FresnelMaterial;
  Cesium._shaders.GrassMaterial = Shaders_Materials_GrassMaterial;
  Cesium._shaders.NormalMapMaterial = Shaders_Materials_NormalMapMaterial;
  Cesium._shaders.ReflectionMaterial = Shaders_Materials_ReflectionMaterial;
  Cesium._shaders.RefractionMaterial = Shaders_Materials_RefractionMaterial;
  Cesium._shaders.StripeMaterial = Shaders_Materials_StripeMaterial;
  Cesium._shaders.TieDyeMaterial = Shaders_Materials_TieDyeMaterial;
  Cesium._shaders.Water = Shaders_Materials_Water;
  Cesium._shaders.WoodMaterial = Shaders_Materials_WoodMaterial;
  Cesium._shaders.Noise = Shaders_Noise;
  Cesium._shaders.PolygonFS = Shaders_PolygonFS;
  Cesium._shaders.PolygonFSPick = Shaders_PolygonFSPick;
  Cesium._shaders.PolygonVS = Shaders_PolygonVS;
  Cesium._shaders.PolygonVSPick = Shaders_PolygonVSPick;
  Cesium._shaders.PolylineFS = Shaders_PolylineFS;
  Cesium._shaders.PolylineVS = Shaders_PolylineVS;
  Cesium._shaders.Ray = Shaders_Ray;
  Cesium._shaders.ReprojectWebMercatorFS = Shaders_ReprojectWebMercatorFS;
  Cesium._shaders.ReprojectWebMercatorVS = Shaders_ReprojectWebMercatorVS;
  Cesium._shaders.SensorVolume = Shaders_SensorVolume;
  Cesium._shaders.SkyAtmosphereFS = Shaders_SkyAtmosphereFS;
  Cesium._shaders.SkyAtmosphereVS = Shaders_SkyAtmosphereVS;
  Cesium._shaders.SkyBoxFS = Shaders_SkyBoxFS;
  Cesium._shaders.SkyBoxVS = Shaders_SkyBoxVS;
  Cesium._shaders.ViewportQuadFS = Shaders_ViewportQuadFS;
  Cesium._shaders.ViewportQuadVS = Shaders_ViewportQuadVS;
  Cesium.Tween = ThirdParty_Tween;
  Cesium.Uri = ThirdParty_Uri;
  Cesium.measureText = ThirdParty_measureText;
  Cesium.when = ThirdParty_when;
  return Cesium;
});
/*global require*/
// require in the complete Cesium object and reassign it globally.
// This is meant for use with the Almond loader.
require(['Cesium'], function(Cesium) {
    
    /*global self*/
    var scope = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {};

    scope.Cesium = Cesium;
}, undefined, true);
define("main", function(){});
}());